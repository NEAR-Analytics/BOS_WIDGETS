"use strict";
const { message, onMessage } = props;
return <iframe
  style={{ display: "none" }}
  srcDoc={'<html><body><script>"use strict";(()=>{function d(t){return e=>e.split(`\n`).map(i=>"    ".repeat(t)+i).join(`\n`)}var l=class{constructor(e){this.config=e}generate(e){let i=[{path:["near_sdk_contract_tools","FungibleToken"]},{path:["near_sdk_contract_tools","standard","nep141","*"]}],a;this.config.preMint.trim().length>0&&(i.push({path:["near_sdk","env"]}),a=`contract.deposit_unchecked(&env::predecessor_account_id(), ${this.config.preMint}u128);`);let n=[`name = "${this.config.name}"`,`symbol = "${this.config.symbol}"`,`decimals = ${this.config.decimals}`],o;e.afterChangeFunction.length==0&&e.beforeChangeFunction.length==0?n.push("no_hooks"):o=`\nimpl Nep141Hook for Contract {\n    fn before_transfer(&mut self, transfer: &Nep141Transfer) {\n${e.beforeChangeFunction.map(d(2)).join(`\n`)}\n    }\n\n    fn after_transfer(&mut self, transfer: &Nep141Transfer, _: ()) {\n${e.afterChangeFunction.map(d(2)).join(`\n`)}\n    }\n}\n`.trim();let s=`#[fungible_token(${n.join(", ")})]`;return{imports:i,deriveMacroName:"FungibleToken",deriveMacroAttribute:s,constructorCode:a,otherCode:o}}},g=class{constructor(e){this.config=e}generate(e){let i=[{path:["near_sdk_contract_tools","nft","*"]}],a=`\ncontract.set_contract_metadata(ContractMetadata::new(\n    "${this.config.name}".to_string(),\n    "${this.config.symbol}".to_string(),\n    None,\n));\n`.trim(),n=[],o;if(e.afterChangeFunction.length==0&&e.beforeChangeFunction.length==0)n.push("no_core_hooks","no_approval_hooks");else{i.push({path:["near_sdk","AccountId"]});let r=e.beforeChangeFunction.map(d(1)).join(`\n`),u=e.afterChangeFunction.map(d(1)).join(`\n`),f=[r.length>0?`\nfn before_nft_approve(&self, token_id: &TokenId, account_id: &AccountId) {\n${r}\n}\n\nfn before_nft_revoke(&self, token_id: &TokenId, account_id: &AccountId) {\n${r}\n}\n\nfn before_nft_revoke_all(&self, token_id: &TokenId) {\n${r}\n}\n`.trim():"",u.length>0?`\nfn after_nft_approve(&mut self, token_id: &TokenId, account_id: &AccountId, _approval_id: &ApprovalId) {\n${u}\n}\n\nfn after_nft_revoke(&mut self, token_id: &TokenId, account_id: &AccountId) {\n${u}\n}\n\nfn after_nft_revoke_all(&mut self, token_id: &TokenId) {\n${u}\n}\n`.trim():""].filter(p=>p.length>0).map(d(1)).join(`\n\n`);f.length==0?n.push("no_approval_hooks"):f=`\nimpl SimpleNep178Hook for Contract {\n${f}\n}\n`.trim();let c=[r.length>0?`\nfn before_nft_transfer(&self, transfer: &Nep171Transfer) {\n${r}\n}\n        `.trim():"",u.length>0?`\nfn before_nft_transfer(&self, transfer: &Nep171Transfer) {\n${u}\n}\n        `.trim():""].filter(p=>p.length>0).map(d(1)).join(`\n\n`);c.length==0?n.push("no_core_hooks"):c=`\nimpl SimpleNep171Hook for Contract {\n${c}\n}\n`.trim(),o=[f,c].filter(p=>p.length>0).join(`\n\n`)}let s=n.length>0?`#[non_fungible_token(${n.join(", ")})]`:void 0;return{imports:i,deriveMacroName:"NonFungibleToken",deriveMacroAttribute:s,constructorCode:a,otherCode:o}}},h=class{constructor(e){}generate(){return{imports:[{path:["near_sdk","env"]},{path:["near_sdk_contract_tools","Owner"]},{path:["near_sdk_contract_tools","owner","*"]}],deriveMacroName:"Owner",constructorCode:"Owner::init(&mut contract, &env::predecessor_account_id());",beforeChangeFunctionGuards:[],afterChangeFunctionGuards:[]}}},m=class{constructor(e){}generate(){return{imports:[{path:["near_sdk_contract_tools","Pause"]},{path:["near_sdk_contract_tools","pause","*"]}],deriveMacroName:"Pause",beforeChangeFunctionGuards:["Contract::require_unpaused();"],afterChangeFunctionGuards:[]}}};function C(t){return t&&typeof t=="object"&&typeof t.token=="object"&&typeof t.token.which=="string"}function k(t){let e=t.token.which==="ft"?new l(t.token.config):new g(t.token.config),i=t.plugins.map(a=>{switch(a){case"owner":return new h({});case"pause":return new m({});default:throw new Error(`Unknown plugin: ${a}`)}});return{token:e,plugins:i}}function b(t){let e={part:"",children:{}};function i(n,o){if(o.length==0)return;let[s,...r]=o;n.children[s]==null&&(n.children[s]={part:s,children:{}}),i(n.children[s],r)}for(let n of t)i(e,n.path);function a(n){let o=Object.values(n.children);if(o.length===1)return`${n.part}::${a(o[0])}`;if(o.length>1){let s=o.map(a).map(d(1)).join(`,\n`);return`${n.part}::{\n${s},\n}`}else return n.part}return Object.values(e.children).map(n=>`use ${a(n)};`).join(`\n`)}function _(t){let e;C(t)?e=k(t):e=t;let i=[{path:["near_sdk","near_bindgen"]},{path:["near_sdk","PanicOnDefault"]},{path:["near_sdk","borsh","self"]},{path:["near_sdk","borsh","BorshSerialize"]},{path:["near_sdk","borsh","BorshDeserialize"]}],a={beforeChangeFunction:[],afterChangeFunction:[]},n=["BorshSerialize","BorshDeserialize","PanicOnDefault"],o=[],s=[];Object.values(e.plugins).forEach(f=>{let c=f.generate();i.push(...c.imports),a.beforeChangeFunction.push(...c.beforeChangeFunctionGuards),a.afterChangeFunction.push(...c.afterChangeFunctionGuards),c.constructorCode&&s.push(c.constructorCode),c.deriveMacroName&&n.push(c.deriveMacroName),c.deriveMacroAttribute&&o.push(c.deriveMacroAttribute)});let r=e.token.generate(a);i.push(...r.imports),r.deriveMacroName&&n.push(r.deriveMacroName),r.deriveMacroAttribute&&o.push(r.deriveMacroAttribute),r.constructorCode&&s.push(r.constructorCode),o.push("#[near_bindgen]");let u="Self {}";return s.length>0&&(u=`\nlet mut contract = Self {};\n\n${s.join(`\n`)}\n\ncontract\n`.trim()),`\n${b(i)}\n\n#[derive(${n.join(", ")})]\n${o.join(`\n`)}\npub struct Contract {}\n\n#[near_bindgen]\nimpl Contract {\n    #[init]\n    pub fn new() -> Self {\n${d(2)(u)}\n    }\n}\n\n${r.otherCode?r.otherCode:""}\n`.trim()+`\n`}window.addEventListener("message",t=>{window.top.postMessage(_(t.data),"*")});})();\n<\/script></body></html>'}
  message={message}
  onMessage={onMessage}
/>;
