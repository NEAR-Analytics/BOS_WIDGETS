"use strict";
const { message, onMessage } = props;
return <iframe
  style={{ display: "none" }}
  srcDoc={'<html><body><script>"use strict";(()=>{function f(i){return e=>e.split(`\n`).map(n=>n.length?"    ".repeat(i)+n:"").join(`\n`)}var _=class{constructor(e){this.config=e}generate(e){let n=[{path:["near_sdk_contract_tools","FungibleToken"]},{path:["near_sdk_contract_tools","standard","nep141","*"]}],u;if((this.config.preMint&&+this.config.preMint>0?(this.config.preMint+"").trim():void 0)!==void 0){let m;this.config.preMintReceiver?m=`"${this.config.preMintReceiver}".parse().unwrap()`:(n.push({path:["near_sdk","env"]}),m="env::predecessor_account_id()"),u=`Nep141Controller::mint(&mut contract, ${m}, ${this.config.preMint}u128, None);`}let d="decimals"in this.config?+this.config.decimals:24,r=Math.max(0,Math.min(38,d)),s=[`name = "${this.config.name}"`,`symbol = "${this.config.symbol}"`,`decimals = ${r}`],a=[],c=e.beforeChangeFunction.length?`\n`+e.beforeChangeFunction.map(f(1)).join(`\n`):"",p=e.afterChangeFunction.length?`\n`+e.afterChangeFunction.map(f(1)).join(`\n`):"",h=e.beforeAuthorizedFunction.length?`\n`+f(1)(e.beforeAuthorizedFunction.join(`\n`)):"";if(this.config.mintable){n.push({path:["near_sdk","AccountId"]}),n.push({path:["near_sdk","json_types","U128"]});let m=`\npub fn mint(&mut self, account_id: AccountId, amount: U128) {${c}${h}\n    Nep141Controller::mint(self, account_id, amount.into(), None);${p}\n}\n`.trim();a.push(m)}if(this.config.burnable){n.push({path:["near_sdk","env"]}),n.push({path:["near_sdk","json_types","U128"]});let m=`\npub fn burn(&mut self, amount: U128) {${c}\n    Nep141Controller::burn(self, env::predecessor_account_id(), amount.into(), None);${p}\n}\n`.trim();a.push(m)}let t=a.join(`\n\n`)||void 0,l;e.afterChangeFunction.length==0&&e.beforeChangeFunction.length==0?s.push("no_hooks"):l=`\nimpl Nep141Hook for Contract {\n    fn before_transfer(&mut self, transfer: &Nep141Transfer) {${f(1)(c)}\n    }\n\n    fn after_transfer(&mut self, transfer: &Nep141Transfer, _: ()) {${f(1)(p)}\n    }\n}\n`.trim();let g=`#[fungible_token(${s.join(", ")})]`;return{imports:n,deriveMacroName:"FungibleToken",deriveMacroAttribute:g,constructorCode:u,bindgenCode:t,otherCode:l}}},b=class{constructor(e){this.config=e}generate(e){let n=[{path:["near_sdk_contract_tools","nft","*"]}],u=`\ncontract.set_contract_metadata(ContractMetadata::new(\n    "${this.config.name}".to_string(),\n    "${this.config.symbol}".to_string(),\n    ${this.config.baseUri?`Some("${this.config.baseUri}".to_string())`:"None"},\n));\n`.trim(),o=[],d,r=e.beforeChangeFunction.length?`\n`+e.beforeChangeFunction.map(f(1)).join(`\n`):"",s=e.afterChangeFunction.length?`\n`+e.afterChangeFunction.map(f(1)).join(`\n`):"",a=e.beforeAuthorizedFunction.length?`\n`+f(1)(e.beforeAuthorizedFunction.join(`\n`)):"";if(e.afterChangeFunction.length==0&&e.beforeChangeFunction.length==0&&e.beforeAuthorizedFunction.length==0)o.push("no_core_hooks","no_approval_hooks");else{let t=[r.length>0?`\nfn before_nft_approve(&self, token_id: &TokenId, account_id: &AccountId) {${r}\n}\n\nfn before_nft_revoke(&self, token_id: &TokenId, account_id: &AccountId) {${r}\n}\n\nfn before_nft_revoke_all(&self, token_id: &TokenId) {${r}\n}\n`.trim():"",s.length>0?`\nfn after_nft_approve(&mut self, token_id: &TokenId, account_id: &AccountId, _approval_id: &ApprovalId) {${s}\n}\n\nfn after_nft_revoke(&mut self, token_id: &TokenId, account_id: &AccountId) {${s}\n}\n\nfn after_nft_revoke_all(&mut self, token_id: &TokenId) {${s}\n}\n`.trim():""].filter(g=>g.length>0).map(f(1)).join(`\n\n`);t.length==0?o.push("no_approval_hooks"):(n.push({path:["near_sdk","AccountId"]}),t=`\nimpl SimpleNep178Hook for Contract {\n${t}\n}\n`.trim());let l=[r.length>0?`fn before_nft_transfer(&self, transfer: &Nep171Transfer) {${r}\n}`:"",s.length>0?`fn after_nft_transfer(&self, transfer: &Nep171Transfer) {${s}\n}`:""].filter(g=>g.length>0).map(f(1)).join(`\n\n`);l.length==0?o.push("no_core_hooks"):l=`\nimpl SimpleNep171Hook for Contract {\n${l}\n}\n`.trim(),d=[t,l].filter(g=>g.length>0).join(`\n\n`)}let c=[];if(this.config.mintable){n.push({path:["near_sdk","AccountId"]}),n.push({path:["near_sdk","env"]});let t=`\npub fn mint(&mut self, token_id: TokenId, account_id: AccountId, metadata: TokenMetadata) {${a}${r}\n    Nep177Controller::mint_with_metadata(self, token_id, account_id, metadata)\n        .unwrap_or_else(|e| env::panic_str(&e.to_string()));${s}\n}\n`.trim();c.push(t)}if(this.config.burnable){n.push({path:["near_sdk","env"]});let t=`\npub fn burn(&mut self, token_id: TokenId) {${r}\n    Nep177Controller::burn_with_metadata(self, token_id, &env::predecessor_account_id())\n        .unwrap_or_else(|e| env::panic_str(&e.to_string()));${s}\n}\n`.trim();c.push(t)}let p=c.join(`\n\n`)||void 0,h=o.length>0?`#[non_fungible_token(${o.join(", ")})]`:void 0;return{imports:n,deriveMacroName:"NonFungibleToken",deriveMacroAttribute:h,constructorCode:u,bindgenCode:p,otherCode:d}}},C=class{constructor(e){this.config=e}generate(){let e=[{path:["near_sdk","borsh","self"]},{path:["near_sdk","borsh","BorshSerialize"]},{path:["near_sdk","BorshStorageKey"]},{path:["near_sdk_contract_tools","Rbac"]},{path:["near_sdk_contract_tools","rbac","*"]}],n;return this.config.accountId?n=`"${this.config.accountId}".parse().unwrap()`:(e.push({path:["near_sdk","env"]}),n="env::predecessor_account_id()"),{imports:e,deriveMacroName:"Rbac",deriveMacroAttribute:\'#[rbac(roles = "Role")]\',beforeChangeFunctionGuards:[],afterChangeFunctionGuards:[],authorizedFunctionGuards:["<Self as Rbac>::require_role(&Role::Admin);"],constructorCode:`contract.add_role(${n}, &Role::Admin);`,otherCode:`\n#[derive(BorshSerialize, BorshStorageKey)]\npub enum Role {\n    Admin,\n}\n`.trim()}}},k=class{constructor(e){this.config=e}generate(){let e=[{path:["near_sdk_contract_tools","Owner"]},{path:["near_sdk_contract_tools","owner","*"]}];this.config.accountId||e.push({path:["near_sdk","env"]});let u=`Owner::init(&mut contract, &${this.config.accountId?`"${this.config.accountId}".parse().unwrap()`:"env::predecessor_account_id()"});`;return{imports:e,deriveMacroName:"Owner",constructorCode:u,beforeChangeFunctionGuards:[],afterChangeFunctionGuards:[],authorizedFunctionGuards:["<Self as Owner>::require_owner();"]}}},F=class{constructor(e){}generate(){return{imports:[{path:["near_sdk_contract_tools","Pause"]},{path:["near_sdk_contract_tools","pause","*"]}],deriveMacroName:"Pause",beforeChangeFunctionGuards:["Contract::require_unpaused();"],afterChangeFunctionGuards:[],authorizedFunctionGuards:[]}}};function v(i){return i&&typeof i=="object"&&typeof i.token=="object"&&typeof i.token.which=="string"}function I(i){let e=i.token.which==="ft"?new _(i.token.config):new b(i.token.config),n=Object.entries(i.plugins).map(([u,o])=>{switch(u){case"owner":return new k(o);case"pause":return new F(o);case"rbac":return new C(o);default:throw new Error(`Unknown plugin: "${u}"`)}});return{token:e,plugins:n}}function M(i){let e={part:"",children:{}};function n(o,d){if(d.length==0)return;let[r,...s]=d;o.children[r]==null&&(o.children[r]={part:r,children:{}}),n(o.children[r],s)}for(let o of i)n(e,o.path);function u(o,d=80){let r=Object.values(o.children),s=`${o.part}::`;if(r.length===1)return`${s}${u(r[0],d-s.length)}`;if(r.length>1){let a=r.map(h=>u(h,d-s.length));a.sort();let c=[a.shift()];for(;a.length>0;){let h=a.shift();if(h.includes(`\n`)){c.push(f(1)(h));continue}let t=c[c.length-1]+", "+h;t.length>d?c.push(f(1)(h)):c[c.length-1]=t}if(c.length===1){let h=c[0],t=`${s}{${h}}`;return t.length<=d?t:`${s}{\n${f(1)(h)}\n}`}c[0]=f(1)(c[0]);let p=c.join(`,\n`);return`${s}{\n${p},\n}`}else return o.part}return Object.values(e.children).map(o=>`use ${u(o,75)};`).join(`\n`)}function $(i){let e;v(i)?e=I(i):e=i;let n=[{path:["near_sdk","near_bindgen"]},{path:["near_sdk","PanicOnDefault"]},{path:["near_sdk","borsh","self"]},{path:["near_sdk","borsh","BorshSerialize"]},{path:["near_sdk","borsh","BorshDeserialize"]}],u={beforeChangeFunction:[],afterChangeFunction:[],beforeAuthorizedFunction:[]},o=["BorshSerialize","BorshDeserialize","PanicOnDefault"],d=[],r=[],s=[];Object.values(e.plugins).forEach(h=>{let t=h.generate();n.push(...t.imports),u.beforeChangeFunction.push(...t.beforeChangeFunctionGuards),u.afterChangeFunction.push(...t.afterChangeFunctionGuards),u.beforeAuthorizedFunction.push(...t.authorizedFunctionGuards),t.constructorCode&&r.push(t.constructorCode),t.deriveMacroName&&o.push(t.deriveMacroName),t.deriveMacroAttribute&&d.push(t.deriveMacroAttribute),t.otherCode&&s.push(t.otherCode)});let a=e.token.generate(u);n.push(...a.imports),a.deriveMacroName&&o.push(a.deriveMacroName),a.deriveMacroAttribute&&d.push(a.deriveMacroAttribute),a.constructorCode&&r.push(a.constructorCode),a.otherCode&&s.push(a.otherCode),d.push("#[near_bindgen]");let c=`\nSelf {}`;r.length>0&&(c=`\nlet mut contract = Self {};\n\n${r.join(`\n`)}\n\ncontract`);let p="";return a.bindgenCode&&(p=`\n\n${a.bindgenCode}`),`\n${M(n)}\n\n#[derive(${o.join(", ")})]\n${d.join(`\n`)}\npub struct Contract {}\n\n#[near_bindgen]\nimpl Contract {\n    #[init]\n    pub fn new() -> Self {${f(2)(c)}\n    }${f(1)(p)}\n}\n\n${s.join(`\n\n`)}\n`.trim()+`\n`}window.addEventListener("message",i=>{window.top.postMessage($(i.data),"*")});})();\n<\/script></body></html>'}
  message={message}
  onMessage={onMessage}
/>;
