"use strict";
const { message, onMessage } = props;
return <iframe
  style={{ display: "none" }}
  srcDoc={'<html><body><script>"use strict";(()=>{function d(r){return e=>e.split(`\n`).map(t=>t.length?"    ".repeat(r)+t:"").join(`\n`)}var m=class{constructor(e){this.config=e}generate(e){let t=[{path:["near_sdk_contract_tools","FungibleToken"]},{path:["near_sdk_contract_tools","standard","nep141","*"]}],c;this.config.preMint&&this.config.preMint.trim().length>0&&+this.config.preMint>0&&(t.push({path:["near_sdk","env"]}),c=`contract.deposit_unchecked(&env::predecessor_account_id(), ${this.config.preMint}u128);`);let n=[`name = "${this.config.name}"`,`symbol = "${this.config.symbol}"`,`decimals = ${this.config.decimals}`],a=[],i=e.beforeChangeFunction.length?`\n`+e.beforeChangeFunction.map(d(1)).join(`\n`):"",s=e.afterChangeFunction.length?`\n`+e.afterChangeFunction.map(d(1)).join(`\n`):"",u=e.beforeAuthorizedFunction.length?`\n`+d(1)(e.beforeAuthorizedFunction.join(`\n`)):"";if(this.config.mintable){t.push({path:["near_sdk","AccountId"]}),t.push({path:["near_sdk","json_types","U128"]});let o=`\npub fn mint(&mut self, account_id: AccountId, amount: U128) {${i}${u}\n    Nep141Controller::mint(self, account_id, amount.into(), None);${s}\n}\n`.trim();a.push(o)}if(this.config.burnable){t.push({path:["near_sdk","env"]}),t.push({path:["near_sdk","json_types","U128"]});let o=`\npub fn burn(&mut self, amount: U128) {${i}\n    Nep141Controller::burn(self, env::predecessor_account_id(), amount.into(), None);${s}\n}\n`.trim();a.push(o)}let f=a.join(`\n\n`)||void 0,p;e.afterChangeFunction.length==0&&e.beforeChangeFunction.length==0?n.push("no_hooks"):p=`\nimpl Nep141Hook for Contract {\n    fn before_transfer(&mut self, transfer: &Nep141Transfer) {${d(1)(i)}\n    }\n\n    fn after_transfer(&mut self, transfer: &Nep141Transfer, _: ()) {${d(1)(s)}\n    }\n}\n`.trim();let h=`#[fungible_token(${n.join(", ")})]`;return{imports:t,deriveMacroName:"FungibleToken",deriveMacroAttribute:h,constructorCode:c,bindgenCode:f,otherCode:p}}},_=class{constructor(e){this.config=e}generate(e){let t=[{path:["near_sdk_contract_tools","nft","*"]}],c=`\ncontract.set_contract_metadata(ContractMetadata::new(\n    "${this.config.name}".to_string(),\n    "${this.config.symbol}".to_string(),\n    None,\n));\n`.trim(),n=[],a,i=e.beforeChangeFunction.length?`\n`+e.beforeChangeFunction.map(d(1)).join(`\n`):"",s=e.afterChangeFunction.length?`\n`+e.afterChangeFunction.map(d(1)).join(`\n`):"",u=e.beforeAuthorizedFunction.length?`\n`+d(1)(e.beforeAuthorizedFunction.join(`\n`)):"";if(e.afterChangeFunction.length==0&&e.beforeChangeFunction.length==0&&e.beforeAuthorizedFunction.length==0)n.push("no_core_hooks","no_approval_hooks");else{t.push({path:["near_sdk","AccountId"]});let o=[i.length>0?`\nfn before_nft_approve(&self, token_id: &TokenId, account_id: &AccountId) {${i}\n}\n\nfn before_nft_revoke(&self, token_id: &TokenId, account_id: &AccountId) {${i}\n}\n\nfn before_nft_revoke_all(&self, token_id: &TokenId) {${i}\n}\n`.trim():"",s.length>0?`\nfn after_nft_approve(&mut self, token_id: &TokenId, account_id: &AccountId, _approval_id: &ApprovalId) {${s}\n}\n\nfn after_nft_revoke(&mut self, token_id: &TokenId, account_id: &AccountId) {${s}\n}\n\nfn after_nft_revoke_all(&mut self, token_id: &TokenId) {${s}\n}\n`.trim():""].filter(l=>l.length>0).map(d(1)).join(`\n\n`);o.length==0?n.push("no_approval_hooks"):o=`\nimpl SimpleNep178Hook for Contract {\n${o}\n}\n`.trim();let g=[i.length>0?`fn before_nft_transfer(&self, transfer: &Nep171Transfer) {${i}\n}`:"",s.length>0?`fn after_nft_transfer(&self, transfer: &Nep171Transfer) {${s}\n}`:""].filter(l=>l.length>0).map(d(1)).join(`\n\n`);g.length==0?n.push("no_core_hooks"):g=`\nimpl SimpleNep171Hook for Contract {\n${g}\n}\n`.trim(),a=[o,g].filter(l=>l.length>0).join(`\n\n`)}let f=[];if(this.config.mintable){t.push({path:["near_sdk","AccountId"]}),t.push({path:["near_sdk","env"]});let o=`\npub fn mint(&mut self, token_id: TokenId, account_id: AccountId, metadata: TokenMetadata) {${u}${i}\n    Nep177Controller::mint_with_metadata(self, token_id, account_id, metadata)\n        .unwrap_or_else(|e| env::panic_str(&e.to_string()));${s}\n}\n`.trim();f.push(o)}if(this.config.burnable){t.push({path:["near_sdk","env"]});let o=`\npub fn burn(&mut self, token_id: TokenId) {${i}\n    Nep177Controller::burn_with_metadata(self, token_id, &env::predecessor_account_id())\n        .unwrap_or_else(|e| env::panic_str(&e.to_string()));${s}\n}\n`.trim();f.push(o)}let p=f.join(`\n\n`)||void 0,h=n.length>0?`#[non_fungible_token(${n.join(", ")})]`:void 0;return{imports:t,deriveMacroName:"NonFungibleToken",deriveMacroAttribute:h,constructorCode:c,bindgenCode:p,otherCode:a}}},b=class{constructor(e){this.config=e}generate(){let e=[{path:["near_sdk","borsh","self"]},{path:["near_sdk","borsh","BorshSerialize"]},{path:["near_sdk","BorshStorageKey"]},{path:["near_sdk_contract_tools","Rbac"]},{path:["near_sdk_contract_tools","rbac","*"]}],t=this.config.accountId?`"${this.config.accountId}".parse().unwrap()`:"env::predecessor_account_id()";return{imports:e,deriveMacroName:"Rbac",deriveMacroAttribute:\'#[rbac(roles = "Role")]\',beforeChangeFunctionGuards:[],afterChangeFunctionGuards:[],authorizedFunctionGuards:["<Self as Rbac>::require_role(&Role::Admin);"],constructorCode:`contract.add_role(${t}, &Role::Admin);`,otherCode:`\n#[derive(BorshSerialize, BorshStorageKey)]\npub enum Role {\n    Admin,\n}\n`.trim()}}},C=class{constructor(e){}generate(){return{imports:[{path:["near_sdk","env"]},{path:["near_sdk_contract_tools","Owner"]},{path:["near_sdk_contract_tools","owner","*"]}],deriveMacroName:"Owner",constructorCode:"Owner::init(&mut contract, &env::predecessor_account_id());",beforeChangeFunctionGuards:[],afterChangeFunctionGuards:[],authorizedFunctionGuards:["<Self as Owner>::require_owner();"]}}},k=class{constructor(e){}generate(){return{imports:[{path:["near_sdk_contract_tools","Pause"]},{path:["near_sdk_contract_tools","pause","*"]}],deriveMacroName:"Pause",beforeChangeFunctionGuards:["Contract::require_unpaused();"],afterChangeFunctionGuards:[],authorizedFunctionGuards:[]}}};function v(r){return r&&typeof r=="object"&&typeof r.token=="object"&&typeof r.token.which=="string"}function $(r){let e=r.token.which==="ft"?new m(r.token.config):new _(r.token.config),t=Object.entries(r.plugins).map(([c,n])=>{switch(c){case"owner":return new C(n);case"pause":return new k(n);case"rbac":return new b(n);default:throw new Error(`Unknown plugin: "${c}"`)}});return{token:e,plugins:t}}function j(r){let e={part:"",children:{}};function t(n,a){if(a.length==0)return;let[i,...s]=a;n.children[i]==null&&(n.children[i]={part:i,children:{}}),t(n.children[i],s)}for(let n of r)t(e,n.path);function c(n){let a=Object.values(n.children);if(a.length===1)return`${n.part}::${c(a[0])}`;if(a.length>1){let i=a.map(c).map(d(1)).join(`,\n`);return`${n.part}::{\n${i},\n}`}else return n.part}return Object.values(e.children).map(n=>`use ${c(n)};`).join(`\n`)}function F(r){let e;v(r)?e=$(r):e=r;let t=[{path:["near_sdk","near_bindgen"]},{path:["near_sdk","PanicOnDefault"]},{path:["near_sdk","borsh","self"]},{path:["near_sdk","borsh","BorshSerialize"]},{path:["near_sdk","borsh","BorshDeserialize"]}],c={beforeChangeFunction:[],afterChangeFunction:[],beforeAuthorizedFunction:[]},n=["BorshSerialize","BorshDeserialize","PanicOnDefault"],a=[],i=[],s=[];Object.values(e.plugins).forEach(h=>{let o=h.generate();t.push(...o.imports),c.beforeChangeFunction.push(...o.beforeChangeFunctionGuards),c.afterChangeFunction.push(...o.afterChangeFunctionGuards),c.beforeAuthorizedFunction.push(...o.authorizedFunctionGuards),o.constructorCode&&i.push(o.constructorCode),o.deriveMacroName&&n.push(o.deriveMacroName),o.deriveMacroAttribute&&a.push(o.deriveMacroAttribute),o.otherCode&&s.push(o.otherCode)});let u=e.token.generate(c);t.push(...u.imports),u.deriveMacroName&&n.push(u.deriveMacroName),u.deriveMacroAttribute&&a.push(u.deriveMacroAttribute),u.constructorCode&&i.push(u.constructorCode),u.otherCode&&s.push(u.otherCode),a.push("#[near_bindgen]");let f=`\nSelf {}`;i.length>0&&(f=`\nlet mut contract = Self {};\n\n${i.join(`\n`)}\n\ncontract`);let p="";return u.bindgenCode&&(p=`\n\n${u.bindgenCode}`),`\n${j(t)}\n\n#[derive(${n.join(", ")})]\n${a.join(`\n`)}\npub struct Contract {}\n\n#[near_bindgen]\nimpl Contract {\n    #[init]\n    pub fn new() -> Self {${d(2)(f)}\n    }${d(1)(p)}\n}\n\n${s.join(`\n\n`)}\n`.trim()+`\n`}window.addEventListener("message",r=>{window.top.postMessage(F(r.data),"*")});})();\n<\/script></body></html>'}
  message={message}
  onMessage={onMessage}
/>;
