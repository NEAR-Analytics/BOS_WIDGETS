{"tx_hash": "Afy2Weq3xAycrBstFmBw3iHDSk6otc5GyAB9whgEgdKQ", "action_id_social": "GdHtbTqgCN93jxJnfHWsXzjTt8xT5sKS71GnEXQZPqBd-0-widget", "block_id": 101622257, "block_timestamp": "2023-09-21T11:38:46.237Z", "signer_id": "contractwizard.near", "widget_name": "CodeGenerator", "source_code": "\"use strict\";\nconst { message, onMessage } = props;\nreturn <iframe\n  style={{ display: \"none\" }}\n  srcDoc={'<html><body><script>\"use strict\";(()=>{function d(o){return e=>e.split(`\\n`).map(t=>t.length?\"    \".repeat(o)+t:\"\").join(`\\n`)}var m=class{constructor(e){this.config=e}generate(e){let t=[{path:[\"near_sdk_contract_tools\",\"FungibleToken\"]},{path:[\"near_sdk_contract_tools\",\"standard\",\"nep141\",\"*\"]}],a;this.config.preMint&&this.config.preMint.trim().length>0&&+this.config.preMint>0&&(t.push({path:[\"near_sdk\",\"env\"]}),a=`contract.deposit_unchecked(&env::predecessor_account_id(), ${this.config.preMint}u128);`);let n=typeof this.config.decimals==\"number\"&&this.config.decimals>0&&this.config.decimals<=255&&(this.config.decimals|0)===this.config.decimals?this.config.decimals:24,s=[`name = \"${this.config.name}\"`,`symbol = \"${this.config.symbol}\"`,`decimals = ${n}`],r=[],c=e.beforeChangeFunction.length?`\\n`+e.beforeChangeFunction.map(d(1)).join(`\\n`):\"\",u=e.afterChangeFunction.length?`\\n`+e.afterChangeFunction.map(d(1)).join(`\\n`):\"\",f=e.beforeAuthorizedFunction.length?`\\n`+d(1)(e.beforeAuthorizedFunction.join(`\\n`)):\"\";if(this.config.mintable){t.push({path:[\"near_sdk\",\"AccountId\"]}),t.push({path:[\"near_sdk\",\"json_types\",\"U128\"]});let h=`\\npub fn mint(&mut self, account_id: AccountId, amount: U128) {${c}${f}\\n    Nep141Controller::mint(self, account_id, amount.into(), None);${u}\\n}\\n`.trim();r.push(h)}if(this.config.burnable){t.push({path:[\"near_sdk\",\"env\"]}),t.push({path:[\"near_sdk\",\"json_types\",\"U128\"]});let h=`\\npub fn burn(&mut self, amount: U128) {${c}\\n    Nep141Controller::burn(self, env::predecessor_account_id(), amount.into(), None);${u}\\n}\\n`.trim();r.push(h)}let p=r.join(`\\n\\n`)||void 0,l;e.afterChangeFunction.length==0&&e.beforeChangeFunction.length==0?s.push(\"no_hooks\"):l=`\\nimpl Nep141Hook for Contract {\\n    fn before_transfer(&mut self, transfer: &Nep141Transfer) {${d(1)(c)}\\n    }\\n\\n    fn after_transfer(&mut self, transfer: &Nep141Transfer, _: ()) {${d(1)(u)}\\n    }\\n}\\n`.trim();let i=`#[fungible_token(${s.join(\", \")})]`;return{imports:t,deriveMacroName:\"FungibleToken\",deriveMacroAttribute:i,constructorCode:a,bindgenCode:p,otherCode:l}}},_=class{constructor(e){this.config=e}generate(e){let t=[{path:[\"near_sdk_contract_tools\",\"nft\",\"*\"]}],a=`\\ncontract.set_contract_metadata(ContractMetadata::new(\\n    \"${this.config.name}\".to_string(),\\n    \"${this.config.symbol}\".to_string(),\\n    ${this.config.baseUri?`Some(\"${this.config.baseUri}\".to_string())`:\"None\"},\\n));\\n`.trim(),n=[],s,r=e.beforeChangeFunction.length?`\\n`+e.beforeChangeFunction.map(d(1)).join(`\\n`):\"\",c=e.afterChangeFunction.length?`\\n`+e.afterChangeFunction.map(d(1)).join(`\\n`):\"\",u=e.beforeAuthorizedFunction.length?`\\n`+d(1)(e.beforeAuthorizedFunction.join(`\\n`)):\"\";if(e.afterChangeFunction.length==0&&e.beforeChangeFunction.length==0&&e.beforeAuthorizedFunction.length==0)n.push(\"no_core_hooks\",\"no_approval_hooks\");else{t.push({path:[\"near_sdk\",\"AccountId\"]});let i=[r.length>0?`\\nfn before_nft_approve(&self, token_id: &TokenId, account_id: &AccountId) {${r}\\n}\\n\\nfn before_nft_revoke(&self, token_id: &TokenId, account_id: &AccountId) {${r}\\n}\\n\\nfn before_nft_revoke_all(&self, token_id: &TokenId) {${r}\\n}\\n`.trim():\"\",c.length>0?`\\nfn after_nft_approve(&mut self, token_id: &TokenId, account_id: &AccountId, _approval_id: &ApprovalId) {${c}\\n}\\n\\nfn after_nft_revoke(&mut self, token_id: &TokenId, account_id: &AccountId) {${c}\\n}\\n\\nfn after_nft_revoke_all(&mut self, token_id: &TokenId) {${c}\\n}\\n`.trim():\"\"].filter(g=>g.length>0).map(d(1)).join(`\\n\\n`);i.length==0?n.push(\"no_approval_hooks\"):i=`\\nimpl SimpleNep178Hook for Contract {\\n${i}\\n}\\n`.trim();let h=[r.length>0?`fn before_nft_transfer(&self, transfer: &Nep171Transfer) {${r}\\n}`:\"\",c.length>0?`fn after_nft_transfer(&self, transfer: &Nep171Transfer) {${c}\\n}`:\"\"].filter(g=>g.length>0).map(d(1)).join(`\\n\\n`);h.length==0?n.push(\"no_core_hooks\"):h=`\\nimpl SimpleNep171Hook for Contract {\\n${h}\\n}\\n`.trim(),s=[i,h].filter(g=>g.length>0).join(`\\n\\n`)}let f=[];if(this.config.mintable){t.push({path:[\"near_sdk\",\"AccountId\"]}),t.push({path:[\"near_sdk\",\"env\"]});let i=`\\npub fn mint(&mut self, token_id: TokenId, account_id: AccountId, metadata: TokenMetadata) {${u}${r}\\n    Nep177Controller::mint_with_metadata(self, token_id, account_id, metadata)\\n        .unwrap_or_else(|e| env::panic_str(&e.to_string()));${c}\\n}\\n`.trim();f.push(i)}if(this.config.burnable){t.push({path:[\"near_sdk\",\"env\"]});let i=`\\npub fn burn(&mut self, token_id: TokenId) {${r}\\n    Nep177Controller::burn_with_metadata(self, token_id, &env::predecessor_account_id())\\n        .unwrap_or_else(|e| env::panic_str(&e.to_string()));${c}\\n}\\n`.trim();f.push(i)}let p=f.join(`\\n\\n`)||void 0,l=n.length>0?`#[non_fungible_token(${n.join(\", \")})]`:void 0;return{imports:t,deriveMacroName:\"NonFungibleToken\",deriveMacroAttribute:l,constructorCode:a,bindgenCode:p,otherCode:s}}},b=class{constructor(e){this.config=e}generate(){let e=[{path:[\"near_sdk\",\"borsh\",\"self\"]},{path:[\"near_sdk\",\"borsh\",\"BorshSerialize\"]},{path:[\"near_sdk\",\"BorshStorageKey\"]},{path:[\"near_sdk_contract_tools\",\"Rbac\"]},{path:[\"near_sdk_contract_tools\",\"rbac\",\"*\"]}],t=this.config.accountId?`\"${this.config.accountId}\".parse().unwrap()`:\"env::predecessor_account_id()\";return{imports:e,deriveMacroName:\"Rbac\",deriveMacroAttribute:\\'#[rbac(roles = \"Role\")]\\',beforeChangeFunctionGuards:[],afterChangeFunctionGuards:[],authorizedFunctionGuards:[\"<Self as Rbac>::require_role(&Role::Admin);\"],constructorCode:`contract.add_role(${t}, &Role::Admin);`,otherCode:`\\n#[derive(BorshSerialize, BorshStorageKey)]\\npub enum Role {\\n    Admin,\\n}\\n`.trim()}}},C=class{constructor(e){this.config=e}generate(){let e=[{path:[\"near_sdk\",\"env\"]},{path:[\"near_sdk_contract_tools\",\"Owner\"]},{path:[\"near_sdk_contract_tools\",\"owner\",\"*\"]}],a=`Owner::init(&mut contract, &${this.config.accountId?`\"${this.config.accountId}\".parse().unwrap()`:\"env::predecessor_account_id()\"});`;return{imports:e,deriveMacroName:\"Owner\",constructorCode:a,beforeChangeFunctionGuards:[],afterChangeFunctionGuards:[],authorizedFunctionGuards:[\"<Self as Owner>::require_owner();\"]}}},k=class{constructor(e){}generate(){return{imports:[{path:[\"near_sdk_contract_tools\",\"Pause\"]},{path:[\"near_sdk_contract_tools\",\"pause\",\"*\"]}],deriveMacroName:\"Pause\",beforeChangeFunctionGuards:[\"Contract::require_unpaused();\"],afterChangeFunctionGuards:[],authorizedFunctionGuards:[]}}};function v(o){return o&&typeof o==\"object\"&&typeof o.token==\"object\"&&typeof o.token.which==\"string\"}function $(o){let e=o.token.which===\"ft\"?new m(o.token.config):new _(o.token.config),t=Object.entries(o.plugins).map(([a,n])=>{switch(a){case\"owner\":return new C(n);case\"pause\":return new k(n);case\"rbac\":return new b(n);default:throw new Error(`Unknown plugin: \"${a}\"`)}});return{token:e,plugins:t}}function I(o){let e={part:\"\",children:{}};function t(n,s){if(s.length==0)return;let[r,...c]=s;n.children[r]==null&&(n.children[r]={part:r,children:{}}),t(n.children[r],c)}for(let n of o)t(e,n.path);function a(n){let s=Object.values(n.children);if(s.length===1)return`${n.part}::${a(s[0])}`;if(s.length>1){let r=s.map(a).map(d(1)).join(`,\\n`);return`${n.part}::{\\n${r},\\n}`}else return n.part}return Object.values(e.children).map(n=>`use ${a(n)};`).join(`\\n`)}function F(o){let e;v(o)?e=$(o):e=o;let t=[{path:[\"near_sdk\",\"near_bindgen\"]},{path:[\"near_sdk\",\"PanicOnDefault\"]},{path:[\"near_sdk\",\"borsh\",\"self\"]},{path:[\"near_sdk\",\"borsh\",\"BorshSerialize\"]},{path:[\"near_sdk\",\"borsh\",\"BorshDeserialize\"]}],a={beforeChangeFunction:[],afterChangeFunction:[],beforeAuthorizedFunction:[]},n=[\"BorshSerialize\",\"BorshDeserialize\",\"PanicOnDefault\"],s=[],r=[],c=[];Object.values(e.plugins).forEach(l=>{let i=l.generate();t.push(...i.imports),a.beforeChangeFunction.push(...i.beforeChangeFunctionGuards),a.afterChangeFunction.push(...i.afterChangeFunctionGuards),a.beforeAuthorizedFunction.push(...i.authorizedFunctionGuards),i.constructorCode&&r.push(i.constructorCode),i.deriveMacroName&&n.push(i.deriveMacroName),i.deriveMacroAttribute&&s.push(i.deriveMacroAttribute),i.otherCode&&c.push(i.otherCode)});let u=e.token.generate(a);t.push(...u.imports),u.deriveMacroName&&n.push(u.deriveMacroName),u.deriveMacroAttribute&&s.push(u.deriveMacroAttribute),u.constructorCode&&r.push(u.constructorCode),u.otherCode&&c.push(u.otherCode),s.push(\"#[near_bindgen]\");let f=`\\nSelf {}`;r.length>0&&(f=`\\nlet mut contract = Self {};\\n\\n${r.join(`\\n`)}\\n\\ncontract`);let p=\"\";return u.bindgenCode&&(p=`\\n\\n${u.bindgenCode}`),`\\n${I(t)}\\n\\n#[derive(${n.join(\", \")})]\\n${s.join(`\\n`)}\\npub struct Contract {}\\n\\n#[near_bindgen]\\nimpl Contract {\\n    #[init]\\n    pub fn new() -> Self {${d(2)(f)}\\n    }${d(1)(p)}\\n}\\n\\n${c.join(`\\n\\n`)}\\n`.trim()+`\\n`}window.addEventListener(\"message\",o=>{window.top.postMessage(F(o.data),\"*\")});})();\\n<\\/script></body></html>'}\n  message={message}\n  onMessage={onMessage}\n/>;\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/contractwizard.near/widget/CodeGenerator", "fact_widget_deployments_id": "e3bd2fe540af2871beee640ab737638e", "inserted_timestamp": "2023-09-21T13:38:04.951Z", "modified_timestamp": "2023-09-21T13:38:04.951Z", "__row_index": 8}