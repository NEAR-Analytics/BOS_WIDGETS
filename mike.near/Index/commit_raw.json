{"tx_hash": "4Mc9FJqKX3onkHcWPFPdgTfKM836fe3xDxEVY37WKtt9", "action_id_social": "Ao5tn5d1ERjq9UtQwVeJQuULFn1eK1XCx4diQK4xwvMe-0-widget", "block_id": 110166039, "block_timestamp": "2024-01-11T19:00:00.977Z", "signer_id": "mike.near", "widget_name": "Index", "source_code": "State.init({\n  orderSize: \"0.0001\",\n  orderPrice: \"2500\",\n  orderMarketId: \"ETH-USD\",\n  orderType: \"LIMIT\",\n  nonce: 0,\n});\n\nconst OrderMarket = styled.div`{\n  display: inline-block;\n  min-width: 180px;\n  }`;\nconst OrderSide = styled.div`{\n    min-width: 50px;\n    text-align: center;\n    display: inline-block;\n    border-radius: 0.25rem;\n    letter-spacing: 0.04em;\n    user-select: none;\n    padding: 0.156rem 0.219rem 0.156rem 0.25rem;\n    color: ${(props) =>\n      [\"BUY\", \"LONG\"].includes(props.side) ? \"#21a677\" : \"#e45353\"};\n    background-color: ${(props) =>\n      [\"BUY\", \"LONG\"].includes(props.side) ? \"#3eb68a29\" : \"#d57676a1\"};\n}`;\n\nconst OrderSize = styled.div`{\n    display: inline-block;\n    text-align: center;\n    min-width: 190px;\n    border-radius: 0.25rem;\n    letter-spacing: 0.04em;\n    user-select: none;\n    padding: 0.156rem 0.219rem 0.156rem 0.25rem;\n    color: #757575;\n    background-color: #d1d4dc;\n}`;\n\nconst etherProviderEnabled = !!Ethers?.provider();\n\nif (etherProviderEnabled) {\n  Ethers.provider()\n    .send(\"eth_chainId\", [])\n    .then((chainId) => {\n      chainId = parseInt(chainId, 16);\n      if (state.chainId !== chainId) {\n        console.log(\"Set chainId\", chainId);\n        State.update({ chainId });\n      }\n    });\n\n  Ethers.provider()\n    .send(\"eth_requestAccounts\", [])\n    .then((accounts) => {\n      if (accounts.length && state.sender !== accounts[0]) {\n        console.log(\"Set sender\", accounts[0]);\n        State.update({ sender: accounts[0] });\n      }\n    });\n}\n\nif (!state.sender) {\n  return (\n    <div class=\"mb-3\">\n      <Web3Connect connectLabel=\"Connect Web3 Wallet to continue\" />\n    </div>\n  );\n}\n\nconst stripHexPrefix = (input) => {\n  if (input.indexOf(\"0x\") === 0) {\n    return input.slice(2);\n  }\n\n  return input;\n};\n\nconst exportMnemonicAndPrivateKey = (entropy, path) => {\n  const mnemonic = ethers.utils.entropyToMnemonic(entropy);\n  // console.log(\"mnemonic\", mnemonic);\n  const seed = ethers.utils.mnemonicToSeed(mnemonic);\n  const hdNode = ethers.utils.HDNode.fromSeed(seed);\n\n  return {\n    mnemonic,\n    privateKey: hdNode.privateKey,\n    publicKey: hdNode.publicKey,\n  };\n};\n\nconst deriveHDKeyFromEthereumSignature = (signature) => {\n  const buffer = Buffer.from(stripHexPrefix(signature), \"hex\");\n\n  if (buffer.length !== 65) {\n    throw new Error(\"Signature must be 65 bytes\");\n  }\n\n  // Remove the 'v' value by taking only the first 64 bytes of the signature\n  const rsValues = buffer.subarray(0, 64);\n  // Hash the 'r' and 's' values down to 32 bytes (256 bits) using Keccak-256\n  const entropy = ethers.utils.keccak256(rsValues);\n\n  return exportMnemonicAndPrivateKey(entropy);\n};\n\nlet wallet;\n\nconst getWalletFromEvmSignature = (signature) => {\n  console.log(signature);\n  const { mnemonic, privateKey, publicKey } =\n    deriveHDKeyFromEthereumSignature(signature);\n  console.log(\"deriveHDKeyFromEthereumSignature\", {\n    mnemonic,\n    privateKey,\n    publicKey,\n  });\n\n  DirectSecp256k1HdWallet.fromMnemonic(mnemonic, {\n    prefix: \"dydx\",\n  }).then((_wallet) => {\n    wallet = new DirectSecp256k1HdWallet(mnemonic, {\n      prefix: \"dydx\",\n      seed: _wallet.seed,\n    });\n    console.log(\"derrived wallet\", wallet);\n\n    wallet.getAccounts().then(([dydx_account]) => {\n      console.log(\"dYdX account derived\", dydx_account);\n      State.update({\n        dydx_account: dydx_account.address,\n        wallet: wallet,\n        mnemonic,\n        updateMarketPrice: true,\n      });\n    });\n  });\n};\n\n// console.log(\"state wallet\", state.wallet);\n\nconst apiUrl = \"https://indexer.v4testnet.dydx.exchange/v4\";\nconst accountId = state.dydx_account;\nconst headers = {\n  Accept: \"application/json\",\n};\n\nconst loadAccount = () => {\n  asyncFetch(`${apiUrl}/addresses/${accountId}`, { headers }).then((r) =>\n    State.update({ account: r?.body?.subaccounts[0], all_accounts: r?.body })\n  );\n\n  asyncFetch(\n    `${apiUrl}/orders?address=${accountId}&subaccountNumber=0&limit=100`,\n    {\n      headers,\n    }\n  ).then((r) => State.update({ orders: r?.body }));\n};\n\nfunction getRandomClientId() {\n  let min = 1000000;\n  let max = 99999999;\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n\nconst updateOrders = () => {\n  const nonce = state.nonce ?? 0;\n  State.update({ nonce: nonce + 1 });\n};\n\nif (state.updateMarketPrice == true) {\n  const url = `https://indexer.v4testnet.dydx.exchange/v4/perpetualMarkets?ticker=${state.orderMarketId}`;\n  let data = fetch(url);\n  if (data.ok) {\n    console.log(data);\n    let price = data?.body?.markets?.[state.orderMarketId]?.oraclePrice;\n    if (price) {\n      State.update({ orderPrice: price, updateMarketPrice: false });\n    } else {\n      State.update({ updateMarketPrice: false });\n    }\n  }\n}\n\nconst placeUserOrder = (side) => {\n  if (\n    !state.orderMarketId ||\n    !state.orderPrice ||\n    !state.orderSize ||\n    !state.orderType\n  ) {\n    console.log(\"NO DATA\");\n    return;\n  }\n\n  let marketId = state.orderMarketId;\n  let type = state.orderType;\n  let price = Number(state.orderPrice);\n  let size = Number(state.orderSize);\n  let clientId = getRandomClientId();\n  let timeInForce = \"GTT\";\n  let execution = \"DEFAULT\";\n  let postOnly = false;\n  let reduceOnly = false;\n\n  let network_config = {\n    env: \"dydx-testnet-4\",\n    indexerConfig: {\n      restEndpoint: \"https://dydx-testnet.imperator.co\",\n      websocketEndpoint: \"wss://dydx-testnet.imperator.co/v4/ws\",\n    },\n    validatorConfig: {\n      restEndpoint: \"https://test-dydx.kingnodes.com\",\n      chainId: \"dydx-testnet-4\",\n      denoms: {\n        USDC_DENOM:\n          \"ibc/8E27BA2D5493AF5636760E354E46004562C46AB7EC0CC4C1CA14E9E20E2545B5\",\n        USDC_DECIMALS: 6,\n        USDC_GAS_DENOM: \"uusdc\",\n        CHAINTOKEN_DENOM: \"adv4tnt\",\n        CHAINTOKEN_DECIMALS: 18,\n      },\n      broadcastOptions: {\n        broadcastPollIntervalMs: 3000,\n        broadcastTimeoutMs: 60000,\n      },\n    },\n  };\n\n  let network = new Network(\n    network_config.env,\n    network_config.indexerConfig,\n    network_config.validatorConfig\n  );\n\n  let params = {\n    marketId,\n    type,\n    side,\n    price,\n    size,\n    clientId,\n    timeInForce,\n    goodTilTimeInSeconds: 999999,\n    orderFlags: \"0\",\n    execution,\n    postOnly,\n    reduceOnly,\n    triggerPrice,\n  };\n\n  console.log(params);\n\n  placeOrder(network, state.mnemonic, \"dydx\", 0, params).then(\n    (placeOrderResp) => {\n      console.log(\"placeOrder resp \", placeOrderResp);\n      updateOrders();\n    }\n  );\n};\n\nif (state.dydx_account == undefined) {\n  const toSign = {\n    domain: {\n      name: \"dYdX V4\",\n      chainId: 5,\n    },\n    primaryType: \"dYdX\",\n    types: {\n      dYdX: [{ name: \"action\", type: \"string\" }],\n    },\n    message: {\n      action: \"dYdX Chain Onboarding\",\n    },\n  };\n\n  /*return getWalletFromEvmSignature(\n    \"0x4405ee8175ef8e4b0f760145f732badb93b0c826f69108d10339a4e32648d97a377dd3119ff98d8260a18aa3b221adb56d29ccd2361fcbe5474e2cbc14b949561c\"\n  );*/\n\n  Ethers.provider()\n    .getSigner()\n    ._signTypedData(toSign.domain, { dYdX: toSign.types.dYdX }, toSign.message)\n    .then((signature) => getWalletFromEvmSignature(signature));\n} else {\n  useEffect(() => {\n    loadAccount();\n  }, [state.account, state.orders, state.nonce]);\n\n  return (\n    <div class=\"mb-5\">\n      {state.account.address && (\n        <div>\n          <h2>Account Details</h2>\n          <div>\n            <div>Address: {state.account.address}</div>\n            <div>Equity: ${state.account.equity}</div>\n            <div>Free Collateral: ${state.account.freeCollateral}</div>\n\n            {Object.keys(state.account.openPerpetualPositions ?? []).length >\n              0 && (\n              <>\n                <h2 class=\"mt-5\">Open Perpetual Positions</h2>\n                {Object.keys(state.account.openPerpetualPositions ?? []).map(\n                  (ticker) => {\n                    let order = state.account.openPerpetualPositions[ticker];\n                    return (\n                      <div class=\"mb-2\">\n                        <OrderSide side={order.side}>{order.side}</OrderSide>\n                        <OrderMarket>\n                          {ticker} at ${Big(order.entryPrice).toFixed(4)}\n                        </OrderMarket>{\" \"}\n                        <OrderSize> Size: {order.size}</OrderSize>\n                        {order.createdAt\n                          ? new Date(order.createdAt).toLocaleString()\n                          : \"\"}\n                        <OrderSize>\n                          Realized PNL: {new Big(order.realizedPnl).toFixed(4)}\n                        </OrderSize>\n                        <OrderSize>\n                          Unrealized PNL:{\" \"}\n                          {new Big(order.unrealizedPnl).toFixed(4)}\n                        </OrderSize>\n                      </div>\n                    );\n                  }\n                )}\n              </>\n            )}\n          </div>\n        </div>\n      )}\n      <div>\n        <h2 class=\"mt-5\">Place Order</h2>\n        <div class=\"mb-3 row\">\n          <label for=\"orderPrice\" class=\"col-sm-2 col-form-label\">\n            Type\n          </label>\n          <div class=\"col-sm-10\">\n            <select\n              class=\"form-select\"\n              aria-label=\"Select a pair\"\n              onChange={(e) => State.update({ orderType: e.target.value })}\n            >\n              <option value=\"LIMIT\" selected>\n                Limit\n              </option>\n              <option value=\"MARKET\">Market</option>\n            </select>\n          </div>\n        </div>\n        <div class=\"mb-3 row\">\n          <label for=\"orderPrice\" class=\"col-sm-2 col-form-label\">\n            Pair\n          </label>\n          <div class=\"col-sm-10\">\n            <select\n              class=\"form-select\"\n              aria-label=\"Select a pair\"\n              onChange={(e) =>\n                State.update({\n                  orderMarketId: e.target.value,\n                  updateMarketPrice: true,\n                })\n              }\n            >\n              <option value=\"BTC-USD\">BTC-USD</option>\n              <option value=\"ETH-USD\" selected>\n                ETH-USD\n              </option>\n            </select>\n          </div>\n        </div>\n        {state.orderType == \"LIMIT\" && (\n          <div class=\"mb-3 row\">\n            <label for=\"orderPrice\" class=\"col-sm-2 col-form-label\">\n              Price\n            </label>\n            <div class=\"col-sm-10\">\n              <input\n                type=\"text\"\n                class=\"form-control\"\n                id=\"orderPrice\"\n                value={state.orderPrice}\n                onChange={(e) => State.update({ orderPrice: e.target.value })}\n              />\n            </div>\n          </div>\n        )}\n        <div class=\"mb-3 row\">\n          <label for=\"orderSize\" class=\"col-sm-2 col-form-label\">\n            Size\n          </label>\n          <div class=\"col-sm-10\">\n            <input\n              type=\"text\"\n              class=\"form-control\"\n              id=\"orderSize\"\n              value={state.orderSize}\n              onChange={(e) => State.update({ orderSize: e.target.value })}\n            />\n          </div>\n        </div>\n\n        <div class=\"mb-3 row\">\n          <div class=\"col\">\n            <button\n              class=\"btn btn-success\"\n              onClick={() => placeUserOrder(\"BUY\")}\n            >\n              Buy\n            </button>\n            <button\n              class=\"btn btn-danger\"\n              onClick={() => placeUserOrder(\"SELL\")}\n            >\n              Sell\n            </button>\n          </div>\n        </div>\n      </div>\n      <div>\n        {(state.orders ?? []).length == 0 && <div>Orders were not found</div>}\n        {(state.orders ?? []).length > 0 && (\n          <>\n            <h2 class=\"mt-5\">Orders Log</h2>\n            {(state.orders ?? []).map((order) => (\n              <div class=\"mb-2\">\n                <OrderSide side={order.side}>{order.side}</OrderSide>\n                <OrderMarket>\n                  {order.ticker} at ${order.price}\n                </OrderMarket>{\" \"}\n                <OrderSize>\n                  {\" \"}\n                  Size: {order.size} / Filled: {order.totalFilled}\n                </OrderSize>\n                {order.updatedAt\n                  ? new Date(order.updatedAt).toLocaleString()\n                  : \"\"}\n              </div>\n            ))}\n          </>\n        )}\n      </div>\n      <button\n        onClick={() => {\n          updateOrders();\n        }}\n      >\n        Refresh\n      </button>\n      {/*\n      <hr />\n      state:\n      {JSON.stringify(state)}\n      */}\n    </div>\n  );\n}\n\nreturn (\n  <>\n    Ethereum Account: {state.sender}\n    <Web3Connect connectLabel=\"Connect Web3 Wallet to continue\" />\n  </>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/mike.near/widget/Index", "fact_widget_deployments_id": "122f854c444ef21d5e5ee9250fad089e", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 277}