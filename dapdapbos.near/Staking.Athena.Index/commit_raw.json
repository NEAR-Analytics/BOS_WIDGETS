{"tx_hash": "6N37Mg47Teszij3d4CYQTjwzBaNciUvens8fgYsGQhip", "action_id_social": "6vw2Fkv1m13jweRvsDQi2doH4yyhdjr7bASri3LCcSfJ-0-widget", "block_id": 115176053, "block_timestamp": "2024-03-21T18:54:40.424Z", "signer_id": "dapdapbos.near", "widget_name": "Staking.Athena.Index", "source_code": "const Wrapper = styled.div`\n  --bg-1: #262836;\n  --bg-2: #373a53;\n  --bg-3: #2e3142;\n  --white: #fff;\n  --purple: #979abe;\n  --dark: #1b1e27;\n\n  --fz-12: 12px;\n  --fz-14: 14px;\n  --fz-16: 16px;\n  --fz-24: 24px;\n\n  --primary: #1aca8a;\n  /* --secondary: #6c757d; */\n\n  color: var(--white);\n\n  input[type=\"number\"]::-webkit-inner-spin-button,\n  input[type=\"number\"]::-webkit-outer-spin-button {\n    -webkit-appearance: none;\n    margin: 0;\n  }\n  input[type=\"number\"] {\n    -moz-appearance: textfield;\n  }\n  .form-control::placeholder {\n    color: white;\n  }\n  .form-control:focus {\n    box-shadow: 0 0 0 0.25rem rgba(26, 202, 138, 0.5);\n  }\n  padding-top: 34px;\n  .grid-pool-head {\n    max-width: 1244px;\n    margin: 0 auto 12px;\n    font-size: 14px;\n    color: var(--purple);\n  }\n`;\nconst EmptyWrap = styled.div`\n  padding-top: 150px;\n  .empty-title {\n    color: #fff;\n    text-align: center;\n    font-size: 18px;\n    font-weight: 400;\n    margin-bottom: 13px;\n  }\n  .empty-intro {\n    color: #979abe;\n    text-align: center;\n    font-size: 14px;\n    font-weight: 400;\n  }\n`;\nconst HeadWrapper = styled.div`\n  /* border-radius: 16px; */\n  max-width: 1244px;\n  margin: 0 auto;\n  color: var(--white);\n  font-size: var(--fz-14);\n  .pool-head {\n    border-radius: 16px;\n    height: 84px;\n    align-items: center;\n    cursor: pointer;\n    background-color: var(--bg-1);\n  }\n  .title-primary {\n    font-size: var(--fz-16);\n    font-weight: 500;\n  }\n  .title-secondary {\n  }\n  .green {\n    color: #1aca8a;\n  }\n  .title-sub {\n    font-size: var(--fz-12);\n    color: var(--purple);\n  }\n`;\nconst GridContainer = styled.div`\n  display: grid;\n  grid-template-columns: 40% 12% 12% 12% 24%;\n`;\nconst GridContainer2 = styled.div`\n  display: grid;\n  grid-template-columns: 20% 20% 20% 20% 20%;\n`;\n\nconst GridItem = styled.div`\n  padding-left: 24px;\n  &.action-item {\n    display: flex;\n    column-gap: 10px;\n    padding-right: 18px;\n    justify-content: center;\n  }\n  &.action-item-head {\n    display: flex;\n    justify-content: center;\n  }\n`;\nconst PoolItem = styled.div`\n  margin-bottom: 10px;\n`;\nconst TabsList = styled(\"Tabs.List\")`\n  display: flex;\n  align-items: center;\n  margin: 0 auto;\n  width: 420px;\n  height: 46px;\n  background-color: var(--bg-1);\n  border-radius: 10px;\n  color: var(--white);\n  padding: 0 5px;\n  margin-bottom: 30px;\n  .tab-head-item {\n    flex: 1;\n    display: flex;\n    height: 36px;\n    align-items: center;\n    justify-content: center;\n    font-size: 16px;\n    border-radius: 5px;\n    color: var(--white);\n    cursor: pointer;\n  }\n  .tab-head-item.active {\n    background-color: var(--bg-2);\n  }\n`;\n\n// assets begin\nconst AssetsWrapper = styled.div`\n  display: flex;\n  justify-content: center;\n  column-gap: 18px;\n  max-width: 1244px;\n  margin: 0 auto 42px;\n`;\nconst AssetsPanel = styled.div`\n  flex: 1;\n  border-radius: 16px;\n  border: 1px solid #373a53;\n  background: #2e3142;\n  padding: 20px 18px 0;\n  height: 105px;\n  .as-title {\n    color: var(--purple);\n    font-size: var(--fz-16);\n  }\n  .as-amount {\n    color: var(--white);\n    font-size: var(--fz-24);\n    padding-top: 16px;\n  }\n  .as-sub {\n    font-size: var(--fz-14);\n    color: var(--purple);\n  }\n  .as-action {\n    display: flex;\n    justify-content: space-between;\n  }\n`;\n// assets end\n\nconst {\n  toast,\n  curChain,\n  onSwitchChain,\n  switchingChain,\n  chainId,\n  isChainSupported,\n  multicallAddress,\n  multicall,\n  dexConfig,\n} = props;\n\nconst POOLS = [\n  {\n    poolName: \"Locked ATH\",\n    tokenAddress: \"0xa4ee142e34d0676edc2b760dd0016003d99a4cec\",\n    StakingAddress: \"0xD481eD22a20708839aeB7f1d07E1d01cbc526184\", // Locking\n    poolType: \"Locking\", // Locking MasterChief Staking\n    tvl: 0,\n  },\n  {\n    poolName: \"HUM-xHUM\",\n    tokenAddress: \"0x31cfdA26D5841d92333D8F9B3acbd5efEedb39c1\",\n    StakingAddress: \"0x652a63c4df14e29080Ab058d6f151aBa61F86c10\", //Staking\n    poolType: \"MasterChief\", // Locking MasterChief Staking\n    tvl: 0,\n  },\n];\nconst TOKENS = {\n  \"0xa4ee142e34d0676edc2b760dd0016003d99a4cec\": {\n    address: \"0xa4ee142e34d0676edc2b760dd0016003d99a4cec\",\n    chainId,\n    name: \"ATH\",\n    symbol: \"ATH\",\n    icon: \"https://www.athenafinance.io/assets/tokens/LATH.svg\",\n    decimals: 18,\n    tokenId: \"\",\n  },\n  \"0x31cfdA26D5841d92333D8F9B3acbd5efEedb39c1\": {\n    address: \"0x31cfdA26D5841d92333D8F9B3acbd5efEedb39c1\",\n    chainId,\n    name: \"vAMM-HUM/xHUM\",\n    symbol: \"vAMM-HUM/xHUM\",\n    icon: \"https://www.athenafinance.io/assets/tokens/HUMxHUM.svg\",\n    decimals: 18,\n  },\n  \"0x4febd4ea737a0ae94dd56e754e9b7a83e1c459e9\": {\n    address: \"0x4febd4ea737a0ae94dd56e754e9b7a83e1c459e9\",\n    chainId,\n    name: \"xHUM\",\n    symbol: \"xHUM\",\n    icon: \"https://www.athenafinance.io/assets/tokens/HUMxHUM.svg\",\n    decimals: 18,\n  },\n};\n\nconst LockingABI = [\n  {\n    type: \"function\",\n    stateMutability: \"view\",\n    outputs: [\n      {\n        type: \"address\",\n        name: \"\",\n        internalType: \"contract IERC20\",\n      },\n    ],\n    name: \"ATH\",\n    inputs: [],\n  },\n  {\n    type: \"function\",\n    stateMutability: \"nonpayable\",\n    outputs: [],\n    name: \"addToUnlock\",\n    inputs: [\n      {\n        type: \"uint256\",\n        name: \"amount\",\n        internalType: \"uint256\",\n      },\n      {\n        type: \"uint256\",\n        name: \"slotIndex\",\n        internalType: \"uint256\",\n      },\n    ],\n  },\n  {\n    type: \"function\",\n    stateMutability: \"view\",\n    outputs: [\n      {\n        type: \"uint256\",\n        name: \"\",\n        internalType: \"uint256\",\n      },\n    ],\n    name: \"allowance\",\n    inputs: [\n      {\n        type: \"address\",\n        name: \"owner\",\n        internalType: \"address\",\n      },\n      {\n        type: \"address\",\n        name: \"spender\",\n        internalType: \"address\",\n      },\n    ],\n  },\n  {\n    type: \"function\",\n    stateMutability: \"nonpayable\",\n    outputs: [\n      {\n        type: \"bool\",\n        name: \"\",\n        internalType: \"bool\",\n      },\n    ],\n    name: \"approve\",\n    inputs: [\n      {\n        type: \"address\",\n        name: \"spender\",\n        internalType: \"address\",\n      },\n      {\n        type: \"uint256\",\n        name: \"amount\",\n        internalType: \"uint256\",\n      },\n    ],\n  },\n  {\n    type: \"function\",\n    stateMutability: \"view\",\n    outputs: [\n      {\n        type: \"uint256\",\n        name: \"\",\n        internalType: \"uint256\",\n      },\n    ],\n    name: \"balanceOf\",\n    inputs: [\n      {\n        type: \"address\",\n        name: \"account\",\n        internalType: \"address\",\n      },\n    ],\n  },\n\n  {\n    type: \"function\",\n    stateMutability: \"nonpayable\",\n    outputs: [],\n    name: \"cancelUnlock\",\n    inputs: [\n      {\n        type: \"uint256\",\n        name: \"slotIndex\",\n        internalType: \"uint256\",\n      },\n    ],\n  },\n  {\n    type: \"function\",\n    stateMutability: \"nonpayable\",\n    outputs: [\n      {\n        type: \"address[]\",\n        name: \"rewardTokens\",\n        internalType: \"address[]\",\n      },\n      {\n        type: \"uint256[]\",\n        name: \"earnedRewards\",\n        internalType: \"uint256[]\",\n      },\n    ],\n    name: \"claim\",\n    inputs: [],\n  },\n  {\n    type: \"function\",\n    stateMutability: \"nonpayable\",\n    outputs: [\n      {\n        type: \"address[]\",\n        name: \"rewardTokens\",\n        internalType: \"address[]\",\n      },\n      {\n        type: \"uint256[]\",\n        name: \"earnedRewards\",\n        internalType: \"uint256[]\",\n      },\n    ],\n    name: \"claimFor\",\n    inputs: [\n      {\n        type: \"address\",\n        name: \"_for\",\n        internalType: \"address\",\n      },\n    ],\n  },\n  {\n    type: \"function\",\n    stateMutability: \"view\",\n    outputs: [\n      {\n        type: \"uint8\",\n        name: \"\",\n        internalType: \"uint8\",\n      },\n    ],\n    name: \"decimals\",\n    inputs: [],\n  },\n\n  {\n    type: \"function\",\n    stateMutability: \"nonpayable\",\n    outputs: [],\n    name: \"deposit\",\n    inputs: [\n      {\n        type: \"uint256\",\n        name: \"_amount\",\n        internalType: \"uint256\",\n      },\n    ],\n  },\n  {\n    type: \"function\",\n    stateMutability: \"nonpayable\",\n    outputs: [],\n    name: \"depositFor\",\n    inputs: [\n      {\n        type: \"address\",\n        name: \"_for\",\n        internalType: \"address\",\n      },\n      {\n        type: \"uint256\",\n        name: \"_amount\",\n        internalType: \"uint256\",\n      },\n    ],\n  },\n  {\n    type: \"function\",\n    stateMutability: \"view\",\n    outputs: [\n      {\n        type: \"tuple[]\",\n        name: \"slots\",\n        internalType: \"struct LockerV2.UserUnlocking[]\",\n        components: [\n          {\n            type: \"uint256\",\n          },\n          {\n            type: \"uint256\",\n          },\n          {\n            type: \"uint256\",\n          },\n          {\n            type: \"uint256\",\n          },\n          {\n            type: \"uint256\",\n          },\n          {\n            type: \"uint256\",\n          },\n        ],\n      },\n    ],\n    name: \"getAllUserUnlocking\",\n    inputs: [\n      {\n        type: \"address\",\n        name: \"_user\",\n        internalType: \"address\",\n      },\n    ],\n  },\n\n  {\n    type: \"function\",\n    stateMutability: \"view\",\n    outputs: [\n      {\n        type: \"uint256\",\n        name: \"rewardPercentage\",\n        internalType: \"uint256\",\n      },\n    ],\n    name: \"getUserRewardPercentage\",\n    inputs: [\n      {\n        type: \"address\",\n        name: \"_user\",\n        internalType: \"address\",\n      },\n    ],\n  },\n  {\n    type: \"function\",\n    stateMutability: \"view\",\n    outputs: [\n      {\n        type: \"uint256\",\n        name: \"\",\n        internalType: \"uint256\",\n      },\n    ],\n    name: \"getUserSlotLength\",\n    inputs: [\n      {\n        type: \"address\",\n        name: \"_user\",\n        internalType: \"address\",\n      },\n    ],\n  },\n  {\n    type: \"function\",\n    stateMutability: \"view\",\n    outputs: [\n      {\n        type: \"uint256\",\n        name: \"\",\n        internalType: \"uint256\",\n      },\n    ],\n    name: \"getUserTotalDeposit\",\n    inputs: [\n      {\n        type: \"address\",\n        name: \"_user\",\n        internalType: \"address\",\n      },\n    ],\n  },\n  {\n    type: \"function\",\n    stateMutability: \"view\",\n    outputs: [\n      {\n        type: \"address\",\n        name: \"\",\n        internalType: \"contract IBaseRewardPoolLocker\",\n      },\n    ],\n    name: \"rewarder\",\n    inputs: [],\n  },\n\n  {\n    type: \"function\",\n    stateMutability: \"nonpayable\",\n    outputs: [],\n    name: \"stakeInMasterChief\",\n    inputs: [],\n  },\n  {\n    type: \"function\",\n    stateMutability: \"view\",\n    outputs: [\n      {\n        type: \"address\",\n        name: \"\",\n        internalType: \"address\",\n      },\n    ],\n    name: \"stakingToken\",\n    inputs: [],\n  },\n  {\n    type: \"function\",\n    stateMutability: \"nonpayable\",\n    outputs: [],\n    name: \"startUnlock\",\n    inputs: [\n      {\n        type: \"uint256\",\n        name: \"strategyIndex\",\n        internalType: \"uint256\",\n      },\n      {\n        type: \"uint256\",\n        name: \"amount\",\n        internalType: \"uint256\",\n      },\n      {\n        type: \"uint256\",\n        name: \"slotIndex\",\n        internalType: \"uint256\",\n      },\n    ],\n  },\n  {\n    type: \"function\",\n    stateMutability: \"view\",\n    outputs: [\n      {\n        type: \"string\",\n        name: \"\",\n        internalType: \"string\",\n      },\n    ],\n    name: \"symbol\",\n    inputs: [],\n  },\n  {\n    type: \"function\",\n    stateMutability: \"view\",\n    outputs: [\n      {\n        type: \"uint256\",\n        name: \"\",\n        internalType: \"uint256\",\n      },\n    ],\n    name: \"totalLocked\",\n    inputs: [],\n  },\n  {\n    type: \"function\",\n    stateMutability: \"view\",\n    outputs: [\n      {\n        type: \"uint256\",\n        name: \"\",\n        internalType: \"uint256\",\n      },\n    ],\n    name: \"totalSupply\",\n    inputs: [],\n  },\n  {\n    type: \"function\",\n    stateMutability: \"view\",\n    outputs: [\n      {\n        type: \"uint256\",\n        name: \"\",\n        internalType: \"uint256\",\n      },\n    ],\n    name: \"totalUnlocking\",\n    inputs: [],\n  },\n\n  {\n    type: \"function\",\n    stateMutability: \"view\",\n    outputs: [\n      {\n        type: \"uint256\",\n        name: \"unlockTime\",\n        internalType: \"uint256\",\n      },\n      {\n        type: \"uint256\",\n        name: \"forfeitPercent\",\n        internalType: \"uint256\",\n      },\n      {\n        type: \"uint256\",\n        name: \"rewardPercent\",\n        internalType: \"uint256\",\n      },\n      {\n        type: \"uint256\",\n        name: \"instantUnstakePercent\",\n        internalType: \"uint256\",\n      },\n      {\n        type: \"bool\",\n        name: \"isLinear\",\n        internalType: \"bool\",\n      },\n      {\n        type: \"bool\",\n        name: \"isActive\",\n        internalType: \"bool\",\n      },\n    ],\n    name: \"unlockingStrategies\",\n    inputs: [\n      {\n        type: \"uint256\",\n        name: \"\",\n        internalType: \"uint256\",\n      },\n    ],\n  },\n\n  {\n    type: \"function\",\n    stateMutability: \"view\",\n    outputs: [\n      {\n        type: \"uint256\",\n        name: \"\",\n        internalType: \"uint256\",\n      },\n    ],\n    name: \"userUnlocking\",\n    inputs: [\n      {\n        type: \"address\",\n        name: \"\",\n        internalType: \"address\",\n      },\n    ],\n  },\n  {\n    type: \"function\",\n    stateMutability: \"view\",\n    outputs: [\n      {\n        type: \"uint256\",\n        name: \"startTime\",\n        internalType: \"uint256\",\n      },\n      {\n        type: \"uint256\",\n        name: \"endTime\",\n        internalType: \"uint256\",\n      },\n      {\n        type: \"uint256\",\n        name: \"amount\",\n        internalType: \"uint256\",\n      },\n      {\n        type: \"uint256\",\n        name: \"unlockingStrategy\",\n        internalType: \"uint256\",\n      },\n      {\n        type: \"uint256\",\n        name: \"alreadyUnstaked\",\n        internalType: \"uint256\",\n      },\n      {\n        type: \"uint256\",\n        name: \"alreadyWithdrawn\",\n        internalType: \"uint256\",\n      },\n    ],\n    name: \"userUnlockings\",\n    inputs: [\n      {\n        type: \"address\",\n        name: \"\",\n        internalType: \"address\",\n      },\n      {\n        type: \"uint256\",\n        name: \"\",\n        internalType: \"uint256\",\n      },\n    ],\n  },\n  {\n    type: \"event\",\n    name: \"Approval\",\n    inputs: [\n      {\n        type: \"address\",\n        name: \"owner\",\n        indexed: true,\n      },\n      {\n        type: \"address\",\n        name: \"spender\",\n        indexed: true,\n      },\n      {\n        type: \"uint256\",\n        name: \"value\",\n        indexed: false,\n      },\n    ],\n    anonymous: false,\n  },\n  {\n    type: \"event\",\n    name: \"Claim\",\n    inputs: [\n      {\n        type: \"address\",\n        name: \"user\",\n        indexed: true,\n      },\n      {\n        type: \"uint256\",\n        name: \"timestamp\",\n        indexed: true,\n      },\n    ],\n    anonymous: false,\n  },\n\n  {\n    type: \"event\",\n    name: \"ResetSlot\",\n    inputs: [\n      {\n        type: \"address\",\n        name: \"user\",\n        indexed: true,\n      },\n      {\n        type: \"uint256\",\n        name: \"timestamp\",\n        indexed: true,\n      },\n      {\n        type: \"uint256\",\n        name: \"amount\",\n        indexed: false,\n      },\n      {\n        type: \"uint256\",\n        name: \"slotIndex\",\n        indexed: false,\n      },\n    ],\n    anonymous: false,\n  },\n\n  {\n    type: \"event\",\n    name: \"Unlock\",\n    inputs: [\n      {\n        type: \"address\",\n        name: \"user\",\n        indexed: true,\n      },\n      {\n        type: \"uint256\",\n        name: \"timestamp\",\n        indexed: true,\n      },\n      {\n        type: \"uint256\",\n        name: \"amount\",\n        indexed: false,\n      },\n    ],\n    anonymous: false,\n  },\n];\nconst LPABI = [\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"sender\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"recipient\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"amount0\",\n        type: \"uint256\",\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"amount1\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"Claim\",\n    type: \"event\",\n  },\n\n  {\n    inputs: [\n      { internalType: \"address\", name: \"\", type: \"address\" },\n      { internalType: \"address\", name: \"\", type: \"address\" },\n    ],\n    name: \"allowance\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"spender\", type: \"address\" },\n      { internalType: \"uint256\", name: \"amount\", type: \"uint256\" },\n    ],\n    name: \"approve\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n    name: \"balanceOf\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n\n  {\n    inputs: [],\n    name: \"decimals\",\n    outputs: [{ internalType: \"uint8\", name: \"\", type: \"uint8\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n\n  {\n    inputs: [],\n    name: \"reserve0\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n\n  {\n    inputs: [],\n    name: \"reserve1\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n\n  {\n    inputs: [],\n    name: \"token0\",\n    outputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"token1\",\n    outputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"tokens\",\n    outputs: [\n      { internalType: \"address\", name: \"\", type: \"address\" },\n      { internalType: \"address\", name: \"\", type: \"address\" },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"totalSupply\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\nconst initList = POOLS.map((item) => ({ ...item, stakedAmount: 0, APR: \"\" }));\n\nState.init({\n  currentTab: \"TAB_POOL\",\n  account: \"\", // current wallet address\n  poolsList: initList, //\n  slotLength: 0,\n  myPoolsList: [],\n  curIndex: undefined,\n  tokenPrices: \"\",\n  lockingTotalSupply: 0,\n  athLockerApr: \"\",\n});\nconst account = Ethers.send(\"eth_requestAccounts\", [])[0];\n\nfunction multiCallV2(abi, calls, options, onSuccess, onError) {\n  // for metis 1088\n  const MULTICALL_ADDRESS = \"0xc39aBB6c4451089dE48Cffb013c39d3110530e5C\";\n  const MULTICALL_ABI = [\n    {\n      inputs: [\n        { internalType: \"bool\", name: \"requireSuccess\", type: \"bool\" },\n        {\n          components: [\n            { internalType: \"address\", name: \"target\", type: \"address\" },\n            { internalType: \"bytes\", name: \"callData\", type: \"bytes\" },\n          ],\n          internalType: \"struct Multicall2.Call[]\",\n          name: \"calls\",\n          type: \"tuple[]\",\n        },\n      ],\n      name: \"tryAggregate\",\n      outputs: [\n        {\n          components: [\n            { internalType: \"bool\", name: \"success\", type: \"bool\" },\n            { internalType: \"bytes\", name: \"returnData\", type: \"bytes\" },\n          ],\n          internalType: \"struct Multicall2.Result[]\",\n          name: \"returnData\",\n          type: \"tuple[]\",\n        },\n      ],\n      stateMutability: \"nonpayable\",\n      type: \"function\",\n    },\n  ];\n  const MulticallContract = new ethers.Contract(\n    MULTICALL_ADDRESS,\n    MULTICALL_ABI,\n    Ethers.provider().getSigner()\n  );\n\n  const { requireSuccess, ...overrides } = options || {};\n  const itf = new ethers.utils.Interface(abi);\n  const calldata = calls.map((call) => ({\n    target: call.address.toLowerCase(),\n    callData: itf.encodeFunctionData(call.name, call.params),\n  }));\n  MulticallContract.callStatic\n    .tryAggregate(requireSuccess || true, calldata, overrides)\n    .then((res) => {\n      onSuccess(\n        res.map((call, i) => {\n          const [result, data] = call;\n          return result && data !== \"0x\"\n            ? itf.decodeFunctionResult(calls[i].name, data)\n            : null;\n        })\n      );\n    })\n    .catch((err) => {\n      onError?.(err);\n    });\n}\n\nfunction calcStakedAmount() {\n  const temp = [...state.poolsList];\n  const { totalDeposit, unlocking } = temp[0];\n  if (!isNaN(Number(totalDeposit)) && !isNaN(Number(unlocking))) {\n    temp[0].stakedAmount = `${Big(totalDeposit).minus(Big(unlocking))}`;\n  } else {\n    temp[0].stakedAmount = \"-\";\n  }\n  State.update({\n    poolsList: temp,\n    // fresh: state.fresh + 1,\n  });\n}\n\nfunction initPoolList() {\n  for (const item of state.poolsList) {\n    if (item.poolType === \"Locking\") {\n      const temp = [...state.poolsList];\n      getMultiLocking(item);\n      // Locking\n\n      getLockingClaim(item).then((array) => {\n        if (array.length) {\n          fetchDexPrice(\"metis\", array[0].join()).then((token_prices) => {\n            const _rewards = array[0].reduce((total, addr, index) => {\n              const _amount = ethers.utils.formatUnits(array[1][index]);\n              const _price = token_prices[addr.toLowerCase()];\n              return Big(_amount || 0)\n                .times(Big(_price || 0))\n                .plus(total)\n                .toFixed();\n            }, 0);\n\n            temp[0].rewardAmount = Big(_rewards).toFixed(2);\n            State.update({\n              poolsList: temp,\n              // fresh: state.fresh + 1,\n            });\n          });\n        }\n      });\n    }\n    if (item.poolType === \"MasterChief\") {\n      getMultiLP(item);\n      getMultiMasterChief(item);\n    }\n  }\n}\n\nfunction fetchDexPrice(network, addresses) {\n  return asyncFetch(\n    `https://api.geckoterminal.com/api/v2/simple/networks/${network}/token_price/${addresses}`,\n    {\n      headers: {\n        Accept: \"application/json;version=20230302\",\n      },\n    }\n  )\n    .then((res) => {\n      if (res.ok) {\n        return res.body.data.attributes.token_prices;\n      }\n    })\n    .catch((error) => {\n      console.log(\"fetchDexPrice_error\", error);\n    });\n}\n\nfunction getLockingClaim(pool) {\n  const myContract = new ethers.Contract(\n    pool.StakingAddress,\n    [\n      {\n        type: \"function\",\n        stateMutability: \"nonpayable\",\n        outputs: [\n          {\n            type: \"address[]\",\n            name: \"rewardTokens\",\n            internalType: \"address[]\",\n          },\n          {\n            type: \"uint256[]\",\n            name: \"earnedRewards\",\n            internalType: \"uint256[]\",\n          },\n        ],\n        name: \"claimFor\",\n        inputs: [\n          {\n            type: \"address\",\n            name: \"_for\",\n            internalType: \"address\",\n          },\n        ],\n      },\n    ],\n    Ethers.provider().getSigner()\n  );\n\n  return myContract.callStatic\n    .claimFor(account)\n    .then((res) => {\n      console.info(\n        res,\n        res[0].join(),\n        res[1].map((item) => item.toString())\n      );\n      return res;\n    })\n    .catch((err) => {\n      console.info(\"getClaim_error:\", err);\n    });\n}\n\nfunction getMultiMasterChief(pool) {\n  const fns = [\"userInfo\", \"depositInfo\"];\n  const calls = fns.map((fn) => {\n    return {\n      address: pool.StakingAddress,\n      name: fn,\n      params: [pool.tokenAddress, account],\n    };\n  });\n\n  multiCallV2(\n    [\n      {\n        type: \"function\",\n        stateMutability: \"view\",\n        outputs: [\n          {\n            type: \"uint256\",\n            name: \"amount\",\n            internalType: \"uint256\",\n          },\n          {\n            type: \"uint256\",\n            name: \"rewardDebt\",\n            internalType: \"uint256\",\n          },\n          {\n            type: \"uint256\",\n            name: \"available\",\n            internalType: \"uint256\",\n          },\n        ],\n        name: \"userInfo\",\n        inputs: [\n          {\n            type: \"address\",\n            name: \"\",\n            internalType: \"address\",\n          },\n          {\n            type: \"address\",\n            name: \"\",\n            internalType: \"address\",\n          },\n        ],\n      },\n      {\n        type: \"function\",\n        stateMutability: \"view\",\n        outputs: [\n          {\n            type: \"uint256\",\n            name: \"availableAmount\",\n            internalType: \"uint256\",\n          },\n        ],\n        name: \"depositInfo\",\n        inputs: [\n          {\n            type: \"address\",\n            name: \"_lp\",\n            internalType: \"address\",\n          },\n          {\n            type: \"address\",\n            name: \"_user\",\n            internalType: \"address\",\n          },\n        ],\n      },\n    ],\n    calls,\n    {},\n    (res) => {\n      console.log(\"getMultiMasterChief res:\", res);\n      const temp = [...state.poolsList];\n\n      const stakedAmount = Big(ethers.utils.formatUnits(res[1][0])).toFixed();\n      const reward = ethers.utils.formatUnits(res[0][1]);\n      const athPrice = state.tokenPrices[state.poolsList[0].tokenAddress];\n      const rewardAmount = Big(reward).times(Big(athPrice));\n\n      temp[1].stakedAmount = stakedAmount;\n      temp[1].rewardAmount = rewardAmount.toFixed(2);\n\n      State.update({\n        poolsList: temp,\n      });\n    },\n    (err) => {\n      console.log(\"getMultiMasterChief_error\", err);\n    }\n  );\n}\n\nfunction getTokenPrices() {\n  const tokenAddresses = state.poolsList\n    .filter((item) => item.poolType === \"Locking\")\n    .map((item) => item.tokenAddress)\n    .join();\n  fetchDexPrice(\"metis\", tokenAddresses).then((prices) => {\n    State.update({\n      tokenPrices: prices,\n    });\n  });\n}\n\nfunction getMultiLocking(pool) {\n  const fns = [\n    \"getUserTotalDeposit\",\n    \"userUnlocking\",\n    \"getUserSlotLength\",\n    \"totalSupply\",\n    \"getAllUserUnlocking\",\n  ];\n  const calls = fns.map((fn) => {\n    if (fn === \"totalSupply\") {\n      return {\n        address: pool.StakingAddress,\n        name: fn,\n      };\n    }\n    return {\n      address: pool.StakingAddress,\n      name: fn,\n      params: [account],\n    };\n  });\n\n  multiCallV2(\n    LockingABI,\n    calls,\n    {},\n    (res) => {\n      console.log(\"getMultiLocking res:\", res);\n      const temp = [...state.poolsList];\n      temp[0].totalDeposit = Big(ethers.utils.formatUnits(res[0][0])).toFixed(\n        2\n      );\n      temp[0].unlocking = Big(ethers.utils.formatUnits(res[1][0])).toFixed(2);\n\n      const slotLength = res[2][0].toString();\n      const totalSupply = res[3][0];\n\n      const list = res[4][0].map((item) =>\n        item.map((number, index) => {\n          switch (index) {\n            case 0:\n            case 1:\n              return number;\n            case 2:\n              return Big(ethers.utils.formatUnits(number)).toFixed(2);\n            default:\n              return number;\n          }\n        })\n      );\n      const _myPoolsList = list\n        .map((item, index) => {\n          item.push(index);\n          return item;\n        })\n        .filter((item) => {\n          return item[2].toString() !== \"0.00\";\n        });\n\n      State.update({\n        lockingTotalSupply: totalSupply,\n        poolsList: temp,\n        slotLength,\n        myPoolsList: _myPoolsList,\n      });\n      calcStakedAmount();\n    },\n    (err) => {\n      console.log(\"getLockingInfo_error\", err);\n    }\n  );\n}\n\nfunction getMultiLP(pool) {\n  const fns = [\n    \"reserve0\",\n    \"reserve1\",\n    \"totalSupply\",\n    \"balanceOf\",\n    \"token0\",\n    \"token1\",\n  ];\n  const calls = fns.map((fn) => {\n    if (fn === \"balanceOf\") {\n      return {\n        address: pool.tokenAddress,\n        name: fn,\n        params: [pool.StakingAddress],\n      };\n    } else {\n      return {\n        address: pool.tokenAddress,\n        name: fn,\n      };\n    }\n  });\n\n  multiCallV2(\n    LPABI,\n    calls,\n    {},\n    (res) => {\n      const reserve0 = ethers.utils.formatUnits(res[0][0]);\n      const reserve1 = ethers.utils.formatUnits(res[1][0]);\n      const totalSupply = ethers.utils.formatUnits(res[2][0]);\n      const balanceOf = ethers.utils.formatUnits(res[3][0]);\n      const tokenAddresses = res.slice(4);\n\n      fetchDexPrice(\"metis\", tokenAddresses).then((prices) => {\n        const pricesArray = Object.values(prices);\n        const LPPrice = Big(reserve0)\n          .times(pricesArray[0])\n          .plus(Big(reserve1).times(pricesArray[1]))\n          .div(Big(totalSupply));\n\n        const tvl = LPPrice.times(Big(balanceOf)).toFixed(2);\n        const temp = [...state.poolsList];\n        temp[1].tvl = tvl;\n        temp[1].LPPrice = LPPrice.toFixed();\n        State.update({\n          poolsList: temp,\n        });\n      });\n    },\n    (err) => {\n      console.log(\"getMultiLP_error\", err);\n    }\n  );\n}\n\nfunction getAPR() {\n  const APR_ABI = [\n    {\n      type: \"function\",\n      stateMutability: \"view\",\n      outputs: [\n        {\n          type: \"uint256\",\n          name: \"APR\",\n          internalType: \"uint256\",\n        },\n      ],\n      name: \"getATHAPRForLocker\",\n      inputs: [],\n    },\n    {\n      type: \"function\",\n      stateMutability: \"view\",\n      outputs: [\n        {\n          type: \"uint256[]\",\n          name: \"APRs\",\n          internalType: \"uint256[]\",\n        },\n        {\n          type: \"address[]\",\n          name: \"rewardTokens\",\n          internalType: \"address[]\",\n        },\n      ],\n      name: \"getMultipleAPRforLockerlsInAdditionalReward\",\n      inputs: [\n        {\n          type: \"uint256\",\n          name: \"feeAmount\",\n          internalType: \"uint256\",\n        },\n        {\n          type: \"address[]\",\n          name: \"lps\",\n          internalType: \"address[]\",\n        },\n        {\n          type: \"address[]\",\n          name: \"inputRewardTokens\",\n          internalType: \"address[]\",\n        },\n      ],\n    },\n    {\n      type: \"function\",\n      stateMutability: \"view\",\n      outputs: [\n        {\n          type: \"uint256\",\n          name: \"APR\",\n          internalType: \"uint256\",\n        },\n      ],\n      name: \"getXHUMAPRForLocker\",\n      inputs: [\n        {\n          type: \"uint256\",\n          name: \"feeAmount\",\n          internalType: \"uint256\",\n        },\n      ],\n    },\n    {\n      type: \"function\",\n      stateMutability: \"view\",\n      outputs: [\n        {\n          type: \"uint256\",\n          name: \"APR\",\n          internalType: \"uint256\",\n        },\n      ],\n      name: \"getATHAprForPool\",\n      inputs: [\n        {\n          type: \"address\",\n          name: \"pool\",\n          internalType: \"address\",\n        },\n      ],\n    },\n  ];\n\n  const feeAmount = 600;\n  const lps = [\n    \"0xa35ad1b31059a652c2bad1114604845469b86692\",\n    \"0x619f235808d57d277c2c485af26a5a726ff7606b\",\n    \"0x9c531f76b974fe0b7f545ba4c0623dd2fea3ef26\",\n    \"0x919395161dd538aa0fb065a8eac878b18d07fbcd\",\n    \"0x3eaa426861a283f0e46b6411aeb3c3608b090e0e\",\n    \"0x8a19e755610aecb3c55bde4ecfb9185ef0267400\",\n    \"0x0cad02c4c6fb7c0d403af74ba9ada3bf40df6478\",\n    \"0xd5a0760d55ad46b6a1c46d28725e4c117312a7ad\",\n    \"0x9f51f0d7f500343e969d28010c7eb0db1bcaaef9\",\n    \"0x9e3f3be65fec3731197aff816489eb1eb6e6b830\",\n  ];\n  const inputRewardTokens = [\"0xdeaddeaddeaddeaddeaddeaddeaddeaddead0000\"];\n\n  const APR_ADDRESS = \"0x0dBDb8e33c66125d990abE4E4898e43781Bd5FEB\";\n  const calls = [\n    {\n      address: APR_ADDRESS,\n      name: \"getATHAPRForLocker\",\n    },\n    {\n      address: APR_ADDRESS,\n      name: \"getMultipleAPRforLockerlsInAdditionalReward\",\n      params: [feeAmount, lps, inputRewardTokens],\n    },\n    {\n      address: APR_ADDRESS,\n      name: \"getXHUMAPRForLocker\",\n      params: [feeAmount],\n    },\n    {\n      address: APR_ADDRESS,\n      name: \"getATHAprForPool\",\n      params: [\"0x31cfdA26D5841d92333D8F9B3acbd5efEedb39c1\"],\n    },\n  ];\n\n  multiCallV2(\n    APR_ABI,\n    calls,\n    {},\n    (res) => {\n      const [[athAmount], [[metisAmount], [addr]], [xhumAmount], [humAmount]] =\n        res;\n\n      const athApr = Big(ethers.utils.formatUnits(athAmount, 8)).toFixed(2);\n      const metisApr = Big(ethers.utils.formatUnits(metisAmount, 8)).toFixed(2);\n      const xhumApr = Big(ethers.utils.formatUnits(xhumAmount, 8)).toFixed(2);\n\n      const humApr = Big(ethers.utils.formatUnits(humAmount, 8)).toFixed(2);\n      const athLockerApr = Big(athApr).plus(metisApr).plus(xhumApr).toFixed(2);\n\n      const temp = [...state.poolsList];\n      temp[0].APR = athLockerApr;\n      temp[1].APR = humApr;\n      State.update({\n        poolsList: temp,\n      });\n    },\n    (err) => {\n      console.log(\"getMultiLP_error\", err);\n    }\n  );\n}\n\nuseEffect(() => {\n  State.update({ account });\n  if (account) {\n    initPoolList();\n    getAPR();\n  }\n}, [account]);\n\nuseEffect(() => {\n  getTokenPrices();\n}, []);\n\n// calc tvl for locking\nuseEffect(() => {\n  const lockingPrice = state.tokenPrices[POOLS[0].tokenAddress];\n  if (!lockingPrice || !state.lockingTotalSupply) return;\n\n  const lockingTVL = Big(lockingPrice)\n    .times(Big(ethers.utils.formatUnits(state.lockingTotalSupply)))\n    .toFixed(2);\n  const temp = [...state.poolsList];\n  temp[0].tvl = lockingTVL;\n  State.update({\n    poolsList: temp,\n  });\n}, [state.tokenPrices, state.lockingTotalSupply]);\n\nconst handleChangeTabs = (value) => {\n  State.update({\n    currentTab: value,\n  });\n};\n\nfunction handleReLock(index) {\n  // State.update({\n  //   unstaking: true,\n  // });\n\n  const myContract = new ethers.Contract(\n    POOLS[0].StakingAddress,\n    LockingABI,\n    Ethers.provider().getSigner()\n  );\n  myContract\n    .startUnlock(0, 0, index)\n    .then((tx) => {\n      console.log(\"tx: \", tx);\n      tx.wait()\n        .then((res) => {\n          const { status, transactionHash } = res;\n          console.info(\"tx_res: \", res);\n          if (status === 1) {\n            toast.success?.({\n              title: \"Transaction Successful!\",\n              text: `transactionHash ${transactionHash}`,\n            });\n          } else {\n            toast.fail?.({\n              title: \"Transaction Failed!\",\n              text: `transactionHash ${transactionHash}`,\n            });\n          }\n        })\n        .finally(() => {\n          // State.update({\n          //   unstaking: false,\n          // });\n        });\n    })\n    .catch((err) => {\n      // State.update({\n      //   unstaking: false,\n      // });\n      console.log(\"handleReLock_error:\", err);\n    });\n}\nfunction handleUnLock(index) {\n  State.update({\n    curIndex: index,\n  });\n\n  const myContract = new ethers.Contract(\n    POOLS[0].StakingAddress,\n    [\n      {\n        type: \"function\",\n        stateMutability: \"nonpayable\",\n        outputs: [],\n        name: \"unlock\",\n        inputs: [\n          {\n            type: \"uint256\",\n            name: \"slotIndex\",\n            internalType: \"uint256\",\n          },\n        ],\n      },\n    ],\n    Ethers.provider().getSigner()\n  );\n  myContract\n    .unlock(index, {\n      gasLimit: 5000000,\n    })\n    .then((tx) => {\n      console.log(\"tx: \", tx);\n      tx.wait()\n        .then((res) => {\n          const { status, transactionHash } = res;\n          console.info(\"tx_res: \", res);\n          if (status === 1) {\n            toast.success?.({\n              title: \"Transaction Successful!\",\n              text: `transactionHash ${transactionHash}`,\n            });\n          } else {\n            toast.fail?.({\n              title: \"Transaction Failed!\",\n              text: `transactionHash ${transactionHash}`,\n            });\n          }\n        })\n        .finally(() => {\n          State.update({\n            curIndex: undefined,\n          });\n        });\n    })\n    .catch((err) => {\n      State.update({\n        curIndex: undefined,\n      });\n      console.log(\"handleUnLock_error:\", err);\n    });\n}\nconsole.log(\"STATE:\", state);\nreturn (\n  <Wrapper>\n    <Tabs.Root value={state.currentTab} onValueChange={handleChangeTabs}>\n      <TabsList>\n        <Tabs.Trigger value=\"TAB_POOL\" asChild>\n          <div\n            className={`tab-head-item ${\n              state.currentTab === \"TAB_POOL\" ? \"active\" : \"\"\n            }`}\n          >\n            All Pools\n          </div>\n        </Tabs.Trigger>\n        <Tabs.Trigger value=\"TAB_ASSETS\" asChild>\n          <div\n            className={`tab-head-item ${\n              state.currentTab === \"TAB_ASSETS\" ? \"active\" : \"\"\n            }`}\n          >\n            Unlock requests\n          </div>\n        </Tabs.Trigger>\n      </TabsList>\n      <Tabs.Content value=\"TAB_POOL\">\n        <GridContainer className=\"grid-pool-head\">\n          <GridItem>Pool</GridItem>\n          <GridItem>APR</GridItem>\n          <GridItem>TVL</GridItem>\n          <GridItem>You Staked</GridItem>\n          <GridItem>Your rewards</GridItem>\n        </GridContainer>\n        <Accordion.Root type=\"single\" collapsible>\n          {state.poolsList.map((item) => (\n            <PoolItem>\n              <Widget\n                src=\"dapdapbos.near/widget/Staking.Athena.Pool\"\n                props={{\n                  ...props,\n                  data: item,\n                  account: state.account,\n                  TOKENS,\n                  LockingABI,\n                  slotLength: state.slotLength,\n                  tokenPrices: state.tokenPrices,\n                  startUnlockIndex: state.myPoolsList?.length,\n                }}\n                key={item.poolName}\n              />\n            </PoolItem>\n          ))}\n        </Accordion.Root>\n      </Tabs.Content>\n      <Tabs.Content value=\"TAB_ASSETS\">\n        {state.myPoolsList.length ? (\n          <GridContainer2 className=\"grid-pool-head\">\n            <GridItem>Start date</GridItem>\n            <GridItem>Amount</GridItem>\n            <GridItem>End date</GridItem>\n            <GridItem>Status</GridItem>\n            <GridItem className=\"action-item-head\">Action</GridItem>\n          </GridContainer2>\n        ) : null}\n        <HeadWrapper>\n          {state.myPoolsList.length ? (\n            state.myPoolsList?.map((item, index) => (\n              <PoolItem key={index}>\n                <GridContainer2 className=\"pool-head\">\n                  <GridItem>\n                    <div className=\"title-primary\">\n                      {/* <Widget\n                          src=\"dapdapbos.near/widget/UI.Avatar\"\n                          props={{ src: TOKENS[tokenAddress].icon }}\n                        /> */}\n\n                      <span>\n                        <Widget\n                          src=\"dapdapbos.near/widget/Utils.FormatTime\"\n                          props={{ time: item[0] }}\n                        />\n                      </span>\n                    </div>\n                  </GridItem>\n                  <GridItem>\n                    <div className=\"title-secondary\">{item[2]}</div>\n                    {/* <div className=\"title-sub\">{item[1]}</div> */}\n                  </GridItem>\n                  <GridItem>\n                    <div className=\"title-secondary\">\n                      <Widget\n                        src=\"dapdapbos.near/widget/Utils.FormatTime\"\n                        props={{ time: item[1] }}\n                      />\n                    </div>\n                  </GridItem>\n                  <GridItem>\n                    {Big(new Date().getTime()).gt(Big(item[1]).times(1000)) ? (\n                      <div className=\"title-secondary green\">Ready</div>\n                    ) : (\n                      <div className=\"title-secondary\">In progress</div>\n                    )}\n                  </GridItem>\n                  <GridItem className=\"action-item\">\n                    {Big(new Date().getTime()).gt(Big(item[1]).times(1000)) ? (\n                      <Widget\n                        src=\"dapdapbos.near/widget/UI.Button\"\n                        props={{\n                          text: \"WITHDRAW\",\n                          type: \"green\",\n                          style: { width: 118 },\n                          loading: index === state.curIndex ? true : false,\n                          disabled:\n                            state.curIndex > -1 && index !== state.curIndex\n                              ? true\n                              : false,\n                          onClick: () => {\n                            handleUnLock(item[6]);\n                          },\n                        }}\n                      />\n                    ) : (\n                      <Widget\n                        src=\"dapdapbos.near/widget/UI.Button\"\n                        props={{\n                          text: \"RE-LOCK\",\n                          type: \"green\",\n                          style: { width: 118 },\n                          onClick: () => {\n                            handleReLock(item, index);\n                          },\n                        }}\n                      />\n                    )}\n                  </GridItem>\n                </GridContainer2>\n              </PoolItem>\n            ))\n          ) : (\n            <EmptyWrap>\n              <div className=\"empty-title\">No productive assets detected</div>\n              <div className=\"empty-intro\">\n                Head over to the pools list and make a deposit to start earning\n                yield!\n              </div>\n            </EmptyWrap>\n          )}\n        </HeadWrapper>\n      </Tabs.Content>\n    </Tabs.Root>\n    {!isChainSupported && (\n      <Widget\n        src=\"bluebiu.near/widget/Swap.ChainWarnigBox\"\n        props={{\n          chain: curChain,\n          onSwitchChain: onSwitchChain,\n          switchingChain: switchingChain,\n          theme: dexConfig.theme,\n        }}\n      />\n    )}\n  </Wrapper>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/dapdapbos.near/widget/Staking.Athena.Index", "fact_widget_deployments_id": "1f4f647c35c66ec699a368f35028abc7", "inserted_timestamp": "2024-03-21T20:28:41.343Z", "modified_timestamp": "2024-03-21T20:28:41.343Z", "__row_index": 8}