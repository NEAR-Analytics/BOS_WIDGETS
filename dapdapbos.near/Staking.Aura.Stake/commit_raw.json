{"tx_hash": "C2SchndhcvdEhu6d2Ua5yeEMNF1PEtLiweYVGT6FDbNY", "action_id_social": "7XeV6UFamKDphyKvgcYT7H32wJxcPTbsj7jyg9SBguLi-0-widget", "block_id": 114673017, "block_timestamp": "2024-03-14T05:06:45.796Z", "signer_id": "dapdapbos.near", "widget_name": "Staking.Aura.Stake", "source_code": "const StakePanel = styled.div`\n  width: 510px;\n  margin: 0 auto;\n  .bos-input-number {\n    background-color: var(--dark);\n    color: var(--white);\n    border: none;\n    border-radius: 10px !important;\n  }\n  .input-group {\n    column-gap: 5px;\n  }\n`;\nconst AmountList = styled.div`\n  display: flex;\n  font-size: var(--fz12);\n  color: var(--purple);\n  justify-content: space-between;\n  padding: 10px 0 16px;\n  .amount-left {\n  }\n  .amount-right {\n  }\n  .amount-white {\n    text-decoration: underline;\n    color: var(--white);\n  }\n`;\nconst StakeBtnWrap = styled.div`\n  display: flex;\n  column-gap: 14px;\n`;\n\nconst BoosterLiteWrapper = \"0x98Ef32edd24e2c92525E59afc4475C1242a30184\";\nconst BoosterLiteABI = [\n  {\n    inputs: [\n      { internalType: \"uint256\", name: \"_pid\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"_amount\", type: \"uint256\" },\n      { internalType: \"bool\", name: \"_stake\", type: \"bool\" },\n    ],\n    name: \"deposit\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n];\nconst {\n  data,\n\n  account,\n  TOKENS,\n  RewardPoolDepositWrapper,\n  RewardPoolDepositABI,\n  toast,\n  addAction,\n  tokenIcons,\n} = props;\n\nState.init({\n  allowance: 0,\n  curToken: \"\", // token address\n  curTokenBal: 0,\n  curSymbol: \"\",\n  needApprove: false,\n  isApproving: false,\n  isApproved: false,\n  canStake: false,\n  isStaking: false,\n  inputValue: \"\",\n  selectData: [],\n});\n\nuseEffect(() => {\n  const { tokenAssets } = data;\n\n  if (tokenAssets) {\n    const selectData = tokenAssets.map((item) =>\n      TOKENS[item]\n        ? {\n            value: item,\n            text: TOKENS[item].symbol,\n            icons: [TOKENS[item].icon],\n          }\n        : null\n    );\n    const usefulSelect = selectData.filter((n) => n);\n\n    usefulSelect.unshift({\n      value: data.LP_token_address,\n      text: \"BPT\",\n      icons: tokenIcons,\n    });\n\n    State.update({\n      selectData: usefulSelect,\n    });\n  }\n}, [data]);\n\nfunction updateAllowance(allowanceRaw) {\n  const allowAmount = ethers.utils.formatUnits(\n    allowanceRaw,\n    TOKENS[state.curToken].decimals\n  );\n\n  State.update({\n    allowance: allowAmount,\n  });\n}\n\nconst handleApprove = (tokenAddress, _spender) => {\n  State.update({\n    isApproving: true,\n  });\n\n  const TokenContract = new ethers.Contract(\n    tokenAddress,\n    [\n      {\n        constant: false,\n        inputs: [\n          {\n            name: \"_spender\",\n            type: \"address\",\n          },\n          {\n            name: \"_value\",\n            type: \"uint256\",\n          },\n        ],\n        name: \"approve\",\n        outputs: [\n          {\n            name: \"\",\n            type: \"bool\",\n          },\n        ],\n        payable: false,\n        stateMutability: \"nonpayable\",\n        type: \"function\",\n      },\n    ],\n    Ethers.provider().getSigner()\n  );\n  console.info(\"to approve: \", tokenAddress, TOKENS[tokenAddress].decimals);\n\n  TokenContract.approve(\n    _spender,\n    ethers.utils.parseUnits(\n      state.inputValue,\n      TOKENS[state.curToken].decimals || 18\n    )\n  )\n    .then((tx) => {\n      tx.wait()\n        .then((res) => {\n          const { status, transactionHash } = res;\n          console.info(\"approve_tx_res:\", res);\n          State.update({\n            isApproved: status === 1,\n            isApproving: false,\n          });\n          if (status === 1) {\n            toast.success?.({\n              title: \"Transaction Successful!\",\n              text: `transactionHash ${transactionHash}`,\n            });\n          } else {\n            toast.fail?.({\n              title: \"Transaction Failed!\",\n              text: `transactionHash ${transactionHash}`,\n            });\n          }\n        })\n        .finally(() => {\n          State.update({\n            isApproving: false,\n          });\n        });\n    })\n    .catch((err) => {\n      console.info(\"approve_error: \", err);\n      State.update({\n        isApproving: false,\n      });\n    });\n};\n\nuseEffect(() => {\n  // get token allowance when current token change\n  if (!state.curToken) {\n    // const defaultToken = data?.tokenAssets[0];\n    const defaultToken = state.selectData[0].value;\n    State.update({\n      curToken: defaultToken,\n      curSymbol: TOKENS[state.curToken].symbol,\n    });\n  } else {\n    if (state.curToken === data.LP_token_address) {\n      State.update({\n        curTokenBal: data.bptAmount,\n        curSymbol: \"BPT\",\n      });\n    } else {\n      State.update({\n        curSymbol: TOKENS[state.curToken].symbol,\n      });\n    }\n  }\n}, [state.curToken]);\n\nuseEffect(() => {\n  if (!state.inputValue) {\n    // input none\n    State.update({\n      needApprove: false,\n      canStake: false,\n    });\n    return false;\n  }\n  if (Big(state.allowance).lt(Big(state.inputValue || 0))) {\n    State.update({\n      canStake: false,\n      isApproved: false,\n      needApprove: true,\n    });\n  } else {\n    State.update({\n      canStake: true,\n      needApprove: false,\n    });\n  }\n}, [state.inputValue, state.allowance, state.curToken]);\n\nuseEffect(() => {\n  if (state.isApproved) {\n    State.update({\n      canStake: true,\n    });\n  } else {\n    State.update({\n      canStake: false,\n    });\n  }\n}, [state.isApproved]);\n\nconst handleInputChange = (e) => {\n  State.update({\n    inputValue: e.target.value,\n  });\n};\n// amount: number | string | BN\n// decimals: number | BN\nconst simpleToExactAmount = (amount, decimals) => {\n  // Code is largely lifted from the guts of web3 toWei here:\n  // https://github.com/ethjs/ethjs-unit/blob/master/src/index.js\n  console.log(\"simpleToExactAmount: \", amount, decimals);\n  let amountString = amount.toString();\n  const decimalsBN = new BN(decimals);\n\n  // if (decimalsBN.gt(100)) {\n  //   console.info(`Invalid decimals amount`);\n  // }\n\n  const scale = new BN(10).pow(decimalsBN);\n  const scaleString = scale.toString();\n\n  // Is it negative?\n  const negative = amountString.substring(0, 1) === \"-\";\n  if (negative) {\n    amountString = amountString.substring(1);\n  }\n\n  if (amountString === \".\") {\n    console.info(\n      `Error converting number ${amountString} to precise unit, invalid value`\n    );\n  }\n\n  // Split it into a whole and fractional part\n  // eslint-disable-next-line prefer-const\n  let [whole, fraction, ...rest] = amountString.split(\".\");\n  if (rest.length > 0) {\n    console.info(\n      `Error converting number ${amountString} to precise unit, too many decimal points`\n    );\n  }\n\n  if (!whole) {\n    whole = \"0\";\n  }\n  if (!fraction) {\n    fraction = \"0\";\n  }\n\n  if (fraction.length > scaleString.length - 1) {\n    console.info(\n      `Error converting number ${amountString} to precise unit, too many decimal places`\n    );\n  }\n\n  while (fraction.length < scaleString.length - 1) {\n    fraction += \"0\";\n  }\n\n  const wholeBN = new BN(whole);\n  const fractionBN = new BN(fraction);\n  let result = wholeBN.mul(scale).add(fractionBN);\n\n  if (negative) {\n    result = result.mul(\"-1\");\n  }\n\n  return result;\n};\n\nfunction handleStakeBPT() {\n  State.update({\n    isStaking: true,\n  });\n  const { Aura_Pool_ID } = data;\n  const BPTContract = new ethers.Contract(\n    BoosterLiteWrapper,\n    BoosterLiteABI,\n    Ethers.provider().getSigner()\n  );\n  console.log(ethers.utils.parseUnits(state.inputValue), data, props);\n  BPTContract.deposit(\n    Aura_Pool_ID,\n    ethers.utils.parseUnits(state.inputValue),\n    true,\n    {\n      gasLimit: 1173642,\n    }\n  )\n    .then((tx) => {\n      console.log(\"tx: \", tx);\n      tx.wait()\n        .then((res) => {\n          const { status, transactionHash } = res;\n          console.info(\"tx_res: \", res);\n          if (status === 1) {\n            toast.success?.({\n              title: \"Transaction Successful!\",\n              text: `transactionHash ${transactionHash}`,\n            });\n            addAction?.({\n              type: \"Staking\",\n              action: \"Stake\",\n              token: TOKENS[curToken],\n              amount: state.inputValue,\n              template: \"Aura Finance\",\n              add: false,\n              status,\n              transactionHash,\n            });\n          } else {\n            toast.fail?.({\n              title: \"Transaction Failed!\",\n              text: `transactionHash ${transactionHash}`,\n            });\n          }\n        })\n        .catch((error) => {\n          console.info(\"tx_error: \", error);\n          toast.fail?.({\n            title: \"Transaction Failed!\",\n            text: `${error.message}`,\n          });\n        })\n        .finally(() => {\n          State.update({\n            isStaking: false,\n          });\n        });\n    })\n    .catch((error) => {\n      State.update({\n        isStaking: false,\n      });\n      console.log(\"Aura_Pool_ID_error:\", error);\n    });\n}\n\nfunction handleStake() {\n  if (state.curToken === data.LP_token_address) {\n    handleStakeBPT();\n  } else {\n    handleStakeToken();\n  }\n}\nfunction handleStakeToken() {\n  State.update({\n    isStaking: true,\n  });\n  const RewardsContract = new ethers.Contract(\n    RewardPoolDepositWrapper,\n    RewardPoolDepositABI,\n    Ethers.provider().getSigner()\n  );\n\n  const { Rewards_contract_address, Balancer_Pool_ID, tokenAssets } = data;\n\n  const amountsIn = tokenAssets.map((token) =>\n    state.curToken === token\n      ? ethers.BigNumber.from(\n          simpleToExactAmount(\n            state.inputValue,\n            TOKENS[state.curToken].decimals\n          ).toString()\n        )\n      : 0\n  );\n  console.log(\"amountsIn:\", amountsIn);\n\n  const userData = ethers.utils.defaultAbiCoder.encode(\n    [\"uint256\", \"uint256[]\", \"uint256\"],\n    [1, amountsIn, 0]\n  );\n\n  const params = {\n    _rewardPoolAddress: Rewards_contract_address,\n    _inputToken: state.curToken,\n    _inputAmount: ethers.BigNumber.from(\n      ethers.utils.parseUnits(state.inputValue, TOKENS[state.curToken].decimals)\n    ),\n    _balancerPoolId: Balancer_Pool_ID,\n    _request: {\n      assets: data.tokenAssets,\n      maxAmountsIn: amountsIn,\n      userData,\n      fromInternalBalance: false,\n    },\n  };\n\n  const {\n    _rewardPoolAddress,\n    _inputToken,\n    _inputAmount,\n    _balancerPoolId,\n    _request,\n  } = params;\n  RewardsContract.depositSingle(\n    _rewardPoolAddress,\n    _inputToken,\n    _inputAmount,\n    _balancerPoolId,\n    _request,\n    {\n      gasLimit: 1173642,\n    }\n  )\n    .then((tx) => {\n      console.log(\"tx: \", tx);\n      tx.wait()\n        .then((res) => {\n          const { status, transactionHash } = res;\n          console.info(\"tx_res: \", res);\n          if (status === 1) {\n            toast.success?.({\n              title: \"Transaction Successful!\",\n              text: `transactionHash ${transactionHash}`,\n            });\n            addAction?.({\n              type: \"Staking\",\n              action: \"Stake\",\n              token: TOKENS[curToken],\n              amount: state.inputValue,\n              template: \"Aura Finance\",\n              add: false,\n              status,\n              transactionHash,\n            });\n          } else {\n            toast.fail?.({\n              title: \"Transaction Failed!\",\n              text: `transactionHash ${transactionHash}`,\n            });\n          }\n        })\n        .catch((error) => {\n          console.info(\"tx_error: \", error);\n          toast.fail?.({\n            title: \"Transaction Failed!\",\n            text: `${error.message}`,\n          });\n        })\n        .finally(() => {\n          State.update({\n            isStaking: false,\n          });\n        });\n    })\n    .catch((err) => {\n      console.info(\"RewardsContract_error:\", err);\n      State.update({\n        isStaking: false,\n      });\n    });\n}\n\nfunction fillBalance() {\n  State.update({\n    inputValue: state.curTokenBal,\n  });\n}\n\nconst renderExtra = () => {\n  return (\n    <>\n      <AmountList>\n        <span></span>\n        <span>\n          Balance:{\" \"}\n          <span className=\"amount-white\" onClick={fillBalance}>\n            {Number(state.curTokenBal).toFixed(2)}\n          </span>\n          {state.curSymbol}\n        </span>\n      </AmountList>\n      <StakeBtnWrap>\n        <Widget\n          src=\"dapdapbos.near/widget/UI.Button\"\n          props={{\n            text: \"Approve\",\n            type: \"primary\",\n            style: { flex: 1 },\n            disabled: !state.needApprove || state.isApproved,\n            loading: state.isApproving,\n            onClick: () => {\n              handleApprove(state.curToken, RewardPoolDepositWrapper);\n            },\n          }}\n        />\n        <Widget\n          src=\"dapdapbos.near/widget/UI.Button\"\n          props={{\n            text: \"Stake\",\n            type: \"primary\",\n            style: { flex: 1 },\n            disabled: !state.canStake,\n            loading: state.isStaking,\n            onClick: handleStake,\n          }}\n        />\n      </StakeBtnWrap>\n    </>\n  );\n};\nfunction updateTokenBalance(bal) {\n  State.update({\n    curTokenBal: bal,\n  });\n}\nconsole.log(\"STAKE_STATE\", state);\nreturn (\n  <StakePanel>\n    <Widget\n      src=\"dapdapbos.near/widget/Utils.Allowance\"\n      props={{\n        tokenAddress:\n          state.curToken === data.LP_token_address\n            ? data.LP_token_address\n            : state.curToken,\n        owner: account,\n        spender:\n          state.curToken === data.LP_token_address\n            ? BoosterLiteWrapper\n            : RewardPoolDepositWrapper,\n        updateAllowance,\n      }}\n    />\n    <Widget\n      src=\"dapdapbos.near/widget/Utils.GetTokenBalance\"\n      props={{\n        tokenAddress: state.curToken,\n        owner: account,\n        updateTokenBalance,\n      }}\n    />\n    <div className=\"input-group\">\n      <input\n        value={state.inputValue}\n        type=\"number\"\n        className=\"form-control bos-input-number\"\n        placeholder=\"0.0\"\n        onChange={handleInputChange}\n      />\n      <div className=\"input-group-append\">\n        <Widget\n          src=\"dapdapbos.near/widget/UI.Select\"\n          props={{\n            options: state.selectData,\n            noLabel: true,\n            value: state.selectData.find((obj) => obj.value === state.curToken),\n            onChange: (option) => {\n              State.update({\n                curToken: option.value,\n              });\n            },\n          }}\n        />\n      </div>\n    </div>\n    {renderExtra()}\n  </StakePanel>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/dapdapbos.near/widget/Staking.Aura.Stake", "fact_widget_deployments_id": "7ecec1e9b8feaf4b2a738797f36186ed", "inserted_timestamp": "2024-03-14T06:26:16.405Z", "modified_timestamp": "2024-03-14T06:26:16.405Z", "__row_index": 0}