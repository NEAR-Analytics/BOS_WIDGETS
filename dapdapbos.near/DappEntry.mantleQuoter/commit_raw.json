{"tx_hash": "CXmnLgvyPeuddPy4RnFqQ1SmdaD2cj95Xoxf3rxRwJnY", "action_id_social": "9fwYvF8BHdbvWnYFoSBCmRkqKYbFbG5dMUyYC6rhQU4t-0-widget", "block_id": 104536087, "block_timestamp": "2023-10-30T12:19:00.756Z", "signer_id": "dapdapbos.near", "widget_name": "DappEntry.mantleQuoter", "source_code": "const abiAgni = [\n  {\n    type: \"function\",\n    stateMutability: \"nonpayable\",\n    outputs: [{ type: \"uint256\", name: \"amountOut\", internalType: \"uint256\" }],\n    name: \"quoteExactInputSingle\",\n    inputs: [\n      { type: \"address\", name: \"tokenIn\", internalType: \"address\" },\n      { type: \"address\", name: \"tokenOut\", internalType: \"address\" },\n      { type: \"uint24\", name: \"fee\", internalType: \"uint24\" },\n      { type: \"uint256\", name: \"amountIn\", internalType: \"uint256\" },\n      { type: \"uint160\", name: \"sqrtPriceLimitX96\", internalType: \"uint160\" },\n    ],\n  },\n];\n\nconst abiFusion_Ammos = [\n  {\n    inputs: [\n      {\n        components: [\n          {\n            internalType: \"address\",\n            name: \"tokenIn\",\n            type: \"address\",\n          },\n          {\n            internalType: \"address\",\n            name: \"tokenOut\",\n            type: \"address\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"amountIn\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint24\",\n            name: \"fee\",\n            type: \"uint24\",\n          },\n          {\n            internalType: \"uint160\",\n            name: \"sqrtPriceLimitX96\",\n            type: \"uint160\",\n          },\n        ],\n        internalType: \"struct IQuoterV2.QuoteExactInputSingleParams\",\n        name: \"params\",\n        type: \"tuple\",\n      },\n    ],\n    name: \"quoteExactInputSingle\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"amountOut\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"uint160\",\n        name: \"sqrtPriceX96After\",\n        type: \"uint160\",\n      },\n      {\n        internalType: \"uint32\",\n        name: \"initializedTicksCrossed\",\n        type: \"uint32\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"gasEstimate\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n];\n\nconst abiIzi = [\n  {\n    inputs: [\n      {\n        internalType: \"bytes[]\",\n        name: \"data\",\n        type: \"bytes[]\",\n      },\n    ],\n    name: \"multicall\",\n    outputs: [\n      {\n        internalType: \"bytes[]\",\n        name: \"results\",\n        type: \"bytes[]\",\n      },\n    ],\n    stateMutability: \"payable\",\n    type: \"function\",\n  },\n\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"tokenX\",\n        type: \"address\",\n      },\n      {\n        internalType: \"address\",\n        name: \"tokenY\",\n        type: \"address\",\n      },\n      {\n        internalType: \"uint24\",\n        name: \"fee\",\n        type: \"uint24\",\n      },\n      {\n        internalType: \"uint128\",\n        name: \"amount\",\n        type: \"uint128\",\n      },\n      {\n        internalType: \"int24\",\n        name: \"lowPt\",\n        type: \"int24\",\n      },\n    ],\n    name: \"swapX2Y\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"amountY\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"int24\",\n        name: \"finalPoint\",\n        type: \"int24\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"tokenX\",\n        type: \"address\",\n      },\n      {\n        internalType: \"address\",\n        name: \"tokenY\",\n        type: \"address\",\n      },\n      {\n        internalType: \"uint24\",\n        name: \"fee\",\n        type: \"uint24\",\n      },\n      {\n        internalType: \"uint128\",\n        name: \"amount\",\n        type: \"uint128\",\n      },\n      {\n        internalType: \"int24\",\n        name: \"highPt\",\n        type: \"int24\",\n      },\n    ],\n    name: \"swapY2X\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"amountX\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"int24\",\n        name: \"finalPoint\",\n        type: \"int24\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n];\n\nconst {\n  amountIn,\n  tokenIn: tokenInProps,\n  tokenOut: tokenOutProps,\n  loadAmountOut,\n  wethAddress,\n  quoterContractId: quoterAddress,\n} = props;\n\nconsole.log(\"tokenInProps: \", tokenInProps, tokenOutProps);\n\nconst tokenIn =\n  tokenInProps.address === \"native\"\n    ? {\n        ...tokenInProps,\n        address: wethAddress,\n      }\n    : tokenInProps;\n\nconst tokenOut =\n  tokenOutProps.address === \"native\"\n    ? {\n        ...tokenOutProps,\n        address: wethAddress,\n      }\n    : tokenOutProps;\n\nconst feeList = [100, 500, 3000, 10000];\n\nconst queryString = `${tokenIn.address}-${tokenOut.address}-${amountIn}`;\n\nif (state.cacheString !== queryString) {\n  State.update({\n    cacheString: queryString,\n    quoteDone: false,\n    quoting: false,\n  });\n}\n\nconst getAbi = () => {\n  if (quoterAddress === \"0x9488C05a7b75a6FefdcAE4f11a33467bcBA60177\") {\n    return abiAgni;\n  } else if (quoterAddress !== \"0x032b241De86a8660f1Ae0691a4760B426EA246d7\") {\n    return abiFusion_Ammos;\n  }\n};\n\nconst quoteSingleAgni = (amountIn, tokenIn, tokenOut, fee, finalList) => {\n  const abi = getAbi();\n  console.log(\"abi: \", abi, quoterAddress);\n\n  const iface = new ethers.utils.Interface(abi);\n\n  const inputs =\n    quoterAddress === \"0x9488C05a7b75a6FefdcAE4f11a33467bcBA60177\"\n      ? [\n          tokenIn.address,\n          tokenOut.address,\n          fee,\n          ethers.utils.parseUnits(amountIn, tokenIn.decimals),\n          0,\n        ]\n      : [\n          {\n            tokenIn: tokenIn.address,\n            tokenOut: tokenOut.address,\n            amountIn: ethers.utils.parseUnits(amountIn, tokenIn.decimals),\n            fee: fee,\n            sqrtPriceLimitX96: 0,\n          },\n        ];\n\n  const encodedData = iface.encodeFunctionData(\"quoteExactInputSingle\", inputs);\n\n  const quoterContractId = quoterAddress;\n\n  return Ethers.provider()\n    .call({\n      to: quoterContractId,\n      data: encodedData,\n    })\n    .then((data) => {\n      const res = iface.decodeFunctionResult(\"quoteExactInputSingle\", data);\n      console.log(\"res: \", res);\n\n      const rawAmountOut = Big(Number(res.amountOut._hex)).toFixed();\n\n      const parsedAmountOut = new Big(rawAmountOut)\n        .div(Big(10).pow(tokenOut.decimals))\n        .toFixed();\n\n      return [\n        ...finalList,\n        {\n          fee: fee,\n          amountOut: parsedAmountOut,\n          success: true,\n        },\n      ];\n    })\n    .catch((e) => {\n      console.log(\" single quote: \", e);\n      return [\n        ...finalList,\n        {\n          fee: fee,\n          amountOut: \"0\",\n          success: false,\n        },\n      ];\n    });\n};\n\nconst qouteSingleIzi = (amountIn, tokenIn, tokenOut, fee, finalList) => {\n  const abi = abiIzi;\n\n  const tokenInAddress = tokenIn.address;\n\n  const tokenOutAddress = tokenOut.address;\n\n  const isX2Y = tokenInAddress.toLowerCase() < tokenOutAddress.toLowerCase();\n\n  const boundaryPt = isX2Y ? -799999 : 799999;\n  const iface = new ethers.utils.Interface(abi);\n\n  const inputs = isX2Y\n    ? [\n        tokenInAddress,\n        tokenOutAddress,\n        fee,\n        ethers.utils.parseUnits(amountIn, tokenIn.decimals),\n        boundaryPt,\n      ]\n    : [\n        tokenOutAddress,\n        tokenInAddress,\n        fee,\n        ethers.utils.parseUnits(amountIn, tokenIn.decimals),\n        boundaryPt,\n      ];\n\n  const method = isX2Y ? \"swapX2Y\" : \"swapY2X\";\n\n  const encodedData = iface.encodeFunctionData(method, inputs);\n\n  const quoterContractId = quoterAddress;\n\n  return Ethers.provider()\n    .call({\n      to: quoterContractId,\n      data: encodedData,\n    })\n    .then((data) => {\n      const res = iface.decodeFunctionResult(method, data);\n\n      const amountName = isX2Y ? \"amountY\" : \"amountX\";\n\n      const rawAmountOut = Big(Number(res[amountName]._hex)).toFixed();\n      const parsedAmountOut = new Big(rawAmountOut)\n        .div(Big(10).pow(tokenOut.decimals))\n        .toFixed();\n\n      return [\n        ...finalList,\n        {\n          fee: fee,\n          amountOut: parsedAmountOut,\n          success: true,\n        },\n      ];\n    })\n    .catch((e) => {\n      return [\n        ...finalList,\n        {\n          fee: fee,\n          amountOut: \"0\",\n          success: false,\n        },\n      ];\n    });\n};\n\nconst quoteSingle = (amountIn, tokenIn, tokenOut, fee, finalList) => {\n  if (quoterAddress === \"0x032b241De86a8660f1Ae0691a4760B426EA246d7\") {\n    return qouteSingleIzi(amountIn, tokenIn, tokenOut, fee, finalList);\n  } else {\n    return quoteSingleAgni(amountIn, tokenIn, tokenOut, fee, finalList);\n  }\n};\n\nconst quoteAll = () => {\n  State.update({\n    quoting: true,\n  });\n\n  if (tokenIn.address === tokenOut.address) {\n    const amountOut = amountIn;\n    console.log(\"amountOut: \", amountOut);\n    State.update({ quoteDone: true, quoting: false });\n    loadAmountOut({\n      fee: 0,\n      amountOut: amountOut,\n      outputCurrencyAmount: amountOut,\n      quoteDone: true,\n      quoting: false,\n      success: true,\n    });\n    return;\n  }\n\n  quoteSingle(amountIn, tokenIn, tokenOut, feeList[0], []).then(\n    (finalList0) => {\n      return quoteSingle(\n        amountIn,\n        tokenIn,\n        tokenOut,\n        feeList[1],\n        finalList0\n      ).then((finalList1) => {\n        return quoteSingle(\n          amountIn,\n          tokenIn,\n          tokenOut,\n          feeList[2],\n          finalList1\n        ).then((finalList2) => {\n          return quoteSingle(\n            amountIn,\n            tokenIn,\n            tokenOut,\n            feeList[3],\n            finalList2\n          ).then((finalList3) => {\n            const maxAmountOutEstimate = finalList3.reduce((prev, current) => {\n              if (Number(prev.amountOut) > Number(current.amountOut)) {\n                return prev;\n              } else {\n                return current;\n              }\n            }, finalList3[0]);\n\n            State.update({ quoteDone: true, quoting: false });\n            loadAmountOut({\n              ...maxAmountOutEstimate,\n              outputCurrencyAmount: maxAmountOutEstimate.amountOut,\n              quoteDone,\n              quoting,\n              noPair: !Big(maxAmountOutEstimate.amountOut).gt(0),\n            });\n          });\n        });\n      });\n    }\n  );\n};\n\nif (Number(amountIn) > 0 && !state.quoteDone && !state.quoting) {\n  quoteAll();\n}\n\nreturn <div></div>;\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/dapdapbos.near/widget/DappEntry.mantleQuoter", "fact_widget_deployments_id": "6114300e192b30d2779a6a1d69762263", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 0}