{"tx_hash": "9PGJA3MxHcyucxTuMinrGBHqcgCy7KCXBS6qY8aTCXgt", "action_id_social": "8qwQ2S2G83SYAqp73czzFrRs2LpQxTGZZh3NZn2c3jHo-0-widget", "block_id": 111754434, "block_timestamp": "2024-01-31T07:24:49.392Z", "signer_id": "dapdapbos.near", "widget_name": "Bridge.Utils", "source_code": "const account = Ethers.send(\"eth_requestAccounts\", [])[0];\nconst { getLifi } = props\n\n\nfunction generateQuery(obj) {\n    return Object.keys(obj).filter(key => !!obj[key]).map(key => {\n        return `${key}=${obj[key]}`\n    }).join('&')\n}\n\nfunction getAllPossibleConnections({ fromChain, toChain, fromToken, toToken, chainTypes }) {\n    const params = {\n        fromChain,\n        toChain,\n        fromToken,\n        toToken,\n        chainTypes,\n    }\n\n    const connectionP = asyncFetch(`https://li.quest/v1/connections?${generateQuery(params)}`)\n\n    return connectionP.then(res => {\n        if (res.status === 200) {\n            const connections = res.body.connections\n            if (connections && connections.length) {\n                const connection = connections[0]\n                const { toTokens } = connection\n                const canUsedTokens = toTokens.filter(token => !!token.logoURI)\n\n                return canUsedTokens\n            }\n        }\n    })\n}\n\nfunction getBalance(address, account, rpcUrl, decimals) {\n    const provider = new ethers.providers.JsonRpcProvider(rpcUrl);\n\n    if (address === \"native\") {\n        return provider.getBalance(account).then((rawBalance) => {\n            return ethers.utils.formatUnits(rawBalance._hex, decimals).toString()\n        });\n    }\n\n    const TokenContract = new ethers.Contract(\n        address,\n        [\n            {\n                constant: true,\n                inputs: [\n                    {\n                        name: \"_owner\",\n                        type: \"address\",\n                    },\n                ],\n                name: \"balanceOf\",\n                outputs: [\n                    {\n                        name: \"balance\",\n                        type: \"uint256\",\n                    },\n                ],\n                payable: false,\n                stateMutability: \"view\",\n                type: \"function\",\n            },\n        ],\n        provider\n    );\n\n    return TokenContract.balanceOf(account)\n        .then((rawBalance) => {\n            return ethers.utils.formatUnits(rawBalance._hex, decimals).toString()\n        })\n        .catch((err) => {\n            console.log(err)\n            callback('0.0')\n        });\n}\n\nfunction balanceFormated(balance, digits) {\n    digits = digits || 4\n    if (!balance) return '0';\n    const _balance = new Big(balance);\n    if (_balance.eq(0)) return '0';\n    if (_balance.lt(0.0001)) return `<${0.0001}`;\n    return _balance.toFixed(digits);\n}\n\nconst addressReg = /(\\w{6})(.*)(\\w{4})/\n\nfunction addressFormated(address) {\n    return address.replace(addressReg, (_1, _2, _3, _4) => {\n        return `${_2}...${_4}`\n    })\n}\n\nfunction getRoute(params, tool) {\n    const url = 'https://li.quest/v1/advanced/routes'\n    const options = {\n        method: 'POST',\n        headers: { accept: 'application/json', 'content-type': 'application/json' },\n        body: JSON.stringify(params)\n    }\n\n    const quoteP = asyncFetch(url, options)\n    return quoteP.then(res => {\n        const { routes } = res.body\n        if (!routes) {\n            return null\n        }\n        const slectedRoute = routes.filter(route => {\n            return route.steps[0].tool === tool\n        })\n\n        return slectedRoute ? slectedRoute[0] : null\n    })\n}\n\nfunction computeDuration(route) {\n    let duration = 0\n    route.steps.forEach(step => {\n        duration += step.estimate.executionDuration\n    })\n\n    return Math.ceil(duration / 60) + ' min'\n}\n\n\nfunction checkAndSetAllowance(rpcUrl, route, getLifi) {\n    const signer = Ethers.provider().getSigner()\n    const lifi = getLifi()\n\n    const quote = route.steps[0]\n\n    return lifi.getTokenApproval(\n        signer,\n        quote.action.fromToken,\n        quote.estimate.approvalAddress,\n    ).then(res => {\n        if (!res) {\n            return lifi.approveToken({\n                signer,\n                token: quote.action.fromToken,\n                approvalAddress: quote.estimate.approvalAddress,\n                amount: quote.action.fromAmount,\n            }).then(res => {\n                console.log(res)\n                return res\n            })\n        }\n    }).then(res => {\n        return lifi.executeRoute(signer, route)\n    }).then(tx => {\n        const process = tx.steps[tx.steps.length - 1].execution?.process\n        console.log('tx:', tx)\n        if (!process) {\n            return\n        }\n        let txHash = process[process.length - 1].txHash\n        const txLink = process[process.length - 1].txLink\n        const start = process[0].startedAt\n        const end = process[process.length - 1].doneAt\n        const duration = Math.ceil((end - start) / 1000 / 60)\n        txHash = txHash || ''\n        saveTransaction(txHash, txLink, duration)\n    })\n        .catch(e => {\n            console.log(e)\n        })\n\n}\n\nconst transaction_key = '$tk$'\nfunction saveTransaction(txHash, txLink, duration) {\n    const transactionList = getTransaction()\n    transactionList.push({\n        txHash,\n        txLink,\n        duration,\n        time: Date.now(),\n    })\n\n    Storage.set(transaction_key, JSON.stringify(transactionList))\n}\n\nfunction getTransaction() {\n    const transactionListStr = Storage.get(transaction_key)\n\n    let transactionList\n    if (transactionListStr) {\n        try {\n            transactionList = JSON.parse(transactionListStr)\n        } catch (e) {\n            transactionList = []\n        }\n    } else {\n        transactionList = []\n    }\n\n    return transactionList\n}\n\nreturn {\n    getAllPossibleConnections,\n    generateQuery,\n    getBalance,\n    balanceFormated,\n    getRoute,\n    computeDuration,\n    addressFormated,\n    checkAndSetAllowance,\n    getTransaction,\n}", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/dapdapbos.near/widget/Bridge.Utils", "fact_widget_deployments_id": "bf6ea9decdc6adb65f5623e66b0b0c94", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 1}