{"tx_hash": "3nbgrFPprjjzDvFE1DEkZzBMSwyLQhWi8VAoSjRf65fM", "action_id_social": "AMkxMYghdgfgWSwo18PHmjthRfLrVjTTpVmNgoVzANye-0-widget", "block_id": 103586726, "block_timestamp": "2023-10-17T13:38:39.762Z", "signer_id": "dapdapbos.near", "widget_name": "Uniswap.Swap.QuoterV3", "source_code": "const WETH_ADDRESS = props.wethAddress;\n\nconst abi = [\n  {\n    inputs: [\n      {\n        components: [\n          { internalType: \"address\", name: \"tokenIn\", type: \"address\" },\n          { internalType: \"address\", name: \"tokenOut\", type: \"address\" },\n          { internalType: \"uint256\", name: \"amountIn\", type: \"uint256\" },\n          { internalType: \"uint24\", name: \"fee\", type: \"uint24\" },\n          {\n            internalType: \"uint160\",\n            name: \"sqrtPriceLimitX96\",\n            type: \"uint160\",\n          },\n        ],\n        internalType: \"struct IQuoterV2.QuoteExactInputSingleParams\",\n        name: \"params\",\n        type: \"tuple\",\n      },\n    ],\n    name: \"quoteExactInputSingle\",\n    outputs: [\n      { internalType: \"uint256\", name: \"amountOut\", type: \"uint256\" },\n      { internalType: \"uint160\", name: \"sqrtPriceX96After\", type: \"uint160\" },\n      {\n        internalType: \"uint32\",\n        name: \"initializedTicksCrossed\",\n        type: \"uint32\",\n      },\n      { internalType: \"uint256\", name: \"gasEstimate\", type: \"uint256\" },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n];\nconst { amountIn, tokenIn, tokenOut, loadAmountOut, quoterContractId } = props;\n\nconst feeList = [50, 100, 250, 500, 3000, 10000];\n\nconst queryString = `${tokenIn.address}-${tokenOut.address}-${amountIn}`;\n\nif (state.cacheString !== queryString) {\n  State.update({\n    cacheString: queryString,\n    quoteDone: false,\n    quoting: false,\n  });\n}\n\nconst quoteSingle = (amountIn, tokenIn, tokenOut, fee, finalList) => {\n  const iface = new ethers.utils.Interface(abi);\n\n  const inputs = [\n    {\n      tokenIn: tokenIn.address === \"native\" ? WETH_ADDRESS : tokenIn.address,\n      tokenOut: tokenOut.address === \"native\" ? WETH_ADDRESS : tokenOut.address,\n      amountIn: ethers.utils.parseUnits(amountIn, tokenIn.decimals),\n      fee: fee,\n      sqrtPriceLimitX96: 0,\n    },\n  ];\n\n  const encodedData = iface.encodeFunctionData(\"quoteExactInputSingle\", inputs);\n\n  return Ethers.provider()\n    .call({\n      to: quoterContractId,\n      data: encodedData,\n    })\n    .then((data) => {\n      const res = iface.decodeFunctionResult(\"quoteExactInputSingle\", data);\n\n      const rawAmountOut = Big(Number(res.amountOut._hex)).toFixed();\n\n      const parsedAmountOut = new Big(rawAmountOut)\n        .div(Big(10).pow(tokenOut.decimals))\n        .toFixed();\n\n      return [\n        ...finalList,\n        {\n          fee: fee,\n          amountOut: parsedAmountOut,\n          success: true,\n        },\n      ];\n    })\n    .catch((e) => {\n      return [\n        ...finalList,\n        {\n          fee: fee,\n          amountOut: \"0\",\n          success: false,\n        },\n      ];\n    });\n};\n\nconst quoteAll = () => {\n  State.update({\n    quoting: true,\n  });\n\n  quoteSingle(amountIn, tokenIn, tokenOut, feeList[0], []).then(\n    (finalList0) => {\n      return quoteSingle(\n        amountIn,\n        tokenIn,\n        tokenOut,\n        feeList[1],\n        finalList0\n      ).then((finalList1) => {\n        return quoteSingle(\n          amountIn,\n          tokenIn,\n          tokenOut,\n          feeList[2],\n          finalList1\n        ).then((finalList2) => {\n          return quoteSingle(\n            amountIn,\n            tokenIn,\n            tokenOut,\n            feeList[3],\n            finalList2\n          ).then((finalList3) => {\n            return quoteSingle(\n              amountIn,\n              tokenIn,\n              tokenOut,\n              feeList[4],\n              finalList3\n            ).then((finalList4) => {\n              return quoteSingle(\n                amountIn,\n                tokenIn,\n                tokenOut,\n                feeList[5],\n                finalList4\n              ).then((finalList5) => {\n                const maxAmountOutEstimate = finalList5.reduce(\n                  (prev, current) => {\n                    if (Number(prev.amountOut) > Number(current.amountOut)) {\n                      return prev;\n                    } else {\n                      return current;\n                    }\n                  },\n                  finalList5[0]\n                );\n\n                State.update({ quoteDone: true, quoting: false });\n                loadAmountOut({\n                  ...maxAmountOutEstimate,\n                  quoteDone,\n                  quoting,\n                });\n              });\n            });\n          });\n        });\n      });\n    }\n  );\n};\nif (Number(amountIn) > 0 && !state.quoteDone && !state.quoting) {\n  quoteAll();\n}\n\nreturn <div></div>;\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/dapdapbos.near/widget/Uniswap.Swap.QuoterV3", "fact_widget_deployments_id": "93e78b1c67529f845c3a421e5087c044", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 0}