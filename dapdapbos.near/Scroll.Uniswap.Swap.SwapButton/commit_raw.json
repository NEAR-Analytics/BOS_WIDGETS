{"tx_hash": "GkKzCF5w9J8zyqAfJUsyc48KAYzAnzdka7EwXtU3Dbnt", "action_id_social": "CfXtpN7iYyqsASGx2iH6HuJzaLBSM4c4Cm8ND23et7H1-0-widget", "block_id": 107200646, "block_timestamp": "2023-12-05T10:36:49.324Z", "signer_id": "dapdapbos.near", "widget_name": "Scroll.Uniswap.Swap.SwapButton", "source_code": "const SwapButtonConnectWrapper = styled.button`\n  border: none;\n  width: 100%;\n  background: transparent;\n\n  .connect-button {\n    width: 100%;\n    height: 60px;\n    border-radius: 10px;\n    background-color: var(--button-no-account-bg);\n    color: var(--button-no-account-text);\n    font-size: 18px;\n    line-height: 22px;\n    border: none;\n    transition: 0.5s;\n    cursor: pointer;\n    font-weight: 700;\n    :hover {\n      opacity: 0.8;\n    }\n    &:disabled {\n      opacity: 0.3;\n      pointer-events: none;\n    }\n    @media (max-width: 768px) {\n      height: 50px;\n      font-size: 16px;\n    }\n  }\n`;\n\nconst SwapButton = styled.button`\n  width: 100%;\n  height: 60px;\n  border-radius: 10px;\n  background-color: var(--button-bg-color);\n  margin-top: 4px;\n\n  color: var(--button-text-color);\n  font-size: 18px;\n  line-height: 22px;\n  border: none;\n  transition: 0.5s;\n  cursor: pointer;\n  font-weight: 700;\n  :hover {\n    opacity: 0.8;\n  }\n  &:disabled {\n    opacity: 0.3;\n    pointer-events: none;\n  }\n  @media (max-width: 768px) {\n    height: 50px;\n    font-size: 16px;\n  }\n`;\n\nconst {\n  inputCurrency,\n  outputCurrency,\n  inputCurrencyAmount,\n  outputCurrencyAmount,\n  maxInputBalance,\n  onSuccess,\n  routerAddress,\n  wethAddress,\n  title,\n  uniType,\n  chainName,\n  handlerV3,\n  handleSyncswap,\n  stable,\n  syncSwapPoolAddress,\n  chainId,\n  currentChainId,\n  slippage,\n  trade,\n  onPending,\n  openRequestModal,\n  toast,\n  account,\n  addTransaction,\n} = props;\n\nif (!account) {\n  return (\n    <SwapButtonConnectWrapper>\n      <Web3Connect className=\"connect-button\" connectLabel=\"Connect Wallet\" />\n    </SwapButtonConnectWrapper>\n  );\n}\n\nif (chainId !== currentChainId) {\n  return (\n    <SwapButton\n      onClick={() => {\n        Ethers.send(\"wallet_switchEthereumChain\", [\n          { chainId: `0x${Number(chainId).toString(16)}` },\n        ]);\n      }}\n    >\n      Switch Scroll Chain\n    </SwapButton>\n  );\n}\n\nif (props.noPair) {\n  const NoPairButton = styled.div`\n    color: #ff684b;\n    font-size: 18px;\n    font-weight: 400;\n    height: 62px;\n    flex-shrink: 0;\n    border-radius: 16px;\n    background: rgba(255, 104, 75, 0.2);\n    margin-top: 4px;\n    text-align: center;\n    line-height: 62px;\n  `;\n  return <NoPairButton>No pool available</NoPairButton>;\n}\n\nif (props.loading) {\n  return <SwapButton disabled>Getting Trade Info...</SwapButton>;\n}\n\nif (Big(inputCurrencyAmount || 0).eq(0)) {\n  return <SwapButton disabled>Enter an amount</SwapButton>;\n}\nif (!inputCurrency || !outputCurrency) {\n  return <SwapButton disabled>Select a token</SwapButton>;\n}\nif (Big(inputCurrencyAmount || 0).gt(maxInputBalance)) {\n  return (\n    <SwapButton disabled>\n      Insufficient {inputCurrency?.symbol} Balance\n    </SwapButton>\n  );\n}\n\nState.init({\n  isApproved: false,\n  approving: false,\n  swapping: false,\n  wrapping: false,\n});\n\nconst getAllowance = () => {\n  const TokenContract = new ethers.Contract(\n    inputCurrency.address,\n    [\n      {\n        constant: true,\n        inputs: [\n          {\n            name: \"_owner\",\n            type: \"address\",\n          },\n          {\n            name: \"_spender\",\n            type: \"address\",\n          },\n        ],\n        name: \"allowance\",\n        outputs: [\n          {\n            name: \"\",\n            type: \"uint256\",\n          },\n        ],\n        payable: false,\n        stateMutability: \"view\",\n        type: \"function\",\n      },\n    ],\n    Ethers.provider().getSigner()\n  );\n  TokenContract.allowance(account, routerAddress).then((allowanceRaw) => {\n    State.update({\n      isApproved: !Big(\n        ethers.utils.formatUnits(allowanceRaw._hex, inputCurrency.decimals)\n      ).lt(inputCurrencyAmount),\n    });\n  });\n};\nif (inputCurrency.address !== \"native\") {\n  getAllowance();\n} else {\n  State.update({ isApproved: true });\n}\nconst wrapType =\n  inputCurrency.address === \"native\" && outputCurrency.address === wethAddress\n    ? 1\n    : inputCurrency.address === wethAddress &&\n      outputCurrency.address === \"native\"\n    ? 2\n    : 0;\nconst handleApprove = () => {\n  State.update({\n    approving: true,\n  });\n  const TokenContract = new ethers.Contract(\n    inputCurrency.address,\n    [\n      {\n        constant: false,\n        inputs: [\n          {\n            name: \"_spender\",\n            type: \"address\",\n          },\n          {\n            name: \"_value\",\n            type: \"uint256\",\n          },\n        ],\n        name: \"approve\",\n        outputs: [\n          {\n            name: \"\",\n            type: \"bool\",\n          },\n        ],\n        payable: false,\n        stateMutability: \"nonpayable\",\n        type: \"function\",\n      },\n    ],\n    Ethers.provider().getSigner()\n  );\n  TokenContract.approve(\n    routerAddress,\n    ethers.utils.parseUnits(inputCurrencyAmount, inputCurrency.decimals)\n  )\n    .then((tx) => {\n      tx.wait().then((res) => {\n        const { status, transactionHash } = res;\n        State.update({\n          isApproved: status === 1,\n          approving: false,\n        });\n        if (status === 1) {\n          toast.success?.({\n            title: \"Transaction Successful!\",\n            text: `Approved ${inputCurrency.symbol}`,\n          });\n        } else {\n          toast.fail?.({\n            title: \"Transaction Failed!\",\n            text: `Approved ${inputCurrency.symbol}`,\n          });\n        }\n        addTransaction?.({\n          icons: [inputCurrency.icon],\n          failed: status !== 1,\n          tx: transactionHash,\n          handler: \"Approved\",\n          desc: inputCurrency.symbol,\n          time: Date.now(),\n        });\n      });\n    })\n    .catch((err) => {\n      if (err.code === \"ACTION_REJECTED\") {\n        toast.fail?.({\n          title: \"Transaction Failed\",\n          text: `User rejected the request. Details: \n          MetaMask Tx Signature: User denied transaction signature. `,\n        });\n      }\n      State.update({\n        approving: false,\n      });\n    });\n};\n\nif (!state.isApproved && wrapType === 0) {\n  return (\n    <SwapButton onClick={handleApprove} disabled={state.approving}>\n      {state.approving ? \" Approving...\" : \" Approve\"}\n    </SwapButton>\n  );\n}\n\nfunction add_action(param_body) {\n  asyncFetch(\"https://api.dapdap.net/api/uniswap/records/add\", {\n    method: \"post\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify(param_body),\n  });\n}\nconst tradeText = `${\n  Big(inputCurrencyAmount).lt(0.001)\n    ? \"<0.001\"\n    : Big(inputCurrencyAmount).toFixed(3)\n} ${inputCurrency.symbol} to ${\n  Big(outputCurrencyAmount || 0).lt(0.001)\n    ? \"<0.001\"\n    : Big(outputCurrencyAmount || 0).toFixed(3)\n} ${outputCurrency.symbol} `;\nfunction successCallback(tx, callback) {\n  const prices = Storage.get(\n    \"tokensPrice\",\n    \"dapdapbos.near/widget/Linea.Uniswap.Swap.TokensPrice\"\n  );\n  tx.wait().then((res) => {\n    const { status, transactionHash } = res;\n    callback?.();\n    const _amountIn = Big(inputCurrencyAmount || 0).mul(\n      Big(10).pow(inputCurrency.decimals)\n    );\n    const _amountOut = Big(outputCurrencyAmount || 0).mul(\n      Big(10).pow(outputCurrency.decimals)\n    );\n    const _priceIn = prices[inputCurrency.symbol] || 0;\n    const _priceOut = prices[outputCurrency.symbol] || 0;\n\n    add_action({\n      sender: account,\n      tx_hash: transactionHash,\n      token_in_address: inputCurrency.address,\n      token_in_volume: _amountIn.toString(),\n      token_in_usd_amount: Big(inputCurrencyAmount || 0)\n        .mul(_priceIn)\n        .toFixed(0),\n      token_out_address: outputCurrency.address,\n      token_out_volume: _amountOut.toString(),\n      token_out_usd_amount: Big(outputCurrencyAmount || 0)\n        .mul(_priceOut)\n        .toFixed(0),\n    });\n    if (status === 1) {\n      onSuccess?.();\n      toast.success?.({\n        title: \"Transaction Successful!\",\n        text: \"Swap\" + tradeText,\n      });\n    } else {\n      toast.fail?.({\n        title: \"Transaction Failed!\",\n        text: \"Swap\" + tradeText,\n      });\n    }\n    addTransaction?.({\n      icons: [inputCurrency.icon, outputCurrency.icon],\n      failed: status !== 1,\n      tx: transactionHash,\n      handler: status !== 1 ? \"Swap Failed\" : \"Swapped\",\n      desc: tradeText,\n      time: Date.now(),\n    });\n  });\n}\n\nconst handleWrap = (type, onSuccess, onError) => {\n  const WethContract = new ethers.Contract(\n    wethAddress,\n    [\n      {\n        constant: false,\n        inputs: [],\n        name: \"deposit\",\n        outputs: [],\n        payable: true,\n        stateMutability: \"payable\",\n        type: \"function\",\n      },\n      {\n        constant: false,\n        inputs: [{ internalType: \"uint256\", name: \"wad\", type: \"uint256\" }],\n        name: \"withdraw\",\n        outputs: [],\n        payable: false,\n        stateMutability: \"nonpayable\",\n        type: \"function\",\n      },\n    ],\n    Ethers.provider().getSigner()\n  );\n  openRequestModal?.({\n    status: 1,\n    text: type === 1 ? \"Wrapped\" : \"Unwrapped\" + tradeText,\n    open: true,\n  });\n  if (type === 1) {\n    WethContract.deposit({\n      value: ethers.utils.parseEther(inputCurrencyAmount),\n    })\n      .then((tx) => {\n        openRequestModal?.({\n          status: 0,\n          text: type === 1 ? \"Wrapped\" : \"Unwrapped\" + tradeText,\n          open: true,\n          tx: tx.hash,\n        });\n        tx.wait().then((res) => {\n          onSuccess?.(res);\n          if (res.status === 1) {\n            toast.success?.({\n              title: \"Transaction Successful!\",\n              text: \"Wrapped\" + tradeText,\n            });\n          } else {\n            toast.fail?.({\n              title: \"Transaction Failed!\",\n              text: \"Wrapped\" + tradeText,\n            });\n          }\n          addTransaction?.({\n            icons: [inputCurrency.icon, outputCurrency.icon],\n            failed: res.status !== 1,\n            tx: res.transactionHash,\n            handler: res.status !== 1 ? \"Wrapp Failed\" : \"Wrapped\",\n            desc: tradeText,\n            time: Date.now(),\n          });\n        });\n      })\n      .catch((err) => {\n        if (err.code === \"ACTION_REJECTED\") {\n          toast.fail?.({\n            title: \"Transaction Failed\",\n            text: `User rejected the request. Details: \n            MetaMask Tx Signature: User denied transaction signature. `,\n          });\n        }\n        onError?.();\n      });\n  } else {\n    WethContract.withdraw(ethers.utils.parseEther(inputCurrencyAmount))\n      .then((tx) => {\n        openRequestModal?.({\n          status: 0,\n          text: type === 1 ? \"Wrapped\" : \"Unwrapped\" + tradeText,\n          open: true,\n          tx: tx.hash,\n        });\n        tx.wait().then((res) => {\n          onSuccess?.(res);\n          if (res.status === 1) {\n            toast.success?.({\n              title: \"Transaction Successful!\",\n              text: \"Unwrapped\" + tradeText,\n            });\n          } else {\n            toast.fail?.({\n              title: \"Transaction Failed!\",\n              text: \"Unwrapped\" + tradeText,\n            });\n          }\n          addTransaction?.({\n            icons: [inputCurrency.icon, outputCurrency.icon],\n            failed: res.status !== 1,\n            tx: res.transactionHash,\n            handler: res.status !== 1 ? \"Unwrapp Failed\" : \"Unwrapped\",\n            desc: tradeText,\n            time: Date.now(),\n          });\n        });\n      })\n      .catch((err) => {\n        if (err.code === \"ACTION_REJECTED\") {\n          toast.fail?.({\n            title: \"Transaction Failed\",\n            text: `User rejected the request. Details: \n            MetaMask Tx Signature: User denied transaction signature. `,\n          });\n        }\n        onError?.();\n      });\n  }\n};\n\nif (wrapType) {\n  return (\n    <SwapButton\n      onClick={() => {\n        State.update({\n          wrapping: true,\n        });\n        handleWrap(\n          wrapType,\n          (res) => {\n            successCallback(res, () => {\n              State.update({ wrapping: false });\n            });\n          },\n          () => {\n            State.update({\n              wrapping: false,\n            });\n          }\n        );\n      }}\n      disabled={state.wrapping}\n    >\n      {wrapType === 1\n        ? state.wrapping\n          ? \"Wrapping...\"\n          : \"Wrap\"\n        : state.wrapping\n        ? \"Unwrapping...\"\n        : \"Unwrap\"}\n    </SwapButton>\n  );\n}\nreturn (\n  <>\n    {uniType === \"v3\" && state.swapping ? (\n      <Widget\n        src={handlerV3}\n        props={{\n          inputCurrencyAmount,\n          outputCurrencyAmount,\n          inputCurrency,\n          outputCurrency,\n          wethAddress,\n          account,\n          chainId,\n          slippage,\n          routerAddress,\n          swapping: state.swapping,\n          title,\n          trade,\n          tradeText,\n          openRequestModal,\n          onSuccess: (res) => {\n            openRequestModal?.({\n              status: 0,\n              text: \"Swap\" + tradeText,\n              open: true,\n              tx: res.hash,\n            });\n            State.update({ swapping: false });\n            successCallback(res, () => {\n              onPending(false);\n            });\n          },\n          onError: (err) => {\n            onPending(false);\n            State.update({ swapping: false });\n            openRequestModal?.({ open: false });\n            if (!err?.message.includes(\"user rejected transaction\")) {\n              openRequestModal?.({\n                status: 3,\n                open: true,\n              });\n            } else {\n              openRequestModal?.({\n                open: false,\n              });\n              toast.fail?.({\n                title: \"Transaction Failed\",\n                text: `User rejected the request. Details: \n                MetaMask Tx Signature: User denied transaction signature. `,\n              });\n            }\n          },\n        }}\n      />\n    ) : (\n      \"\"\n    )}\n\n    <SwapButton\n      onClick={() => {\n        onPending(true);\n        openRequestModal?.({\n          status: 1,\n          text: \"Swap\" + tradeText,\n          open: true,\n        });\n        State.update({ swapping: true });\n      }}\n      disabled={state.swapping}\n    >\n      {state.swapping ? \"Swapping...\" : \"Swap\"}\n    </SwapButton>\n  </>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/dapdapbos.near/widget/Scroll.Uniswap.Swap.SwapButton", "fact_widget_deployments_id": "9b3a1d4b8b242e5b410d80193401221d", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 8}