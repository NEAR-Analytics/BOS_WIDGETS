{"tx_hash": "6N37Mg47Teszij3d4CYQTjwzBaNciUvens8fgYsGQhip", "action_id_social": "6vw2Fkv1m13jweRvsDQi2doH4yyhdjr7bASri3LCcSfJ-0-widget", "block_id": 115176053, "block_timestamp": "2024-03-21T18:54:40.424Z", "signer_id": "dapdapbos.near", "widget_name": "Staking.Aura.Index", "source_code": "const Wrapper = styled.div`\n  --bg-1: #262836;\n  --bg-2: #373a53;\n  --bg-3: #2e3142;\n  --white: #fff;\n  --purple: #979abe;\n  --dark: #1b1e27;\n\n  --fz-12: 12px;\n  --fz-14: 14px;\n  --fz-16: 16px;\n  --fz-24: 24px;\n\n  --primary: #783ae3;\n  /* --secondary: #6c757d; */\n\n  color: var(--white);\n\n  input[type=\"number\"]::-webkit-inner-spin-button,\n  input[type=\"number\"]::-webkit-outer-spin-button {\n    -webkit-appearance: none;\n    margin: 0;\n  }\n  input[type=\"number\"] {\n    -moz-appearance: textfield;\n  }\n  .form-control::placeholder {\n    color: white;\n  }\n  .form-control:focus {\n    box-shadow: 0 0 0 0.25rem rgba(120, 58, 227, 0.5);\n  }\n\n  padding-top: 34px;\n  .grid-pool-head {\n    max-width: 1244px;\n    margin: 0 auto 12px;\n    font-size: 14px;\n    color: var(--purple);\n  }\n`;\nconst HeadWrapper = styled.div`\n  /* border-radius: 16px; */\n  max-width: 1244px;\n  margin: 0 auto;\n  color: var(--white);\n  font-size: var(--fz-14);\n  position: relative;\n  .pool-head {\n    border-radius: 16px;\n    height: 84px;\n    align-items: center;\n    cursor: pointer;\n    background-color: var(--bg-1);\n  }\n  .title-primary {\n    font-size: var(--fz-16);\n    font-weight: 500;\n  }\n  .title-secondary {\n  }\n  .title-sub {\n    font-size: var(--fz-12);\n    color: var(--purple);\n  }\n`;\nconst GridContainer = styled.div`\n  display: grid;\n  grid-template-columns: 40% 12% 12% 12% 24%;\n`;\n\nconst GridItem = styled.div`\n  padding-left: 24px;\n  &.action-item {\n    display: flex;\n    column-gap: 10px;\n    padding-right: 18px;\n    justify-content: right;\n  }\n  &.action-item-head {\n    display: flex;\n    justify-content: center;\n  }\n`;\nconst PoolItem = styled.div`\n  margin-bottom: 10px;\n`;\nconst TabsList = styled(\"Tabs.List\")`\n  display: flex;\n  align-items: center;\n  margin: 0 auto;\n  width: 420px;\n  height: 46px;\n  background-color: var(--bg-1);\n  border-radius: 10px;\n  color: var(--white);\n  padding: 0 5px;\n  margin-bottom: 30px;\n  .tab-head-item {\n    flex: 1;\n    display: flex;\n    height: 36px;\n    align-items: center;\n    justify-content: center;\n    font-size: 16px;\n    border-radius: 5px;\n    color: var(--white);\n    cursor: pointer;\n  }\n  .tab-head-item.active {\n    background-color: var(--bg-2);\n  }\n`;\n\n// assets begin\nconst AssetsWrapper = styled.div`\n  display: flex;\n  justify-content: center;\n  column-gap: 18px;\n  max-width: 1244px;\n  margin: 0 auto 42px;\n`;\nconst AssetsPanel = styled.div`\n  flex: 1;\n  border-radius: 16px;\n  border: 1px solid #373a53;\n  background: #2e3142;\n  padding: 20px 18px 0;\n  height: 105px;\n  .as-title {\n    color: var(--purple);\n    font-size: var(--fz-16);\n  }\n  .as-amount {\n    color: var(--white);\n    font-size: var(--fz-24);\n    padding-top: 16px;\n  }\n  .as-sub {\n    font-size: var(--fz-14);\n    color: var(--purple);\n  }\n  .as-action {\n    display: flex;\n    justify-content: space-between;\n  }\n`;\nconst EmptyWrap = styled.div`\n  padding-top: 150px;\n  .empty-title {\n    color: #fff;\n    text-align: center;\n    font-size: 18px;\n    font-weight: 400;\n    margin-bottom: 13px;\n  }\n  .empty-intro {\n    color: #979abe;\n    text-align: center;\n    font-size: 14px;\n    font-weight: 400;\n  }\n`;\n// assets end\n\nconst {\n  toast,\n  curChain,\n  onSwitchChain,\n  switchingChain,\n  chainId,\n  isChainSupported,\n  multicallAddress,\n  multicall,\n  dexConfig,\n  prices,\n} = props;\n\nconst { POOLS, TOKENS } = dexConfig;\n\nconst RewardsContractABI = [\n  {\n    inputs: [],\n    name: \"totalSupply\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"decimals\",\n    outputs: [\n      {\n        internalType: \"uint8\",\n        name: \"\",\n        type: \"uint8\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"account\",\n        type: \"address\",\n      },\n    ],\n    name: \"balanceOf\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"owner\",\n        type: \"address\",\n      },\n    ],\n    name: \"maxWithdraw\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"newRewardRatio\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"rewardRate\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\",\n      },\n    ],\n    name: \"rewards\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"totalAssets\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"uint256\",\n        name: \"assets\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"convertToShares\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\nconst { RewardPoolDepositWrapper, PoolContractWrapper } = dexConfig;\n\nconst RewardPoolDepositABI = [\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"_rewardPoolAddress\",\n        type: \"address\",\n      },\n      {\n        internalType: \"contract IERC20\",\n        name: \"_inputToken\",\n        type: \"address\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"_inputAmount\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"_balancerPoolId\",\n        type: \"bytes32\",\n      },\n      {\n        components: [\n          {\n            internalType: \"contract IAsset[]\",\n            name: \"assets\",\n            type: \"address[]\",\n          },\n          {\n            internalType: \"uint256[]\",\n            name: \"maxAmountsIn\",\n            type: \"uint256[]\",\n          },\n          {\n            internalType: \"bytes\",\n            name: \"userData\",\n            type: \"bytes\",\n          },\n          {\n            internalType: \"bool\",\n            name: \"fromInternalBalance\",\n            type: \"bool\",\n          },\n        ],\n        internalType: \"struct IBalancerVault.JoinPoolRequest\",\n        name: \"_request\",\n        type: \"tuple\",\n      },\n    ],\n    name: \"depositSingle\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n];\nconst PoolContractABI = [\n  {\n    inputs: [{ internalType: \"bytes32\", name: \"poolId\", type: \"bytes32\" }],\n    name: \"getPoolTokens\",\n    outputs: [\n      {\n        internalType: \"contract IERC20[]\",\n        name: \"tokens\",\n        type: \"address[]\",\n      },\n      { internalType: \"uint256[]\", name: \"balances\", type: \"uint256[]\" },\n      {\n        internalType: \"uint256\",\n        name: \"lastChangeBlock\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\nconst LPTokenABI = [\n  {\n    inputs: [],\n    name: \"getActualSupply\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"account\", type: \"address\" }],\n    name: \"balanceOf\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"getSwapFeePercentage\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\n\nconst globalABI = [\n  {\n    inputs: [],\n    name: \"reductionPerCliff\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"EMISSIONS_MAX_SUPPLY\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"totalSupply\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"totalCliffs\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\n\nconsole.log(\"AURA_PROPS:\", props);\nconst initList = POOLS.map((item) => ({\n  ...item,\n  swapFee: 0,\n  stakedAmount: 0,\n  reward: 0,\n}));\n\nState.init({\n  currentTab: \"TAB_POOL\",\n  account: \"\", // current wallet address\n  poolsList: initList, //\n  myPoolsList: [],\n  totalDepositAmount: 0,\n  totalRewardsAmount: 0,\n  isClaiming: false,\n  isAllClaiming: false,\n  flag1: false,\n  flag2: false,\n  flag3: false,\n});\nconst account = Ethers.send(\"eth_requestAccounts\", [])[0];\nconst auraGlobalData = {\n  auraMaxSupply: \"50000000000000000000000000\",\n  auraTotalCliffs: \"500\",\n  auraMinterMinted: \"0\",\n  auraReductionPerCliff: \"100000000000000000000000\",\n  auraTotalSupply: \"70357299813420858641594656\",\n};\nfunction initPoolList() {\n  for (let i = 0; i < state.poolsList.length; i++) {\n    const item = state.poolsList[i];\n\n    getMultiLPToken(item, i);\n\n    getMultiRewards(item, i);\n  }\n\n  getMultiPoolTokens();\n  // getMultiGlobal();\n}\n\nfunction getMultiRewards(pool, index) {\n  const calls = [\n    {\n      address: pool.Rewards_contract_address,\n      name: \"balanceOf\",\n      params: [account],\n    },\n    {\n      address: pool.Rewards_contract_address,\n      name: \"rewardRate\",\n    },\n    {\n      address: pool.Rewards_contract_address,\n      name: \"totalSupply\",\n    },\n    {\n      address: pool.Rewards_contract_address,\n      name: \"rewards\",\n      params: [account],\n    },\n  ];\n  multicall({\n    abi: RewardsContractABI,\n    calls,\n    options: {},\n    multicallAddress,\n    provider: Ethers.provider(),\n  })\n    .then((res) => {\n      console.log(\"getMultiRewards_res\", res);\n      const temp = [...state.poolsList];\n      const [[balance], [rewardRate], [totalSupply], [rewards]] = res;\n      // console.log(ethers.utils.formatUnits(balance || 0));\n      temp[index].rewardRate = rewardRate;\n      temp[index].stakedAmount = Big(\n        ethers.utils.formatUnits(balance || 0)\n      ).toFixed();\n      temp[index].rewardTotalSupply = totalSupply;\n      temp[index].reward = Big(\n        ethers.utils.formatUnits(rewards || 0)\n      ).toFixed();\n      State.update({\n        poolsList: temp,\n        flag1: true,\n      });\n    })\n    .catch((err) => {\n      console.log(\"getMultiRewards_error\", err);\n    });\n}\n\nfunction getMultiLPToken(pool, index) {\n  const calls = [\n    {\n      address: pool.LP_token_address,\n      name: \"balanceOf\",\n      params: [account],\n    },\n    {\n      address: pool.LP_token_address,\n      name: \"getActualSupply\",\n    },\n    {\n      address: pool.LP_token_address,\n      name: \"getSwapFeePercentage\",\n    },\n  ];\n\n  multicall({\n    abi: LPTokenABI,\n    calls,\n    options: {},\n    multicallAddress,\n    provider: Ethers.provider(),\n  })\n    .then((res) => {\n      console.log(\"getMultiLPToken res:\", res);\n      const temp = [...state.poolsList];\n      const [[balance], [totalSupply], [swapFeePer]] = res;\n\n      temp[index].bptAmount = ethers.utils.formatUnits(balance || 0);\n      temp[index].bptTotalSupply = totalSupply;\n      const _swapFee = Big(ethers.utils.formatUnits(swapFeePer))\n        .mul(100)\n        .toFixed();\n      temp[index].swapFee = _swapFee;\n\n      State.update({\n        poolsList: temp,\n        flag2: true,\n      });\n    })\n    .catch((err) => {\n      console.log(\"getMultiLPToken_error\", err);\n    });\n}\n\nfunction getMultiPoolTokens() {\n  const ids = state.poolsList.map((item) => item.Balancer_Pool_ID);\n\n  const calls = ids.map((id) => ({\n    address: PoolContractWrapper,\n    name: \"getPoolTokens\",\n    params: [id],\n  }));\n\n  multicall({\n    abi: PoolContractABI,\n    calls,\n    options: {},\n    multicallAddress,\n    provider: Ethers.provider(),\n  })\n    .then((res) => {\n      console.log(\"getMultiPoolTokens res:\", res);\n      const temp = [...state.poolsList];\n      for (let i = 0; i < res.length; i++) {\n        const addrArray = res[i][0];\n        const tokenBalArray = res[i][1];\n        temp[i].tokenAssets = addrArray;\n        temp[i].tokenBalance = tokenBalArray;\n        temp[i].tokens = addrArray\n          ? addrArray.map((addr) => TOKENS[addr].symbol)\n          : [];\n      }\n      State.update({\n        poolsList: temp,\n        flag3: true,\n      });\n    })\n    .catch((err) => {\n      console.log(\"getMultiPoolTokens_error\", err);\n    });\n}\n\nfunction getMultiGlobal() {\n  const globalAddress = \"0xC0c293ce456fF0ED870ADd98a0828Dd4d2903DBF\";\n  const calls = [\n    {\n      address: globalAddress,\n      name: \"reductionPerCliff\",\n    },\n    {\n      address: globalAddress,\n      name: \"EMISSIONS_MAX_SUPPLY\",\n    },\n    {\n      address: globalAddress,\n      name: \"totalSupply\",\n    },\n    {\n      address: globalAddress,\n      name: \"totalCliffs\",\n    },\n  ];\n\n  multicall({\n    abi: globalABI,\n    calls,\n    options: {},\n    multicallAddress,\n    provider: Ethers.provider(),\n  })\n    .then((res) => {\n      console.log(\"getMultiGlobal res:\", res);\n    })\n    .catch((err) => {\n      console.log(\"getMultiGlobal error\", err);\n    });\n}\n\nfunction getAuraMintAmount(balEarned, global) {\n  const reductionPerCliff = ethers.BigNumber.from(global.auraReductionPerCliff);\n  const maxSupply = ethers.BigNumber.from(global.auraMaxSupply);\n  const totalSupply = ethers.BigNumber.from(global.auraTotalSupply);\n  const totalCliffs = ethers.BigNumber.from(global.auraTotalCliffs);\n  const minterMinted = ethers.BigNumber.from(0);\n\n  // e.g. emissionsMinted = 6e25 - 5e25 - 0 = 1e25;\n  const emissionsMinted = totalSupply.sub(maxSupply).sub(minterMinted);\n\n  // e.g. reductionPerCliff = 5e25 / 500 = 1e23\n  // e.g. cliff = 1e25 / 1e23 = 100\n  const cliff = emissionsMinted.div(reductionPerCliff);\n\n  // e.g. 100 < 500\n  if (cliff.lt(totalCliffs)) {\n    // e.g. (new) reduction = (500 - 100) * 2.5 + 700 = 1700;\n    // e.g. (new) reduction = (500 - 250) * 2.5 + 700 = 1325;\n    // e.g. (new) reduction = (500 - 400) * 2.5 + 700 = 950;\n    const reduction = totalCliffs.sub(cliff).mul(5).div(2).add(700);\n    // e.g. (new) amount = 1e19 * 1700 / 500 =  34e18;\n    // e.g. (new) amount = 1e19 * 1325 / 500 =  26.5e18;\n    // e.g. (new) amount = 1e19 * 950 / 500  =  19e17;\n    // let amount = simpleToExact(balEarned).mul(reduction).div(totalCliffs);\n    let amount = ethers.utils\n      .parseUnits(balEarned)\n      .mul(reduction)\n      .div(totalCliffs);\n\n    // e.g. amtTillMax = 5e25 - 1e25 = 4e25\n    const amtTillMax = maxSupply.sub(emissionsMinted);\n    if (amount.gt(amtTillMax)) {\n      amount = amtTillMax;\n    }\n\n    return amount;\n  }\n\n  return ethers.BigNumber.from(0);\n}\nfunction calcTVL() {\n  const temp = [...state.poolsList];\n  for (let i = 0; i < temp.length; i++) {\n    const tokens = temp[i].tokens;\n    const tokenBalance = temp[i].tokenBalance;\n    const bptTotalSupply = temp[i].bptTotalSupply;\n    const rewardTotalSupply = temp[i].rewardTotalSupply;\n    const rewardRate = temp[i].rewardRate;\n\n    if (tokens && tokenBalance && bptTotalSupply && rewardTotalSupply) {\n      try {\n        const sum = tokens?.reduce((total, cur, j) => {\n          if (cur) {\n            const price = prices[cur] || 0;\n\n            return Big(total)\n              .plus(\n                Big(ethers.utils.formatUnits(tokenBalance[j] || 0)).times(\n                  Big(price || 0)\n                )\n              )\n              .toFixed();\n          } else {\n            return total;\n          }\n        }, 0);\n\n        const bptPriceUsd = Big(sum).div(Big(bptTotalSupply));\n\n        const TVL = Big(rewardTotalSupply).times(bptPriceUsd).toFixed(0);\n\n        // temp[i].poolValueUsd = sum;\n        temp[i].bptPriceUsd = bptPriceUsd;\n        temp[i].TVL = TVL;\n\n        // calc bal apr\n        const rewardPerYear = Big(ethers.utils.formatUnits(rewardRate)).times(\n          Big(86400).times(365)\n        );\n\n        const rewardPerYearUsd = rewardPerYear.times(Big(prices[\"BAL\"]));\n        const BAL_APR = rewardPerYearUsd.div(TVL).times(100).toFixed(2);\n        temp[i].BAL_APR = BAL_APR;\n\n        const auraPerYear = getAuraMintAmount(\n          rewardPerYear.toString(),\n          auraGlobalData\n        );\n        const auraPerYearUsd =\n          ethers.utils.formatUnits(auraPerYear) * prices[\"AURA\"];\n        const AURA_APR = Big(auraPerYearUsd)\n          .div(Big(TVL))\n          .times(100)\n          .toFixed(2);\n        temp[i].AURA_APR = AURA_APR;\n\n        temp[i].APR =\n          Number(temp[i].swapFee) + Number(BAL_APR) + Number(AURA_APR);\n      } catch (error) {\n        console.log(\"calcTVL_error\", error);\n      }\n    }\n  }\n}\n\nuseEffect(() => {\n  State.update({ account });\n  if (account && isChainSupported) {\n    initPoolList();\n  }\n}, [account]);\n\nuseEffect(() => {\n  if (!isChainSupported) return;\n\n  if (state.flag1 && state.flag2 && state.flag3) {\n    try {\n      const totalDepositAmount = state.poolsList.reduce((total, cur) => {\n        return Big(cur.stakedAmount || 0)\n          .plus(total)\n          .toFixed(2);\n      }, 0);\n      const totalRewardsAmount = state.poolsList.reduce((total, cur) => {\n        return Big(cur.reward || 0)\n          .plus(total)\n          .toFixed(2);\n      }, 0);\n\n      const temp = state.poolsList.filter((item) =>\n        Big(item.stakedAmount || 0).gt(0)\n      );\n      const _myPools = temp.map((item) => ({ ...item, isClaiming: false }));\n      calcTVL();\n      State.update({\n        totalDepositAmount,\n        totalRewardsAmount,\n        myPoolsList: _myPools,\n      });\n    } catch (error) {\n      console.log(333, error);\n    }\n  }\n}, [state.flag1, state.flag2, state.flag3]);\n\nconst handleChangeTabs = (value) => {\n  State.update({\n    currentTab: value,\n  });\n};\nconst getPoolIcon = (tokenAssets) => {\n  if (tokenAssets) {\n    const icons = tokenAssets?.map((addr, index) => TOKENS[addr].icon);\n    const usefulIcons = icons.filter((n) => n);\n    return usefulIcons;\n  } else {\n    return [];\n  }\n};\n\nconst renderPoolIcon = (tokenAssets) => {\n  const icons = getPoolIcon(tokenAssets);\n\n  if (icons) {\n    return icons.map((addr, index) => {\n      return (\n        <span key={index} style={{ marginRight: -12 }}>\n          <Widget src=\"dapdapbos.near/widget/UI.Avatar\" props={{ src: addr }} />\n        </span>\n      );\n    });\n  }\n};\n\nconst handleClaim = (address, index) => {\n  const temp = [...state.myPoolsList];\n  temp[index].isClaiming = true;\n  State.update({\n    myPoolsList: temp,\n  });\n  const ClaimRewardsContract = new ethers.Contract(\n    address,\n    [\n      {\n        inputs: [\n          {\n            internalType: \"address\",\n            name: \"_account\",\n            type: \"address\",\n          },\n          {\n            internalType: \"bool\",\n            name: \"_claimExtras\",\n            type: \"bool\",\n          },\n        ],\n        name: \"getReward\",\n        outputs: [\n          {\n            internalType: \"bool\",\n            name: \"\",\n            type: \"bool\",\n          },\n        ],\n        stateMutability: \"nonpayable\",\n        type: \"function\",\n      },\n    ],\n    Ethers.provider().getSigner()\n  );\n\n  return ClaimRewardsContract.getReward(account, true)\n    .then((tx) => {\n      console.log(\"tx: \", tx);\n      tx.wait()\n        .then((res) => {\n          const { status, transactionHash } = res;\n          console.info(\"tx_res: \", res);\n          if (status === 1) {\n            toast.success?.({\n              title: \"Transaction Successful!\",\n              text: `transactionHash ${transactionHash}`,\n            });\n          } else {\n            toast.fail?.({\n              title: \"Transaction Failed!\",\n              text: `transactionHash ${transactionHash}`,\n            });\n          }\n        })\n        .finally(() => {\n          const temp = [...state.myPoolsList];\n          temp[index].isClaiming = false;\n          State.update({\n            myPoolsList: temp,\n          });\n        });\n    })\n    .catch((err) => {\n      console.log(\"getPoolTokens_error:\", err);\n      const temp = [...state.myPoolsList];\n      temp[index].isClaiming = false;\n      State.update({\n        myPoolsList: temp,\n      });\n    });\n};\n\nconst handleClaimAll = () => {\n  State.update({\n    isAllClaiming: true,\n  });\n  let getClaimAllArray = [];\n\n  for (let i = 0; i < state.myPoolsList.length; i++) {\n    const addr = state.myPoolsList[i].Rewards_contract_address;\n    getClaimAllArray.push(handleClaim(addr));\n  }\n  Promise.allSettled(getClaimAllArray)\n    .then((res) => {\n      console.info(\"getClaimAllArray: \", res);\n    })\n    .catch((error) => {\n      console.info(\"getClaimAllArray: \", error);\n    })\n    .finally(() => {\n      State.update({\n        isAllClaiming: false,\n      });\n    });\n};\n\nconsole.info(\"STATE: \", state);\nreturn (\n  <Wrapper>\n    <Tabs.Root value={state.currentTab} onValueChange={handleChangeTabs}>\n      <TabsList>\n        <Tabs.Trigger value=\"TAB_POOL\" asChild>\n          <div\n            className={`tab-head-item ${\n              state.currentTab === \"TAB_POOL\" ? \"active\" : \"\"\n            }`}\n          >\n            All Pools\n          </div>\n        </Tabs.Trigger>\n        <Tabs.Trigger value=\"TAB_ASSETS\" asChild>\n          <div\n            className={`tab-head-item ${\n              state.currentTab === \"TAB_ASSETS\" ? \"active\" : \"\"\n            }`}\n          >\n            Your Assets\n          </div>\n        </Tabs.Trigger>\n      </TabsList>\n      <Tabs.Content value=\"TAB_POOL\">\n        <GridContainer className=\"grid-pool-head\">\n          <GridItem>Pool</GridItem>\n          <GridItem>APR</GridItem>\n          <GridItem>TVL</GridItem>\n          <GridItem>You Staked</GridItem>\n          <GridItem>Your rewards</GridItem>\n        </GridContainer>\n        <Accordion.Root type=\"single\" collapsible>\n          {state.poolsList.map((item) => (\n            <PoolItem>\n              <Widget\n                src=\"dapdapbos.near/widget/Staking.Aura.Pool\"\n                props={{\n                  ...props,\n                  data: item,\n                  account: state.account,\n                  TOKENS,\n                  RewardPoolDepositWrapper,\n                  RewardPoolDepositABI,\n                  tokenIcons: getPoolIcon(item.tokenAssets),\n                }}\n                key={item.poolName}\n              />\n            </PoolItem>\n          ))}\n        </Accordion.Root>\n      </Tabs.Content>\n      <Tabs.Content value=\"TAB_ASSETS\">\n        <AssetsWrapper>\n          <AssetsPanel>\n            <div className=\"as-title\">You deposit</div>\n            <div className=\"as-amount\">${state.totalDepositAmount}</div>\n          </AssetsPanel>\n          <AssetsPanel>\n            <div className=\"as-title\">Claimable Rewards</div>\n            <div className=\"as-action\">\n              <div className=\"as-amount\">\n                ${state.totalRewardsAmount}\n                <span className=\"as-sub\"></span>\n              </div>\n              {state.myPoolsList.length ? (\n                <Widget\n                  src=\"dapdapbos.near/widget/UI.Button\"\n                  props={{\n                    text: \"Claim All\",\n                    type: \"primary\",\n                    style: { width: 118 },\n                    loading: state.isAllClaiming,\n                    disabled: !state.myPoolsList.length,\n                    onClick: handleClaimAll,\n                  }}\n                />\n              ) : null}\n            </div>\n          </AssetsPanel>\n        </AssetsWrapper>\n        {state.myPoolsList.length ? (\n          <GridContainer className=\"grid-pool-head\">\n            <GridItem>Pool</GridItem>\n            <GridItem>APR</GridItem>\n            <GridItem>You Staked</GridItem>\n            <GridItem>Your rewards</GridItem>\n            <GridItem className=\"action-item-head\">Action</GridItem>\n          </GridContainer>\n        ) : null}\n\n        <HeadWrapper>\n          {state.myPoolsList.length ? (\n            state.myPoolsList?.map((item, index) => (\n              <PoolItem key={index}>\n                <GridContainer className=\"pool-head\">\n                  <GridItem>\n                    <div className=\"title-primary\">\n                      {renderPoolIcon(item.tokenAssets)}\n\n                      <span style={{ marginLeft: 20 }}>{item.poolName}</span>\n                    </div>\n                  </GridItem>\n                  <GridItem>\n                    <div className=\"title-secondary\">\n                      {Big(item.APR || 0).toFixed(2)}%\n                    </div>\n                    <div className=\"title-sub\">\n                      proj.{Big(item.pjAPR).mul(100).toFixed(2)} %\n                    </div>\n                  </GridItem>\n                  <GridItem>\n                    <div className=\"title-secondary\">\n                      <Widget\n                        src=\"dapdapbos.near/widget/Utils.FormatRawValue\"\n                        props={{\n                          value: item.stakedAmount,\n                        }}\n                      />\n                    </div>\n                  </GridItem>\n                  <GridItem>\n                    <div className=\"title-secondary\">\n                      <Widget\n                        src=\"dapdapbos.near/widget/Utils.FormatRawValue\"\n                        props={{\n                          value: item.reward,\n                        }}\n                      />\n                    </div>\n                    <div className=\"title-sub\"></div>\n                  </GridItem>\n                  <GridItem className=\"action-item\">\n                    {/* <Widget\n                        src=\"dapdapbos.near/widget/UI.Button\"\n                        props={{\n                          text: \"Unstake\",\n                          type: \"secondary\",\n                          style: { width: 118 },\n                          disabled: true,\n                          onClick: () => {},\n                        }}\n                      /> */}\n                    {Big(item.reward).gt(0) ? (\n                      <Widget\n                        src=\"dapdapbos.near/widget/UI.Button\"\n                        props={{\n                          text: \"Claim\",\n                          type: \"primary\",\n                          style: { width: 118 },\n                          loading: item.isClaiming,\n                          onClick: () => {\n                            handleClaim(item.Rewards_contract_address, index);\n                          },\n                        }}\n                      />\n                    ) : (\n                      <Widget\n                        src=\"dapdapbos.near/widget/UI.Button\"\n                        props={{\n                          text: \"Claim\",\n                          type: \"primary\",\n                          disabled: true,\n                          style: { width: 118 },\n                        }}\n                      />\n                    )}\n                  </GridItem>\n                </GridContainer>\n              </PoolItem>\n            ))\n          ) : (\n            <EmptyWrap>\n              <div className=\"empty-title\">No productive assets detected</div>\n              <div className=\"empty-intro\">\n                Head over to the pools list and make a deposit to start earning\n                yield!\n              </div>\n            </EmptyWrap>\n          )}\n        </HeadWrapper>\n      </Tabs.Content>\n    </Tabs.Root>\n    {!isChainSupported && (\n      <Widget\n        src=\"bluebiu.near/widget/Swap.ChainWarnigBox\"\n        props={{\n          chain: curChain,\n          onSwitchChain: onSwitchChain,\n          switchingChain: switchingChain,\n          theme: dexConfig.theme,\n        }}\n      />\n    )}\n  </Wrapper>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/dapdapbos.near/widget/Staking.Aura.Index", "fact_widget_deployments_id": "4c4d250914f49973cd56495858ca34cf", "inserted_timestamp": "2024-03-21T20:28:41.343Z", "modified_timestamp": "2024-03-21T20:28:41.343Z", "__row_index": 16}