{"tx_hash": "7LQC4TtBePAtCUUXEiuC4qfJFCrAHi2rgK2NBMTnd645", "action_id_social": "9oKSysswdRBa5gGFZRU8VbqMm9XdadW9sxSMZogikhit-0-widget", "block_id": 119835261, "block_timestamp": "2024-05-27T06:34:38.381Z", "signer_id": "dapdapbos.near", "widget_name": "Staking.Hyperlock.UserData", "source_code": "const {\n  type,\n  account,\n  update,\n  dexConfig,\n  pools,\n  multicall,\n  multicallAddress,\n  onLoad,\n} = props;\n\nuseEffect(() => {\n  if (!pools) return;\n\n  const getPositionsData = (pool, tokens, cb) => {\n    asyncFetch(\n      `https://api.hyperlock.finance/v1/blast-mainnet/points/${pool}/positions`,\n      {\n        method: \"post\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          tokens,\n        }),\n      }\n    )\n      .then((res) => {\n        cb(res.body);\n      })\n      .catch((err) => {});\n  };\n\n  const initData = {\n    staked: [],\n    unstaked: [],\n    stakedMap: {},\n    unstakedMap: {},\n  };\n  let typeCounter = 0;\n  const getV2Data = () => {\n    const v2Pools = Object.values(pools).filter((pool) => pool.type === \"V2\");\n    const ids = [];\n    v2Pools.forEach((pool) => {\n      ids.push(`${pool.id}-${account.toLowerCase()}`);\n      ids.push(`${pool.id}-${dexConfig.v2Address.toLowerCase()}`);\n    });\n    asyncFetch(\n      \"https://graph.hyperlock.finance/subgraphs/name/hyperlock/v2-subgraph-mainnet-b\",\n      {\n        method: \"post\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          operationName: \"Positions\",\n          query:\n            \"query pairs($ids: [ID!]) {\\n  liquidityPositions(where: {id_in: $ids}) {\\n    id\\n    user {\\n      id\\n    }\\n    liquidityTokenBalance\\n    pair {\\n      id\\n      token0 {\\n        id\\n      }\\n      token1 {\\n        id\\n      }\\n      lpTokenPriceUSD\\n    }\\n  }\\n}\",\n          variables: {\n            ids,\n          },\n        }),\n      }\n    ).then((res) => {\n      const data = res.body.data?.liquidityPositions || [];\n\n      const unstaked = data.filter(\n        (pool) => pool.user.id === account.toLowerCase()\n      );\n      const staked = data.filter(\n        (pool) => pool.user.id === dexConfig.v2Address.toLowerCase()\n      );\n\n      const calls = staked.map((pool) => ({\n        address: dexConfig.v2Address,\n        name: \"staked\",\n        params: [account, pool.pair.id],\n      }));\n\n      multicall({\n        abi: [\n          {\n            inputs: [\n              { internalType: \"address\", name: \"\", type: \"address\" },\n              { internalType: \"address\", name: \"\", type: \"address\" },\n            ],\n            name: \"staked\",\n            outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n            stateMutability: \"view\",\n            type: \"function\",\n          },\n        ],\n        calls,\n        options: {},\n        multicallAddress,\n        provider: Ethers.provider(),\n      }).then((stakedBalancesRes) => {\n        const _unstaked = unstaked.map((item) => {\n          return {\n            id: item.pair.id,\n            pool: {\n              id: item.pair.id,\n            },\n            token0: item.pair.token0,\n            token1: item.pair.token1,\n            balance: item.liquidityTokenBalance,\n            price: item.pair.lpTokenPriceUSD,\n            type: \"V2\",\n          };\n        });\n\n        const _staked = [];\n        stakedBalancesRes.forEach((item, i) => {\n          if (!item) return;\n          const stakedItem = staked[i];\n          const pool = pools[stakedItem.pair.id];\n          _staked.push({\n            id: stakedItem.pair.id,\n            pool: {\n              id: stakedItem.pair.id,\n            },\n            token0: pool.token0,\n            token1: pool.token1,\n            balance: Big(item).div(Big(10).pow(18)).toFixed(18),\n            price: stakedItem.pair.lpTokenPriceUSD,\n            type: \"V2\",\n          });\n        });\n\n        const _unstakedMap = _unstaked.reduce(\n          (acc, item) => ({ ...acc, [item.id]: [item] }),\n          {}\n        );\n        const _stakedMap = _staked.reduce(\n          (acc, item) => ({ ...acc, [item.id]: [item] }),\n          {}\n        );\n        initData[\"staked\"] = [...initData[\"staked\"], ..._staked];\n        initData[\"unstaked\"] = [...initData[\"unstaked\"], ..._unstaked];\n        initData[\"unstakedMap\"] = {\n          ...initData[\"unstakedMap\"],\n          ..._unstakedMap,\n        };\n        initData[\"stakedMap\"] = { ...initData[\"stakedMap\"], ..._stakedMap };\n        typeCounter++;\n        if (typeCounter === 2) {\n          onLoad({ ...initData });\n        }\n      });\n    });\n  };\n  const getTokenIds = () => {\n    asyncFetch(\n      \"https://graph.hyperlock.finance/subgraphs/name/hyperlock/v3-subgraph-mainnet\",\n      {\n        method: \"post\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          query: `query my {\\n  positionSnapshots(\\n    where: {owner: \\\"${account}\\\", liquidity_gt: 0}\\n  ) {\\n    id\\n  }\\n}\n            `,\n        }),\n      }\n    )\n      .then((res) => {\n        const data = res.body.data.positionSnapshots;\n        const tokens = {};\n        data.forEach((token) => {\n          const id = token.id.split(\"#\")[0];\n          tokens[id] = true;\n        });\n        getV3Data(Object.keys(tokens));\n      })\n      .catch((err) => {});\n  };\n  initData.getV3Fees = (tokens) => {\n    if (!tokens?.length) return;\n    const contract = new ethers.Contract(\n      dexConfig.positionManagerAddress,\n      [\n        {\n          inputs: [\n            {\n              components: [\n                { internalType: \"uint256\", name: \"tokenId\", type: \"uint256\" },\n                { internalType: \"address\", name: \"recipient\", type: \"address\" },\n                {\n                  internalType: \"uint128\",\n                  name: \"amount0Max\",\n                  type: \"uint128\",\n                },\n                {\n                  internalType: \"uint128\",\n                  name: \"amount1Max\",\n                  type: \"uint128\",\n                },\n              ],\n              internalType:\n                \"struct INonfungiblePositionManagerStruct.CollectParams\",\n              name: \"params\",\n              type: \"tuple\",\n            },\n          ],\n          name: \"collect\",\n          outputs: [\n            { internalType: \"uint256\", name: \"\", type: \"uint256\" },\n            { internalType: \"uint256\", name: \"\", type: \"uint256\" },\n          ],\n          stateMutability: \"nonpayable\",\n          type: \"function\",\n        },\n      ],\n      Ethers.provider()\n    );\n    const fees = {};\n    const loop = (_tokens) => {\n      const token = _tokens.pop();\n      contract.callStatic\n        .collect([\n          token.id,\n          token.owner,\n          \"340282366920938463463374607431768211455\",\n          \"340282366920938463463374607431768211455\",\n        ])\n        .then((res) => {\n          fees[token.id] = {\n            token0: Big(res[0] || 0).toString(),\n            token1: Big(res[1] || 0).toString(),\n          };\n          if (_tokens.length) {\n            loop(_tokens);\n          } else {\n            onLoad({ fees });\n          }\n        })\n        .catch((err) => {});\n    };\n    loop(tokens);\n  };\n  const getV3Data = (tokenIds) => {\n    asyncFetch(\n      \"https://graph.hyperlock.finance/subgraphs/name/hyperlock/v3-subgraph-mainnet\",\n      {\n        method: \"post\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          query:\n            'query Positions($account: Bytes!, $ids: [ID!]) {\\n  staked: positions(\\n    where: {owner: \"0xc28effdfef75448243c1d9ba972b97e32df60d06\", id_in: $ids},\\n    orderBy: id,\\n    orderDirection: asc\\n  ) {\\n    ...PositionFragment\\n  }\\n  unstaked: positions(where: {owner: $account}, orderBy: id, orderDirection: asc) {\\n    ...PositionFragment\\n  }\\n}\\n\\nfragment PositionFragment on Position {\\n  id\\n  owner\\n  token0 {\\n    ...TokenFragment\\n  }\\n  token1 {\\n    ...TokenFragment\\n  }\\n  pool {\\n    id\\n    feeTier\\n    liquidity\\n    tick\\n  }\\n}\\n\\nfragment TokenFragment on Token {\\n  id\\n  symbol\\n  decimals\\n}',\n          variables: {\n            account,\n            ids: tokenIds,\n          },\n        }),\n      }\n    )\n      .then((res) => {\n        const { staked, unstaked } = res.body.data;\n\n        const _unstaked = {};\n\n        unstaked.forEach((item) => {\n          let _item = _unstaked[item.pool.id];\n          if (_item) {\n            _item.push(item.id);\n          } else {\n            _unstaked[item.pool.id] = [item.id];\n          }\n        });\n\n        const _staked = {};\n\n        staked.forEach((item) => {\n          let _item = _staked[item.pool.id];\n          if (_item) {\n            _item.push(item.id);\n          } else {\n            _staked[item.pool.id] = [item.id];\n          }\n        });\n\n        const unstakedPools = Object.entries(_unstaked);\n        const unstakedAmountData = {};\n        const stakedPools = Object.entries(_staked);\n        const stakedAmountData = {};\n\n        let count =\n          Number(!!unstakedPools.length) + Number(!!stakedPools.length);\n\n        const loop = (list, amountData, key) => {\n          const pool = list.pop();\n\n          getPositionsData(pool[0], pool[1], (data) => {\n            data.forEach((item) => {\n              amountData[item.tokenId] = item;\n            });\n            if (list.length) {\n              loop(list, amountData, key);\n            } else {\n              const tokens = key === \"staked\" ? staked : unstaked;\n\n              const list = tokens\n                .filter((item) => {\n                  const { token0Amount, token1Amount } = amountData[item.id];\n                  return Big(token0Amount).gt(0) || Big(token1Amount).gt(0);\n                })\n                .map((item) => {\n                  return { ...item, ...amountData[item.id] };\n                });\n\n              initData[key] = [...initData[key], ...list];\n\n              const mapData = {};\n\n              const _pools = key === \"staked\" ? stakedPools : unstakedPools;\n\n              _pools.forEach(([poolId, ids]) => {\n                if (!mapData[poolId]) mapData[poolId] = [];\n                ids.forEach((id) => {\n                  const item = tokens.find((token) => token.id === id);\n\n                  const { token0Amount, token1Amount } = amountData[id];\n\n                  if (Big(token0Amount).gt(0) || Big(token1Amount).gt(0)) {\n                    mapData[poolId].push({\n                      ...item,\n                      token0Amount,\n                      token1Amount,\n                    });\n                  }\n                });\n              });\n\n              const _key = `${key}Map`;\n\n              initData[_key] = { ...initData[_key], ...mapData };\n              count--;\n              if (count === 0) {\n                setTimeout(() => {\n                  initData.getV3Fees(staked);\n                }, 500);\n\n                typeCounter++;\n\n                if (typeCounter === 2) {\n                  onLoad({ ...initData });\n                }\n              }\n            }\n          });\n        };\n\n        if (stakedPools.length) loop(stakedPools, stakedAmountData, \"staked\");\n        if (unstakedPools.length)\n          loop(unstakedPools, unstakedAmountData, \"unstaked\");\n\n        if (!stakedPools.length && !unstakedPools.length) {\n          onLoad({ ...initData });\n        }\n      })\n      .catch((err) => {\n        onLoad({ ...initData });\n      });\n  };\n\n  getTokenIds();\n  getV2Data();\n}, [update, pools]);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/dapdapbos.near/widget/Staking.Hyperlock.UserData", "fact_widget_deployments_id": "93c15d9c1682a60bd3133c173ca4714a", "inserted_timestamp": "2024-05-27T08:20:54.371Z", "modified_timestamp": "2024-05-27T09:05:03.748Z", "__row_index": 0}