{"tx_hash": "EC9f32MbqbUMtKgTQ74XuhqMsS1yy5bq8RecnbcyqFfq", "action_id_social": "ApSLximzk4m5q86CDdk6LmRGCtPtapDN8R6zze73dSS6-0-widget", "block_id": 117880095, "block_timestamp": "2024-04-29T11:25:01.682Z", "signer_id": "dapdapbos.near", "widget_name": "Staking.Hyperlock.UserData", "source_code": "const { type, account, update, dexConfig, onLoad } = props;\n\nuseEffect(() => {\n  const getPositionsData = (pool, tokens, cb) => {\n    asyncFetch(\n      `https://api.hyperlock.finance/v1/blast-mainnet/points/${pool}/positions`,\n      {\n        method: \"post\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          tokens,\n        }),\n      }\n    )\n      .then((res) => {\n        cb(res.body);\n      })\n      .catch((err) => {});\n  };\n\n  const initData = {\n    staked: [],\n    unstaked: [],\n    stakedMap: {},\n    unstakedMap: {},\n  };\n  const getTokenIds = () => {\n    asyncFetch(\n      \"https://graph.hyperlock.finance/subgraphs/name/hyperlock/v3-subgraph-mainnet\",\n      {\n        method: \"post\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          query: `query my {\\n  positionSnapshots(\\n    where: {owner: \\\"${account}\\\", liquidity_gt: 0}\\n  ) {\\n    id\\n  }\\n}\n            `,\n        }),\n      }\n    )\n      .then((res) => {\n        const data = res.body.data.positionSnapshots;\n        const tokens = {};\n        data.forEach((token) => {\n          const id = token.id.split(\"#\")[0];\n          tokens[id] = true;\n        });\n        getV3Data(Object.keys(tokens));\n      })\n      .catch((err) => {});\n  };\n  initData.getV3Fees = (tokens) => {\n    if (!tokens?.length) return;\n    const contract = new ethers.Contract(\n      dexConfig.positionManagerAddress,\n      [\n        {\n          inputs: [\n            {\n              components: [\n                { internalType: \"uint256\", name: \"tokenId\", type: \"uint256\" },\n                { internalType: \"address\", name: \"recipient\", type: \"address\" },\n                {\n                  internalType: \"uint128\",\n                  name: \"amount0Max\",\n                  type: \"uint128\",\n                },\n                {\n                  internalType: \"uint128\",\n                  name: \"amount1Max\",\n                  type: \"uint128\",\n                },\n              ],\n              internalType:\n                \"struct INonfungiblePositionManagerStruct.CollectParams\",\n              name: \"params\",\n              type: \"tuple\",\n            },\n          ],\n          name: \"collect\",\n          outputs: [\n            { internalType: \"uint256\", name: \"\", type: \"uint256\" },\n            { internalType: \"uint256\", name: \"\", type: \"uint256\" },\n          ],\n          stateMutability: \"nonpayable\",\n          type: \"function\",\n        },\n      ],\n      Ethers.provider()\n    );\n    const fees = {};\n    const loop = (_tokens) => {\n      const token = _tokens.pop();\n      contract.callStatic\n        .collect([\n          token.id,\n          token.owner,\n          \"340282366920938463463374607431768211455\",\n          \"340282366920938463463374607431768211455\",\n        ])\n        .then((res) => {\n          fees[token.id] = {\n            token0: Big(res[0] || 0).toString(),\n            token1: Big(res[1] || 0).toString(),\n          };\n          if (_tokens.length) {\n            loop(_tokens);\n          } else {\n            onLoad({ fees });\n          }\n        })\n        .catch((err) => {});\n    };\n    loop(tokens);\n  };\n  const getV3Data = (tokenIds) => {\n    asyncFetch(\n      \"https://graph.hyperlock.finance/subgraphs/name/hyperlock/v3-subgraph-mainnet\",\n      {\n        method: \"post\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          query:\n            'query Positions($account: Bytes!, $ids: [ID!]) {\\n  staked: positions(\\n    where: {owner: \"0xc28effdfef75448243c1d9ba972b97e32df60d06\", id_in: $ids},\\n    orderBy: id,\\n    orderDirection: asc\\n  ) {\\n    ...PositionFragment\\n  }\\n  unstaked: positions(where: {owner: $account}, orderBy: id, orderDirection: asc) {\\n    ...PositionFragment\\n  }\\n}\\n\\nfragment PositionFragment on Position {\\n  id\\n  owner\\n  token0 {\\n    ...TokenFragment\\n  }\\n  token1 {\\n    ...TokenFragment\\n  }\\n  pool {\\n    id\\n    feeTier\\n    liquidity\\n    tick\\n  }\\n}\\n\\nfragment TokenFragment on Token {\\n  id\\n  symbol\\n  decimals\\n}',\n          variables: {\n            account,\n            ids: tokenIds,\n          },\n        }),\n      }\n    )\n      .then((res) => {\n        const { staked, unstaked } = res.body.data;\n\n        const _unstaked = {};\n\n        unstaked.forEach((item) => {\n          let _item = _unstaked[item.pool.id];\n          if (_item) {\n            _item.push(item.id);\n          } else {\n            _unstaked[item.pool.id] = [item.id];\n          }\n        });\n\n        const _staked = {};\n\n        staked.forEach((item) => {\n          let _item = _staked[item.pool.id];\n          if (_item) {\n            _item.push(item.id);\n          } else {\n            _staked[item.pool.id] = [item.id];\n          }\n        });\n\n        const unstakedPools = Object.entries(_unstaked);\n        const unstakedAmountData = {};\n        const stakedPools = Object.entries(_staked);\n        const stakedAmountData = {};\n\n        let count =\n          Number(!!unstakedPools.length) + Number(!!stakedPools.length);\n\n        const loop = (list, amountData, key) => {\n          const pool = list.pop();\n\n          getPositionsData(pool[0], pool[1], (data) => {\n            data.forEach((item) => {\n              amountData[item.tokenId] = item;\n            });\n            if (list.length) {\n              loop(list, amountData, key);\n            } else {\n              const tokens = key === \"staked\" ? staked : unstaked;\n\n              initData[key] = tokens\n                .filter((item) => {\n                  const { token0Amount, token1Amount } = amountData[item.id];\n                  return Big(token0Amount).gt(0) || Big(token1Amount).gt(0);\n                })\n                .map((item) => {\n                  return { ...item, ...amountData[item.id] };\n                });\n\n              const mapData = {};\n\n              const _pools = key === \"staked\" ? stakedPools : unstakedPools;\n\n              _pools.forEach(([poolId, ids]) => {\n                if (!mapData[poolId]) mapData[poolId] = [];\n                ids.forEach((id) => {\n                  const item = tokens.find((token) => token.id === id);\n\n                  const { token0Amount, token1Amount } = amountData[id];\n\n                  if (Big(token0Amount).gt(0) || Big(token1Amount).gt(0)) {\n                    mapData[poolId].push({\n                      ...item,\n                      token0Amount,\n                      token1Amount,\n                    });\n                  }\n                });\n              });\n\n              const _key = `${key}Map`;\n\n              initData[_key] = mapData;\n              count--;\n              if (count === 0) {\n                onLoad({ ...initData });\n\n                setTimeout(() => {\n                  initData.getV3Fees(staked);\n                }, 500);\n              }\n            }\n          });\n        };\n\n        if (stakedPools.length) loop(stakedPools, stakedAmountData, \"staked\");\n        if (unstakedPools.length)\n          loop(unstakedPools, unstakedAmountData, \"unstaked\");\n\n        if (!stakedPools.length && !unstakedPools.length) {\n          onLoad({ ...initData });\n        }\n      })\n      .catch((err) => {\n        onLoad({ ...initData });\n      });\n  };\n\n  getTokenIds();\n}, [update]);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/dapdapbos.near/widget/Staking.Hyperlock.UserData", "fact_widget_deployments_id": "0ea2be070eed50f7aa0cddf3a82a14c3", "inserted_timestamp": "2024-04-29T12:48:04.052Z", "modified_timestamp": "2024-04-29T13:40:15.700Z", "__row_index": 0}