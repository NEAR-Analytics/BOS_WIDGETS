{"tx_hash": "Ghsk6hvwcSEHJzGRD5tLgbJYqHfJqqb7YeB86EkRpdCn", "action_id_social": "BAVLp9nSDVm1dk6frLDvGkeve4vMjot6FNStraLsZQzL-0-widget", "block_id": 103795055, "block_timestamp": "2023-10-20T09:19:11.116Z", "signer_id": "dapdapbos.near", "widget_name": "Uniswap.Swap.AmountOutV2", "source_code": "const {\n  update,\n  routerAddress,\n  wethAddress,\n  inputCurrency,\n  outputCurrency,\n  inputCurrencyAmount,\n  outputCurrencyAmount,\n  onLoad,\n  chainId,\n  amountIn,\n  tokenIn,\n  tokenOut,\n  loadAmountOut,\n  quoterAddress,\n  tradeType,\n} = props;\n\nconst account = Ethers.send(\"eth_requestAccounts\", [])[0];\n\nif (!update || !account) return \"\";\n\nif (!tokenOut || !tokenIn) {\n  loadAmountOut({\n    loading: false,\n    success: true,\n    noPair: true,\n    outputCurrencyAmount: \"0\",\n  });\n}\n\nconst quoter02List = [56, 8453, 42220, 43114];\n\nconst is02 = quoter02List.indexOf(chainId) > -1;\n\nconst currentCurrency = tradeType === \"in\" ? inputCurrency : outputCurrency;\n\nconst WETH_ADDRESS = props.wethAddress;\n\nconst swapQuoterAbi = [\n  {\n    inputs: [\n      { internalType: \"address\", name: \"tokenIn\", type: \"address\" },\n      { internalType: \"address\", name: \"tokenOut\", type: \"address\" },\n      { internalType: \"uint24\", name: \"fee\", type: \"uint24\" },\n      { internalType: \"uint256\", name: \"amountIn\", type: \"uint256\" },\n      { internalType: \"uint160\", name: \"sqrtPriceLimitX96\", type: \"uint160\" },\n    ],\n    name: \"quoteExactInputSingle\",\n    outputs: [{ internalType: \"uint256\", name: \"amountOut\", type: \"uint256\" }],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n];\n\nconst swapQuoterAbi02 = [\n  {\n    inputs: [\n      {\n        components: [\n          { internalType: \"address\", name: \"tokenIn\", type: \"address\" },\n          { internalType: \"address\", name: \"tokenOut\", type: \"address\" },\n          { internalType: \"uint256\", name: \"amountIn\", type: \"uint256\" },\n          { internalType: \"uint24\", name: \"fee\", type: \"uint24\" },\n          {\n            internalType: \"uint160\",\n            name: \"sqrtPriceLimitX96\",\n            type: \"uint160\",\n          },\n        ],\n        internalType: \"struct IQuoterV2.QuoteExactInputSingleParams\",\n        name: \"params\",\n        type: \"tuple\",\n      },\n    ],\n    name: \"quoteExactInputSingle\",\n    outputs: [\n      { internalType: \"uint256\", name: \"amountOut\", type: \"uint256\" },\n      { internalType: \"uint160\", name: \"sqrtPriceX96After\", type: \"uint160\" },\n      {\n        internalType: \"uint32\",\n        name: \"initializedTicksCrossed\",\n        type: \"uint32\",\n      },\n      { internalType: \"uint256\", name: \"gasEstimate\", type: \"uint256\" },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n];\n\nconst getQuoterAbi = () => {\n  if (!is02) {\n    return swapQuoterAbi;\n  }\n  return swapQuoterAbi02;\n};\n\nconst feeList = [100, 500, 3000, 10000];\n\nconst quoteSingle = (amountIn, tokenIn, tokenOut, fee, finalList) => {\n  const iface = new ethers.utils.Interface(getQuoterAbi());\n\n  const amountInUnit = Big(amountIn)\n    .times(Big(10).pow(tokenIn.decimals))\n    .toFixed(0);\n\n  const inputs = !is02\n    ? [\n        tokenIn.address === \"native\" ? WETH_ADDRESS : tokenIn.address,\n        tokenOut.address === \"native\" ? WETH_ADDRESS : tokenOut.address,\n        fee,\n        amountInUnit,\n        0,\n      ]\n    : [\n        {\n          tokenIn:\n            tokenIn.address === \"native\" ? WETH_ADDRESS : tokenIn.address,\n          tokenOut:\n            tokenOut.address === \"native\" ? WETH_ADDRESS : tokenOut.address,\n          amountIn: ethers.utils.parseUnits(amountIn, tokenIn.decimals),\n          fee,\n          sqrtPriceLimitX96: 0,\n        },\n      ];\n\n  const encodedData = iface.encodeFunctionData(\"quoteExactInputSingle\", inputs);\n\n  return Ethers.provider()\n    .call({\n      to: quoterAddress,\n      data: encodedData,\n    })\n    .then((data) => {\n      const res = iface.decodeFunctionResult(\"quoteExactInputSingle\", data);\n\n      const rawAmountOut = Big(res.amountOut.toString()).toFixed();\n\n      const parsedAmountOut = new Big(rawAmountOut)\n        .div(Big(10).pow(tokenOut.decimals))\n        .toFixed();\n\n      return [\n        ...finalList,\n        {\n          fee: fee,\n          amountOut: parsedAmountOut,\n          success: true,\n        },\n      ];\n    })\n    .catch((e) => {\n      return [\n        ...finalList,\n        {\n          fee: fee,\n          amountOut: \"0\",\n          success: false,\n        },\n      ];\n    });\n};\n\nconst quoteAll = () => {\n  return quoteSingle(amountIn, tokenIn, tokenOut, feeList[0], [])\n    .then((finalList0) => {\n      return quoteSingle(amountIn, tokenIn, tokenOut, feeList[1], finalList0);\n    })\n    .then((finalList1) => {\n      return quoteSingle(amountIn, tokenIn, tokenOut, feeList[2], finalList1);\n    })\n    .then((finalList2) => {\n      return quoteSingle(amountIn, tokenIn, tokenOut, feeList[3], finalList2);\n    })\n    .then((finalList3) => {\n      const maxAmountOutEstimate = finalList3.reduce((prev, current) => {\n        if (Number(prev.amountOut) > Number(current.amountOut)) {\n          return prev;\n        } else {\n          return current;\n        }\n      }, finalList3[0]);\n\n      if (maxAmountOutEstimate.amountOut === \"0\") {\n        loadAmountOut({\n          loading: false,\n          noPair: true,\n        });\n      }\n\n      if (tokenIn.chainId === chainId) {\n        loadAmountOut({\n          ...maxAmountOutEstimate,\n          outputCurrencyAmount: maxAmountOutEstimate.amountOut,\n          noPair: false,\n        });\n      }\n    });\n};\n\nconst wrapType =\n  tokenIn.address === \"native\" && tokenOut.address === wethAddress\n    ? 1\n    : tokenIn.address === wethAddress && tokenOut.address === \"native\"\n    ? 2\n    : 0;\n\nif (wrapType > 0) {\n  loadAmountOut({\n    amountOut: amountIn,\n    outputCurrencyAmount: amountIn,\n    fee: 0,\n    success: true,\n    noPair: false,\n    loading: false,\n  });\n} else {\n  if (Big(amountIn || \"0\").eq(0)) {\n    loadAmountOut({\n      loading: false,\n      success: true,\n      noPair: false,\n    });\n    return \"\";\n  }\n\n  const amountInUnit = Big(amountIn)\n    .times(Big(10).pow(tokenIn.decimals))\n    .toFixed(0);\n\n  const realTokenIn =\n    tokenIn.address === \"native\" ? WETH_ADDRESS : tokenIn.address;\n\n  const realTokenOut =\n    tokenOut.address === \"native\" ? WETH_ADDRESS : tokenOut.address;\n\n  // asyncFetch(\n  //   `https://bos-api.delink.one/api/uniswap/get_token?token_in=${realTokenIn}&token_out=${realTokenOut}&amount=${amountInUnit}&chain_id=ETH`\n  // ).then((res) => {\n  //   console.log(\"res: \", res);\n  // });\n\n  quoteAll();\n}\nreturn \"\";\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/dapdapbos.near/widget/Uniswap.Swap.AmountOutV2", "fact_widget_deployments_id": "7aea06013ebf9a2ba69da271dc4685ce", "inserted_timestamp": "2023-10-20T11:23:38.941Z", "modified_timestamp": "2023-10-20T11:23:38.941Z", "__row_index": 10}