{"tx_hash": "BwZWDoP2Rdu3DbT1oNMH5ELaHtFmobYJ4vTViEzU7MTM", "action_id_social": "HnVaezLVT4MDJaXto9m23YwdJ1sekKBUeftaLiJTwXGV-0-widget", "block_id": 99048289, "block_timestamp": "2023-08-17T23:43:01.934Z", "signer_id": "andyh.near", "widget_name": "IndexFeed", "source_code": "State.init({ cachedItems: {} });\nconst index = JSON.parse(JSON.stringify(props.index));\nif (!index) {\n  return \"props.index is not defined\";\n}\n\nconst filter = props.filter;\n\nconst renderItem =\n  props.renderItem ??\n  ((item, i) => (\n    <div key={JSON.stringify(item)}>\n      #{item.blockHeight}: {JSON.stringify(item)}\n    </div>\n  ));\n// const cachedRenderItem = (item, i) => {\n//   if (item === undefined) {\n//     return \"loading...\";\n//   }\n//   try {\n//     const key = JSON.stringify(item);\n\n//     if (!(key in state.cachedItems)) {\n//       state.cachedItems[key] = renderItem(item, i);\n//       console.log({ item, cached: state.cachedItems[key] });\n//       State.update();\n//     }\n//     return state.cachedItems[key];\n//   } catch (e) {\n//     console.warn(e, { cached: state.cachedItems, state: { ...state } });\n//   }\n// };\n\nindex.options = index.options || {};\nconst initialRenderLimit =\n  props.initialRenderLimit ?? index.options.limit ?? 10;\nconst addDisplayCount = props.nextLimit ?? initialRenderLimit;\n\nindex.options.limit = Math.min(\n  Math.max(initialRenderLimit + addDisplayCount * 2, index.options.limit),\n  100\n);\nconst reverse = !!props.reverse;\n\nconst initialItems = Social.index(index.action, index.key, index.options);\nif (initialItems === null) {\n  return \"\";\n}\n\nconst computeFetchFrom = (items, limit) => {\n  if (!items || items.length < limit) {\n    return false;\n  }\n  const blockHeight = items[items.length - 1].blockHeight;\n  return index.options.order === \"desc\" ? blockHeight - 1 : blockHeight + 1;\n};\n\nconst mergeItems = (newItems) => {\n  const items = [\n    ...new Set([...newItems, ...state.items].map((i) => JSON.stringify(i))),\n  ].map((i) => JSON.parse(i));\n  items.sort((a, b) => a.blockHeight - b.blockHeight);\n  if (index.options.order === \"desc\") {\n    items.reverse();\n  }\n  return items;\n};\n\nconst jInitialItems = JSON.stringify(initialItems);\nif (state.jInitialItems !== jInitialItems) {\n  const jIndex = JSON.stringify(index);\n  const nextFetchFrom = computeFetchFrom(initialItems, index.options.limit);\n  if (jIndex !== state.jIndex || nextFetchFrom !== state.initialNextFetchFrom) {\n    State.update({\n      jIndex,\n      jInitialItems,\n      items: initialItems,\n      fetchFrom: false,\n      initialNextFetchFrom: nextFetchFrom,\n      nextFetchFrom,\n      displayCount: initialRenderLimit,\n      cachedItems: {},\n    });\n  } else {\n    State.update({\n      jInitialItems,\n      items: mergeItems(initialItems),\n    });\n  }\n}\n\nif (state.fetchFrom) {\n  const limit = addDisplayCount;\n  const newItems = Social.index(\n    index.action,\n    index.key,\n    Object.assign({}, index.options, {\n      from: state.fetchFrom,\n      subscribe: undefined,\n      limit,\n    })\n  );\n  if (newItems !== null) {\n    State.update({\n      items: mergeItems(newItems),\n      fetchFrom: false,\n      nextFetchFrom: computeFetchFrom(newItems, limit),\n    });\n  }\n}\n\nconst filteredItems = state.items || [];\nif (filter) {\n  if (filter.ignore) {\n    filteredItems = filteredItems.filter(\n      (item) => !(item.accountId in filter.ignore)\n    );\n  }\n}\n\nconst maybeFetchMore = () => {\n  if (\n    filteredItems.length - state.displayCount < addDisplayCount * 2 &&\n    !state.fetchFrom &&\n    state.nextFetchFrom &&\n    state.nextFetchFrom !== state.fetchFrom\n  ) {\n    State.update({\n      fetchFrom: state.nextFetchFrom,\n    });\n  }\n};\n\nmaybeFetchMore();\n\nconst makeMoreItems = () => {\n  State.update({\n    displayCount: state.displayCount + addDisplayCount,\n  });\n  maybeFetchMore();\n};\n\nconst loader = (\n  <div className=\"loader\" key={\"loader\"}>\n    <span\n      className=\"spinner-grow spinner-grow-sm me-1\"\n      role=\"status\"\n      aria-hidden=\"true\"\n    />\n    Loading ...\n  </div>\n);\n\nconst fetchMore =\n  props.manual &&\n  !props.hideFetchMore &&\n  (state.fetchFrom && filteredItems.length < state.displayCount\n    ? loader\n    : state.displayCount < filteredItems.length && (\n        <div key={\"loader more\"}>\n          <a href=\"javascript:void\" onClick={(e) => makeMoreItems()}>\n            {props.loadMoreText ?? \"Load more...\"}\n          </a>\n        </div>\n      ));\n\nconst items = filteredItems ? filteredItems.slice(0, state.displayCount) : [];\nif (reverse) {\n  items.reverse();\n}\n\nreturn (\n  <Widget\n    src=\"andyh.near/widget/IndexFeed.Items\"\n    props={{\n      items,\n      manual: props.manual,\n      reverse,\n      fetchMore,\n      hasMore: state.displayCount < filteredItems.length,\n      makeMoreItems,\n      renderItems: (i) =>\n        Promise.all(\n          i.map((it, ix) => {\n            const rendered = renderItem(it, ix);\n            console.log({ rendered });\n            return rendered;\n          })\n        ),\n    }}\n    isTrusted={true}\n  />\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/andyh.near/widget/IndexFeed", "fact_widget_deployments_id": "5a83d527f00a5f1ba717d263d0026a66", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 40}