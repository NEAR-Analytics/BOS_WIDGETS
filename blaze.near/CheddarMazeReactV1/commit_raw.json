{"tx_hash": "AYLnTaxK2Qc4Sq2kkjX5rpdBsrfcdbmwc3bwnBKhtJ9k", "action_id_social": "FzDeDF4uHhCgH6Ekf5XRs9Rj4QYrGD5uFRbXmgKf3TcA-0-widget", "block_id": 118179290, "block_timestamp": "2024-05-03T20:01:08.271Z", "signer_id": "blaze.near", "widget_name": "CheddarMazeReactV1", "source_code": "const [mazeData, setMazeData] = useState([]);\nconst [playerPosition, setPlayerPosition] = useState({ x: 1, y: 1 });\nconst [score, setScore] = useState(0);\nconst [timeLimitInSeconds, setTimeLimitInSeconds] = useState(120);\nconst [timerId, setTimerId] = useState(null);\nconst [cheeseCooldown, setCheeseCooldown] = useState(false);\nconst [enemyCooldown, setEnemyCooldown] = useState(false);\nconst [moves, setMoves] = useState(0);\nconst [gameOverFlag, setGameOverFlag] = useState(false);\nconst [remainingTime, setRemainingTime] = useState(timeLimitInSeconds);\nconst [remainingMinutes, setRemainingMinutes] = useState(0);\nconst [remainingSeconds, setRemainingSeconds] = useState(0);\nconst [gameOverMessage, setGameOverMessage] = useState(\"\");\nconst [initialTouch, setInitialTouch] = useState(null);\nconst [playerStartX, setPlayerStartX] = useState(0);\nconst [playerStartY, setPlayerStartY] = useState(0);\nconst [timerStarted, setTimerStarted] = useState(false);\nconst [luckyColor, setLuckyColor] = useState(\n  Math.random() < 0.1 ? \"#9d67ef\" : \"Gold\"\n);\nconst [direction, setDirection] = useState(\"right\");\nconst [selectedColorSet, setSelectedColorSet] = useState(null);\nconst [backgroundImage, setBackgroundImage] = useState(\"\");\nconst [rarity, setRarity] = useState(\"\");\nconst [won, setWon] = useState(false);\nconst [touchStart, setTouchStart] = useState({ x: null, y: null });\nconst [touchEnd, setTouchEnd] = useState({ x: null, y: null });\n\n// Initialize path color from the selected color set\nconst pathColor = selectedColorSet ? selectedColorSet.pathColor : \"\";\nconst backgroundImageStyle = {\n  backgroundImage: backgroundImage,\n  backgroundSize: \"cover\",\n};\n\nconst Maze = ({\n  mazeData,\n  playerPosition,\n  score,\n  timerStarted,\n  remainingMinutes,\n  remainingSeconds,\n  gameOverFlag,\n  gameOverMessage,\n  startTimerOnTap,\n  handleKeyPress,\n  handleContainerClick,\n  handleTouchStart,\n  handleTouchEnd,\n  handleMouseDown,\n  handleMouseUp,\n  restartGame,\n}) => {\n  const pathColor = selectedColorSet ? selectedColorSet.pathColor : \"\";\n  const backgroundImageStyle = {\n    backgroundImage: backgroundImage,\n    backgroundSize: \"cover\",\n  };\n\n  const styles = {\n    gameContainer: {\n      display: \"flex\",\n      flexDirection: \"column\",\n      alignItems: \"center\",\n      border: \"1px solid gold\",\n    },\n    mazeContainer: {\n      marginBottom: \"20px\",\n      border: \"2px solid black\",\n      borderRadius: \"5px\",\n      overflow: \"hidden\",\n      width: \"fit-content\",\n      border: \"1px solid green\", // Typo: 'border' instead of 'bordeer'\n    },\n    mazeRow: {\n      display: \"flex\",\n      border: \"1px solid red\",\n    },\n    mazeCell: {\n      display: \"flex\",\n      flex: \"0 0 auto\", // Fix the size of the cell\n      width: \"40px\",\n      height: \"40px\",\n      border: \"1px solid green\",\n      justifyContent: \"center\",\n      alignItems: \"center\",\n      fontSize: \"24px\" /* Adjust the font size of the emojis */,\n      backgroundColor: \"white\", // Default background color for cells\n    },\n    playerCell: {\n      backgroundColor: \"yellow\",\n    },\n    debugInfo: {\n      display: \"none\", // Hide debug info by default\n    },\n    gameInfo: {\n      display: \"flex\",\n      justifyContent: \"space-between\",\n      width: \"200px\",\n    },\n    gameOver: {\n      fontSize: \"24px\",\n      fontWeight: \"bold\",\n      color: \"red\",\n    },\n  };\n\n  // Render the maze cells\n  const renderMaze = () => {\n    return mazeData.map((row, rowIndex) => (\n      <div key={rowIndex} style={styles.mazeRow}>\n        {row.map((cell, colIndex) => (\n          <div\n            key={colIndex}\n            style={{\n              ...styles.mazeCell,\n              backgroundColor: cell.isPath\n                ? pathColor\n                : cell.hasEnemy\n                ? \"red\"\n                : cell.hasCheese\n                ? \"orange\"\n                : \"black\",\n            }}\n          >\n            {cell.hasCheese && \"\ud83e\uddc0\"}\n            {cell.hasEnemy && \"\ud83d\udc7e\"}\n            {cell.enemyWon && \"\ud83d\udca2\"}\n            {cell.cartelWon && \"\ud83e\udd2e\"}\n            {playerPosition.x === colIndex && playerPosition.y === rowIndex && (\n              <div\n                style={{\n                  ...styles.mazeCell,\n                  ...styles.playerCell,\n                  backgroundImage: `url('https://lh3.googleusercontent.com/d/114_RLl18MAzX035svMyvNJpE3ArfLNCF=w500')`,\n                  backgroundSize: \"cover\",\n                  backgroundRepeat: \"no-repeat\",\n                  backgroundPosition: \"center\",\n                  backgroundSize: \"70%\",\n                  position: \"relative\",\n                }}\n              ></div>\n            )}\n          </div>\n        ))}\n      </div>\n    ));\n  };\n\n  return (\n    <div\n      style={{\n        ...styles.gameContainer,\n        backgroundColor: selectedColorSet\n          ? selectedColorSet.backgroundColor\n          : \"#FFFFFF\",\n      }}\n    >\n      <h1\n        style={{\n          color: selectedColorSet ? selectedColorSet.textColor : \"black\",\n        }}\n      >\n        Cheese Maze Game\n      </h1>\n      <div\n        style={{\n          ...styles.mazeContainer,\n          ...backgroundImageStyle,\n        }}\n        tabIndex=\"0\"\n        onKeyDown={handleKeyPress}\n        onClick={handleContainerClick}\n        onTouchStart={handleTouchStart}\n        onTouchEnd={handleTouchEnd}\n        onMouseDown={handleMouseDown}\n        onMouseUp={handleMouseUp}\n      >\n        {renderMaze()}\n      </div>\n      <div style={styles.gameInfo}>\n        <div>Score: {score}</div>\n        <div>\n          Time:{\" \"}\n          {remainingMinutes < 10 ? \"0\" + remainingMinutes : remainingMinutes}:\n          {remainingSeconds < 10 ? \"0\" + remainingSeconds : remainingSeconds}\n        </div>\n      </div>\n      <div style={styles.gameOver}>{gameOverMessage}</div>\n      {gameOverFlag && (\n        <button onClick={restartGame} style={{ fontSize: \"18px\" }}>\n          Restart Game\n        </button>\n      )}\n    </div>\n  );\n};\n\nconst styles = {\n  gameContainer: {\n    display: \"flex\",\n    flexDirection: \"column\",\n    alignItems: \"center\",\n    border: \"1px solid gold\",\n  },\n  mazeContainer: {\n    marginBottom: \"20px\",\n    border: \"2px solid black\",\n    borderRadius: \"5px\",\n    overflow: \"hidden\",\n    width: \"fit-content\",\n    border: \"1px solid green\", // Typo: 'border' instead of 'bordeer'\n  },\n  mazeRow: {\n    display: \"flex\",\n    border: \"1px solid red\",\n  },\n  mazeCell: {\n    flex: \"0 0 auto\", // Fix the size of the cell\n    width: \"40px\",\n    height: \"40px\",\n    border: \"1px solid green\",\n    backgroundColor: \"white\", // Default background color for cells\n  },\n  playerCell: {\n    backgroundColor: \"yellow\",\n  },\n  debugInfo: {\n    display: \"none\", // Hide debug info by default\n  },\n  gameInfo: {\n    display: \"flex\",\n    justifyContent: \"space-between\",\n    width: \"200px\",\n  },\n  gameOver: {\n    fontSize: \"24px\",\n    fontWeight: \"bold\",\n    color: \"red\",\n  },\n};\n\n// Function to select a random color set, background image, and rarity\nconst selectRandomColorSet = () => {\n  const colorSets = [\n    {\n      backgroundColor: \"#F0F0F0\",\n      pathColor: \"#9d67ef\",\n      nonPathColor: \"white\",\n      textColor: \"#000000\",\n      rarity: \"common\",\n      backgroundImage:\n        \"url('https://cheddar.farm/newFarmBackground.c6905a5e.png')\",\n    },\n    {\n      backgroundColor: \"#E0E0E0\",\n      pathColor: \"gold\",\n      nonPathColor: \"white\",\n      textColor: \"#333333\",\n      rarity: \"rare\",\n      backgroundImage:\n        \"url('https://ipfs.near.social/ipfs/bafkreihpddbzbioe7kctes25rr52klcs5we4pocwiwbmwldqf4acdarpcm')\",\n    },\n    // Add more color sets as needed\n  ];\n\n  return colorSets[Math.floor(Math.random() * colorSets.length)];\n};\n\n// Set the selected color set, background image, and rarity once at the start of the game\nuseEffect(() => {\n  const randomColorSet = selectRandomColorSet();\n  setSelectedColorSet(randomColorSet);\n  setBackgroundImage(randomColorSet.backgroundImage);\n  setRarity(randomColorSet.rarity);\n}, []);\n\n// Define a new useEffect hook to manage the timer\nuseEffect(() => {\n  let intervalId;\n  if (timerStarted && !gameOverFlag) {\n    intervalId = setInterval(() => {\n      setRemainingTime((prevTime) => {\n        if (prevTime === 1) {\n          clearInterval(intervalId);\n          gameOver(\"\u23f0 Time's up! Game Over!\");\n          return prevTime;\n        }\n        return prevTime - 1;\n      });\n    }, 1000);\n  } else {\n    clearInterval(intervalId);\n  }\n\n  return () => clearInterval(intervalId); // Cleanup function to clear interval on unmount or when timer conditions change\n}, [timerStarted, gameOverFlag]);\n\nuseEffect(() => {\n  const minutes = Math.floor(remainingTime / 60);\n  const seconds = remainingTime % 60;\n  setRemainingMinutes(minutes);\n  setRemainingSeconds(seconds);\n}, [remainingTime]);\n\nuseEffect(() => {\n  // Clear timer when component unmounts\n  return () => {\n    clearInterval(timerId);\n  };\n}, [timerId]);\n\n// Function to restart the game\nconst restartGame = () => {\n  clearInterval(timerId);\n  setScore(0);\n  setTimeLimitInSeconds(120);\n  setRemainingTime(120);\n  setCheeseCooldown(false);\n  setEnemyCooldown(true);\n  setMoves(0);\n  setGameOverFlag(false);\n  setWon(false);\n  setGameOverMessage(\"\");\n\n  // Regenerate maze data\n  const mazeRows = 11;\n  const mazeCols = 9;\n  const newMazeData = generateMazeData(mazeRows, mazeCols);\n\n  // Find a valid starting position for the player\n  let playerStartX = Math.floor(Math.random() * (mazeCols - 2)) + 1;\n  let playerStartY = Math.floor(Math.random() * (mazeRows - 2)) + 1;\n  while (!newMazeData[playerStartY][playerStartX].isPath) {\n    playerStartX = Math.floor(Math.random() * (mazeCols - 2)) + 1;\n    playerStartY = Math.floor(Math.random() * (mazeRows - 2)) + 1;\n  }\n\n  // Set the maze data with the new maze and player's starting position\n  setMazeData(newMazeData);\n  setPlayerPosition({ x: playerStartX, y: playerStartY });\n\n  startTimer(); // Start the timer again after resetting the game\n};\n\n// Function to generate maze data\nconst generateMazeData = (rows, cols) => {\n  const maze = Array.from({ length: rows }, () =>\n    Array.from({ length: cols }, () => ({\n      isPath: false,\n      isActive: false,\n      hasCheese: false,\n      hasEnemy: false,\n      hasExit: false,\n      enemyWon: false,\n    }))\n  );\n\n  // Choose a random starting position on the outer border\n  const startEdge = Math.floor(Math.random() * 4); // 0: top, 1: right, 2: bottom, 3: left\n  let x, y;\n\n  switch (startEdge) {\n    case 0: // Top edge\n      x = Math.floor(Math.random() * (cols - 2)) + 1;\n      y = 0;\n      break;\n    case 1: // Right edge\n      x = cols - 1;\n      y = Math.floor(Math.random() * (rows - 2)) + 1;\n      break;\n    case 2: // Bottom edge\n      x = Math.floor(Math.random() * (cols - 2)) + 1;\n      y = rows - 1;\n      break;\n    case 3: // Left edge\n      x = 0;\n      y = Math.floor(Math.random() * (rows - 2)) + 1;\n      break;\n  }\n\n  maze[y][x].isPath = true;\n  const stack = [[x, y]];\n\n  while (stack.length) {\n    const [cx, cy] = stack[stack.length - 1];\n    const directions = [];\n\n    // Check all possible directions\n    [\n      [2, 0], // Increase step to 2 for wider paths\n      [-2, 0], // Increase step to 2 for wider paths\n      [0, 2], // Increase step to 2 for wider paths\n      [0, -2], // Increase step to 2 for wider paths\n    ].forEach(([dx, dy]) => {\n      const nx = cx + dx,\n        ny = cy + dy;\n      if (\n        nx >= 0 &&\n        nx < cols &&\n        ny >= 0 &&\n        ny < rows &&\n        !maze[ny][nx].isPath\n      ) {\n        directions.push([nx, ny, cx + dx / 2, cy + dy / 2]); // Adjust coordinates for wider paths\n      }\n    });\n\n    if (directions.length) {\n      const [nx, ny, px, py] =\n        directions[Math.floor(Math.random() * directions.length)];\n      maze[ny][nx].isPath = true;\n      maze[py][px].isPath = true;\n      stack.push([nx, ny]);\n    } else {\n      stack.pop();\n    }\n  }\n\n  return maze;\n};\n\n// Inside the component where you're using the Maze component\nuseEffect(() => {\n  // Generate maze data and set it to the state\n  const mazeRows = 11;\n  const mazeCols = 9;\n  const newMazeData = generateMazeData(mazeRows, mazeCols);\n  setMazeData(newMazeData);\n}, []); // Empty dependency array to run this effect only once on component mount\n\nconst movePlayer = (newX, newY) => {\n  if (!mazeData[newY][newX].isPath) {\n    return; // Player cannot move to non-path cells\n  }\n\n  // Start the timer if it hasn't started yet\n  if (!timerStarted) {\n    startTimer();\n    setTimerStarted(true);\n  }\n\n  const newMazeData = mazeData.map((row, rowIndex) =>\n    row.map((cell, colIndex) => ({\n      ...cell,\n      isActive: rowIndex === newY && colIndex === newX,\n    }))\n  );\n\n  // Reset isActive for the previous player position\n  newMazeData[playerPosition.y][playerPosition.x].isActive = false;\n\n  // Update player position state\n  setPlayerPosition({ x: newX, y: newY });\n\n  // Update mazeData state\n  setMazeData(newMazeData);\n\n  // Increment moves count\n  setMoves(moves + 1);\n\n  // Periodically add artifacts to the board based on cooldowns and randomness\n  addArtifacts(newX, newY, newMazeData);\n};\n\nconst addArtifacts = (newX, newY, newMazeData) => {\n  if (\n    !gameOverFlag &&\n    !newMazeData[newY][newX].hasEnemy &&\n    !newMazeData[newY][newX].hasCheese\n  ) {\n    if (!enemyCooldown && Math.random() < 0.5) {\n      // 50% chance of encountering an enemy\n      // Code for adding enemy artifact...\n\n      // Add logic for the enemy defeating the player\n      if (Math.random() < 0.1) {\n        // 10% chance of the enemy winning\n        console.log(\"enemy won\");\n        const updatedMazeData = newMazeData.map((row, rowIndex) =>\n          row.map((mazeCell, colIndex) => {\n            const isPlayerPosition = rowIndex === newY && colIndex === newX;\n            if (isPlayerPosition) {\n              return {\n                ...mazeCell,\n                enemyWon: true, // Update enemyWon flag\n                isActive: false, // Update isActive flag\n              };\n            }\n            return mazeCell;\n          })\n        );\n        setMazeData(updatedMazeData);\n        setScore(0); // Set score to zero\n        gameOver(\"Enemy won! Game Over!\");\n        stopTimer();\n      } else {\n        const updatedMazeData = newMazeData.map((row, rowIndex) =>\n          row.map((mazeCell, colIndex) => {\n            const isPlayerPosition = rowIndex === newY && colIndex === newX;\n            if (isPlayerPosition) {\n              return {\n                ...mazeCell,\n                hasEnemy: true, // Update enemyWon flag\n              };\n            }\n            return mazeCell;\n          })\n        );\n        setMazeData(updatedMazeData);\n        setEnemyCooldown(true);\n        setTimeout(() => {\n          setEnemyCooldown(false);\n        }, Math.floor(Math.random() * 5000) + 1000);\n      }\n    } else if (!cheeseCooldown && Math.random() < 0.055) {\n      // 5.5% chance of winning cheese\n      const updatedMazeData = newMazeData.map((row, rowIndex) =>\n        row.map((cell, colIndex) => {\n          if (rowIndex === newY && colIndex === newX) {\n            return {\n              ...cell,\n              hasCheese: true,\n            };\n          }\n          return cell;\n        })\n      );\n      setMazeData(updatedMazeData);\n      setScore(score + 1);\n      setCheeseCooldown(true);\n      setTimeout(() => {\n        setCheeseCooldown(false);\n      }, Math.floor(Math.random() * 5000) + 1000);\n    } else if (Math.random() < 0.002) {\n      // 0.2% chance of hitting the \"cartel\" event\n      const updatedMazeData = newMazeData.map((row, rowIndex) =>\n        row.map((cell, colIndex) => {\n          if (rowIndex === newY && colIndex === newX) {\n            return {\n              ...cell,\n              hasCartel: true,\n            };\n          }\n          return cell;\n        })\n      );\n      setMazeData(updatedMazeData);\n      setScore(0);\n      gameOver(\"You ran into the cartel! Game Over!\");\n      stopTimer();\n    } else if (Math.random() < 0.002) {\n      // 0.2% chance of finding the exit\n      const updatedMazeData = newMazeData.map((row, rowIndex) =>\n        row.map((cell, colIndex) => {\n          if (rowIndex === newY && colIndex === newX) {\n            return {\n              ...cell,\n              hasExit: true,\n            };\n          }\n          return cell;\n        })\n      );\n      setMazeData(updatedMazeData);\n      gameOver(\"Congrats! You found the Hidden Door.\");\n      stopTimer();\n    }\n  } else if (newMazeData[newY][newX].hasExit) {\n    gameOver(\"Congrats! You found the Hidden Door.\");\n    stopTimer();\n  }\n};\n\n// Function to handle key press events\nconst handleKeyPress = (event) => {\n  if (gameOverFlag) return; // If game over, prevent further movement\n\n  const key = event.key;\n  let newX = playerPosition.x;\n  let newY = playerPosition.y;\n\n  switch (key) {\n    case \"ArrowUp\":\n      newY--;\n      setDirection(\"up\");\n      break;\n    case \"ArrowDown\":\n      newY++;\n      setDirection(\"down\");\n      break;\n    case \"ArrowLeft\":\n      newX--;\n      setDirection(\"left\");\n      break;\n    case \"ArrowRight\":\n      newX++;\n      setDirection(\"right\");\n      break;\n    default:\n      return;\n  }\n\n  movePlayer(newX, newY);\n};\n\n// Function to handle container click events\nconst handleContainerClick = () => {\n  startTimerOnTap(); // Start the timer when the user clicks on the maze container\n};\n\n// Function to handle touch start events\nconst handleTouchStart = (event) => {\n  setInitialTouch({ x: event.touches[0].clientX, y: event.touches[0].clientY });\n  setTouchStart({ x: event.touches[0].clientX, y: event.touches[0].clientY });\n};\n\n// Function to handle touch end events\nconst handleTouchEnd = (event) => {\n  const deltaX = event.changedTouches[0].clientX - initialTouch.x;\n  const deltaY = event.changedTouches[0].clientY - initialTouch.y;\n\n  if (Math.abs(deltaX) > Math.abs(deltaY)) {\n    if (deltaX > 0) {\n      handleKeyPress({ key: \"ArrowRight\" });\n    } else {\n      handleKeyPress({ key: \"ArrowLeft\" });\n    }\n  } else {\n    if (deltaY > 0) {\n      handleKeyPress({ key: \"ArrowDown\" });\n    } else {\n      handleKeyPress({ key: \"ArrowUp\" });\n    }\n  }\n\n  setTouchEnd({\n    x: event.changedTouches[0].clientX,\n    y: event.changedTouches[0].clientY,\n  });\n};\n\nconst handleMouseDown = (event) => {\n  setTouchStart({ x: event.clientX, y: event.clientY });\n};\n\nconst handleMouseUp = (event) => {\n  const deltaX = event.clientX - touchStart.x;\n  const deltaY = event.clientY - touchStart.y;\n\n  if (Math.abs(deltaX) > Math.abs(deltaY)) {\n    if (deltaX > 0) {\n      handleKeyPress({ key: \"ArrowRight\" });\n    } else {\n      handleKeyPress({ key: \"ArrowLeft\" });\n    }\n  } else {\n    if (deltaY > 0) {\n      handleKeyPress({ key: \"ArrowDown\" });\n    } else {\n      handleKeyPress({ key: \"ArrowUp\" });\n    }\n  }\n\n  setTouchEnd({ x: event.clientX, y: event.clientY });\n};\n\n// Function to start the timer\nconst startTimer = () => {\n  const id = setInterval(() => {\n    setTimeLimitInSeconds((prevTime) => {\n      if (prevTime === 0) {\n        clearInterval(id);\n        setGameOverFlag(true);\n        setGameOverMessage(\"Time's up! Game over!\");\n        return prevTime;\n      }\n      return prevTime - 1;\n    });\n  }, 1000);\n\n  setTimerId(id);\n  setTimerStarted(true);\n};\n\nconst startTimerOnTap = () => {\n  if (!timerStarted) {\n    startTimer();\n  }\n};\n\nconst stopTimer = () => {\n  clearInterval(timerId);\n  setTimerStarted(false);\n};\n\n// Function to handle game over\nconst gameOver = (message) => {\n  setGameOverFlag(true);\n  setGameOverMessage(message);\n  stopTimer();\n};\n\nreturn (\n  <div>\n    <Maze\n      mazeData={mazeData}\n      playerPosition={playerPosition}\n      score={score}\n      timerStarted={timerStarted}\n      remainingMinutes={remainingMinutes}\n      remainingSeconds={remainingSeconds}\n      gameOverFlag={gameOverFlag}\n      gameOverMessage={gameOverMessage}\n      startTimerOnTap={startTimerOnTap}\n      handleKeyPress={handleKeyPress}\n      handleContainerClick={handleContainerClick}\n      handleTouchStart={handleTouchStart}\n      handleTouchEnd={handleTouchEnd}\n      handleMouseDown={handleMouseDown}\n      handleMouseUp={handleMouseUp}\n      restartGame={restartGame}\n    />\n  </div>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/blaze.near/widget/CheddarMazeReactV1", "fact_widget_deployments_id": "2ee647ca4d6c9b68623156e7ad3f40b4", "inserted_timestamp": "2024-05-03T21:39:25.926Z", "modified_timestamp": "2024-05-03T21:39:25.926Z", "__row_index": 0}