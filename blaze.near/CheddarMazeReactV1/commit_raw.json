{"tx_hash": "EfJUTehkhoSjxrvYpmXEbCiZLMd7PVrg6qXWFfoE3Key", "action_id_social": "Fy71Q2pXLJro5Fqar8TQP62gYUbAyvgJj65xs56F91Ba-0-widget", "block_id": 118195816, "block_timestamp": "2024-05-04T01:44:58.377Z", "signer_id": "blaze.near", "widget_name": "CheddarMazeReactV1", "source_code": "const [mazeData, setMazeData] = useState([]);\nconst [playerPosition, setPlayerPosition] = useState({ x: 1, y: 1 });\nconst [score, setScore] = useState(0);\nconst [timeLimitInSeconds, setTimeLimitInSeconds] = useState(120);\nconst [timerId, setTimerId] = useState(null);\nconst [cheeseCooldown, setCheeseCooldown] = useState(false);\nconst [enemyCooldown, setEnemyCooldown] = useState(false);\nconst [moves, setMoves] = useState(0);\nconst [gameOverFlag, setGameOverFlag] = useState(false);\nconst [remainingTime, setRemainingTime] = useState(timeLimitInSeconds);\nconst [remainingMinutes, setRemainingMinutes] = useState(0);\nconst [remainingSeconds, setRemainingSeconds] = useState(0);\nconst [gameOverMessage, setGameOverMessage] = useState(\"\");\nconst [playerStartY, setPlayerStartY] = useState(0);\nconst [timerStarted, setTimerStarted] = useState(false);\nconst [direction, setDirection] = useState(\"right\");\nconst [selectedColorSet, setSelectedColorSet] = useState(null);\nconst [backgroundImage, setBackgroundImage] = useState(\"\");\nconst [rarity, setRarity] = useState(\"\");\nconst [won, setWon] = useState(false);\nconst [touchStart, setTouchStart] = useState({ x: null, y: null });\nconst [touchEnd, setTouchEnd] = useState({ x: null, y: null });\nconst [lastCellX, setLastCellX] = useState(null);\nconst [lastCellY, setLastCellY] = useState(null);\n\n// Initialize path color from the selected color set\nconst pathColor = selectedColorSet ? selectedColorSet.pathColor : \"\";\nconst backgroundImageStyle = {\n  backgroundImage: backgroundImage,\n  backgroundSize: \"cover\",\n};\n\nconst Maze = ({\n  mazeData,\n  playerPosition,\n  score,\n  timerStarted,\n  remainingMinutes,\n  remainingSeconds,\n  gameOverFlag,\n  gameOverMessage,\n  startTimerOnTap,\n  handleKeyPress,\n  handleTouchMove,\n  handleMouseClick,\n  restartGame,\n}) => {\n  const pathColor = selectedColorSet ? selectedColorSet.pathColor : \"\";\n  const backgroundImageStyle = {\n    backgroundImage: backgroundImage,\n    backgroundSize: \"cover\",\n  };\n\n  const styles = {\n    gameContainer: {\n      display: \"flex\",\n      flexDirection: \"column\",\n      alignItems: \"center\",\n      border: \"1px solid gold\",\n    },\n    mazeContainer: {\n      marginBottom: \"20px\",\n      border: \"2px solid black\",\n      borderRadius: \"5px\",\n      overflow: \"hidden\",\n      width: \"fit-content\",\n      border: \"1px solid green\", // Typo: 'border' instead of 'bordeer'\n    },\n    mazeRow: {\n      display: \"flex\",\n      border: \"1px solid red\",\n    },\n    mazeCell: {\n      display: \"flex\",\n      flex: \"0 0 auto\", // Fix the size of the cell\n      width: \"40px\",\n      height: \"40px\",\n      border: \"1px solid green\",\n      justifyContent: \"center\",\n      alignItems: \"center\",\n      fontSize: \"24px\" /* Adjust the font size of the emojis */,\n      backgroundColor: \"white\", // Default background color for cells\n    },\n    playerCell: {\n      position: \"relative\", // Ensure the player is positioned relative to its parent\n      width: \"40px\",\n      height: \"40px\",\n      justifyContent: \"center\",\n      alignItems: \"center\",\n      fontSize: \"24px\",\n      backgroundImage:\n        \"url('https://lh3.googleusercontent.com/d/114_RLl18MAzX035svMyvNJpE3ArfLNCF=w500')\",\n      backgroundSize: \"cover\",\n      backgroundRepeat: \"no-repeat\",\n      backgroundPosition: \"center\",\n      backgroundSize: \"70%\",\n      backgroundColor: \"transparent\",\n    },\n    playerMoveUp: {\n      transform: \"rotate(-90deg)\",\n    },\n    playerMoveDown: {\n      transform: \"rotate(90deg)\",\n    },\n    playerMoveLeft: {\n      transform: \"scaleX(-1)\",\n    },\n    playerMoveRight: {\n      transform: \"rotate(0deg)\",\n    },\n    playerActive: {\n      zIndex: 1, // Ensure the active player appears above other elements\n    },\n    debugInfo: {\n      display: \"none\", // Hide debug info by default\n    },\n    gameInfo: {\n      display: \"flex\",\n      justifyContent: \"space-between\",\n      width: \"200px\",\n    },\n    gameOver: {\n      fontSize: \"24px\",\n      fontWeight: \"bold\",\n      color: \"red\",\n    },\n  };\n\n  // Render the maze cells\n  // Function to render the maze cells\n  // Function to render the maze cells with blur effect\n  const renderMaze = () => {\n    // Check if the player position has changed\n    const playerMoved =\n      lastCellX !== playerPosition.x || lastCellY !== playerPosition.y;\n\n    // // Update last player position\n    setLastCellX(playerPosition.x);\n    setLastCellY(playerPosition.y);\n\n    return mazeData.map((row, rowIndex) => (\n      <div key={rowIndex} style={styles.mazeRow}>\n        {row.map((cell, colIndex) => {\n          const blurRadius = playerMoved\n            ? calculateBlurRadius(colIndex, rowIndex)\n            : 0;\n          const applyBlur = blurRadius > 0; // Determine if blur should be applied\n          return (\n            <div\n              key={colIndex}\n              id={`cell-${rowIndex}-${colIndex}`}\n              style={{\n                ...styles.mazeCell,\n                backgroundColor: cell.isPath\n                  ? \"#9d67ef\"\n                  : cell.hasEnemy\n                  ? \"red\"\n                  : cell.hasCheese\n                  ? \"orange\"\n                  : \"black\",\n                filter: applyBlur ? `blur(${blurRadius}px)` : \"none\", // Apply blur conditionally\n              }}\n              onClick={handleMouseClick}\n            >\n              {cell.hasCheese && \"\ud83e\uddc0\"}\n              {cell.hasEnemy && \"\ud83d\udc7e\"}\n              {playerPosition.x === colIndex &&\n                playerPosition.y === rowIndex && (\n                  <div\n                    className={`player-icon ${direction}`} // Apply dynamic CSS class based on the direction\n                    style={{\n                      ...styles.mazeCell,\n                      ...styles.playerCell,\n                      ...styles[\n                        `playerMove${\n                          direction.charAt(0).toUpperCase() + direction.slice(1)\n                        }`\n                      ], // Applying the direction style dynamically\n                      backgroundImage: `url('https://lh3.googleusercontent.com/d/114_RLl18MAzX035svMyvNJpE3ArfLNCF=w500')`,\n                      backgroundSize: \"cover\",\n                      backgroundRepeat: \"no-repeat\",\n                      backgroundPosition: \"center\",\n                      backgroundSize: \"70%\",\n                      position: \"relative\",\n                    }}\n                  ></div>\n                )}\n            </div>\n          );\n        })}\n      </div>\n    ));\n  };\n\n  // Inside the Maze component return statement\n  return (\n    <div style={styles.gameContainer}>\n      <h1>Cheese Maze Game</h1>\n      <div\n        style={styles.mazeContainer}\n        tabIndex=\"0\"\n        onKeyDown={handleKeyPress}\n        onTouchMove={handleTouchMove}\n        onClick={handleMouseClick}\n      >\n        {renderMaze()}\n      </div>\n      <div style={styles.gameInfo}>\n        <div>Score: {score}</div>\n        <div>\n          Time:{\" \"}\n          {remainingMinutes < 10 ? \"0\" + remainingMinutes : remainingMinutes}:\n          {remainingSeconds < 10 ? \"0\" + remainingSeconds : remainingSeconds}\n        </div>\n      </div>\n      <div style={styles.gameOver}>{gameOverMessage}</div>\n      {gameOverFlag && (\n        <button onClick={restartGame} style={{ fontSize: \"18px\" }}>\n          Restart Game\n        </button>\n      )}\n    </div>\n  );\n};\n\nconst styles = {\n  gameContainer: {\n    display: \"flex\",\n    flexDirection: \"column\",\n    alignItems: \"center\",\n    border: \"1px solid gold\",\n  },\n  mazeContainer: {\n    marginBottom: \"20px\",\n    border: \"2px solid black\",\n    borderRadius: \"5px\",\n    overflow: \"hidden\",\n    width: \"fit-content\",\n    border: \"1px solid green\", // Typo: 'border' instead of 'bordeer'\n  },\n  mazeRow: {\n    display: \"flex\",\n    border: \"1px solid red\",\n  },\n  mazeCell: {\n    flex: \"0 0 auto\", // Fix the size of the cell\n    width: \"40px\",\n    height: \"40px\",\n    border: \"1px solid green\",\n    backgroundColor: \"white\", // Default background color for cells\n  },\n  playerCell: {\n    backgroundColor: \"yellow\",\n  },\n  debugInfo: {\n    display: \"none\", // Hide debug info by default\n  },\n  gameInfo: {\n    display: \"flex\",\n    justifyContent: \"space-between\",\n    width: \"200px\",\n  },\n  gameOver: {\n    fontSize: \"24px\",\n    fontWeight: \"bold\",\n    color: \"red\",\n  },\n};\n\n// Function to select a random color set, background image, and rarity\nconst selectRandomColorSet = () => {\n  const colorSets = [\n    {\n      backgroundColor: \"#F0F0F0\",\n      pathColor: \"#9d67ef\",\n      nonPathColor: \"white\",\n      textColor: \"#000000\",\n      rarity: \"common\",\n      backgroundImage:\n        \"url('https://cheddar.farm/newFarmBackground.c6905a5e.png')\",\n    },\n    {\n      backgroundColor: \"#E0E0E0\",\n      pathColor: \"gold\",\n      nonPathColor: \"white\",\n      textColor: \"#333333\",\n      rarity: \"rare\",\n      backgroundImage:\n        \"url('https://ipfs.near.social/ipfs/bafkreihpddbzbioe7kctes25rr52klcs5we4pocwiwbmwldqf4acdarpcm')\",\n    },\n    // Add more color sets as needed\n  ];\n\n  return colorSets[Math.floor(Math.random() * colorSets.length)];\n};\n\n// Set the selected color set, background image, and rarity once at the start of the game\nuseEffect(() => {\n  const randomColorSet = selectRandomColorSet();\n  setSelectedColorSet(randomColorSet);\n  setBackgroundImage(randomColorSet.backgroundImage);\n  setRarity(randomColorSet.rarity);\n}, []);\n\n// Define a new useEffect hook to manage the timer\nuseEffect(() => {\n  let intervalId;\n  if (timerStarted && !gameOverFlag) {\n    intervalId = setInterval(() => {\n      setRemainingTime((prevTime) => {\n        if (prevTime === 1) {\n          clearInterval(intervalId);\n          gameOver(\"\u23f0 Time's up! Game Over!\");\n          return prevTime;\n        }\n        return prevTime - 1;\n      });\n    }, 1000);\n  } else {\n    clearInterval(intervalId);\n  }\n\n  return () => clearInterval(intervalId); // Cleanup function to clear interval on unmount or when timer conditions change\n}, [timerStarted, gameOverFlag]);\n\nuseEffect(() => {\n  const minutes = Math.floor(remainingTime / 60);\n  const seconds = remainingTime % 60;\n  setRemainingMinutes(minutes);\n  setRemainingSeconds(seconds);\n}, [remainingTime]);\n\nuseEffect(() => {\n  // Clear timer when component unmounts\n  return () => {\n    clearInterval(timerId);\n  };\n}, [timerId]);\n\n// Function to restart the game\nconst restartGame = () => {\n  clearInterval(timerId);\n  setScore(0);\n  setTimeLimitInSeconds(120);\n  setRemainingTime(120);\n  setCheeseCooldown(false);\n  setEnemyCooldown(true);\n  setMoves(0);\n  setGameOverFlag(false);\n  setWon(false);\n  setGameOverMessage(\"\");\n\n  // Regenerate maze data\n  const mazeRows = 11;\n  const mazeCols = 9;\n  const newMazeData = generateMazeData(mazeRows, mazeCols);\n\n  // Find a valid starting position for the player\n  let playerStartX = Math.floor(Math.random() * (mazeCols - 2)) + 1;\n  let playerStartY = Math.floor(Math.random() * (mazeRows - 2)) + 1;\n  while (!newMazeData[playerStartY][playerStartX].isPath) {\n    playerStartX = Math.floor(Math.random() * (mazeCols - 2)) + 1;\n    playerStartY = Math.floor(Math.random() * (mazeRows - 2)) + 1;\n  }\n\n  // Set the maze data with the new maze and player's starting position\n  setMazeData(newMazeData);\n  setPlayerPosition({ x: playerStartX, y: playerStartY });\n\n  startTimer(); // Start the timer again after resetting the game\n};\n\n// Function to generate maze data\nconst generateMazeData = (rows, cols) => {\n  // Initialize lastCellX and lastCellY with initial player position\n  setLastCellX(Math.floor(cols / 2)); // Initial X coordinate\n  setLastCellY(Math.floor(rows / 2)); // Initial Y coordinate\n\n  const maze = Array.from({ length: rows }, () =>\n    Array.from({ length: cols }, () => ({\n      isPath: false,\n      isActive: false,\n      hasCheese: false,\n      hasEnemy: false,\n      hasExit: false,\n      enemyWon: false,\n    }))\n  );\n\n  // Choose a random starting position on the outer border\n  const startEdge = Math.floor(Math.random() * 4); // 0: top, 1: right, 2: bottom, 3: left\n  let x, y;\n\n  switch (startEdge) {\n    case 0: // Top edge\n      x = Math.floor(Math.random() * (cols - 2)) + 1;\n      y = 0;\n      break;\n    case 1: // Right edge\n      x = cols - 1;\n      y = Math.floor(Math.random() * (rows - 2)) + 1;\n      break;\n    case 2: // Bottom edge\n      x = Math.floor(Math.random() * (cols - 2)) + 1;\n      y = rows - 1;\n      break;\n    case 3: // Left edge\n      x = 0;\n      y = Math.floor(Math.random() * (rows - 2)) + 1;\n      break;\n  }\n\n  maze[y][x].isPath = true;\n  const stack = [[x, y]];\n\n  while (stack.length) {\n    const [cx, cy] = stack[stack.length - 1];\n    const directions = [];\n\n    // Check all possible directions\n    [\n      [2, 0], // Increase step to 2 for wider paths\n      [-2, 0], // Increase step to 2 for wider paths\n      [0, 2], // Increase step to 2 for wider paths\n      [0, -2], // Increase step to 2 for wider paths\n    ].forEach(([dx, dy]) => {\n      const nx = cx + dx,\n        ny = cy + dy;\n      if (\n        nx >= 0 &&\n        nx < cols &&\n        ny >= 0 &&\n        ny < rows &&\n        !maze[ny][nx].isPath\n      ) {\n        directions.push([nx, ny, cx + dx / 2, cy + dy / 2]); // Adjust coordinates for wider paths\n      }\n    });\n\n    if (directions.length) {\n      const [nx, ny, px, py] =\n        directions[Math.floor(Math.random() * directions.length)];\n      maze[ny][nx].isPath = true;\n      maze[py][px].isPath = true;\n      stack.push([nx, ny]);\n    } else {\n      stack.pop();\n    }\n  }\n\n  return maze;\n};\n\n// Inside the component where you're using the Maze component\nuseEffect(() => {\n  // Generate maze data and set it to the state\n  const mazeRows = 11;\n  const mazeCols = 9;\n  const newMazeData = generateMazeData(mazeRows, mazeCols);\n  setMazeData(newMazeData);\n}, []); // Empty dependency array to run this effect only once on component mount\n\nconst movePlayer = (newX, newY) => {\n  if (!mazeData[newY][newX].isPath) {\n    return; // Player cannot move to non-path cells\n  }\n\n  // Start the timer if it hasn't started yet\n  if (!timerStarted) {\n    startTimer();\n    setTimerStarted(true);\n  }\n\n  const newMazeData = mazeData.map((row, rowIndex) =>\n    row.map((cell, colIndex) => ({\n      ...cell,\n      isActive: rowIndex === newY && colIndex === newX,\n    }))\n  );\n\n  // Reset isActive for the previous player position\n  newMazeData[playerPosition.y][playerPosition.x].isActive = false;\n\n  // Update player position state\n  setPlayerPosition({ x: newX, y: newY });\n\n  // Update mazeData state\n  setMazeData(newMazeData);\n\n  // Increment moves count\n  setMoves(moves + 1);\n\n  // Periodically add artifacts to the board based on cooldowns and randomness\n  addArtifacts(newX, newY, newMazeData);\n\n  // Set lastCellX and lastCellY to the new player position\n  setLastCellX(newX);\n  setLastCellY(newY);\n};\n\nconst addArtifacts = (newX, newY, newMazeData) => {\n  if (\n    !gameOverFlag &&\n    !newMazeData[newY][newX].hasEnemy &&\n    !newMazeData[newY][newX].hasCheese\n  ) {\n    if (!enemyCooldown && Math.random() < 0.5) {\n      // 50% chance of encountering an enemy\n      // Code for adding enemy artifact...\n\n      // Add logic for the enemy defeating the player\n      if (Math.random() < 0.1) {\n        // 10% chance of the enemy winning\n        console.log(\"enemy won\");\n        const updatedMazeData = newMazeData.map((row, rowIndex) =>\n          row.map((mazeCell, colIndex) => {\n            const isPlayerPosition = rowIndex === newY && colIndex === newX;\n            if (isPlayerPosition) {\n              return {\n                ...mazeCell,\n                enemyWon: true, // Update enemyWon flag\n                isActive: false, // Update isActive flag\n              };\n            }\n            return mazeCell;\n          })\n        );\n        setMazeData(updatedMazeData);\n        setScore(0); // Set score to zero\n        gameOver(\"Enemy won! Game Over!\");\n        stopTimer();\n      } else {\n        const updatedMazeData = newMazeData.map((row, rowIndex) =>\n          row.map((mazeCell, colIndex) => {\n            const isPlayerPosition = rowIndex === newY && colIndex === newX;\n            if (isPlayerPosition) {\n              return {\n                ...mazeCell,\n                hasEnemy: true, // Update enemyWon flag\n              };\n            }\n            return mazeCell;\n          })\n        );\n        setMazeData(updatedMazeData);\n        setEnemyCooldown(true);\n        setTimeout(() => {\n          setEnemyCooldown(false);\n        }, Math.floor(Math.random() * 5000) + 1000);\n      }\n    } else if (!cheeseCooldown && Math.random() < 0.055) {\n      // 5.5% chance of winning cheese\n      const updatedMazeData = newMazeData.map((row, rowIndex) =>\n        row.map((cell, colIndex) => {\n          if (rowIndex === newY && colIndex === newX) {\n            return {\n              ...cell,\n              hasCheese: true,\n            };\n          }\n          return cell;\n        })\n      );\n      setMazeData(updatedMazeData);\n      setScore(score + 1);\n      setCheeseCooldown(true);\n      setTimeout(() => {\n        setCheeseCooldown(false);\n      }, Math.floor(Math.random() * 5000) + 1000);\n    } else if (Math.random() < 0.002) {\n      // 0.2% chance of hitting the \"cartel\" event\n      const updatedMazeData = newMazeData.map((row, rowIndex) =>\n        row.map((cell, colIndex) => {\n          if (rowIndex === newY && colIndex === newX) {\n            return {\n              ...cell,\n              hasCartel: true,\n            };\n          }\n          return cell;\n        })\n      );\n      setMazeData(updatedMazeData);\n      setScore(0);\n      gameOver(\"You ran into the cartel! Game Over!\");\n      stopTimer();\n    } else if (Math.random() < 0.002) {\n      // 0.2% chance of finding the exit\n      const updatedMazeData = newMazeData.map((row, rowIndex) =>\n        row.map((cell, colIndex) => {\n          if (rowIndex === newY && colIndex === newX) {\n            return {\n              ...cell,\n              hasExit: true,\n            };\n          }\n          return cell;\n        })\n      );\n      setMazeData(updatedMazeData);\n      gameOver(\"Congrats! You found the Hidden Door.\");\n      stopTimer();\n    }\n  } else if (newMazeData[newY][newX].hasExit) {\n    gameOver(\"Congrats! You found the Hidden Door.\");\n    stopTimer();\n  }\n};\n\n// Function to handle key press events\nconst handleKeyPress = (event) => {\n  if (gameOverFlag) return; // If game over, prevent further movement\n\n  const key = event.key;\n  let newX = playerPosition.x;\n  let newY = playerPosition.y;\n\n  switch (key) {\n    case \"ArrowUp\":\n      newY--;\n      setDirection(\"up\");\n      break;\n    case \"ArrowDown\":\n      newY++;\n      setDirection(\"down\");\n      break;\n    case \"ArrowLeft\":\n      newX--;\n      setDirection(\"left\");\n      break;\n    case \"ArrowRight\":\n      newX++;\n      setDirection(\"right\");\n      break;\n    default:\n      return;\n  }\n\n  movePlayer(newX, newY);\n  setLastCellX(newX);\n  setLastCellY(newY);\n};\n\nconst isMobile = () => {\n  const userAgent = navigator.userAgent;\n  return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(\n    userAgent\n  );\n};\n\nconst handleContainerClick = () => {\n  startTimerOnTap(); // Start the timer when the user clicks on the maze container\n};\n\nlet isMouseDown = false;\n\nconst handleMouseClick = (event) => {\n  if (gameOverFlag) return; // If game over, prevent further movement\n\n  // Extract cell coordinates from the id attribute\n  const id = event.target.id;\n  const [_, y, x] = id.split(\"-\");\n  const newX = parseInt(x);\n  const newY = parseInt(y);\n\n  // Calculate the direction based on the clicked cell's position relative to the player's current position\n  let newDirection = direction; // Initialize newDirection with the current direction\n  if (newY < playerPosition.y) {\n    newDirection = \"up\";\n  } else if (newY > playerPosition.y) {\n    newDirection = \"down\";\n  } else if (newX < playerPosition.x) {\n    newDirection = \"left\";\n  } else if (newX > playerPosition.x) {\n    newDirection = \"right\";\n  }\n\n  // Update the direction state\n  setDirection(newDirection);\n\n  // Call movePlayer to move the player to the clicked cell\n  movePlayer(newX, newY);\n};\n\n// Function to calculate the path from the current position to the target position\nconst calculatePath = (currentX, currentY, targetX, targetY) => {\n  console.log(\n    `Calculating path from (${currentX}, ${currentY}) to (${targetX}, ${targetY})`\n  );\n  const path = [];\n\n  let deltaX = Math.sign(targetX - currentX);\n  let deltaY = Math.sign(targetY - currentY);\n\n  let x = currentX;\n  let y = currentY;\n\n  console.log(\"Delta X:\", deltaX);\n  console.log(\"Delta Y:\", deltaY);\n\n  // Ensure that both x and y are not equal to their respective target values\n  while (x !== targetX || y !== targetY) {\n    path.push([x, y]);\n\n    // Move along the x-axis towards the target\n    if (x !== targetX) x += deltaX;\n\n    // Move along the y-axis towards the target\n    if (y !== targetY) y += deltaY;\n  }\n\n  // Add the target position to the path\n  path.push([targetX, targetY]);\n\n  console.log(\"Calculated path:\", path);\n\n  return path;\n};\n\n// Function to move the player along the calculated path\nconst moveAlongPath = (path) => {\n  console.log(\"Moving along path:\", path);\n  path.forEach(([x, y]) => {\n    console.log(`Moving to cell (${x}, ${y})`);\n    movePlayer(x, y);\n  });\n};\n\nconst cellSize = isMobile() ? 30 : 40; // Adjust cell size for mobile devices\nlet mazeContainerRef = null;\n\nconst handleContainerRef = (event) => {\n  mazeContainerRef = event.target;\n};\n\n// Function to extract cell coordinates from the id attribute\nconst getCellCoordinates = (id) => {\n  const [_, y, x] = id.split(\"-\");\n  return { newX: parseInt(x), newY: parseInt(y) };\n};\n\nconst handleTouchMove = (event) => {\n  event.preventDefault(); // Prevent default touch move behavior\n\n  if (!mazeContainerRef || !isMouseDown) return;\n\n  const cellWidth = isMobile() ? 30 : 40; // Adjusted cell size for mobile devices\n\n  // Extract cell coordinates from the id attribute\n  const id = event.target.id;\n  const [_, y, x] = id.split(\"-\");\n  const newX = parseInt(x);\n  const newY = parseInt(y);\n\n  // Update last cell coordinates\n  setLastCellX(newX);\n  setLastCellY(newY);\n\n  // Call movePlayerDirection to move the player based on touch direction\n  const deltaX = newX - touchStart.x;\n  const deltaY = newY - touchStart.y;\n  let direction = \"\";\n\n  if (Math.abs(deltaX) > Math.abs(deltaY)) {\n    direction = deltaX > 0 ? \"right\" : \"left\";\n  } else {\n    direction = deltaY > 0 ? \"down\" : \"up\";\n  }\n\n  // Move the player in the determined direction\n  for (let i = 0; i < Math.abs(cellsMovedX); i++) {\n    movePlayerDirection(direction);\n  }\n\n  for (let i = 0; i < Math.abs(cellsMovedY); i++) {\n    movePlayerDirection(direction);\n  }\n\n  // Update touch start position for next move\n  setTouchStart({ x: touch.clientX, y: touch.clientY });\n};\n\nconst calculateBlurRadius = (cellX, cellY) => {\n  // Check if lastCellX and lastCellY are null or undefined\n  if (lastCellX === null || lastCellY === null) {\n    // Initialize lastCellX and lastCellY with initial player position\n    setLastCellX(playerPosition.x);\n    setLastCellY(playerPosition.y);\n  }\n\n  // Calculate distance between current cell and last cell\n  const distance = Math.sqrt(\n    Math.pow(cellX - lastCellX, 2) + Math.pow(cellY - lastCellY, 2)\n  );\n\n  // Define max blur radius and adjust based on distance\n  const maxBlurRadius = 10; // Adjust as needed\n  return Math.min(maxBlurRadius, distance);\n};\n\nconst ControlPad = ({ movePlayerDirection }) => {\n  return (\n    <div\n      style={{ display: \"flex\", flexDirection: \"column\", alignItems: \"center\" }}\n    >\n      <button onClick={() => movePlayerDirection(\"up\")}>Up</button>\n      <div style={{ display: \"flex\", justifyContent: \"center\" }}>\n        <button onClick={() => movePlayerDirection(\"left\")}>Left</button>\n        <button onClick={() => movePlayerDirection(\"down\")}>Down</button>\n        <button onClick={() => movePlayerDirection(\"right\")}>Right</button>\n      </div>\n    </div>\n  );\n};\n\n// Function to handle directional button inputs\nconst movePlayerDirection = (direction) => {\n  if (gameOverFlag) return;\n\n  let newX = playerPosition.x;\n  let newY = playerPosition.y;\n\n  switch (direction) {\n    case \"up\":\n      newY--;\n      break;\n    case \"down\":\n      newY++;\n      break;\n    case \"left\":\n      newX--;\n      break;\n    case \"right\":\n      newX++;\n      break;\n    default:\n      return;\n  }\n\n  // Call moveAlongPath if you want to animate step by step movement\n  const path = calculatePath(playerPosition.x, playerPosition.y, newX, newY);\n  // Call handleMove to move the player to the new cell\n  handleMove(newX, newY);\n  setDirection(direction); // Optionally update the direction if needed\n};\n\n// Example handler for touch or click events where path calculation is desired\nconst handleMove = (event) => {\n  const { newX, newY } = getCellCoordinates(event.target.id);\n  const path = calculatePath(playerPosition.x, playerPosition.y, newX, newY);\n  moveAlongPath(path);\n};\n\n// Function to start the timer\nconst startTimer = () => {\n  const id = setInterval(() => {\n    setTimeLimitInSeconds((prevTime) => {\n      if (prevTime === 0) {\n        clearInterval(id);\n        setGameOverFlag(true);\n        setGameOverMessage(\"Time's up! Game over!\");\n        return prevTime;\n      }\n      return prevTime - 1;\n    });\n  }, 1000);\n\n  setTimerId(id);\n  setTimerStarted(true);\n};\n\nconst startTimerOnTap = () => {\n  if (!timerStarted) {\n    startTimer();\n  }\n};\n\nconst stopTimer = () => {\n  clearInterval(timerId);\n  setTimerStarted(false);\n};\n\n// Function to handle game over\nconst gameOver = (message) => {\n  setGameOverFlag(true);\n  setGameOverMessage(message);\n  stopTimer();\n};\n\nreturn (\n  <div>\n    <Maze\n      mazeData={mazeData}\n      playerPosition={playerPosition}\n      score={score}\n      timerStarted={false}\n      remainingMinutes={Math.floor(remainingTime / 60)}\n      remainingSeconds={remainingTime % 60}\n      gameOverFlag={gameOverFlag}\n      gameOverMessage={gameOverMessage}\n      startTimerOnTap={startTimer}\n      handleKeyPress={handleKeyPress}\n      handleTouchMove={handleTouchMove}\n      handleMouseClick={handleMouseClick}\n      restartGame={restartGame}\n    />\n  </div>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/blaze.near/widget/CheddarMazeReactV1", "fact_widget_deployments_id": "2bc61718d6587bcf04225aab79016131", "inserted_timestamp": "2024-05-04T02:40:35.403Z", "modified_timestamp": "2024-05-04T03:38:37.019Z", "__row_index": 3}