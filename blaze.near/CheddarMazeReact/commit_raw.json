{"tx_hash": "Fi8ZZj4GhZKUTwoqwRoHkvBWYf1N3d2CisXQeczRLnne", "action_id_social": "7MysW7tkaWzJgDrx1o6gmLZHzRv5kbi1jFa9zgiX83KE-0-widget", "block_id": 117859412, "block_timestamp": "2024-04-29T04:35:03.046Z", "signer_id": "blaze.near", "widget_name": "CheddarMazeReact", "source_code": "const [mazeData, setMazeData] = useState([]);\nconst [playerPosition, setPlayerPosition] = useState({ x: 1, y: 1 });\nconst [score, setScore] = useState(0);\nconst [timeLimitInSeconds, setTimeLimitInSeconds] = useState(120);\nconst [timerId, setTimerId] = useState(null);\nconst [cheeseCooldown, setCheeseCooldown] = useState(false);\nconst [enemyCooldown, setEnemyCooldown] = useState(false);\nconst [moves, setMoves] = useState(0);\nconst [gameOverFlag, setGameOverFlag] = useState(false);\nconst [remainingTime, setRemainingTime] = useState(timeLimitInSeconds);\nconst remainingMinutes = Math.floor(remainingTime / 60);\nconst remainingSeconds = remainingTime % 60;\nconst [gameOverMessage, setGameOverMessage] = useState(\"\");\n\nconst gameOver = (message) => {\n  const hasCheese = cell.hasCheese;\n  const hasEnemy = cell.hasEnemy;\n  const hasExit = cell.hasExit;\n\n  console.log(message);\n  setCheeseCooldown(false);\n  setEnemyCooldown(false);\n  setGameOverMessage(message);\n  setGameOverFlag(true);\n  stopTimer();\n  if (hasCheese || hasEnemy) {\n    setScore(0);\n  }\n};\n\nconst stopTimer = () => {\n  clearInterval(timerId);\n  setTimerId(null);\n};\n\nuseEffect(() => {\n  // Initial delay before enemy encounters become possible\n  setEnemyCooldown(true);\n  setTimeout(() => {\n    setEnemyCooldown(false);\n  }, 10000); // Delay for 5 seconds\n}, []);\n\nconst restartGame = () => {\n  clearInterval(timerId);\n  setScore(0);\n  setTimeLimitInSeconds(240); // Set the time limit to 240 seconds (twice the original time)\n  setRemainingTime(240); // Set the remaining time to match the new time limit\n  setPlayerPosition({ x: 1, y: 1 });\n  setCheeseCooldown(false);\n  setEnemyCooldown(true);\n  setMoves(0);\n  setGameOverFlag(false);\n  setGameOverMessage(\"\");\n\n  // Regenerate maze data\n  const mazeRows = 11;\n  const mazeCols = 11;\n  const newMazeData = generateMazeData(mazeRows, mazeCols);\n  let playerStartX = Math.floor(Math.random() * (mazeCols - 2)) + 1;\n  let playerStartY = Math.floor(Math.random() * (mazeRows - 2)) + 1;\n  while (!newMazeData[playerStartY][playerStartX].isPath) {\n    playerStartX = Math.floor(Math.random() * (mazeCols - 2)) + 1;\n    playerStartY = Math.floor(Math.random() * (mazeRows - 2)) + 1;\n  }\n  setMazeData(newMazeData);\n\n  startTimer(); // Start the timer again after resetting the game\n};\n\nconst generateAndSetMaze = () => {\n  const mazeRows = 11;\n  const mazeCols = 11;\n  const newMazeData = generateMazeData(mazeRows, mazeCols);\n  let playerStartX = Math.floor(Math.random() * (mazeCols - 2)) + 1;\n  let playerStartY = Math.floor(Math.random() * (mazeRows - 2)) + 1;\n\n  while (!newMazeData[playerStartY][playerStartX].isPath) {\n    playerStartX = Math.floor(Math.random() * (mazeCols - 2)) + 1;\n    playerStartY = Math.floor(Math.random() * (mazeRows - 2)) + 1;\n  }\n\n  newMazeData[playerStartY][playerStartX].isActive = true;\n  setPlayerPosition({ x: playerStartX, y: playerStartY });\n  setMazeData(newMazeData);\n};\n\n// Inside generateMazeData function\nconst generateMazeData = (rows, cols) => {\n  const maze = Array.from({ length: rows }, () =>\n    Array.from({ length: cols }, () => ({\n      isPath: false,\n      isActive: false,\n      hasCheese: false,\n      hasEnemy: false,\n      hasExit: false,\n    }))\n  );\n\n  // Creating a simple connected path maze\n  let x = 1,\n    y = 1;\n  maze[y][x].isPath = true;\n  const stack = [[x, y]];\n\n  while (stack.length) {\n    const [cx, cy] = stack[stack.length - 1];\n    const directions = [];\n\n    // Check all possible directions\n    [\n      [1, 0],\n      [-1, 0],\n      [0, 1],\n      [0, -1],\n    ].forEach(([dx, dy]) => {\n      const nx = cx + 2 * dx,\n        ny = cy + 2 * dy;\n      if (\n        nx > 0 &&\n        nx < cols - 1 &&\n        ny > 0 &&\n        ny < rows - 1 &&\n        !maze[ny][nx].isPath\n      ) {\n        directions.push([nx, ny, cx + dx, cy + dy]);\n      }\n    });\n\n    if (directions.length) {\n      const [nx, ny, px, py] =\n        directions[Math.floor(Math.random() * directions.length)];\n      maze[ny][nx].isPath = true;\n      maze[py][px].isPath = true;\n\n      // Initialize hasCheese and hasEnemy properties\n      maze[ny][nx].hasCheese = false;\n      maze[ny][nx].hasEnemy = false;\n\n      stack.push([nx, ny]);\n    } else {\n      stack.pop();\n    }\n  }\n\n  //console.log(\"Maze Data:\", maze); // Log the maze data to check hasCheese and hasEnemy properties\n  return maze;\n};\n\nconst startTimer = () => {\n  const id = setInterval(() => {\n    setRemainingTime((time) => {\n      if (time === 1) {\n        clearInterval(id);\n        gameOver(\"Time's up! Game Over!\");\n      }\n      return time - 1;\n    });\n  }, 1000);\n  setTimerId(id);\n};\n\nuseEffect(() => {\n  const mazeRows = 11;\n  const mazeCols = 11;\n  const newMazeData = generateMazeData(mazeRows, mazeCols);\n  let playerStartX = Math.floor(Math.random() * (mazeCols - 2)) + 1;\n  let playerStartY = Math.floor(Math.random() * (mazeRows - 2)) + 1;\n\n  while (!newMazeData[playerStartY][playerStartX].isPath) {\n    playerStartX = Math.floor(Math.random() * (mazeCols - 2)) + 1;\n    playerStartY = Math.floor(Math.random() * (mazeRows - 2)) + 1;\n  }\n\n  newMazeData[playerStartY][playerStartX].isActive = true;\n  setPlayerPosition({ x: playerStartX, y: playerStartY });\n  setMazeData(newMazeData);\n}, []);\n\nconst movePlayer = (newX, newY) => {\n  const newMazeData = mazeData.map((row, rowIndex) =>\n    row.map((cell, colIndex) => ({\n      ...cell,\n      isActive: rowIndex === newY && colIndex === newX,\n    }))\n  );\n\n  // Reset isActive for the previous player position\n  newMazeData[playerPosition.y][playerPosition.x].isActive = false;\n\n  setPlayerPosition({ x: newX, y: newY });\n  setMazeData(newMazeData);\n  checkForEvents(newMazeData[newY][newX]);\n};\n\nuseEffect(() => {\n  if (remainingTime === 0) {\n    gameOver(\"Time's up! Game Over!\");\n  }\n}, [remainingTime]);\n\nconst handleKeyDown = (event) => {\n  if (gameOverFlag) return; // If game over, prevent further movement\n\n  const key = event.key;\n  let newX = playerPosition.x;\n  let newY = playerPosition.y;\n\n  switch (key) {\n    case \"ArrowUp\":\n      newY--;\n      break;\n    case \"ArrowDown\":\n      newY++;\n      break;\n    case \"ArrowLeft\":\n      newX--;\n      break;\n    case \"ArrowRight\":\n      newX++;\n      break;\n    default:\n      return;\n  }\n\n  if (\n    newX >= 0 &&\n    newX < mazeData[0].length &&\n    newY >= 0 &&\n    newY < mazeData.length &&\n    mazeData[newY][newX].isPath\n  ) {\n    const newMazeData = mazeData.map((row, rowIndex) =>\n      row.map((cell, colIndex) => {\n        if (rowIndex === newY && colIndex === newX) {\n          return { ...cell, isActive: true };\n        } else if (cell.isActive) {\n          return { ...cell, isActive: false };\n        }\n        return cell;\n      })\n    );\n\n    setMazeData(newMazeData);\n    setPlayerPosition({ x: newX, y: newY });\n    setMoves(moves + 1);\n    checkForEvents(newMazeData[newY][newX]);\n  }\n};\n\n// Inside checkForEvents function\nconst checkForEvents = (cell) => {\n  if (!cell.isPath) {\n    return; // Exit the function if the cell is not a path cell\n  }\n\n  if (cell.isPath && !enemyCooldown && !cell.hasCheese && !cell.hasEnemy) {\n    console.log(\"enemy encountered\");\n    const chance = Math.random();\n\n    const newMazeData = mazeData.map((row, rowIndex) =>\n      row.map((mazeCell, colIndex) => {\n        // Log the position of the cell being checked\n        if (rowIndex === playerPosition.y && colIndex === playerPosition.x) {\n          // Check the value of found\n          console.log(\"Found:\", found);\n\n          return { ...mazeCell, hasEnemy: true };\n        }\n        return mazeCell;\n      })\n    );\n\n    setMazeData(newMazeData);\n    setEnemyCooldown(true);\n    const cooldownPeriod = Math.floor(Math.random() * 5000) + 10000;\n    setTimeout(() => {\n      setEnemyCooldown(false);\n    }, cooldownPeriod);\n\n    if (chance < 0.1) {\n      console.log(\"enemy won\");\n      gameOver(\"Enemy won! Game Over!\");\n      return; // Exit the function after triggering game over\n    } else {\n      console.log(\"enemy defeated...\");\n    }\n  }\n\n  if (cell.isPath && !cheeseCooldown && !cell.hasCheese && !cell.hasEnemy) {\n    if (Math.random() < 0.01) {\n      // `% chance of winning cheese\n      console.log(\"cheese\");\n      const newMazeData = mazeData.map((row, rowIndex) =>\n        row.map((mazeCell, colIndex) => {\n          if (rowIndex === playerPosition.y && colIndex === playerPosition.x) {\n            return { ...mazeCell, hasCheese: true };\n          }\n          return mazeCell;\n        })\n      );\n      setMazeData(newMazeData);\n      setScore(score + 1);\n      setCheeseCooldown(true);\n      const cooldownPeriod = Math.floor(Math.random() * 5000) + 1000;\n      setTimeout(() => {\n        setCheeseCooldown(false);\n      }, cooldownPeriod);\n    }\n  }\n\n  const totalCells = mazeData.length * mazeData[0].length;\n  const navigatedCells = moves;\n  const percentNavigated = (navigatedCells / totalCells) * 100;\n\n  if (percentNavigated >= 75 && Math.random() < 0.5) {\n    const newMazeData = mazeData.map((row, rowIndex) =>\n      row.map((mazeCell, colIndex) => {\n        if (rowIndex === playerPosition.y && colIndex === playerPosition.x) {\n          return { ...mazeCell, hasExit: true };\n        }\n        return mazeCell;\n      })\n    );\n    setMazeData(newMazeData);\n    gameOver(\"Congratulations! You reached the end of the maze!\");\n  }\n};\n\nconst renderMazeCells = () => {\n  return mazeData.map((row, rowIndex) =>\n    row.map((cell, colIndex) => {\n      const isActive =\n        playerPosition.x === colIndex && playerPosition.y === rowIndex;\n      const isPath = cell.isPath;\n      const hasCheese = cell.hasCheese;\n      const hasEnemy = cell.hasEnemy;\n      const hasExit = cell.hasExit;\n\n      return (\n        <div\n          key={`${rowIndex}-${colIndex}`}\n          className={`maze-cell ${isPath ? \"path\" : \"\"} ${\n            isActive ? \"active\" : \"\"\n          }`}\n          style={{\n            width: \"40px\",\n            height: \"40px\",\n            fontSize: \"20px\",\n            border: \"thin solid #ccc\",\n            textAlign: \"center\",\n            display: \"flex\",\n            justifyContent: \"center\",\n            alignItems: \"center\",\n            backgroundColor: isPath ? \"yellow\" : \"\",\n            color: isActive ? \"gray\" : \"\",\n          }}\n        >\n          {hasCheese ? \"\ud83e\uddc0\" : \"\"}\n          {hasEnemy ? \"\ud83e\uddb9\u200d\u2642\ufe0f\" : \"\"}\n          {hasExit ? \"\ud83d\udeaa\" : \"\"}\n          {isActive && !hasCheese && !hasEnemy && !hasExit ? \"\ud83d\udc2d\" : \"\"}\n        </div>\n      );\n    })\n  );\n};\n\nreturn (\n  <div>\n    {gameOverMessage && (\n      <div>\n        <p style={{ color: \"red\" }}>{gameOverMessage}</p>\n        <button onClick={restartGame}>Restart Game</button>\n      </div>\n    )}\n    <div\n      className=\"maze-container\"\n      style={{\n        display: \"grid\",\n        gridTemplateColumns: `repeat(${mazeData[0].length}, 40px)`,\n        gridTemplateRows: `repeat(${mazeData.length}, 40px)`,\n        gap: \"0px\",\n        border: \"1px solid black\",\n        width: \"450px\",\n        height: \"450px\",\n        padding: \"0px\",\n        position: \"relative\",\n      }}\n      tabIndex=\"0\"\n      onKeyDown={handleKeyDown}\n    >\n      {renderMazeCells()}\n      <div style={{ position: \"absolute\", top: 10, right: 10 }}>\n        Score: {score}\n      </div>\n      <div style={{ position: \"absolute\", top: 10, left: 10 }}>\n        Time: {remainingMinutes}m {remainingSeconds}s\n      </div>\n    </div>\n  </div>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/blaze.near/widget/CheddarMazeReact", "fact_widget_deployments_id": "32052ed0b01de043f25eb85c1866525c", "inserted_timestamp": "2024-04-29T06:41:20.766Z", "modified_timestamp": "2024-04-29T06:41:20.766Z", "__row_index": 51}