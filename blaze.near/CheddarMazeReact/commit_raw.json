{"tx_hash": "H7KDnexVVd122ifFD4tmX6waQM4hsDDLjmr5LEm9jS1b", "action_id_social": "JDD8RJpLqrmE3t38rB4ZbYKJGhbbXcCcSaeWJzW5q87W-0-widget", "block_id": 118030572, "block_timestamp": "2024-05-01T17:02:25.535Z", "signer_id": "blaze.near", "widget_name": "CheddarMazeReact", "source_code": "const [mazeData, setMazeData] = useState([]);\nconst [playerPosition, setPlayerPosition] = useState({ x: 1, y: 1 });\nconst [score, setScore] = useState(0);\nconst [timeLimitInSeconds, setTimeLimitInSeconds] = useState(120);\nconst [timerId, setTimerId] = useState(null);\nconst [cheeseCooldown, setCheeseCooldown] = useState(false);\nconst [enemyCooldown, setEnemyCooldown] = useState(false);\nconst [moves, setMoves] = useState(0);\nconst [gameOverFlag, setGameOverFlag] = useState(false);\nconst [remainingTime, setRemainingTime] = useState(timeLimitInSeconds);\nconst [remainingMinutes, setRemainingMinutes] = useState(\n  Math.floor(timeLimitInSeconds / 60)\n);\nconst [remainingSeconds, setRemainingSeconds] = useState(\n  timeLimitInSeconds % 60\n);\nconst [gameOverMessage, setGameOverMessage] = useState(\"\");\nconst [initialTouch, setInitialTouch] = useState(null);\nconst [playerStartX, setPlayerStartX] = useState(0);\nconst [playerStartY, setPlayerStartY] = useState(0);\nconst [timerStarted, setTimerStarted] = useState(false);\nconst [notification, setNotification] = useState(\"\");\n\nconst gameOver = (message, cell) => {\n  const hasCheese = cell.hasCheese;\n  const hasEnemy = cell.hasEnemy;\n\n  setCheeseCooldown(false);\n  setEnemyCooldown(false);\n  setGameOverMessage(message);\n  setGameOverFlag(true);\n  stopTimer();\n  if (hasCheese || hasEnemy) {\n    setScore(0);\n  }\n};\n\nconst startTimer = () => {\n  const id = setInterval(() => {\n    setRemainingTime((time) => {\n      if (time === 1) {\n        clearInterval(id);\n        gameOver(\"Time's up! Game Over!\");\n      }\n      return time - 1;\n    });\n  }, 1000);\n  setTimerId(id);\n};\n\n// Define a new useEffect hook that starts the timer when timerStarted state changes\nuseEffect(() => {\n  if (timerStarted) {\n    startTimer();\n  } else {\n    // Clear the timer when timerStarted is false\n    clearInterval(timerId);\n  }\n}, [timerStarted]); // Add timerId as a dependency\n\n// Update remainingTime, remainingMinutes, and remainingSeconds whenever remainingTime changes\nuseEffect(() => {\n  const minutes = Math.floor(remainingTime / 60);\n  const seconds = remainingTime % 60;\n  setRemainingMinutes(minutes);\n  setRemainingSeconds(seconds);\n}, [remainingTime]);\n\n// Update remainingMinutes and remainingSeconds whenever timeLimitInSeconds changes\nuseEffect(() => {\n  setRemainingTime(timeLimitInSeconds);\n}, [timeLimitInSeconds]);\n\nconst startTimerOnTap = () => {\n  if (!timerStarted) {\n    setTimerStarted(true); // Set timerStarted to true to start the timer\n  }\n};\n\nconst stopTimer = () => {\n  clearInterval(timerId);\n  setTimerStarted(false); // Set timerStarted to false to stop the timer\n  setTimerId(null);\n};\n\nuseEffect(() => {\n  // Initial delay before enemy encounters become possible\n  setEnemyCooldown(true);\n  setTimeout(() => {\n    setEnemyCooldown(false);\n  }, 5500); // Delay for 10 seconds\n}, []);\n\nconst restartGame = () => {\n  clearInterval(timerId);\n  setScore(0);\n  setTimeLimitInSeconds(120);\n  setRemainingTime(120);\n  setPlayerPosition({ x: 1, y: 1 }); // Reset player position to default (1, 1)\n  setCheeseCooldown(false);\n  setEnemyCooldown(true);\n  setMoves(0);\n  setGameOverFlag(false);\n  setGameOverMessage(\"\");\n\n  // Regenerate maze data\n  const mazeRows = 11;\n  const mazeCols = 9;\n  const newMazeData = generateMazeData(mazeRows, mazeCols);\n\n  // Find a valid starting position for the player\n  let playerStartX = Math.floor(Math.random() * (mazeCols - 2)) + 1;\n  let playerStartY = Math.floor(Math.random() * (mazeRows - 2)) + 1;\n  while (!newMazeData[playerStartY][playerStartX].isPath) {\n    playerStartX = Math.floor(Math.random() * (mazeCols - 2)) + 1;\n    playerStartY = Math.floor(Math.random() * (mazeRows - 2)) + 1;\n  }\n\n  // Set the maze data with the new maze and player's starting position\n  setMazeData(newMazeData);\n  setPlayerPosition({ x: playerStartX, y: playerStartY });\n\n  startTimer(); // Start the timer again after resetting the game\n};\n\nconst generateMazeData = (rows, cols) => {\n  const maze = Array.from({ length: rows }, () =>\n    Array.from({ length: cols }, () => ({\n      isPath: false,\n      isActive: false,\n      hasCheese: false,\n      hasEnemy: false,\n      hasExit: false,\n      hasEnemyWon: false,\n    }))\n  );\n\n  // Choose a random starting position on the outer border\n  const startEdge = Math.floor(Math.random() * 4); // 0: top, 1: right, 2: bottom, 3: left\n  let x, y;\n\n  switch (startEdge) {\n    case 0: // Top edge\n      x = Math.floor(Math.random() * (cols - 2)) + 1;\n      y = 0;\n      break;\n    case 1: // Right edge\n      x = cols - 1;\n      y = Math.floor(Math.random() * (rows - 2)) + 1;\n      break;\n    case 2: // Bottom edge\n      x = Math.floor(Math.random() * (cols - 2)) + 1;\n      y = rows - 1;\n      break;\n    case 3: // Left edge\n      x = 0;\n      y = Math.floor(Math.random() * (rows - 2)) + 1;\n      break;\n  }\n\n  maze[y][x].isPath = true;\n  const stack = [[x, y]];\n\n  while (stack.length) {\n    const [cx, cy] = stack[stack.length - 1];\n    const directions = [];\n\n    // Check all possible directions\n    [\n      [1, 0],\n      [-1, 0],\n      [0, 1],\n      [0, -1],\n    ].forEach(([dx, dy]) => {\n      const nx = cx + 2 * dx,\n        ny = cy + 2 * dy;\n      if (\n        nx >= 0 &&\n        nx < cols &&\n        ny >= 0 &&\n        ny < rows &&\n        !maze[ny][nx].isPath\n      ) {\n        directions.push([nx, ny, cx + dx, cy + dy]);\n      }\n    });\n\n    if (directions.length) {\n      const [nx, ny, px, py] =\n        directions[Math.floor(Math.random() * directions.length)];\n      maze[ny][nx].isPath = true;\n      maze[py][px].isPath = true;\n      stack.push([nx, ny]);\n    } else {\n      stack.pop();\n    }\n  }\n\n  return maze;\n};\n\nuseEffect(() => {\n  const mazeRows = 11;\n  const mazeCols = 9; // Updated width to 9 columns\n  const newMazeData = generateMazeData(mazeRows, mazeCols);\n  let startX = Math.floor(Math.random() * (mazeCols - 2)) + 1;\n  let startY = Math.floor(Math.random() * (mazeRows - 2)) + 1;\n\n  while (!newMazeData[startY][startX].isPath) {\n    startX = Math.floor(Math.random() * (mazeCols - 2)) + 1;\n    startY = Math.floor(Math.random() * (mazeRows - 2)) + 1;\n  }\n\n  newMazeData[startY][startX].isActive = true;\n  setPlayerPosition({ x: startX, y: startY });\n  setPlayerStartX(startX);\n  setPlayerStartY(startY);\n  setMazeData(newMazeData);\n}, []);\n\nuseEffect(() => {\n  if (remainingTime === 0) {\n    gameOver(\n      \"Time's up! Game Over!\"\n      //mazeData[playerPosition.y][playerPosition.x]\n    );\n  }\n}, [remainingTime]);\n\nconst handleKeyPress = (event) => {\n  if (gameOverFlag) return; // If game over, prevent further movement\n\n  const key = event.key;\n  let newX = playerPosition.x;\n  let newY = playerPosition.y;\n\n  switch (key) {\n    case \"ArrowUp\":\n      newY--;\n      break;\n    case \"ArrowDown\":\n      newY++;\n      break;\n    case \"ArrowLeft\":\n      newX--;\n      break;\n    case \"ArrowRight\":\n      newX++;\n      break;\n    default:\n      return;\n  }\n\n  movePlayer(newX, newY);\n};\n\nconst checkForEvents = (cell) => {\n  if (!cell.isPath) {\n    return; // Exit the function if the cell is not a path cell\n  }\n\n  if (cell.isPath && !enemyCooldown && !cell.hasCheese && !cell.hasEnemy) {\n    console.log(\"enemy encountered\");\n    const chance = Math.random();\n\n    const newMazeData = mazeData.map((row, rowIndex) =>\n      row.map((mazeCell, colIndex) => {\n        if (rowIndex === playerPosition.y && colIndex === playerPosition.x) {\n          return { ...mazeCell, hasEnemy: true };\n        }\n        return mazeCell;\n      })\n    );\n\n    setMazeData(newMazeData);\n    setEnemyCooldown(true);\n    const cooldownPeriod = Math.floor(Math.random() * 5000) + 10000;\n    setTimeout(() => {\n      setEnemyCooldown(false);\n    }, cooldownPeriod);\n\n    if (chance < 0.2) {\n      console.log(\"enemy won\");\n      const newMazeData = mazeData.map((row, rowIndex) =>\n        row.map((mazeCell, colIndex) => {\n          const isPlayerPosition =\n            rowIndex === playerPosition.y && colIndex === playerPosition.x;\n          if (isPlayerPosition) {\n            return {\n              ...mazeCell,\n              enemyWon: true, // Update enemyWon flag\n              isActive: false, // Update isActive flag\n            };\n          }\n          return mazeCell;\n        })\n      );\n      setMazeData(newMazeData);\n      setScore(0); // Set score to zero\n      gameOver(\"Enemy won! Game Over!\", cell);\n      return; // Exit the function after triggering game over\n    } else {\n      console.log(\"enemy defeated...\");\n    }\n  }\n\n  if (cell.isPath && !cheeseCooldown && !cell.hasCheese && !cell.hasEnemy) {\n    // Generate cheese only if the cell does not already have an enemy\n    if (Math.random() < 0.01) {\n      // 1% chance of winning cheese\n      console.log(\"cheese\");\n      const newMazeData = mazeData.map((row, rowIndex) =>\n        row.map((mazeCell, colIndex) => {\n          if (rowIndex === playerPosition.y && colIndex === playerPosition.x) {\n            return { ...mazeCell, hasCheese: true };\n          }\n          return mazeCell;\n        })\n      );\n      setMazeData(newMazeData);\n      setScore(score + 1);\n      setCheeseCooldown(true);\n      const cooldownPeriod = Math.floor(Math.random() * 5000) + 1000;\n      setTimeout(() => {\n        setCheeseCooldown(false);\n      }, cooldownPeriod);\n    }\n  }\n\n  const totalCells = mazeData.length * mazeData[0].length;\n  const navigatedCells = moves;\n  const percentNavigated = (navigatedCells / totalCells) * 100;\n\n  if (percentNavigated >= 75 && Math.random() < 0.5) {\n    const newMazeData = mazeData.map((row, rowIndex) =>\n      row.map((mazeCell, colIndex) => {\n        if (rowIndex === playerPosition.y && colIndex === playerPosition.x) {\n          return { ...mazeCell, hasExit: true };\n        }\n        return mazeCell;\n      })\n    );\n    setMazeData(newMazeData);\n    gameOver(\"Congrats! You found the Hidden Door.\", cell);\n    stopTimer();\n  }\n};\n\nconst renderMazeCells = () => {\n  return mazeData.map((row, rowIndex) =>\n    row.map((cell, colIndex) => {\n      const isActive =\n        playerPosition.x === colIndex && playerPosition.y === rowIndex;\n      const isPath = cell.isPath;\n      const hasCheese = cell.hasCheese;\n      const hasEnemy = cell.hasEnemy;\n      const hasExit = cell.hasExit;\n      const enemyWon = cell.enemyWon; // New flag to check if the enemy won\n\n      // Generate a unique id for each cell\n      const cellId = `cell-${rowIndex}-${colIndex}`;\n\n      const cellStyle = {\n        width: \"40px\",\n        height: \"40px\",\n        fontSize: \"20px\",\n        border: \"thin solid #ccc\",\n        textAlign: \"center\",\n        display: \"flex\",\n        justifyContent: \"center\",\n        alignItems: \"center\",\n        backgroundColor: isPath ? \"yellow\" : \"\",\n        color: isActive ? \"gray\" : \"\",\n      };\n\n      return (\n        <div\n          key={cellId}\n          id={cellId}\n          className={`maze-cell ${isPath ? \"path\" : \"\"} ${\n            isActive ? \"active\" : \"\"\n          }`}\n          style={cellStyle}\n        >\n          {hasCheese ? \"\ud83e\uddc0\" : \"\"}\n          {hasEnemy ? \"\ud83e\uddb9\u200d\u2642\ufe0f\" : \"\"}\n          {hasExit ? \"\ud83d\udeaa\" : \"\"}\n          {isActive && !hasCheese && !hasEnemy && !hasExit ? \"\ud83d\udc2d\" : \"\"}\n          {enemyWon ? \"\ud83d\udca2\" : \"\"} {/* Render the angry emoji if enemy won */}\n        </div>\n      );\n    })\n  );\n};\n\nconst isMobile = () => {\n  const userAgent = navigator.userAgent;\n  return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(\n    userAgent\n  );\n};\n\nconst handleContainerClick = () => {\n  startTimerOnTap(); // Start the timer when the user clicks on the maze container\n};\n\nconst movePlayer = (newX, newY) => {\n  if (!mazeData[newY][newX].isPath) {\n    return; // Player cannot move to non-path cells\n  }\n\n  const newMazeData = mazeData.map((row, rowIndex) =>\n    row.map((cell, colIndex) => ({\n      ...cell,\n      isActive: rowIndex === newY && colIndex === newX,\n    }))\n  );\n\n  // Reset isActive for the previous player position\n  newMazeData[playerPosition.y][playerPosition.x].isActive = false;\n\n  // Update player position state\n  setPlayerPosition({ x: newX, y: newY });\n\n  // Update mazeData state\n  setMazeData(newMazeData);\n\n  // Check for events at the new player position\n  checkForEvents(newMazeData[newY][newX]);\n\n  // Increment moves count\n  setMoves(moves + 1);\n};\n\nlet isMouseDown = false;\nlet lastCellX = null;\nlet lastCellY = null;\n\nconst handleMouseDown = (event) => {\n  isMouseDown = true;\n  handleMouseMove(event);\n};\n\nconst handleMouseMove = (event) => {\n  if (!mazeContainerRef || !isMouseDown) return;\n\n  const cellWidth = isMobile() ? 30 : 40; // Adjusted cell size for mobile devices\n\n  // Extract cell coordinates from the id attribute\n  const id = event.target.id;\n  const [_, y, x] = id.split(\"-\");\n  const newX = parseInt(x);\n  const newY = parseInt(y);\n\n  // Update last cell coordinates\n  lastCellX = newX;\n  lastCellY = newY;\n};\n\nconst handleMouseUp = () => {\n  isMouseDown = false;\n  lastCellX = null;\n  lastCellY = null;\n};\n\nconst handleClick = (event) => {\n  if (!mazeContainerRef) return;\n\n  // Extract cell coordinates from the id attribute\n  const id = event.target.id;\n  const [_, y, x] = id.split(\"-\");\n  const newX = parseInt(x);\n  const newY = parseInt(y);\n\n  console.log(`Clicked on cell (${newX}, ${newY})`);\n\n  // Save the current player position as the starting cell\n  const startX = playerPosition.x;\n  const startY = playerPosition.y;\n\n  // Calculate the path from the current position to the clicked cell\n  const path = calculatePath(startX, startY, newX, newY);\n\n  // Move the player along the calculated path\n  moveAlongPath(path);\n\n  // Stop the timer if the exit is found\n  if (mazeData[newY][newX].hasExit) {\n    stopTimer();\n  }\n};\n\n// Function to calculate the path from the current position to the target position\nconst calculatePath = (currentX, currentY, targetX, targetY) => {\n  console.log(\n    `Calculating path from (${currentX}, ${currentY}) to (${targetX}, ${targetY})`\n  );\n  const path = [];\n\n  let deltaX = Math.sign(targetX - currentX);\n  let deltaY = Math.sign(targetY - currentY);\n\n  let x = currentX;\n  let y = currentY;\n\n  console.log(\"Delta X:\", deltaX);\n  console.log(\"Delta Y:\", deltaY);\n\n  // Ensure that both x and y are not equal to their respective target values\n  while (x !== targetX || y !== targetY) {\n    path.push([x, y]);\n\n    // Move along the x-axis towards the target\n    if (x !== targetX) x += deltaX;\n\n    // Move along the y-axis towards the target\n    if (y !== targetY) y += deltaY;\n  }\n\n  // Add the target position to the path\n  path.push([targetX, targetY]);\n\n  console.log(\"Calculated path:\", path);\n\n  return path;\n};\n\n// Function to move the player along the calculated path\nconst moveAlongPath = (path) => {\n  console.log(\"Moving along path:\", path);\n  path.forEach(([x, y]) => {\n    console.log(`Moving to cell (${x}, ${y})`);\n    movePlayer(x, y);\n  });\n};\n\nconst cellSize = isMobile() ? 30 : 40; // Adjust cell size for mobile devices\nlet mazeContainerRef = null;\n\nconst handleContainerRef = (event) => {\n  mazeContainerRef = event.target;\n};\n\nreturn (\n  <div\n    style={{ maxWidth: `${mazeData[0].length * cellSize}px`, margin: \"0 auto\" }}\n  >\n    <div style={{ display: \"flex\", justifyContent: \"space-between\" }}>\n      <div>Score: {score}</div>\n      <div>\n        Time: {remainingMinutes}m {remainingSeconds}s\n      </div>\n    </div>\n    {gameOverMessage && (\n      <div>\n        <p style={{ color: \"red\" }}>{gameOverMessage}</p>\n        <button onClick={restartGame}>Restart Game</button>\n      </div>\n    )}\n    <div\n      className=\"maze-container\"\n      onTouchStart={(e) => {\n        handleContainerRef(e);\n        handleMouseDown(e);\n      }}\n      onTouchMove={(e) => {\n        handleContainerRef(e);\n        handleMouseMove(e);\n      }}\n      onTouchEnd={(e) => {\n        handleContainerRef(e);\n        handleMouseUp(e);\n      }}\n      onClick={(e) => {\n        handleContainerRef(e);\n        handleContainerClick();\n        handleClick(e);\n      }}\n      style={{\n        display: \"grid\",\n        gridTemplateColumns: `repeat(${mazeData[0].length}, ${cellSize}px)`, // Adjusted cell size\n        gridTemplateRows: `repeat(${mazeData.length}, ${cellSize}px)`, // Adjusted cell size\n        gap: \"0px\",\n        border: \"1px solid black\",\n        padding: \"0px\",\n        position: \"relative\",\n        width: `${mazeData[0].length * cellSize}px`, // Adjusted width\n      }}\n      tabIndex=\"0\"\n      onKeyDown={handleKeyPress}\n    >\n      {renderMazeCells()}\n\n      <div className=\"notification-bar\">\n        <p style={{ color: \"red\" }}>{notification}</p>{\" \"}\n        {/* Display the notification message here */}\n      </div>\n    </div>\n    <ol>\n      <li>Click or Tap to Start</li>\n      <li>Navigate with Arrows or Tap</li>\n      <li>Collect Cheddar\ud83e\uddc0</li>\n      <li>Battle Cartel to protect your Bag</li>\n      <li>Find the Hidden Door\ud83d\udeaa to Win!</li>\n    </ol>\n  </div>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/blaze.near/widget/CheddarMazeReact", "fact_widget_deployments_id": "5bdb4ece7982143d5ad649e5124ad541", "inserted_timestamp": "2024-05-01T18:40:46.716Z", "modified_timestamp": "2024-05-01T18:40:46.716Z", "__row_index": 34}