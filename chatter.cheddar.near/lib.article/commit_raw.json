{"tx_hash": "7vqUCaJtwjjZRk3PgeRUAmeatR6iFZY6ap1EEd8Gf41H", "action_id_social": "HzKkaFtpi4S4RC18NJZLMNWfXZZNx4Lpwo2ZRbAGzv4V-0-widget", "block_id": 120866184, "block_timestamp": "2024-06-10T16:24:03.443Z", "signer_id": "chatter.cheddar.near", "widget_name": "lib.article", "source_code": "const { getUserSBTs, getSBTWhiteList } = VM.require(\n    'communityvoice.ndctools.near/widget/lib.SBT'\n)\n\nconst { generateMetadata, updateMetadata, buildDeleteMetadata } = VM.require(\n    'communityvoice.ndctools.near/widget/lib.metadata'\n)\nconst { normalizeObjectWithMetadata } = VM.require(\n    'communityvoice.ndctools.near/widget/lib.normalization'\n)\nconst { camelCaseToUserReadable } = VM.require(\n    'communityvoice.ndctools.near/widget/lib.strings'\n)\n\nconst { extractMentions, getNotificationData } = VM.require(\n    'communityvoice.ndctools.near/widget/lib.notifications'\n)\n\nconst currentVersion = 'v0.0.1'\n\nlet config = {}\n\nfunction setConfig(value) {\n    config = value\n}\n\nfunction getConfig() {\n    return config\n}\n\nfunction getAction(version) {\n    const baseAction = getConfig().baseActions.article\n    const versionData = version ? versions[version] : versions[currentVersion]\n    const action = baseAction + versionData.actionSuffix\n    return getConfig().isTest ? `test_${action}` : action\n}\n\nfunction setIsTest(value) {\n    isTest = value\n}\n\nfunction getArticlesVersions(config, articleId) {\n    setConfig(config)\n    return getArticlesHistoryNormalized(articleId)\n}\n\nfunction getArticles(config, filters) {\n    setConfig(config)\n    return getArticlesNormalized(filters)\n}\n\nfunction filterFakeAuthors(articleData, articleIndexData) {\n    if (articleData.author === articleIndexData.accountId) {\n        return articleData\n    }\n}\n\nfunction getArticleNormalized(articleIndex, action) {\n    const articleVersionIndex = Object.keys(versions).findIndex(\n        (versionName) => {\n            const versionData = versions[versionName]\n            return (\n                (versionData.validBlockHeightRange[0] <=\n                    articleIndex.blockHeight &&\n                    articleIndex.blockHeight <\n                        versionData.validBlockHeightRange[1]) ||\n                versionData.validBlockHeightRange[1] === undefined\n            )\n        }\n    )\n\n    const articleVersionKey = Object.keys(versions)[articleVersionIndex]\n    // const action = versions[articleVersionKey].action\n    const key = 'main'\n\n    return asyncFetch(' https://api.near.social/get', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n            keys: [`${articleIndex.accountId}/${action}/${key}`],\n            blockHeight: articleIndex.blockHeight,\n        }),\n    }).then((response) => {\n        //ERROR: Check the structure of the response to define \"article\"\n        let article = JSON.parse(\n            response.body[articleIndex.accountId][action][key]\n        )\n        article.blockHeight = articleIndex.blockHeight\n        article.articleIndex = articleIndex\n        Object.keys(versions).forEach((versionName, index) => {\n            if (articleVersionIndex >= index) {\n                const versionData = versions[versionName]\n                article = versionData.normalizationFunction(article)\n            }\n        })\n        return article\n    })\n}\n\nfunction normalizeArticleData(articleData) {\n    return normalizeObjectWithMetadata(articleData, versions)\n}\n\nfunction getArticleBlackListByBlockHeight() {\n    return [\n        91092435, 91092174, 91051228, 91092223, 91051203, 98372095, 96414482,\n        96412953, 103131250, 106941548, 103053147, 102530777,\n    ]\n}\n\nfunction getArticleBlackListByArticleId() {\n    return [\n        'blaze.near-1690410074090',\n        'blaze.near-1690409577184',\n        'blaze.near-1690803928696',\n        'blaze.near-1690803872147',\n        'blaze.near-1690574978421',\n        'f2bc8abdb8ba64fe5aac9689ded9491ff0e6fdcd7a5c680b7cf364142d1789fb-1691703303485',\n        'f2bc8abdb8ba64fe5aac9689ded9491ff0e6fdcd7a5c680b7cf364142d1789fb-1691702619510',\n        'f2bc8abdb8ba64fe5aac9689ded9491ff0e6fdcd7a5c680b7cf364142d1789fb-1691702487944',\n        'f2bc8abdb8ba64fe5aac9689ded9491ff0e6fdcd7a5c680b7cf364142d1789fb-1691707918243',\n        'f2bc8abdb8ba64fe5aac9689ded9491ff0e6fdcd7a5c680b7cf364142d1789fb-1691707889297',\n        'blaze.near-1697211386373',\n        'silkking.near-1696797896796',\n        'silkking.near-1696797784589',\n        'silkking.near-1696797350661',\n        'silkking.near-1696797276482',\n        'silkking.near-1696797155012',\n        'silkking.near-1696796793605',\n        'silkking.near-1696796543546',\n        'silkking.near-1696795954175',\n        'silkking.near-1696794571874',\n        'silkking.near-1696792789177',\n        'zarmade.near-1690578803015',\n    ]\n}\n\nfunction filterInvalidArticlesIndexes(articlesData) {\n    return articlesData\n        .filter((articleData) => articleData.value.metadata.id) // Has id\n        .filter((articleData) => {\n            const splittedId = articleData.value.metadata.id.split('-')\n            splittedId.pop()\n\n            return splittedId.join('-') === articleData.accountId\n        }) // id begins with same accountId as index object\n        .filter(\n            (articleData) =>\n                !getArticleBlackListByBlockHeight().includes(\n                    articleData.blockHeight\n                ) // Blockheight is not in blacklist\n        )\n        .filter(\n            (articleData) =>\n                !getArticleBlackListByArticleId().includes(articleData.value.id) // Article id is not in blacklist\n        )\n}\n\nfunction getLatestEdits(articles) {\n    return articles.filter((articleData, index) => {\n        const latestEditForThisArticleIndex = articles.findIndex(\n            (newArticle) =>\n                newArticle.value.metadata.id === articleData.value.metadata.id\n        )\n        return index === latestEditForThisArticleIndex\n    })\n}\n\nfunction applyUserFilters(articles, filters) {\n    const { id, category, authors, tags } = filters\n    if (id) {\n        articles = articles.filter((article) => {\n            return article.value.metadata.id === id\n        })\n    }\n    if (category && category !== 'all_categories') {\n        articles = articles.filter((article) => {\n            return article.value.articleData.category === category\n        })\n    }\n    if (authors && authors.length > 0) {\n        articles = articles.filter((article) => {\n            return authors.includes(article.value.metadata.author)\n        })\n    }\n    if (tags && tags.length > 0) {\n        articles = articles.filter((article) => {\n            return tags.some((tag) =>\n                article.value.articleData.tags.includes(tag)\n            )\n        })\n    }\n    return articles\n}\n\nfunction isActive(article) {\n    return article.value.metadata && !article.value.metadata.isDelete\n}\n\nfunction getArticlesHistoryNormalized(articleId) {\n    const articlesDataPromises = Object.keys(versions).map((version) => {\n        // const action = versions[version].action;\n        const action = getAction(version)\n        const articles = getArticlesIndexes(action, 'main')\n\n        return articles\n    })\n\n    return Promise.all(articlesDataPromises).then((articlesVersionArray) => {\n        const articles = articlesVersionArray.flat()\n        const filteredArticles = applyUserFilters(articles, { id: articleId })\n\n        return filteredArticles\n    })\n}\n\nfunction normalizeArticle(article) {\n    const versionsKeys = Object.keys(versions)\n    const versionIndex = article.versionIndex\n\n    for (let i = versionIndex; i < versionsKeys.length; i++) {\n        const version = versions[versionsKeys[i]]\n        article = version.normalizationFunction(article)\n    }\n    delete article.versionIndex\n\n    return article\n}\n\nfunction getArticlesNormalized(userFilters) {\n    const articlesDataPromises = Object.keys(versions).map(\n        (version, versionIndex) => {\n            // const action = versions[version].action;\n            const action = getAction(version)\n            const articles = getArticlesIndexes(action, 'main').then(\n                (articles) => {\n                    return articles.map((article) => {\n                        article.versionIndex = versionIndex\n                        return article\n                    })\n                }\n            )\n\n            return articles\n        }\n    )\n\n    return Promise.all(articlesDataPromises).then((articlesVersionArray) => {\n        const articles = articlesVersionArray.flat()\n        const normalizedArticles = articles.map((article) =>\n            normalizeArticle(article)\n        )\n        const latestActiveEdits = getLatestEdits(normalizedArticles)\n        const activeArticles = latestActiveEdits.filter(isActive)\n        const filteredArticles = applyUserFilters(activeArticles, userFilters)\n\n        return filteredArticles\n    })\n}\n\nfunction getArticlesIndexes(action, key) {\n    const indexUrl = 'https://api.near.social/index'\n    const articlesPromise = asyncFetch(indexUrl, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n            action,\n            key,\n            options: {\n                order: 'desc',\n            },\n        }),\n    }).then((response) => response.body)\n\n    return articlesPromise\n}\n\nfunction normalizeOldToV_0_0_1(article) {\n    article.realArticleId = `${article.author}-${article.timeCreate}`\n    article.sbts = ['public']\n\n    return article\n}\n\nfunction normalizeFromV0_0_1ToV0_0_2(article) {\n    article.title = article.articleId\n    article.id = article.realArticleId\n    if (article.sbts[0] !== 'public') {\n        article.sbts[0] = article.sbts[0] + ' - class 1'\n    } // There is only one article that is not public and only has class 1\n\n    delete article.articleId\n    delete article.realArticleId\n\n    return article\n}\n\nfunction normalizeFromV0_0_2ToV0_0_3(article) {\n    if (!Array.isArray(article.tags) && typeof article.tags === 'object') {\n        article.tags = Object.keys(article.tags)\n    }\n\n    if (article.tags) {\n        article.tags = article.tags.filter(\n            (tag) => tag !== undefined && tag !== null\n        )\n    } else {\n        article.tags = []\n    }\n\n    //Add day-month-year tag if it doesn't exists yet by request\n    const creationDate = new Date(article.timeCreate)\n\n    const dateTag = `${creationDate.getDate()}-${\n        creationDate.getMonth() + 1\n    }-${creationDate.getFullYear()}`\n\n    if (!article.tags.includes(dateTag)) article.tags.push(dateTag)\n\n    if (article.blockHeight < 105654020 && article.sbts.includes('public')) {\n        article.sbts = ['fractal.i-am-human.near - class 1']\n    }\n\n    return article\n}\n\nfunction normalizeFromV0_0_4ToV0_0_5(article) {\n    if (!isActive(article)) return article\n    article.value.articleData.category = 'uncategorized'\n    return article\n}\n\nfunction normalizeFromV0_0_5ToV0_0_6(article) {\n    // change to normalizeFromV0_0_5ToV0_0_6\n    return article\n}\n\n// EDIT: set versions you want to handle, considering their action to Social.index and the way to transform to one version to another (normalization)\nconst versions = {\n    // old: {\n    //     normalizationFunction: normalizeOldToV_0_0_1,\n    //     actionSuffix: \"\",\n    //     validBlockHeightRange: [0, 102530777],\n    // },\n    'v0.0.1': {\n        normalizationFunction: (article) => article,\n        actionSuffix: `_v0.0.1`,\n        validBlockHeightRange: [0, Infinity],\n    },\n    // \"v0.0.2\": {\n    //     normalizationFunction: normalizeFromV0_0_2ToV0_0_3,\n    //     actionSuffix: `_v0.0.2`,\n    //     validBlockHeightRange: [103053147, Infinity],\n    // },\n    // \"v0.0.3\": {\n    //     normalizationFunction: normalizeFromV0_0_3ToV0_0_4,\n    //     actionSuffix: `_v0.0.3`,\n    //     validBlockHeightRange: [Infinity, Infinity],\n    // },\n    'v0.0.4': {\n        normalizationFunction: normalizeFromV0_0_4ToV0_0_5,\n        actionSuffix: `_v0.0.4`,\n        validBlockHeightRange: [0, 115688831],\n    },\n    'v0.0.5': {\n        normalizationFunction: normalizeFromV0_0_5ToV0_0_6,\n        actionSuffix: `_v0.0.5`,\n        validBlockHeightRange: [115688831, Infinity],\n    },\n}\n\nfunction validateArticleData(article) {\n    const expectedStringProperties = ['title', 'body']\n    const expectedArrayProperties = ['tags']\n    const errArrMessage = []\n    // String properties\n    errArrMessage.push(\n        ...expectedStringProperties\n            .filter((currentProperty) => {\n                const isValidProperty =\n                    !article[currentProperty] ||\n                    typeof article[currentProperty] !== 'string'\n                return isValidProperty\n            })\n            .map(\n                (currentProperty) =>\n                    `Missing ${camelCaseToUserReadable(currentProperty)} or not a string`\n            )\n    )\n    // Array properties\n    errArrMessage.push(\n        ...expectedArrayProperties\n            .filter((currentProperty) => {\n                return !Array.isArray(article[currentProperty])\n            })\n            .map(\n                (currentProperty) =>\n                    `Article ${camelCaseToUserReadable(\n                        currentProperty\n                    )}'s is not an array`\n            )\n    )\n\n    return errArrMessage\n}\n\n/**\n * Only properties that are not set automatically should be validated\n * @param {*} metadata\n */\nfunction validateMetadata(metadata) {\n    const expectedStringProperties = ['id', 'author']\n    const expectedNumberProperties = ['createdTimestamp']\n\n    const errArrMessage = []\n    // String properties\n    errArrMessage.push(\n        ...expectedStringProperties\n            .filter((currentProperty) => {\n                const isValidProperty =\n                    !metadata[currentProperty] ||\n                    typeof metadata[currentProperty] !== 'string'\n                return isValidProperty\n            })\n            .map(\n                (currentProperty) =>\n                    `Missing ${camelCaseToUserReadable(currentProperty)} or not a string`\n            )\n    )\n    // Array properties\n    errArrMessage.push(\n        ...expectedNumberProperties\n            .filter((currentProperty) => {\n                return (\n                    !metadata[currentProperty] ||\n                    typeof metadata[currentProperty] !== 'number'\n                )\n            })\n            .map(\n                (currentProperty) =>\n                    `Property ${camelCaseToUserReadable(\n                        currentProperty\n                    )}'s is not an array`\n            )\n    )\n\n    return errArrMessage\n}\n\nfunction validateNewArticle(articleData) {\n    const errorArray = validateArticleData(articleData)\n    return errorArray\n}\n\nfunction validateEditArticle(articleData, previousMetadata) {\n    const errorArray = validateArticleData(articleData)\n    if (!previousMetadata.id) {\n        errorArray.push(`Trying to edit article with no article id`)\n    }\n    return errorArray\n}\n\nfunction composeData(article) {\n    let data = {\n        index: {\n            [getAction()]: JSON.stringify({\n                key: 'main',\n                value: {\n                    ...article,\n                },\n            }),\n        },\n    }\n\n    if (article.metadata.isDelete) return data\n\n    const mentions = extractMentions(article.articleData.body)\n\n    if (mentions.length > 0) {\n        const dataToAdd = getNotificationData(\n            getConfig(),\n            'mention',\n            mentions,\n            article.metadata\n        )\n\n        data.post = dataToAdd.post\n        data.index.notify = dataToAdd.index.notify\n    }\n\n    return data\n}\n\nfunction composeDeleteData(articleId) {\n    const deleteMetadata = buildDeleteMetadata(articleId)\n    let data = {\n        index: {\n            [getAction()]: JSON.stringify({\n                key: 'main',\n                value: {\n                    metadata: {\n                        ...deleteMetadata,\n                    },\n                },\n            }),\n        },\n    }\n    return data\n}\n\nfunction executeSaveArticle(article, onCommit, onCancel) {\n    const newData = composeData(article)\n    Social.set(newData, {\n        force: true,\n        onCommit,\n        onCancel,\n    })\n}\n\nfunction buildArticle(articleData, userMetadataHelper) {\n    const metadataHelper = {\n        ...userMetadataHelper,\n        idPrefix: 'article',\n        versionKey: currentVersion,\n    }\n    const metadata = generateMetadata(metadataHelper)\n    return {\n        articleData,\n        metadata,\n    }\n}\n\nfunction createArticle(\n    config,\n    articleData,\n    userMetadataHelper,\n    onCommit,\n    onCancel\n) {\n    setConfig(config)\n    const errors = validateNewArticle(articleData)\n    if (errors && errors.length) {\n        return { error: true, data: errors }\n    }\n\n    const article = buildArticle(articleData, userMetadataHelper)\n    const result = executeSaveArticle(\n        article,\n        () => onCommit(article.metadata.id),\n        onCancel\n    )\n    return { error: false, data: result }\n}\n\nfunction editArticle(\n    config,\n    newArticleData,\n    previousMetadata,\n    onCommit,\n    onCancel\n) {\n    setConfig(config)\n    const errors = validateEditArticle(newArticleData, previousMetadata)\n    if (errors && errors.length) {\n        return { error: true, data: errors }\n    }\n\n    const newMetadata = updateMetadata(previousMetadata, currentVersion)\n\n    const article = {\n        articleData: newArticleData,\n        metadata: newMetadata,\n    }\n    const result = executeSaveArticle(article, onCommit, onCancel)\n    return { error: false, data: result }\n}\n\nfunction deleteArticle(config, articleId, onCommit, onCancel) {\n    setConfig(config)\n\n    const deleteMetadata = buildDeleteMetadata(articleId)\n    const article = {\n        metadata: deleteMetadata,\n    }\n    executeSaveArticle(article, onCommit, onCancel)\n}\n\nreturn {\n    createArticle,\n    getArticles,\n    buildArticle,\n    editArticle,\n    deleteArticle,\n    getArticlesIndexes,\n    getLatestEdits,\n    getAction,\n    filterFakeAuthors,\n    getArticleBlackListByArticleId,\n    getArticleBlackListByBlockHeight,\n    getArticlesVersions,\n}\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/chatter.cheddar.near/widget/lib.article", "fact_widget_deployments_id": "8253087087c1cb9afc48d04b98d693ec", "inserted_timestamp": "2024-06-10T18:04:33.237Z", "modified_timestamp": "2024-06-10T18:04:33.237Z", "__row_index": 41}