{"tx_hash": "9cLa6axKEStmGnCZSCPH76mSKjyVFZcCkZAsA8wSQVHb", "action_id_social": "9oQWnDJWArrabyAmnadjG2DqSRN1ErjUuZAY1brQd6XE-0-widget", "block_id": 120922396, "block_timestamp": "2024-06-11T10:23:03.995Z", "signer_id": "chatter.cheddar.near", "widget_name": "lib.comment", "source_code": "const { getFromIndex } = VM.require(\n    'chatter.cheddar.near/widget/lib.socialDbIndex'\n) || { getFromIndex: () => {} }\nconst { normalize, normalizeId } = VM.require(\n    'chatter.cheddar.near/widget/lib.normalization'\n) || { normalize: () => {}, normalizeId: () => {} }\nconst { generateMetadata, updateMetadata, buildDeleteMetadata } = VM.require(\n    'chatter.cheddar.near/widget/lib.metadata'\n) || {\n    generateMetadata: () => {},\n    updateMetadata: () => {},\n    buildDeleteMetadata: () => {},\n}\n\nconst { extractMentions, getNotificationData } = VM.require(\n    'chatter.cheddar.near/widget/lib.notifications'\n) || { extractMentions: () => {}, getNotificationData: () => {} }\n\nlet config = {}\n\nconst currentVersion = 'v0.0.1'\n\nfunction getSplittedCommentIdV0_0_3(commentId) {\n    const commentIdWithoutPrefix = commentId.slice(2)\n    const prefix = 'c-'\n\n    const oldFormatID = prefix + commentIdWithoutPrefix\n\n    const newCommentID = normalizeId(oldFormatID, 'comment')\n\n    const splitCommentId = (newCommentID ?? '').split('/')\n\n    return splitCommentId\n    // }\n}\n\nfunction normalizeOldToV_0_0_1(comment) {\n    return comment\n}\n\nfunction normalizeFromV0_0_1ToV0_0_2(comment) {\n    return comment\n}\n\nfunction normalizeFromV0_0_2ToV0_0_3(comment) {\n    comment.value.comment.rootId = comment.value.comment.originalCommentId\n    delete comment.value.comment.originalCommentId\n    delete comment.value.comment.id\n\n    return comment\n}\n\nfunction normalizeFromV0_0_3ToV0_0_4(comment) {\n    const now = Date.now()\n\n    // const splitCommentId = getSplittedCommentIdV0_0_3(comment.value.metadata.id);\n    const splitCommentId = getSplittedCommentIdV0_0_3(\n        comment.value.comment.commentId\n    )\n\n    comment.value.commentData = { text: comment.value.comment.text }\n    const author = splitCommentId[1]\n    comment.value.metadata = {\n        id: splitCommentId.join('/'),\n        author,\n        createdTimestamp: now,\n        lastEditTimestamp: now,\n        rootId: comment.value.comment.rootId,\n        versionKey: 'v0.0.4',\n    }\n\n    delete comment.value.comment.commentId\n    delete comment.value.comment.rootId\n    delete comment.value.comment.timestamp\n    delete comment.value.comment.text\n    delete comment.value.comment\n    delete comment.isEdition\n\n    return comment\n}\n\nfunction normalizeFromV0_0_4ToV0_0_5(comment) {\n    return comment\n}\n\nconst versions = {\n    // old: {\n    //     normalizationFunction: normalizeOldToV_0_0_1,\n    //     suffixAction: '',\n    // },\n    'v0.0.1': {\n        normalizationFunction: (comment) => comment,\n        suffixAction: `-v0.0.1`,\n    },\n    // 'v0.0.2': {\n    //     normalizationFunction: normalizeFromV0_0_2ToV0_0_3,\n    //     suffixAction: `_v0.0.2`,\n    // },\n    // 'v0.0.3': {\n    //     normalizationFunction: normalizeFromV0_0_3ToV0_0_4,\n    //     suffixAction: `_v0.0.3`,\n    // },\n    // 'v0.0.4': {\n    //     normalizationFunction: normalizeFromV0_0_4ToV0_0_5,\n    //     suffixAction: `_v0.0.4`,\n    // },\n}\n\nfunction setConfig(newConfig) {\n    config = newConfig\n}\n\nfunction getConfig() {\n    return config\n}\n\nfunction fillAction(version, config) {\n    const baseAction = config.baseActions.comment\n    const filledAction = baseAction + version.suffixAction\n    return config.isTest ? `test_${filledAction}` : filledAction\n}\n\nfunction getCommentBlackListByBlockHeight() {\n    return [98588599, 115199907, 115238101]\n}\n\nfunction filterInvalidComments(comments) {\n    return comments\n        .filter(\n            (comment) =>\n                comment.blockHeight &&\n                !getCommentBlackListByBlockHeight().includes(\n                    comment.blockHeight\n                ) // Comment is not in blacklist\n        )\n        .filter((comment) => {\n            return (\n                comment.accountId ===\n                getUserNameFromCommentId(\n                    comment.value.metadata.id ?? comment.value.comment.commentId\n                )\n            )\n        })\n}\n\nfunction getUserNameFromCommentId(commentId) {\n    let userName\n    if (commentId.startsWith('c/') || commentId.startsWith('comment/')) {\n        const splittedCommentId = commentId.split('/')\n        userName = splittedCommentId[1]\n    } else if (commentId.startsWith('c_')) {\n        const userNamePlusTimestamp = commentId.split('c_')[1]\n\n        const splittedUserNamePlusTimestamp = userNamePlusTimestamp.split('-')\n\n        splittedUserNamePlusTimestamp.pop()\n\n        userName = splittedUserNamePlusTimestamp.join('-')\n    }\n\n    return userName\n}\n\nfunction processComments(comments) {\n    const lastEditionComments = comments.filter((comment) => {\n        const firstCommentWithThisCommentId = comments.find((compComment) => {\n            return compComment.value.metadata.id === comment.value.metadata.id\n        })\n\n        return (\n            JSON.stringify(firstCommentWithThisCommentId) ===\n            JSON.stringify(comment)\n        )\n    })\n\n    const lastEditionCommentsWithoutDeletedOnes = lastEditionComments.filter(\n        (comment) => !comment.value.metadata.isDelete\n    )\n\n    const lastEditionCommentsWithEditionMark =\n        lastEditionCommentsWithoutDeletedOnes.map((comment) => {\n            const commentsWithThisCommentId = comments.filter((compComment) => {\n                return (\n                    comment.value.metadata.id ===\n                    compComment.value.metadata.commentId\n                )\n            })\n\n            if (commentsWithThisCommentId.length > 1) {\n                comment.value.metadata.isEdition = true\n            }\n\n            return comment\n        })\n\n    return lastEditionCommentsWithEditionMark\n}\n\nfunction getComments(articleId, config) {\n    setConfig(config)\n    const commentsByVersionPromise = Object.keys(versions).map(\n        (version, index, arr) => {\n            const action = fillAction(versions[version], config)\n\n            return getFromIndex(action, articleId, 'asc').then((comments) => {\n                const validComments = filterInvalidComments(comments)\n\n                const normalizedComments = validComments.map((comment) => {\n                    return normalize(comment, versions, index)\n                })\n\n                return normalizedComments\n            })\n        }\n    )\n\n    return Promise.all(commentsByVersionPromise).then((commentsByVersion) => {\n        return processComments(commentsByVersion.flat())\n    })\n}\n\nfunction getAction(parameterVersion, parameterConfig) {\n    //parameterVersion and parameterCconfig are optative for testing\n    const baseAction =\n        parameterConfig.baseActions.comment ?? getConfig().baseActions.comment\n\n    const versionData = parameterVersion\n        ? versions[parameterVersion]\n        : versions[currentVersion]\n\n    const action = baseAction + versionData.suffixAction\n\n    return parameterConfig.isTest || getConfig().isTest\n        ? `test_${action}`\n        : action\n}\n\nfunction composeCommentData(comment, version, config) {\n    // if (comment.metadata.replyingTo) {\n    //   //We add the following so the user been replied get's a notification\n    //   comment.commentData.text = `@${comment.metadata.replyingTo} ${comment.commentData.text}`;\n    // }\n\n    let data = {\n        index: {\n            [getAction(version, config)]: JSON.stringify({\n                key: comment.metadata.articleId,\n                value: {\n                    type: 'md',\n                    ...comment,\n                },\n            }),\n        },\n    }\n\n    if (comment.metadata.isDelete) return data\n\n    const mentions = comment.commentData.isDelete\n        ? []\n        : extractMentions(comment.commentData.text)\n\n    const articleIdSplitted = comment.metadata.articleId.split('/')\n    const articleAuthor = articleIdSplitted[1]\n\n    const dataToAdd = getNotificationData(\n        getConfig(),\n        mentions.length > 0 ? 'mentionOnComment' : 'comment',\n        mentions,\n        comment.metadata,\n        { author: articleAuthor }\n    )\n\n    data.post = dataToAdd.post\n    data.index.notify = dataToAdd.index.notify\n\n    return data\n}\n\nfunction executeSaveComment(\n    comment,\n    onCommit,\n    onCancel,\n    parameterVersion,\n    parameterConfig\n) {\n    //parameterVersion and parameterConfig are optative for testing\n    const newData = composeCommentData(\n        comment,\n        parameterVersion ?? currentVersion,\n        parameterConfig ?? config\n    )\n\n    Social.set(newData, {\n        force: true,\n        onCommit,\n        onCancel,\n    })\n\n    return comment.metadata.id\n}\n\nfunction createComment(props) {\n    const {\n        config,\n        author,\n        commentText,\n        replyingTo,\n        articleId,\n        onCommit,\n        onCancel,\n    } = props\n\n    setConfig(config)\n\n    const metadataHelper = {\n        author,\n        idPrefix: 'comment',\n        versionKey: currentVersion,\n    }\n\n    let metadata = generateMetadata(metadataHelper)\n    metadata.articleId = articleId\n    metadata.rootId = replyingTo\n\n    const comment = {\n        commentData: { text: commentText },\n        metadata,\n    }\n\n    const result = executeSaveComment(comment, onCommit, onCancel)\n\n    return { error: !result, data: result }\n}\n\nfunction editComment(props) {\n    const { config, comment, onCommit, onCancel } = props\n\n    setConfig(config)\n\n    //TODO ask Dani abaut the second parameter in this case\n    // let metadata = updateMetadata(comment.metadata, currentVersion);\n    let metadata = updateMetadata(comment.value.metadata, currentVersion)\n    metadata.isEdition = true\n\n    //===========================================================================================================================================================================\n    // interface comment {\n    //   commentData: {text: string},\n    //   metadata\n    // }\n    //===========================================================================================================================================================================\n\n    const newComment = {\n        commentData: { text: comment.value.commentData.text },\n        metadata,\n    }\n\n    const result = executeSaveComment(newComment, onCommit, onCancel)\n\n    return { error: !result, data: result }\n}\n\nfunction deleteComment(props) {\n    const { config, commentId, articleId, rootId, onCommit, onCancel } = props\n\n    setConfig(config)\n\n    let metadata = buildDeleteMetadata(commentId)\n    metadata.articleId = articleId\n    metadata.rootId = rootId\n\n    const comment = {\n        metadata,\n    }\n\n    const result = executeSaveComment(comment, onCommit, onCancel)\n\n    return { error: !result, data: result }\n}\n\nreturn {\n    getComments,\n    createComment,\n    editComment,\n    deleteComment,\n    functionsToTest: {\n        normalizeOldToV_0_0_1,\n        normalizeFromV0_0_1ToV0_0_2,\n        normalizeFromV0_0_2ToV0_0_3,\n        normalizeFromV0_0_3ToV0_0_4,\n        setConfig,\n        getConfig,\n        fillAction,\n        getCommentBlackListByBlockHeight,\n        filterInvalidComments,\n        getUserNameFromCommentId,\n        processComments,\n        getComments,\n        getSplittedCommentIdV0_0_3,\n        composeCommentData,\n        createComment,\n        editComment,\n        deleteComment,\n    },\n}\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/chatter.cheddar.near/widget/lib.comment", "fact_widget_deployments_id": "38f963c852d1fa31b0dbe31f49c73e94", "inserted_timestamp": "2024-06-11T11:04:37.842Z", "modified_timestamp": "2024-06-11T12:05:37.054Z", "__row_index": 32}