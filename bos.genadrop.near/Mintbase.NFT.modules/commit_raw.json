{"tx_hash": "Forw1kFiJXLQ8QCV3Auz1BWebS8RoG54BAfbPkiuaXkN", "action_id_social": "6isi7W8Aucq6hAP4C19cfgKp9SnA9qPaL58ZfyMdq3hY-0-widget", "block_id": 116899127, "block_timestamp": "2024-04-15T13:36:44.027Z", "signer_id": "bos.genadrop.near", "widget_name": "Mintbase.NFT.modules", "source_code": "const LISTING_DEPOSIT = `1000${\"0\".repeat(18)}`;\nconst GAS = \"200000000000000\";\n\nconst MARKET_CONTRACT_ADDRESS = {\n  mainnet: \"simple.market.mintbase1.near\",\n  testnet: \"market-v2-beta.mintspace2.testnet\",\n};\n\nconst USDC_ADDRESS = {\n  mainnet: \"a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48.factory.bridge.near\",\n  testnet: \"usdc.fakes.testnet\",\n};\n\nconst USDT_ADDRESS = {\n  mainnet: \"dac17f958d2ee523a2206206994597c13d831ec7.factory.bridge.near\",\n  testnet: \"usdt.fakes.testnet\",\n};\n\nconst ftContracts = {\n  usdt: USDT_ADDRESS,\n  usdc: USDC_ADDRESS,\n};\n\nconst _price = (price) =>\n  Number(Number(new Big(price).mul(new Big(10).pow(24)).toString()))\n    .toLocaleString()\n    .replace(/,/g, \"\");\n\n/**\n * The function `nftTransfer` transfers an NFT with a specified token ID to a specified account ID\n * using a specified contract name.\n * @returns The function `nftTransfer` is returning the result of calling the `Near.call` function with\n * a specific configuration object as an argument. The configuration object includes the contract name,\n * method name, arguments (token_id and receiver_id), and deposit amount. The function is attempting to\n * transfer an NFT (Non-Fungible Token) with the specified token ID to the specified account ID using\n * the given\n */\nconst nftTransfer = (tokenId, accountIds, contractName) => {\n  const deposit = 1;\n  if (typeof accountIds !== \"string\") {\n    return Near.call([\n      {\n        contractName,\n        methodName: \"nft_batch_transfer\",\n        args: {\n          token_ids: accountIds,\n        },\n        deposit,\n        gas: GAS,\n      },\n    ]);\n  }\n  try {\n    return Near.call([\n      {\n        contractName,\n        methodName: \"nft_transfer\",\n        args: {\n          token_id: tokenId,\n          receiver_id: accountIds,\n        },\n        deposit,\n      },\n    ]);\n  } catch (err) {\n    console.log(err);\n  }\n};\n\n/**\n * The function `listNFT` lists NFTs for sale on a marketplace contract, handling different scenarios\n * based on parameters such as contract address, token IDs, price, and fungible token.\n * @returns The `listNFT` function returns the result of calling the `Near.call` function with an array\n * of objects containing contract information for depositing storage and listing NFTs. If an error\n * occurs during the process, the function catches the error and logs it to the console.\n */\nconst listNFT = (contractAddress, tokenIds, mainnet, price, ft) => {\n  if (!contractAddress) return;\n  if (tokenIds.length < 1) return;\n  const gas = 2e14;\n  const storageDeposit = 1e22;\n  const msg = { price: _price(price) };\n\n  if (ft) {\n    const ftContractId = ftContracts[ft].mainnet;\n    msg.ft_contract = ftContractId;\n    msg.price = Number(price) * 1000000;\n  }\n\n  const ids = tokenIds.map((data) => ({\n    contractName: contractAddress,\n    args: {\n      token_id: data,\n      account_id: mainnet\n        ? MARKET_CONTRACT_ADDRESS.mainnet\n        : MARKET_CONTRACT_ADDRESS.testnet,\n      msg: JSON.stringify(msg),\n    },\n    methodName: \"nft_approve\",\n    deposit: LISTING_DEPOSIT,\n    gas: GAS,\n  }));\n  try {\n    return Near.call([\n      {\n        contractName: mainnet\n          ? MARKET_CONTRACT_ADDRESS.mainnet\n          : MARKET_CONTRACT_ADDRESS.testnet,\n        methodName: \"deposit_storage\",\n        args: {},\n        gas: gas,\n        deposit: storageDeposit,\n      },\n      ...ids,\n    ]);\n  } catch (error) {\n    console.log(error);\n  }\n};\n\n/**\n * The `delist` function takes a contract address, an array of token IDs, a boolean flag for mainnet,\n * and an old market object, then constructs and executes a series of unlist operations using the Near\n * protocol.\n * @returns The `delist` function returns the result of calling the `Near.call` function with an array\n * of objects representing token IDs to be delisted from a market contract.\n */\nconst delist = (contractAddress, tokenIds, mainnet, oldMarket) => {\n  if (!tokenIds.length) return;\n  const ids = tokenIds.map((data) => ({\n    contractName: mainnet\n      ? MARKET_CONTRACT_ADDRESS.mainnet\n      : MARKET_CONTRACT_ADDRESS.testnet,\n    methodName: \"unlist\",\n    gas: GAS,\n    deposit: `1`,\n    args: {\n      token_ids: [data],\n      nft_contract_id: contractAddress,\n    },\n  }));\n  try {\n    return Near.call([...ids]);\n  } catch (error) {\n    console.log(error);\n  }\n};\n\n/**\n * The function `burnNFT` is used to batch burn NFTs by calling the `nft_batch_burn` method on a\n * specified contract address with given token IDs.\n * @returns The `burnNFT` function is returning the result of calling the `Near.call` function with the\n * specified parameters. The `Near.call` function is making a contract call to the specified\n * `contractAddress` with the method name \"nft_batch_burn\" and passing the `tokenIds` as arguments. The\n * function is also specifying gas and deposit values for the contract call. If the contract\n */\nconst burnNFT = (contractAddress, tokenIds, mainnet) => {\n  if (!tokenIds.length) return;\n\n  try {\n    return Near.call([\n      {\n        contractName: contractAddress,\n        methodName: \"nft_batch_burn\",\n        gas: GAS,\n        deposit: `1`,\n        args: {\n          token_ids: tokenIds,\n        },\n      },\n    ]);\n  } catch (error) {\n    console.log(error);\n  }\n};\n\nconst multiplyNFT = (\n  contractAddress,\n  ownerId,\n  reference,\n  media,\n  numberToMint\n) => {\n  try {\n    return Near.call([\n      {\n        contractName: contractAddress,\n        methodName: \"nft_batch_mint\",\n        gas: GAS,\n        deposit: `1`,\n        args: {\n          owner_id: ownerId,\n          metadata: {\n            reference: reference,\n            media: media,\n          },\n          num_to_mint: numberToMint,\n          royalty_args: null,\n          token_ids_to_mint: null,\n          split_owners: null,\n        },\n      },\n    ]);\n  } catch (error) {\n    console.log(error);\n  }\n};\n\nreturn {\n  nftTransfer,\n  listNFT,\n  delist,\n  burnNFT,\n  multiplyNFT,\n};\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/bos.genadrop.near/widget/Mintbase.NFT.modules", "fact_widget_deployments_id": "dbc58a8b2b48e8c0ea52b44c362190df", "inserted_timestamp": "2024-04-15T15:41:57.750Z", "modified_timestamp": "2024-04-15T15:41:57.750Z", "__row_index": 0}