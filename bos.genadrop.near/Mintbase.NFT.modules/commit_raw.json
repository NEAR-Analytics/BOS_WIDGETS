{"tx_hash": "6XwzW8JtXz7vHaVYMdWCu9Bz4zTpzc4QRopoTXcvRQpd", "action_id_social": "ERz7kvoLAxZL5q8UXVjxksujfp6EBVSFx3W5h9tQAPiz-0-widget", "block_id": 121953568, "block_timestamp": "2024-06-25T08:33:55.326Z", "signer_id": "bos.genadrop.near", "widget_name": "Mintbase.NFT.modules", "source_code": "const LISTING_DEPOSIT = `1000${\"0\".repeat(18)}`;\nconst GAS = \"200000000000000\";\nconst MAX_GAS = \"300000000000000\";\nconst MARKET_CONTRACT_ADDRESS = {\n  mainnet: \"simple.market.mintbase1.near\",\n  testnet: \"market-v2-beta.mintspace2.testnet\",\n};\nconst USDC_ADDRESS = {\n  mainnet: \"a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48.factory.bridge.near\",\n  testnet: \"usdc.fakes.testnet\",\n};\nconst USDT_ADDRESS = {\n  mainnet: \"dac17f958d2ee523a2206206994597c13d831ec7.factory.bridge.near\",\n  testnet: \"usdt.fakes.testnet\",\n};\nconst ftContracts = {\n  usdt: USDT_ADDRESS,\n  usdc: USDC_ADDRESS,\n};\nconst _price = (price) =>\n  Number(Number(new Big(price).mul(new Big(10).pow(24)).toString()))\n    .toLocaleString()\n    .replace(/,/g, \"\");\nconst nftTransfer = (tokenId, accountIds, contractName) => {\n  const deposit = 1;\n  if (typeof accountIds !== \"string\") {\n    return Near.call([\n      {\n        contractName,\n        methodName: \"nft_batch_transfer\",\n        args: {\n          token_ids: accountIds,\n        },\n        deposit,\n        gas: GAS,\n      },\n    ]);\n  }\n  try {\n    return Near.call([\n      {\n        contractName,\n        methodName: \"nft_transfer\",\n        args: {\n          token_id: tokenId,\n          receiver_id: accountIds,\n        },\n        deposit,\n      },\n    ]);\n  } catch (err) {\n    console.log(err);\n  }\n};\n// a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48.factory.bridge.near\nconst listNFT = (contractAddress, tokenIds, mainnet, price, listAmount, ft) => {\n  const storageDeposit = listAmount * 1e22;\n  if (!contractAddress) return;\n  if (tokenIds.length < 1) return;\n  const gas = 2.25e14;\n  // const storageDeposit = 1e22;\n  let msg = { price: _price(price) };\n  let optionalDeposit = [];\n  if (ft) {\n    const ftContractId = ftContracts[ft].mainnet;\n    msg.ft_contract = ftContractId;\n    msg.price = `${Number(price) * 1000000}`;\n    // Extra Deposit\n    optionalDeposit.push({\n      contractName: ftContracts[ft].mainnet,\n      methodName: \"storage_deposit\",\n      args: {\n        registration_only: true,\n      },\n      gas: gas,\n      deposit: `1250${\"0\".repeat(18)}`,\n    });\n  }\n  const ids = tokenIds.slice(0, listAmount).map((data) => ({\n    contractName: contractAddress,\n    args: {\n      token_id: data,\n      account_id: mainnet\n        ? MARKET_CONTRACT_ADDRESS.mainnet\n        : MARKET_CONTRACT_ADDRESS.testnet,\n      msg: JSON.stringify(msg),\n    },\n    methodName: \"nft_approve\",\n    deposit: listAmount > 1 ? `9300${\"0\".repeat(18)}` : LISTING_DEPOSIT,\n    gas: GAS,\n  }));\n  try {\n    return Near.call([\n      {\n        contractName: mainnet\n          ? MARKET_CONTRACT_ADDRESS.mainnet\n          : MARKET_CONTRACT_ADDRESS.testnet,\n        methodName: \"deposit_storage\",\n        args: {\n          autotransfer: true,\n        },\n        gas: gas,\n        deposit: storageDeposit.toString(),\n      },\n      ...optionalDeposit,\n      ...ids,\n    ]);\n  } catch (error) {\n    console.log(error);\n  }\n};\nconst delist = (contractAddress, tokenIds, mainnet, oldMarket) => {\n  if (!tokenIds.length) return;\n  const ids = tokenIds.map((data) => ({\n    contractName: mainnet\n      ? MARKET_CONTRACT_ADDRESS.mainnet\n      : MARKET_CONTRACT_ADDRESS.testnet,\n    methodName: \"unlist\",\n    gas: GAS,\n    deposit: `1`,\n    args: {\n      token_ids: [data],\n      nft_contract_id: contractAddress,\n    },\n  }));\n  try {\n    return Near.call([...ids]);\n  } catch (error) {\n    console.log(error);\n  }\n};\nconst burnNFT = (contractAddress, tokenIds, mainnet) => {\n  if (!tokenIds.length) return;\n  try {\n    return Near.call([\n      {\n        contractName: contractAddress,\n        methodName: \"nft_batch_burn\",\n        gas: GAS,\n        deposit: `1`,\n        args: {\n          token_ids: tokenIds,\n        },\n      },\n    ]);\n  } catch (error) {\n    console.log(error);\n  }\n};\nfunction mintingDeposit({ nTokens, nRoyalties, nSplits, metadata }) {\n  const nSplitsAdj = nSplits < 1 ? 0 : nSplits - 1;\n  const bytesPerToken = 440 + nSplitsAdj * 80 + 80;\n  const metadataBytesEstimate = JSON.stringify(metadata).length;\n  const totalBytes =\n    92 +\n    100 +\n    metadataBytesEstimate +\n    bytesPerToken * nTokens +\n    80 * nRoyalties;\n  return `${Math.ceil(totalBytes)}${\"0\".repeat(19)}`;\n}\nconst buyToken = (contractId, tokenId, price, mainnet, ftAddress) => {\n  if (ftAddress !== \"near\") {\n    //  WORK IN PROGRESS\n    return Near.call([\n      {\n        contractName: ftAddress.substring(4),\n        methodName: \"ft_transfer_call\",\n        args: {\n          amount: `${price}`,\n          receiver_id: mainnet\n            ? MARKET_CONTRACT_ADDRESS.mainnet\n            : MARKET_CONTRACT_ADDRESS.testnet,\n          msg: JSON.stringify({\n            nft_contract_id: contractId,\n            token_id: tokenId,\n          }),\n        },\n        gas: MAX_GAS,\n        deposit: \"1\",\n      },\n    ]);\n  }\n  return Near.call([\n    {\n      contractName: mainnet\n        ? MARKET_CONTRACT_ADDRESS.mainnet\n        : MARKET_CONTRACT_ADDRESS.testnet,\n      methodName: \"buy\",\n      args: {\n        nft_contract_id: contractId,\n        token_id: tokenId,\n        referrer_id: null,\n      },\n      gas: MAX_GAS,\n      deposit: price,\n    },\n  ]);\n};\nconst buyFTToken = (contractAddress, contractId, tokenId, price) => {\n  return Near.call([{}]);\n};\nconst multiplyNFT = (\n  contractAddress,\n  ownerId,\n  reference,\n  media,\n  numberToMint\n) => {\n  try {\n    return Near.call([\n      {\n        contractName: contractAddress,\n        methodName: \"nft_batch_mint\",\n        gas: GAS,\n        deposit: mintingDeposit({\n          nSplits: 0,\n          nTokens: numberToMint,\n          nRoyalties: 0,\n          metadata: {\n            reference: reference,\n            media: media,\n          },\n        }),\n        args: {\n          owner_id: ownerId,\n          metadata: {\n            reference: reference,\n            media: media,\n          },\n          num_to_mint: numberToMint,\n          royalty_args: null,\n          token_ids_to_mint: null,\n          split_owners: null,\n        },\n      },\n    ]);\n  } catch (error) {\n    console.log(error);\n  }\n};\nreturn {\n  nftTransfer,\n  listNFT,\n  buyToken,\n  delist,\n  burnNFT,\n  multiplyNFT,\n};\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/bos.genadrop.near/widget/Mintbase.NFT.modules", "fact_widget_deployments_id": "334e4e6108e03d0b991674ce926104cc", "inserted_timestamp": "2024-06-25T09:54:32.359Z", "modified_timestamp": "2024-06-25T09:54:32.359Z", "__row_index": 1}