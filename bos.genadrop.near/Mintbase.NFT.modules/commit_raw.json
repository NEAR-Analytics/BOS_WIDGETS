{"tx_hash": "AaW8pS7sza7xHL5SGM2sFMfGRLW8SkiKtvGfMgR6oDR4", "action_id_social": "FVzQM911kY9Ec5M3cqFW7LXwBTSqwRS7nkcR5N5t295B-0-widget", "block_id": 120887209, "block_timestamp": "2024-06-10T23:09:19.449Z", "signer_id": "bos.genadrop.near", "widget_name": "Mintbase.NFT.modules", "source_code": "const LISTING_DEPOSIT = `1000${\"0\".repeat(18)}`;\nconst GAS = \"200000000000000\";\nconst MARKET_CONTRACT_ADDRESS = {\n  mainnet: \"simple.market.mintbase1.near\",\n  testnet: \"market-v2-beta.mintspace2.testnet\",\n};\nconst USDC_ADDRESS = {\n  mainnet: \"a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48.factory.bridge.near\",\n  testnet: \"usdc.fakes.testnet\",\n};\nconst USDT_ADDRESS = {\n  mainnet: \"dac17f958d2ee523a2206206994597c13d831ec7.factory.bridge.near\",\n  testnet: \"usdt.fakes.testnet\",\n};\nconst ftContracts = {\n  usdt: USDT_ADDRESS,\n  usdc: USDC_ADDRESS,\n};\nconst _price = (price) =>\n  Number(Number(new Big(price).mul(new Big(10).pow(24)).toString()))\n    .toLocaleString()\n    .replace(/,/g, \"\");\nconst nftTransfer = (tokenId, accountIds, contractName) => {\n  const deposit = 1;\n  if (typeof accountIds !== \"string\") {\n    return Near.call([\n      {\n        contractName,\n        methodName: \"nft_batch_transfer\",\n        args: {\n          token_ids: accountIds,\n        },\n        deposit,\n        gas: GAS,\n      },\n    ]);\n  }\n  try {\n    return Near.call([\n      {\n        contractName,\n        methodName: \"nft_transfer\",\n        args: {\n          token_id: tokenId,\n          receiver_id: accountIds,\n        },\n        deposit,\n      },\n    ]);\n  } catch (err) {\n    console.log(err);\n  }\n};\nconst listNFT = (contractAddress, tokenIds, mainnet, price, listAmount, ft) => {\n  if (!contractAddress) return;\n  if (tokenIds.length < 1) return;\n  const gas = 2e14;\n  const storageDeposit = 1e22;\n  const msg = { price: _price(price) };\n  if (ft) {\n    const ftContractId = ftContracts[ft].mainnet;\n    msg.ft_contract = ftContractId;\n    msg.price = Number(price) * 1000000;\n  }\n  const ids = tokenIds.slice(0, listAmount).map((data) => ({\n    contractName: contractAddress,\n    args: {\n      token_id: data,\n      account_id: mainnet\n        ? MARKET_CONTRACT_ADDRESS.mainnet\n        : MARKET_CONTRACT_ADDRESS.testnet,\n      msg: JSON.stringify(msg),\n    },\n    methodName: \"nft_approve\",\n    deposit: LISTING_DEPOSIT,\n    gas: GAS,\n  }));\n  try {\n    return Near.call([\n      {\n        contractName: mainnet\n          ? MARKET_CONTRACT_ADDRESS.mainnet\n          : MARKET_CONTRACT_ADDRESS.testnet,\n        methodName: \"deposit_storage\",\n        args: {},\n        gas: gas,\n        deposit: storageDeposit,\n      },\n      ...ids,\n    ]);\n  } catch (error) {\n    console.log(error);\n  }\n};\nconst delist = (contractAddress, tokenIds, mainnet, oldMarket) => {\n  if (!tokenIds.length) return;\n  const ids = tokenIds.map((data) => ({\n    contractName: mainnet\n      ? MARKET_CONTRACT_ADDRESS.mainnet\n      : MARKET_CONTRACT_ADDRESS.testnet,\n    methodName: \"unlist\",\n    gas: GAS,\n    deposit: `1`,\n    args: {\n      token_ids: [data],\n      nft_contract_id: contractAddress,\n    },\n  }));\n  try {\n    return Near.call([...ids]);\n  } catch (error) {\n    console.log(error);\n  }\n};\nconst burnNFT = (contractAddress, tokenIds, mainnet) => {\n  if (!tokenIds.length) return;\n  try {\n    return Near.call([\n      {\n        contractName: contractAddress,\n        methodName: \"nft_batch_burn\",\n        gas: GAS,\n        deposit: `1`,\n        args: {\n          token_ids: tokenIds,\n        },\n      },\n    ]);\n  } catch (error) {\n    console.log(error);\n  }\n};\nfunction mintingDeposit({ nTokens, nRoyalties, nSplits, metadata }) {\n  const nSplitsAdj = nSplits < 1 ? 0 : nSplits - 1;\n  const bytesPerToken = 440 + nSplitsAdj * 80 + 80;\n  const metadataBytesEstimate = JSON.stringify(metadata).length;\n  const totalBytes =\n    92 +\n    100 +\n    metadataBytesEstimate +\n    bytesPerToken * nTokens +\n    80 * nRoyalties;\n  return `${Math.ceil(totalBytes)}${\"0\".repeat(19)}`;\n}\nconst multiplyNFT = (\n  contractAddress,\n  ownerId,\n  reference,\n  media,\n  numberToMint\n) => {\n  try {\n    return Near.call([\n      {\n        contractName: contractAddress,\n        methodName: \"nft_batch_mint\",\n        gas: GAS,\n        deposit: mintingDeposit({\n          nSplits: 0,\n          nTokens: numberToMint,\n          nRoyalties: 0,\n          metadata: {\n            reference: reference,\n            media: media,\n          },\n        }),\n        args: {\n          owner_id: ownerId,\n          metadata: {\n            reference: reference,\n            media: media,\n          },\n          num_to_mint: numberToMint,\n          royalty_args: null,\n          token_ids_to_mint: null,\n          split_owners: null,\n        },\n      },\n    ]);\n  } catch (error) {\n    console.log(error);\n  }\n};\n// const buyNft = (contractAddress, ownerId, reference, media, numberToMint) => {};\nreturn {\n  nftTransfer,\n  listNFT,\n  delist,\n  burnNFT,\n  multiplyNFT,\n};\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/bos.genadrop.near/widget/Mintbase.NFT.modules", "fact_widget_deployments_id": "a9a3d68c4796094559605f7c83f0a705", "inserted_timestamp": "2024-06-11T00:06:35.913Z", "modified_timestamp": "2024-06-11T01:30:40.584Z", "__row_index": 2}