{"tx_hash": "3t96h1uYoHMgn9jc9n47EQtz6gnVTfEGqNifEKEfXyoR", "action_id_social": "CBzRbo8PRnMDbtczsKnmXbVqYW4FD4G4VnDGjaUKJT8z-0-widget", "block_id": 117657323, "block_timestamp": "2024-04-26T10:09:01.207Z", "signer_id": "bos.genadrop.near", "widget_name": "Mintbase.SDK", "source_code": "let { onLoad, onRefresh, loaded } = props;\nconst spec = \"nft-1.0.0\";\nconst base_uri = \"https://arweave.net\";\nconst isSignedin = !!context.accountId;\n// const marketAddress = \"simple.market.mintbase1.near\";\nconst _price = (price) =>\n  Number(Number(new Big(price).mul(new Big(10).pow(24)).toString()))\n    .toLocaleString()\n    .replace(/,/g, \"\");\nlet MintbaseSDK = {\n  initialized: false,\n  mainnet: props.mainnet ? true : false,\n  factoryAddress: MintbaseSDK.mainnet ? \"mintbase1.near\" : \"mintspace2.testnet\",\n  contractName: props.contractName || \"\",\n  marketAddress: MintbaseSDK.mainnet\n    ? \"simple.market.mintbase1.near\"\n    : \"market-v2-beta.mintspace2.testnet\",\n  owner_id: context.accountId,\n  mbGraphEndpoin: `https://graph.mintbase.xyz`,\n  init: () => {\n    MintbaseSDK.initialized = true;\n    MintbaseSDK.refresh();\n  },\n  refresh: () => {\n    if (onRefresh) {\n      onRefresh(MintbaseSDK);\n    }\n  },\n  ipfsUrl: (cid) => `https://ipfs.near.social/ipfs/${cid}`,\n  getTokenById: (contractName, tokenId) => {\n    if (!contractName || !tokenId)\n      return console.log(\"missing contract name or token id\");\n    const res = asyncFetch(MintbaseSDK.mbGraphEndpoin, {\n      method: \"POST\",\n      headers: {\n        \"mb-api-key\": \"anon\",\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        query: `\n        query GetTokenById(\n          $tokenId: String!\n          $contractAddress: String!\n        ) {\n          mb_views_nft_tokens(\n            where: {\n              nft_contract_id: { _eq: $contractAddress }\n              token_id: { _eq: $tokenId }\n            }\n            limit: 1\n          ) {\n            baseUri: base_uri\n            burned_receipt_id\n            burned_timestamp\n            copies\n            description\n            expires_at\n            issued_at\n            last_transfer_receipt_id\n            last_transfer_timestamp\n            media\n            minter\n            media_hash\n            mint_memo\n            nft_contract_is_mintbase\n            minted_receipt_id\n            minted_timestamp\n            metadata_id\n            document: reference_blob(path: \"$.document\")\n            animationUrl: reference_blob(path: \"$.animation_url\")\n            extra: reference_blob(path: \"$.extra\")\n            reference\n            reference_hash\n            starts_at\n            title\n            updated_at\n            owner\n            royalties\n            royalties_percent\n            token_id\n          }\n      \n          mb_views_active_listings_aggregate(\n            where: {\n              token_id: { _eq: $tokenId }\n              kind: { _eq: \"auction\" }\n              nft_contract_id: { _eq: $contractAddress }\n            }\n          ) {\n            aggregate {\n              count\n            }\n          }\n        }\n        `,\n        variables: {\n          tokenId: tokenId,\n          contractAddress: contractName || MintbaseSDK.contractName,\n        },\n      }),\n    });\n    return res;\n  },\n  getStoreNfts: (contractName) => {\n    if (!contractName) return console.log(\"missing contract name\");\n    try {\n      const response = asyncFetch(MintbaseSDK.mbGraphEndpoin, {\n        method: \"POST\",\n        headers: {\n          \"mb-api-key\": \"anon\",\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          query: `query GetStoreNfts( \n          $offset: Int = 0 $condition: mb_views_nft_metadata_unburned_bool_exp ) \n          @cached \n          { mb_views_nft_metadata_unburned( where: $condition \n            offset: $offset order_by: { minted_timestamp: desc } ) \n           { createdAt: minted_timestamp \n             listed: price \n             media \n             storeId: nft_contract_id \n             metadataId: metadata_id \n             title base_uri \n           } \n          mb_views_nft_metadata_unburned_aggregate(where: $condition) \n          { \n            aggregate { \n              count \n            } \n           } \n         }\n      `,\n          variables: {\n            condition: {\n              nft_contract_id: {\n                _in: contractName || MintbaseSDK.contractName,\n              },\n            },\n          },\n        }),\n      });\n      return response;\n    } catch (err) {\n      console.log(err);\n    }\n  },\n  getOwnedNFTs: (owner) => {\n    if (!owner) return console.log(\"missing owner address\");\n    try {\n      const response = asyncFetch(MintbaseSDK.mbGraphEndpoin, {\n        method: \"POST\",\n        headers: {\n          \"mb-api-key\": \"anon\",\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          query: `query MyQuery($owner: String!) {\n                  mb_views_nft_tokens(\n                    where: {owner: {_eq: $owner}, _and: {burned_timestamp: {}, last_transfer_timestamp: {}}}\n                    limit: 30\n                    order_by: {minted_timestamp: asc}\n                  ) {\n                    nft_contract_id\n                    title\n                    description\n                    media\n                    last_transfer_receipt_id\n                  }\n                }`,\n          variables: {\n            owner: owner || MintbaseSDK.owner_id,\n          },\n        }),\n      });\n      return response;\n    } catch (err) {\n      console.log(err);\n    }\n  },\n  deployStore: (storeName, symbol_name, reference, referenceHash) => {\n    const gas = 2e14;\n    const deposit = 65e23;\n    if (!isSignedin) return console.log(\"sign in first\");\n    if (!storeName || !symbol_name) {\n      return console.log(\"missing store name or symbol\");\n    }\n    try {\n      return Near.call([\n        {\n          contractName: MintbaseSDK.factoryAddress,\n          methodName: \"create_store\",\n          args: {\n            owner_id: MintbaseSDK.owner_id,\n            metadata: {\n              name: storeName,\n              spec: spec,\n              symbol: symbol_name,\n              base_uri,\n              ...(reference && { reference }),\n              ...(referenceHash && { reference_hash: referenceHash }),\n            },\n          },\n          deposit: deposit,\n          gas: gas,\n        },\n      ]);\n    } catch (err) {\n      console.log(err);\n    }\n  },\n  mint: (tokenMetadata, media, contractName, numToMint) => {\n    if (!isSignedin) return console.log(\"sign in first\");\n    if (!media) return console.log(\"missing file\");\n    asyncFetch(\"https://ipfs.near.social/add\", {\n      method: \"POST\",\n      headers: {\n        Accept: \"application/json\",\n      },\n      body: media,\n    })\n      .then((res) => {\n        const cid = res.body.cid;\n        const gas = 2e14;\n        return Near.call([\n          {\n            contractName: contractName || MintbaseSDK.contractName,\n            methodName: \"nft_batch_mint\",\n            args: {\n              owner_id: MintbaseSDK.owner_id,\n              metadata: {\n                media: MintbaseSDK.ipfsUrl(cid),\n                ...tokenMetadata,\n              },\n              num_to_mint: numToMint || 1,\n              royalty_args: {\n                split_between: {\n                  [MintbaseSDK.owner_id]: 10000,\n                },\n                percentage: 1000,\n              },\n              split_owners: null,\n            },\n            gas: gas,\n            deposit: 1e22,\n          },\n        ]);\n      })\n      .catch((err) => console.log(err));\n  },\n  nftBurn: (tokenIds, contractName) => {\n    if (!isSignedin) return console.log(\"sign in first\");\n    if (!tokenIds.length) return console.log(\"missing token ids\");\n    const gas = 2e14;\n    const deposit = 1;\n    try {\n      return Near.call([\n        {\n          contractName: contractName || MintbaseSDK.contractName,\n          methodName: \"nft_batch_burn\",\n          args: {\n            token_ids: tokenIds,\n          },\n          gas,\n          deposit,\n        },\n      ]);\n    } catch (err) {\n      console.log(err);\n    }\n  },\n  nftTransfer: (tokenId, accountId, contractName) => {\n    if (!isSignedin) return console.log(\"sign in first\");\n    if (!tokenId || !accountId)\n      return console.log(\"token id or receiver address is missing\");\n    const deposit = 1;\n    try {\n      return Near.call([\n        {\n          contractName: contractName || MintbaseSDK.contractName,\n          methodName: \"nft_transfer\",\n          args: {\n            token_id: tokenId,\n            receiver_id: accountId,\n          },\n          deposit,\n        },\n      ]);\n    } catch (err) {\n      console.log(err);\n    }\n  },\n  nftApprove: (tokenId, contractName, price) => {\n    if (!isSignedin) return console.log(\"sign in first\");\n    if (!tokenId || !price > 0)\n      return console.log(\"token id or price is missing\");\n    const gas = 2e14;\n    const storageDeposit = 1e22;\n    return Near.call([\n      {\n        contractName: MintbaseSDK.marketAddress,\n        methodName: \"deposit_storage\",\n        args: {},\n        gas: gas,\n        deposit: storageDeposit,\n      },\n      {\n        methodName: \"nft_approve\",\n        contractName: contractName || MintbaseSDK.contractName,\n        gas: gas,\n        args: {\n          token_id: tokenId,\n          account_id: MintbaseSDK.marketAddress,\n          msg: JSON.stringify({\n            price: _price(price),\n          }),\n        },\n        deposit: 8e22,\n      },\n    ]);\n  },\n};\nif (onLoad && !loaded) {\n  MintbaseSDK.init();\n  onLoad(MintbaseSDK);\n}\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/bos.genadrop.near/widget/Mintbase.SDK", "fact_widget_deployments_id": "af133f52a7d09ef814f7dcd104f448a0", "inserted_timestamp": "2024-04-26T11:43:20.585Z", "modified_timestamp": "2024-04-26T11:43:20.585Z", "__row_index": 0}