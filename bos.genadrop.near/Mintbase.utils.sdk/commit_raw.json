{"tx_hash": "4noDoxcrxdVLqZ9SH9x7VqhLAYrzAsBwnu4SU72fK22S", "action_id_social": "9Ra8K5S1D8A9k4vP5zsrk5JoZh7HWiHGFBgPTBwgKkYH-0-widget", "block_id": 119339143, "block_timestamp": "2024-05-20T10:50:21.709Z", "signer_id": "bos.genadrop.near", "widget_name": "Mintbase.utils.sdk", "source_code": "const { deployStore } = VM.require(\n  \"bos.genadrop.near/widget/Mintbase.utils.deploy_store\"\n);\nconst { getTimePassed } = VM.require(\n  \"bos.genadrop.near/widget/Mintbase.utils.get_time_passed\"\n);\nconst { getUserStores, checkStoreOwner, fetchStoreMinters } = VM.require(\n  \"bos.genadrop.near/widget/Mintbase.utils.get_user_stores\"\n);\nconst { getUserEarnings } = VM.require(\n  \"bos.genadrop.near/widget/Mintbase.utils.get_user_earnings\"\n);\nconst { getOffersToAccount } = VM.require(\n  \"bos.genadrop.near/widget/Mintbase.utils.get_offers_to_account\"\n);\nconst { getOpenOffersByAccount } = VM.require(\n  \"bos.genadrop.near/widget/Mintbase.utils.get_open_offers_by_account\"\n);\nconst { getCombinedStoreData } = VM.require(\n  \"bos.genadrop.near/widget/Mintbase.utils.get_combined_store_data\"\n);\nconst { saveBasicSettings, transferStoreOwnership, addAndRemoveMinters } =\n  VM.require(\"bos.genadrop.near/widget/Mintbase.utils.store_contract_settings\");\n// Function to retrieve all NFTs associated with a store contract\nconst { getStoreNFTs } = VM.require(\n  \"bos.genadrop.near/widget/Mintbase.utils.get_store_nfts\"\n);\nconst { getActivityByContract } = VM.require(\n  \"bos.genadrop.near/widget/Mintbase.utils.get_activity_by_contract\"\n);\n// Configuration (replace with your actual values or define them globally)\nconst factoryAddress = mainnet ? \"mintbase1.near\" : \"mintspace2.testnet\";\nconst MARKET_ADDRESS = {\n  mainnet: \"simple.market.mintbase1.near\",\n  testnet: \"market-v2-beta.mintspace2.testnet\",\n};\nconst FACTORY_ADDRESS = {\n  mainnet: \"mintbase1.near\",\n  testnet: \"mintspace2.testnet\",\n};\nconst mbGraphEndpoint = \"https://graph.mintbase.xyz\";\n// Helper function to generate IPFS gateway URL\nconst ipfsUrl = (cid) => `https://ipfs.near.social/ipfs/${cid}`;\n// Function to fetch details of a specific NFT\nconst getTokenById = (contractName, tokenId) => {\n  if (!contractName || !tokenId)\n    return console.log(\"missing contract name or token id\");\n  const res = asyncFetch(mbGraphEndpoint, {\n    method: \"POST\",\n    headers: {\n      \"mb-api-key\": \"anon\",\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({\n      query: `\n    query GetTokenById(\n      $tokenId: String!\n      $contractAddress: String!\n    ) {\n      mb_views_nft_tokens(\n        where: {\n          nft_contract_id: { _eq: $contractAddress }\n          token_id: { _eq: $tokenId }\n        }\n        limit: 1\n      ) {\n        baseUri: base_uri\n        burned_receipt_id\n        burned_timestamp\n        copies\n        description\n        expires_at\n        issued_at\n        last_transfer_receipt_id\n        last_transfer_timestamp\n        media\n        minter\n        media_hash\n        mint_memo\n        nft_contract_is_mintbase\n        minted_receipt_id\n        minted_timestamp\n        metadata_id\n        document: reference_blob(path: \"$.document\")\n        animationUrl: reference_blob(path: \"$.animation_url\")\n        extra: reference_blob(path: \"$.extra\")\n        reference\n        reference_hash\n        starts_at\n        title\n        updated_at\n        owner\n        royalties\n        royalties_percent\n        token_id\n      }\n  \n      mb_views_active_listings_aggregate(\n        where: {\n          token_id: { _eq: $tokenId }\n          kind: { _eq: \"auction\" }\n          nft_contract_id: { _eq: $contractAddress }\n        }\n      ) {\n        aggregate {\n          count\n        }\n      }\n    }\n    `,\n      variables: {\n        tokenId: tokenId,\n        contractAddress: contractName || \"\",\n      },\n    }),\n  });\n  return res;\n};\n// Function to retrieve all NFTs owned by a specific account address\nconst getOwnedNFTs = (owner) => {\n  if (!owner) return console.log(\"missing owner address\");\n  try {\n    const response = asyncFetch(mbGraphEndpoint, {\n      method: \"POST\",\n      headers: {\n        \"mb-api-key\": \"anon\",\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        query: `query MyQuery($owner: String!) {\n                mb_views_nft_tokens(\n                  where: {owner: {_eq: $owner}, _and: {burned_timestamp: {}, last_transfer_timestamp: {}}}\n                  limit: 30\n                  order_by: {minted_timestamp: asc}\n                ) {\n                  nft_contract_id\n                  title\n                  description\n                  media\n                  last_transfer_receipt_id\n                }\n              }`,\n        variables: {\n          owner: owner || context.accountId,\n        },\n      }),\n    });\n    return response;\n  } catch (err) {\n    console.log(err);\n  }\n};\nfunction mintingDeposit({ nTokens, nRoyalties, nSplits, metadata }) {\n  const nSplitsAdj = nSplits < 1 ? 0 : nSplits - 1;\n  const bytesPerToken = 440 + nSplitsAdj * 80 + 80;\n  const metadataBytesEstimate = JSON.stringify(metadata).length;\n  const totalBytes =\n    92 +\n    100 +\n    metadataBytesEstimate +\n    bytesPerToken * nTokens +\n    80 * nRoyalties;\n  return `${Math.ceil(totalBytes)}${\"0\".repeat(19)}`;\n}\n// Function to create (mint) new NFTs and uploads them to IPFS\nconst mint = (\n  metadata,\n  media,\n  contractName,\n  numToMint,\n  owner,\n  errorMessage,\n  fileUploadStatus\n) => {\n  if (!media && !metadata) return console.log(\"missing file\");\n  fileUploadStatus(true);\n  asyncFetch(\"https://ipfs.near.social/add\", {\n    method: \"POST\",\n    headers: {\n      Accept: \"application/json\",\n    },\n    body: metadata,\n  })\n    .then((res) => {\n      const reference = res.body.cid;\n      fileUploadStatus(false);\n      if (!reference) {\n        return errorMessage(\"could not upload to IPFS\");\n      }\n      const gas = 2e14;\n      return Near.call([\n        {\n          contractName: contractName || \"\",\n          methodName: \"nft_batch_mint\",\n          args: {\n            owner_id: owner,\n            metadata: {\n              media: ipfsUrl(media),\n              reference,\n              title: metadata.title,\n              description: metadata.description,\n            },\n            num_to_mint: numToMint || 1,\n            royalty_args: null,\n            split_owners: null,\n            token_ids_to_mint: null,\n          },\n          gas: gas,\n          deposit: mintingDeposit({\n            nSplits: 0,\n            nTokens: 1,\n            nRoyalties: 0,\n            metadata,\n          }),\n        },\n      ]);\n    })\n    .catch((err) => errorMessage(err.toString()));\n};\n// Function to burn (permanently remove) existing NFTs\nconst nftBurn = (tokenIds, contractName) => {\n  if (!isSignedin) return console.log(\"sign in first\");\n  if (!tokenIds.length) return console.log(\"missing token ids\");\n  const gas = 2e14;\n  const deposit = 1;\n  try {\n    return Near.call([\n      {\n        contractName: contractName || \"\",\n        methodName: \"nft_batch_burn\",\n        args: {\n          token_ids: tokenIds,\n        },\n        gas,\n        deposit,\n      },\n    ]);\n  } catch (err) {\n    console.log(err);\n  }\n};\n// Function to approve an NFT for listing on a marketplace with a specific price\nconst nftApprove = (tokenId, contractName, price, isTestnet) => {\n  if (!isSignedin) return console.log(\"sign in first\");\n  if (!tokenId || !price > 0)\n    return console.log(\"token id or price is missing\");\n  const gas = 2e14;\n  const storageDeposit = 1e22;\n  return Near.call([\n    {\n      contractName: MARKET_ADDRESS[isTestnet ? \"testnet\" : \"mainnet\"],\n      methodName: \"deposit_storage\",\n      args: {},\n      gas: gas,\n      deposit: storageDeposit,\n    },\n    {\n      methodName: \"nft_approve\",\n      contractName: contractName || \"\",\n      gas: gas,\n      args: {\n        token_id: tokenId,\n        account_id: MARKET_ADDRESS[isTestnet ? \"testnet\" : \"mainnet\"],\n        msg: JSON.stringify({\n          price: _price(price),\n        }),\n      },\n      deposit: 8e22,\n    },\n  ]);\n};\nreturn {\n  deployStore,\n  getTokenById,\n  getStoreNFTs,\n  getOwnedNFTs,\n  mint,\n  nftBurn,\n  nftApprove,\n  getTimePassed,\n  getUserStores,\n  checkStoreOwner,\n  getUserEarnings,\n  getOffersToAccount,\n  getOpenOffersByAccount,\n  addAndRemoveMinters,\n  getCombinedStoreData,\n  saveBasicSettings,\n  transferStoreOwnership,\n  fetchStoreMinters,\n  getActivityByContract,\n};\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/bos.genadrop.near/widget/Mintbase.utils.sdk", "fact_widget_deployments_id": "3a5feb2a41b070aa876e56aa249b88c5", "inserted_timestamp": "2024-05-20T12:58:45.841Z", "modified_timestamp": "2024-05-20T12:58:45.841Z", "__row_index": 0}