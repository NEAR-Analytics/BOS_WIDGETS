{"tx_hash": "ANAE6tt34MGwHey9fq6c49Cn12ud4Wgk4frsvobWZQiw", "action_id_social": "311c1kyj8rRGWskn6DdSSFx39CwaXBFkzGA7j181kJJQ-0-widget", "block_id": 117436302, "block_timestamp": "2024-04-23T07:26:49.644Z", "signer_id": "bos.genadrop.near", "widget_name": "Mintbase.utils.sdk", "source_code": "const { deployStore } = VM.require(\n  \"bos.genadrop.near/widget/Mintbase.utils.deploy_store\"\n);\n\nconst { getTimePassed } = VM.require(\n  \"bos.genadrop.near/widget/Mintbase.utils.get_time_passed\"\n);\n\nconst { getUserStores } = VM.require(\n  \"bos.genadrop.near/widget/Mintbase.utils.get_user_stores\"\n);\n\nconst { getUserEarnings } = VM.require(\n  \"bos.genadrop.near/widget/Mintbase.utils.get_user_earnings\"\n);\n\n// Configuration (replace with your actual values or define them globally)\nconst factoryAddress = mainnet ? \"mintbase1.near\" : \"mintspace2.testnet\";\nconst MARKET_ADDRESS = {\n  mainnet: \"simple.market.mintbase1.near\",\n  testnet: \"market-v2-beta.mintspace2.testnet\",\n};\n\nconst FACTORY_ADDRESS = {\n  mainnet: \"mintbase1.near\",\n  testnet: \"mintspace2.testnet\",\n};\nconst mbGraphEndpoint = \"https://graph.mintbase.xyz\";\n\n// Helper function to generate IPFS gateway URL\nconst ipfsUrl = (cid) => `https://ipfs.near.social/ipfs/${cid}`;\n\n// Function to fetch details of a specific NFT\nconst getTokenById = (contractName, tokenId) => {\n  if (!contractName || !tokenId)\n    return console.log(\"missing contract name or token id\");\n  const res = asyncFetch(mbGraphEndpoint, {\n    method: \"POST\",\n    headers: {\n      \"mb-api-key\": \"anon\",\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({\n      query: `\n    query GetTokenById(\n      $tokenId: String!\n      $contractAddress: String!\n    ) {\n      mb_views_nft_tokens(\n        where: {\n          nft_contract_id: { _eq: $contractAddress }\n          token_id: { _eq: $tokenId }\n        }\n        limit: 1\n      ) {\n        baseUri: base_uri\n        burned_receipt_id\n        burned_timestamp\n        copies\n        description\n        expires_at\n        issued_at\n        last_transfer_receipt_id\n        last_transfer_timestamp\n        media\n        minter\n        media_hash\n        mint_memo\n        nft_contract_is_mintbase\n        minted_receipt_id\n        minted_timestamp\n        metadata_id\n        document: reference_blob(path: \"$.document\")\n        animationUrl: reference_blob(path: \"$.animation_url\")\n        extra: reference_blob(path: \"$.extra\")\n        reference\n        reference_hash\n        starts_at\n        title\n        updated_at\n        owner\n        royalties\n        royalties_percent\n        token_id\n      }\n  \n      mb_views_active_listings_aggregate(\n        where: {\n          token_id: { _eq: $tokenId }\n          kind: { _eq: \"auction\" }\n          nft_contract_id: { _eq: $contractAddress }\n        }\n      ) {\n        aggregate {\n          count\n        }\n      }\n    }\n    `,\n      variables: {\n        tokenId: tokenId,\n        contractAddress: contractName || \"\",\n      },\n    }),\n  });\n  return res;\n};\n\n// Function to retrieve all NFTs associated with a store contract\nconst getStoreNfts = (contractName) => {\n  if (!contractName) return console.log(\"missing contract name\");\n  try {\n    const response = asyncFetch(mbGraphEndpoint, {\n      method: \"POST\",\n      headers: {\n        \"mb-api-key\": \"anon\",\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        query: `query GetStoreNfts( \n        $offset: Int = 0 $condition: mb_views_nft_metadata_unburned_bool_exp ) \n        @cached \n        { mb_views_nft_metadata_unburned( where: $condition \n          offset: $offset order_by: { minted_timestamp: desc } ) \n         { createdAt: minted_timestamp \n           listed: price \n           media \n           storeId: nft_contract_id \n           metadataId: metadata_id \n           title base_uri \n         } \n        mb_views_nft_metadata_unburned_aggregate(where: $condition) \n        { \n          aggregate { \n            count \n          } \n         } \n       }\n    `,\n        variables: {\n          condition: {\n            nft_contract_id: {\n              _in: contractName || \"\",\n            },\n          },\n        },\n      }),\n    });\n    return response;\n  } catch (err) {\n    console.log(err);\n  }\n};\n\n// Function to retrieve all NFTs owned by a specific account address\nconst getOwnedNFTs = (owner) => {\n  if (!owner) return console.log(\"missing owner address\");\n  try {\n    const response = asyncFetch(mbGraphEndpoint, {\n      method: \"POST\",\n      headers: {\n        \"mb-api-key\": \"anon\",\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        query: `query MyQuery($owner: String!) {\n                mb_views_nft_tokens(\n                  where: {owner: {_eq: $owner}, _and: {burned_timestamp: {}, last_transfer_timestamp: {}}}\n                  limit: 30\n                  order_by: {minted_timestamp: asc}\n                ) {\n                  nft_contract_id\n                  title\n                  description\n                  media\n                  last_transfer_receipt_id\n                }\n              }`,\n        variables: {\n          owner: owner || contet.accountId,\n        },\n      }),\n    });\n    return response;\n  } catch (err) {\n    console.log(err);\n  }\n};\n\n// Function to create (mint) new NFTs and uploads them to IPFS\nconst mint = (tokenMetadata, media, contractName, numToMint) => {\n  if (!isSignedin) return console.log(\"sign in first\");\n  if (!media) return console.log(\"missing file\");\n  asyncFetch(\"https://ipfs.near.social/add\", {\n    method: \"POST\",\n    headers: {\n      Accept: \"application/json\",\n    },\n    body: media,\n  })\n    .then((res) => {\n      const cid = res.body.cid;\n      const gas = 2e14;\n      return Near.call([\n        {\n          contractName: contractName || \"\",\n          methodName: \"nft_batch_mint\",\n          args: {\n            owner_id: context.accountId,\n            metadata: {\n              media: ipfsUrl(cid),\n              ...tokenMetadata,\n            },\n            num_to_mint: numToMint || 1,\n            royalty_args: {\n              split_between: {\n                [context.accountId]: 10000,\n              },\n              percentage: 1000,\n            },\n            split_owners: null,\n          },\n          gas: gas,\n          deposit: 1e22,\n        },\n      ]);\n    })\n    .catch((err) => console.log(err));\n};\n\n// Function to burn (permanently remove) existing NFTs\nconst nftBurn = (tokenIds, contractName) => {\n  if (!isSignedin) return console.log(\"sign in first\");\n  if (!tokenIds.length) return console.log(\"missing token ids\");\n  const gas = 2e14;\n  const deposit = 1;\n  try {\n    return Near.call([\n      {\n        contractName: contractName || \"\",\n        methodName: \"nft_batch_burn\",\n        args: {\n          token_ids: tokenIds,\n        },\n        gas,\n        deposit,\n      },\n    ]);\n  } catch (err) {\n    console.log(err);\n  }\n};\n\n// Function to approve an NFT for listing on a marketplace with a specific price\nconst nftApprove = (tokenId, contractName, price, isTestnet) => {\n  if (!isSignedin) return console.log(\"sign in first\");\n  if (!tokenId || !price > 0)\n    return console.log(\"token id or price is missing\");\n  const gas = 2e14;\n  const storageDeposit = 1e22;\n  return Near.call([\n    {\n      contractName: MARKET_ADDRESS[isTestnet ? \"testnet\" : \"mainnet\"],\n      methodName: \"deposit_storage\",\n      args: {},\n      gas: gas,\n      deposit: storageDeposit,\n    },\n    {\n      methodName: \"nft_approve\",\n      contractName: contractName || \"\",\n      gas: gas,\n      args: {\n        token_id: tokenId,\n        account_id: MARKET_ADDRESS[isTestnet ? \"testnet\" : \"mainnet\"],\n        msg: JSON.stringify({\n          price: _price(price),\n        }),\n      },\n      deposit: 8e22,\n    },\n  ]);\n};\n\nreturn {\n  deployStore,\n  getTokenById,\n  getStoreNfts,\n  getOwnedNFTs,\n  mint,\n  nftBurn,\n  nftApprove,\n  getTimePassed,\n  getUserStores,\n  getUserEarnings,\n};\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/bos.genadrop.near/widget/Mintbase.utils.sdk", "fact_widget_deployments_id": "8495e6d5d636710547337b39d9cf486b", "inserted_timestamp": "2024-04-23T09:44:05.024Z", "modified_timestamp": "2024-04-23T09:44:05.024Z", "__row_index": 0}