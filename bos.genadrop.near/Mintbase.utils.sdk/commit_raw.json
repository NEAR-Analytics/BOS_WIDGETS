{"tx_hash": "3n329XwmqmUv9hQDcgsSdZsJgMbeUCfa57TzM1rs5p4d", "action_id_social": "EcVVarvUjMLEBdZm1CeQH2LevSPiaZxCiiii5weZRV5o-0-widget", "block_id": 119855630, "block_timestamp": "2024-05-27T13:25:50.183Z", "signer_id": "bos.genadrop.near", "widget_name": "Mintbase.utils.sdk", "source_code": "const { deployStore } = VM.require(\n  \"bos.genadrop.near/widget/Mintbase.utils.deploy_store\"\n);\nconst { getTimePassed } = VM.require(\n  \"bos.genadrop.near/widget/Mintbase.utils.get_time_passed\"\n);\nconst { getUserStores, checkStoreOwner, fetchStoreMinters } = VM.require(\n  \"bos.genadrop.near/widget/Mintbase.utils.get_user_stores\"\n);\nconst { getUserEarnings } = VM.require(\n  \"bos.genadrop.near/widget/Mintbase.utils.get_user_earnings\"\n);\nconst { getOffersToAccount } = VM.require(\n  \"bos.genadrop.near/widget/Mintbase.utils.get_offers_to_account\"\n);\nconst { getOpenOffersByAccount } = VM.require(\n  \"bos.genadrop.near/widget/Mintbase.utils.get_open_offers_by_account\"\n);\nconst { getCombinedStoreData } = VM.require(\n  \"bos.genadrop.near/widget/Mintbase.utils.get_combined_store_data\"\n);\nconst { saveBasicSettings, transferStoreOwnership, addAndRemoveMinters } =\n  VM.require(\"bos.genadrop.near/widget/Mintbase.utils.store_contract_settings\");\n// Function to retrieve all NFTs associated with a store contract\nconst { getStoreNFTs } = VM.require(\n  \"bos.genadrop.near/widget/Mintbase.utils.get_store_nfts\"\n);\nconst { getActivityByContract } = VM.require(\n  \"bos.genadrop.near/widget/Mintbase.utils.get_activity_by_contract\"\n);\nconst { mint } = VM.require(\"bos.genadrop.near/widget/Mintbase.utils.mint\");\n// Configuration (replace with your actual values or define them globally)\nconst factoryAddress = mainnet ? \"mintbase1.near\" : \"mintspace2.testnet\";\nconst MARKET_ADDRESS = {\n  mainnet: \"simple.market.mintbase1.near\",\n  testnet: \"market-v2-beta.mintspace2.testnet\",\n};\nconst FACTORY_ADDRESS = {\n  mainnet: \"mintbase1.near\",\n  testnet: \"mintspace2.testnet\",\n};\nconst mbGraphEndpoint = \"https://graph.mintbase.xyz\";\n// Helper function to generate IPFS gateway URL\nconst ipfsUrl = (cid) => `https://ipfs.near.social/ipfs/${cid}`;\n// Function to fetch details of a specific NFT\nconst getTokenById = (contractName, tokenId) => {\n  if (!contractName || !tokenId)\n    return console.log(\"missing contract name or token id\");\n  const res = asyncFetch(mbGraphEndpoint, {\n    method: \"POST\",\n    headers: {\n      \"mb-api-key\": \"anon\",\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({\n      query: `\n    query GetTokenById(\n      $tokenId: String!\n      $contractAddress: String!\n    ) {\n      mb_views_nft_tokens(\n        where: {\n          nft_contract_id: { _eq: $contractAddress }\n          token_id: { _eq: $tokenId }\n        }\n        limit: 1\n      ) {\n        baseUri: base_uri\n        burned_receipt_id\n        burned_timestamp\n        copies\n        description\n        expires_at\n        issued_at\n        last_transfer_receipt_id\n        last_transfer_timestamp\n        media\n        minter\n        media_hash\n        mint_memo\n        nft_contract_is_mintbase\n        minted_receipt_id\n        minted_timestamp\n        metadata_id\n        document: reference_blob(path: \"$.document\")\n        animationUrl: reference_blob(path: \"$.animation_url\")\n        extra: reference_blob(path: \"$.extra\")\n        reference\n        reference_hash\n        starts_at\n        title\n        updated_at\n        owner\n        royalties\n        royalties_percent\n        token_id\n      }\n  \n      mb_views_active_listings_aggregate(\n        where: {\n          token_id: { _eq: $tokenId }\n          kind: { _eq: \"auction\" }\n          nft_contract_id: { _eq: $contractAddress }\n        }\n      ) {\n        aggregate {\n          count\n        }\n      }\n    }\n    `,\n      variables: {\n        tokenId: tokenId,\n        contractAddress: contractName || \"\",\n      },\n    }),\n  });\n  return res;\n};\n// Function to retrieve all NFTs owned by a specific account address\nconst getOwnedNFTs = (owner) => {\n  if (!owner) return console.log(\"missing owner address\");\n  try {\n    const response = asyncFetch(mbGraphEndpoint, {\n      method: \"POST\",\n      headers: {\n        \"mb-api-key\": \"anon\",\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        query: `query MyQuery($owner: String!) {\n                mb_views_nft_tokens(\n                  where: {owner: {_eq: $owner}, _and: {burned_timestamp: {}, last_transfer_timestamp: {}}}\n                  limit: 30\n                  order_by: {minted_timestamp: asc}\n                ) {\n                  nft_contract_id\n                  title\n                  description\n                  media\n                  last_transfer_receipt_id\n                }\n              }`,\n        variables: {\n          owner: owner || context.accountId,\n        },\n      }),\n    });\n    return response;\n  } catch (err) {\n    console.log(err);\n  }\n};\n// Function to burn (permanently remove) existing NFTs\nconst nftBurn = (tokenIds, contractName) => {\n  if (!isSignedin) return console.log(\"sign in first\");\n  if (!tokenIds.length) return console.log(\"missing token ids\");\n  const gas = 2e14;\n  const deposit = 1;\n  try {\n    return Near.call([\n      {\n        contractName: contractName || \"\",\n        methodName: \"nft_batch_burn\",\n        args: {\n          token_ids: tokenIds,\n        },\n        gas,\n        deposit,\n      },\n    ]);\n  } catch (err) {\n    console.log(err);\n  }\n};\n// Function to approve an NFT for listing on a marketplace with a specific price\nconst nftApprove = (tokenId, contractName, price, isTestnet) => {\n  if (!isSignedin) return console.log(\"sign in first\");\n  if (!tokenId || !price > 0)\n    return console.log(\"token id or price is missing\");\n  const gas = 2e14;\n  const storageDeposit = 1e22;\n  return Near.call([\n    {\n      contractName: MARKET_ADDRESS[isTestnet ? \"testnet\" : \"mainnet\"],\n      methodName: \"deposit_storage\",\n      args: {},\n      gas: gas,\n      deposit: storageDeposit,\n    },\n    {\n      methodName: \"nft_approve\",\n      contractName: contractName || \"\",\n      gas: gas,\n      args: {\n        token_id: tokenId,\n        account_id: MARKET_ADDRESS[isTestnet ? \"testnet\" : \"mainnet\"],\n        msg: JSON.stringify({\n          price: _price(price),\n        }),\n      },\n      deposit: 8e22,\n    },\n  ]);\n};\nreturn {\n  deployStore,\n  getTokenById,\n  getStoreNFTs,\n  getOwnedNFTs,\n  mint,\n  nftBurn,\n  nftApprove,\n  getTimePassed,\n  getUserStores,\n  checkStoreOwner,\n  getUserEarnings,\n  getOffersToAccount,\n  getOpenOffersByAccount,\n  addAndRemoveMinters,\n  getCombinedStoreData,\n  saveBasicSettings,\n  transferStoreOwnership,\n  fetchStoreMinters,\n  getActivityByContract,\n};\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/bos.genadrop.near/widget/Mintbase.utils.sdk", "fact_widget_deployments_id": "88f94a9720216452e56a135cac292774", "inserted_timestamp": "2024-05-27T14:57:59.050Z", "modified_timestamp": "2024-05-27T14:57:59.050Z", "__row_index": 1}