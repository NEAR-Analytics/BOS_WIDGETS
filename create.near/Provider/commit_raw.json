{"tx_hash": "CJf581D8x61wJJdAnAkY3k5AJZbsnsXVge53ZRW2e7ad", "action_id_social": "FMs1zq35BjgRPHcvHDkzrFvtsQD4n9oQ6TNGkdrF2rAG-0-widget", "block_id": 105653770, "block_timestamp": "2023-11-14T01:50:09.803Z", "signer_id": "create.near", "widget_name": "Provider", "source_code": "/*__@import:everything/utils/UUID__*/\n/*__@import:everything/sdk__*/\n/*__@import:QoL/storage__*/\n\nState.init({\n  debug: true,\n});\n\nconst accountId = context.accountId;\nconst Children = props.Children;\n\nlet theprops = { ...props };\ndelete theprops.Children;\n\nconst KEYS = {\n  selectedDoc: (pid) => `selectedDoc/${pid}`,\n  doc: (path) => `doc/${path}`, // having path here will let us always know the structure of the doc\n  docs: (pid) => `docs/${pid}`, // this should be the array of project docs\n  init: (pid) => `init/${pid}`, // lets us know when the project has been initialized\n};\nconst DOC_SEPARATOR = \".\";\nconst DEFAULT_TEMPLATE = \"/*__@appAccount__*//widget/templates.project.doc\";\n\nconst handleDocument = {\n  /**\n   * Create, or updates, or deletes document in Local Storage\n   *\n   * if value is an object, then create or update the document\n   * if value is null, then delete the document\n   *\n   * @param {string} pid - project id\n   * @param {string} path - path to the document\n   * @param {object} value - the value to set at the path\n   *\n   * @returns {void} - nothing\n   */\n  set: (pid, path, value) => {\n    store(KEYS.doc(path), value);\n\n    // We need to keep track of the documents in the project\n    let paths = retrieve(KEYS.docs(pid));\n    paths = Array.isArray(paths) ? paths : [];\n\n    // If the document is being deleted, then we need to remove it from the docs array\n    if (value === null) {\n      const newDocs = paths.filter((docPath) => docPath !== path);\n      store(KEYS.docs(pid), newDocs);\n    }\n\n    // If the document is being created or updated, we need to make sure it's in the docs array\n    if (value !== null && !paths.includes(path)) {\n      store(KEYS.docs(pid), [...paths, path]);\n    }\n\n    // Open the new document\n    store(KEYS.selectedDoc(pid), path);\n  },\n\n  /**\n   * Wrapper for set that only updates the document keys\n   *\n   * @param {string} pid - project id\n   * @param {string} path - path to the document\n   * @param {object} value - the value to set at the path\n   * @returns {void} - nothing\n   *\n   * @example\n   * // This will update the document title, without afecting the content\n   * handle[\"document\"].update(projectId, path, { title: \"New Title\" });\n   */\n  update: (pid, path, value) => {\n    const doc = retrieve(KEYS.doc(path));\n    console.log(\"doc\", doc);\n    // TODO need to fix the structure\n    handleDocument.set(pid, path, {\n      data: {\n        ...doc.data,\n        ...value,\n      },\n      metadata: {\n        ...doc.metadata,\n        updatedAt: new Date().toISOString(),\n      },\n      _: {\n        inBuffer: true,\n      },\n    });\n  },\n\n  /**\n   * Wrapper for set that creates a new document under parent path\n   * @param {string} pid - project id (root id)\n   * @param {string} parentPath - optional path to the parent document\n   * @param {object} value - optional value to set at the path\n   */\n  create: (pid, parentPath, value) => {\n    if (!value) value = { title: \"\", content: \"\" };\n    if (!parentPath) parentPath = \"\";\n    const did = UUID.generate(\"xxxxxxx\");\n\n    const document = {\n      // I'm doing it this funny nested away cuz I'm trying to figure out a generic createThing\n      [did]: {\n        data: value,\n        metadata: {\n          createdAt: new Date().toISOString(),\n          type: \"/*__@appAccount__*//type/document\",\n        },\n      },\n    };\n    const path = `${parentPath}${parentPath && DOC_SEPARATOR}${did}`;\n\n    // Now just using pid to help with Storage\n    handleDocument.set(pid, path, {\n      ...document[did],\n      _: {\n        inBuffer: true,\n      },\n    });\n  },\n\n  /**\n   * Wrapper for set that deletes a document\n   * @param {string} pid - project id\n   * @param {string} path - path to the document\n   * @returns {void} - nothing\n   */\n  delete: (pid, path) => handleDocument.set(pid, path, undefined),\n\n  /**\n   * Get a document from Local Storage\n   * @param {string} path - path to the document\n   * @returns {object} - the document\n   */\n  get: (path) => retrieve(KEYS.doc(path)),\n  // TODO: this should get from local storage first and then from SocialDB if not found\n\n  /**\n   * Get project documents from Local Storage\n   * @param {string} pid - project id\n   * @returns {object} - the documents\n   */\n  getAll: (pid) => {\n    let paths = retrieve(KEYS.docs(pid)) || [];\n    paths = Array.isArray(paths) ? paths : [];\n\n    let docs = {};\n    paths.forEach((path) => {\n      const doc = retrieve(KEYS.doc(path));\n      if (doc) docs[path] = retrieve(KEYS.doc(path));\n    });\n    return docs;\n  },\n\n  /**\n   * Get the selected document from Local Storage, if none is selected, then return the first document and open it\n   * @param {string} pid - project id\n   * @returns {path} - the path to the selected document\n   */\n  getSelected: (pid) => {\n    const selected = retrieve(KEYS.selectedDoc(pid));\n    if (selected) return selected;\n\n    const docs = handleDocument.getAll(pid);\n    const firstDoc = Object.keys(docs)[0];\n    if (firstDoc) {\n      handleDocument.open(pid, firstDoc);\n      return firstDoc;\n    }\n  },\n\n  // TODO\n  fetch: (did) => {\n    const doc = Social.get(`${accountId}/thing/${did}/**`);\n    return doc;\n  },\n\n  // TODO\n  fetchAll: (pid) => {\n    const docs = JSON.parse(Social.get(`${accountId}/thing/${pid}/documents`) || \"null\");\n    return docs;\n  },\n\n  // TODO\n  fetchAllTitles: (pid, path) => {\n    const docs = Social.get(`${accountId}/document/${pid}/*/title`);\n    return docs;\n  },\n\n  /**\n   * Set the selected document in Local Storage\n   * @param {string} pid - project id\n   * @param {string} path - path to the document\n   */\n  open: (pid, path) => store(KEYS.selectedDoc(pid), path),\n\n  /**\n   * Saves the document to SocialDB\n   * @param {string} pid - project id\n   * @param {string} path - path to the document\n   */\n  publish: (pid, path) => {\n    const doc = handleDocument.get(path);\n    delete doc._;\n    const did = path.split(DOC_SEPARATOR).pop();\n    \n    // TODO: check if document has already been added\n    function addDocumentToProject() {\n      const project = handleProject.get(pid);\n      const documents = JSON.parse(project.documents) || [];\n      // this holds the heirachical data\n      return {\n        thing: {\n          [pid]: {\n            documents: [...documents, path],\n          },\n        },\n      };\n    }\n\n    // TODO: check if project has already been added\n    function addProjectToDocument() {\n      const projects = JSON.parse(document[did].projects) || [];\n      return {\n        thing: {\n          [did]: {\n            projects: [...projects, pid],\n          },\n        },\n      };\n    }\n\n    const projectToDoc = addProjectToDocument(did, pid);\n    const docToProject = addDocumentToProject(pid, did);\n\n    //combine the json from createThing and addDocumentToProject\n    const combined = deepMerge(\n      deepMerge({ thing: { [did]: doc } }, projectToDoc),\n      docToProject\n    );\n\n    Social.set(combined, {\n      onCommit: () => {\n        handleDocument.set(pid, path, {\n          ...doc,\n          _: {\n            inBuffer: false,\n          },\n        });\n      },\n    });\n  },\n\n  /**\n   * Generates a new UID\n   * @returns {string} - the new UID\n   */\n  generateId: () => UUID.generate(\"xxxxxxx\"),\n};\n\nconst handleProject = {\n  getAll: () => {\n    return getAllThings(\"/*__@appAccount__*//type/project\", [accountId]);\n  },\n  get: (pid) => {\n    return getThing(pid, [accountId]);\n  },\n  create: (project) => {\n    // TODO: this should be prehandled by the form\n    const tags = {};\n    project.tags.forEach((tag) => {\n      tags[tag] = \"\";\n    });\n    // currently setting project as metadata, need to match with typical metadata\n    Social.set({\n      thing: createThing(\"/*__@appAccount__*//type/project\", {}, project),\n    });\n  },\n  delete: (pid) => {\n    Social.set({\n      thing: {\n        [pid]: null,\n      },\n    });\n  },\n  update: (pid, project) => {\n    Social.set({\n      thing: {\n        [pid]: project,\n      },\n    });\n  },\n\n  /**\n   * Fetches project documents from SocialDB and stores them in Local Storage,\n   * it does not override the local documents if updatedAt is more recent,\n   *\n   * @note I'm not sure if it's okay to store all documents in Local Storage, it may be too much data for big projects,\n   * I think it's better to use fetchTitle and fetch to get the document when user opens it, and then store it in Local Storage\n   * if edited.\n   *\n   * @param {string} pid - project id\n   * @returns {void} - nothing\n   */\n  init: (pid, force) => {\n    if (!pid) return;\n    if (!force) {\n      const lastInit = retrieve(KEYS.init(pid));\n      // if the project has already been initialized in the past 24 hours, then don't do it again\n      if (lastInit && new Date(lastInit) > new Date(Date.now() - 86400000))\n        return;\n    }\n\n    const docs = handleDocument.fetchAll(pid);\n    if (docs === null) return;\n\n    docs.forEach((path) => {\n      const doc = docs[path];\n      const localDoc = handleDocument.get(path);\n      if (!localDoc || new Date(doc.updatedAt) > new Date(localDoc.updatedAt)) {\n        handleDocument.set(pid, path, doc);\n      }\n    });\n\n    store(KEYS.init(pid), new Date().toISOString());\n    console.log(\"Project initialized\");\n  },\n};\n\n/**\n * Initialize\n */\nprops.project && handleProject.init(props.project);\n\nconst handleUtils = {\n  /**\n   * Unflatten the documents object\n   * @param {object} inputObject - the object to unflatten\n   * @returns {object} - the unflattened object\n   * @example\n   * \nconst input = {\n  702250: { title: \"\", content: \"\" },\n  \"702250.3cbbb3\": { title: \"\", content: \"\" },\n  \"702250.3cbbb3.acuont\": { title: \"\", content: \"\" },\n  \"702250.89thao\": { title: \"\", content: \"\" },\n};\n\nconst output = {\n  702250: {\n    title: \"\",\n    content: \"\",\n    children: {\n      \"3cbbb3\": {\n        title: \"\",\n        content: \"\",\n        children: {\n          acuont: { title: \"\", content: \"\" },\n        },\n      },\n      \"89thao\": {\n        title: \"\",\n        content: \"\",\n      },\n    },\n  },\n};\n    */\n  unflattenDocuments: (inputObject) => {\n    const result = {};\n\n    Object.keys(inputObject).forEach((key) => {\n      const keys = key.split(\".\");\n      let currentLevel = result;\n\n      keys.forEach((k, i) => {\n        if (i === keys.length - 1) {\n          // last key\n          currentLevel[k] = inputObject[key];\n        } else {\n          currentLevel[k] = currentLevel[k] || {};\n          currentLevel[k].children = currentLevel[k].children || {};\n          currentLevel = currentLevel[k].children;\n        }\n      });\n    });\n\n    return result;\n  },\n};\n\nconst handle = {\n  document: handleDocument,\n  project: handleProject,\n  utils: handleUtils,\n  other: { DOC_SEPARATOR },\n};\n\nif (Storage.privateGet(\"debug\")) {\n  const selectedDoc = handle[\"document\"].getSelected(props.project);\n  const doc = handle[\"document\"].get(selectedDoc);\n  const projectData = handle[\"project\"].get(props.project);\n\n  return (\n    <>\n      <Children handle={handle} {...theprops} />\n      <hr />\n      <Widget\n        src=\"/*__@replace:nui__*//widget/Input.Select\"\n        props={{\n          label: \"Debug\",\n          value: `${!!Storage.privateGet(\"debug\")}`,\n          onChange: (v) => {\n            Storage.privateSet(\"debug\", v === \"true\");\n          },\n          options: [\n            {\n              title: \"Enabled\",\n              value: true,\n            },\n            {\n              title: \"Disabled\",\n              value: false,\n            },\n          ],\n        }}\n      />\n      <hr />\n      <p>Selected Project: {props.project}</p>\n      Content:\n      <p style={{ maxHeight: 300, overflow: \"auto\" }}>\n        <Markdown text={\"```json \" + JSON.stringify(projectData, null, 2)} />\n      </p>\n      <hr />\n      <p>Selected Doc: {selectedDoc}</p>\n      Local Doc:\n      <p style={{ maxHeight: 300, overflow: \"auto\" }}>\n        <Markdown text={\"```json \" + JSON.stringify(doc, null, 2)} />\n      </p>\n      <hr />\n      All Local Docs:\n      <p style={{ maxHeight: 300, overflow: \"auto\" }}>\n        <Markdown\n          text={\n            \"```json \" +\n            JSON.stringify(handle[\"document\"].getAll(props.project), null, 2)\n          }\n        />\n      </p>\n      <button\n        onClick={() => {\n          store(KEYS.docs(props.project), []);\n        }}\n      >\n        clear local docs\n      </button>\n      <hr />\n      Fetched\n      <p style={{ maxHeight: 300, overflow: \"auto\" }}>\n        <Markdown\n          text={\n            \"```json \" +\n            JSON.stringify(\n              handle[\"document\"].fetch(props.project, selectedDoc),\n              null,\n              2\n            )\n          }\n        />\n      </p>\n      <hr />\n      Fetch All Titles\n      <p style={{ maxHeight: 300, overflow: \"auto\" }}>\n        <Markdown\n          text={\n            \"```json \" +\n            JSON.stringify(\n              handle[\"document\"].fetchAllTitles(props.project),\n              null,\n              2\n            )\n          }\n        />\n      </p>\n      <hr />\n      Fetch All\n      <p style={{ maxHeight: 300, overflow: \"auto\" }}>\n        <Markdown\n          text={\n            \"```json \" +\n            JSON.stringify(handle[\"document\"].fetchAll(props.project), null, 2)\n          }\n        />\n      </p>\n    </>\n  );\n}\n\nreturn (\n  <>\n    <Children handle={handle} {...theprops} />\n    <hr />\n    <Widget\n      src=\"/*__@replace:nui__*//widget/Input.Select\"\n      props={{\n        label: \"Debug\",\n        value: `${!!Storage.privateGet(\"debug\")}`,\n        onChange: (v) => {\n          Storage.privateSet(\"debug\", v === \"true\");\n        },\n        options: [\n          {\n            title: \"Enabled\",\n            value: true,\n          },\n          {\n            title: \"Disabled\",\n            value: false,\n          },\n        ],\n      }}\n    />\n    <hr />\n  </>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/create.near/widget/Provider", "fact_widget_deployments_id": "2f55f410eefbfca2b0fc0458a5490f9c", "inserted_timestamp": "2023-11-14T03:34:01.978Z", "modified_timestamp": "2023-11-14T03:34:01.978Z", "__row_index": 2}