{"tx_hash": "FapAbzBk2Dh6d5DQvmEBaZDaapP457zux8NesPgwc9eU", "action_id_social": "JAt6h2z3EjpnKyWhrsVf4aQAGicwRtyX1gnLLmRwcoc3-0-widget", "block_id": 109956138, "block_timestamp": "2024-01-09T05:06:18.581Z", "signer_id": "create.near", "widget_name": "Provider", "source_code": "const UUID = {\n  generate: (template) => {\n    if (typeof template !== \"string\") {\n      template = \"xxxxxxxx-xxxx-xxxx-yxxx-xxxxxxxxxxxx\";\n    }\n    return template.replace(/[xy]/g, (c) => {\n      var r = (Math.random() * 16) | 0;\n      var v = c === \"x\" ? r : (r & 0x3) | 0x8;\n      return v.toString(16);\n    });\n  },\n};\n\n/*__@import:everything/utils/UUID__*/\n\nfunction filterByType(data, targetType) {\n  return Object.keys(data || {}).reduce((result, key) => {\n    if (data[key].metadata?.type === targetType) {\n      result[key] = data[key];\n    }\n    return result;\n  }, {});\n}\n\nfunction deepMerge(obj1, obj2) {\n  return Object.keys({ ...obj1, ...obj2 }).reduce((acc, key) => {\n    if (\n      obj1[key] &&\n      obj2[key] &&\n      typeof obj1[key] === \"object\" &&\n      typeof obj2[key] === \"object\"\n    ) {\n      acc[key] = deepMerge(obj1[key], obj2[key]);\n    } else {\n      acc[key] = obj2[key] !== undefined ? obj2[key] : obj1[key];\n    }\n    return acc;\n  }, {});\n}\n\n/**\n * Gets all things of a given type, optionally filtered by accounts and blockHeight\n * @param {string} type - type of thing to filter by\n * @param {Array<string>} [accounts] - Optional list of accounts to filter by\n * @param {string|number} blockHeight - Optional blockHeight to use; defaults to \"final\"\n * @returns {object} - all things of the given type\n */\nfunction getAllThings(type, accounts, blockHeight) {\n  let paths;\n  if (!blockHeight) {\n    blockHeight = \"final\";\n  }\n\n  if (Array.isArray(accounts) && accounts.length) {\n    // We could change this to get all metadata, metadata includes type\n    // and then we have all we need in order to show on screens. Anything else can be fetched separately.\n    paths = accounts.map((account) => `${account}/thing/*/metadata/*`);\n  } else {\n    paths = [\"*/thing/*/metadata/*\"];\n  }\n  const things = Social.get(paths, blockHeight);\n  return filterByType(things, type) ?? {};\n}\n\n/**\n * Gets the thing matching id, optionally filtered by accounts and blockHeight\n * @param {string} id - thing id\n * @param {Array<string>} [accountIds] - Optional list of accounts to filter by. If not provided, defaults to any account.\n * @param {string|number} blockHeight - Optional blockHeight to use; defaults to \"final\"\n * @returns {object|null} - the thing, multiple things if matches id across accounts, or null if not found\n */\nfunction getThing(id, accountIds, blockHeight) {\n  let paths;\n  if (!blockHeight) {\n    blockHeight = \"final\";\n  }\n\n  if (Array.isArray(accountIds) && accountIds.length) {\n    paths = accountIds.map((accountId) => `${accountId}/thing/${id}/**`);\n  } else {\n    paths = [`*/thing/${id}/**`];\n  }\n\n  const thing = Social.get(paths, blockHeight) || {};\n\n  return thing;\n}\n\nfunction deleteThing(id) {\n  Social.set({\n    thing: {\n      [id]: null,\n    },\n  });\n}\n\n/**\n * Creates a thing with the given type, data, and metadata\n * Subsequently calls onCommit or onCancel\n * @param {string} type - type of thing to create\n * @param {object} data - data to store\n * @param {object} metadata - metadata to store\n */\nfunction createThing(type, data, metadata) {\n  // Temporary small id\n  const id = UUID.generate(\"xxxxxxx\");\n  return {\n    [id]: {\n      // I think there may be some value in stringify-ing the data and storing in empty key, but I'm not sure\n      // Maybe it's for published data? Data that has no relations?\n      // It's more space efficient for the social contract if we limit the number of keys\n      \"\": JSON.stringify(data),\n      data, // so I'm just gonna do both for right now :)\n      metadata: { ...metadata, type },\n    },\n  };\n}\n\nconst store = (k, v) => Storage.privateSet(k, v);\nconst retrieve = (k) => Storage.privateGet(k);\n\n\nState.init({\n  debug: true,\n});\n\nconst accountId = context.accountId;\nconst Children = props.Children;\n\nlet theprops = { ...props };\ndelete theprops.Children;\n\nconst KEYS = {\n  selectedDoc: (pid) => `selectedDoc/${pid}`,\n  doc: (path) => `doc/${path}`, // having path here will let us always know the structure of the doc\n  docs: (pid) => `docs/${pid}`, // this should be the array of project docs\n  init: (pid) => `init/${pid}`, // lets us know when the project has been initialized\n};\nconst DOC_SEPARATOR = \".\";\nconst DEFAULT_TEMPLATE = \"create.near/widget/templates.project.doc\";\n\nconst handleDocument = {\n  /**\n   * Create, or updates, or deletes document in Local Storage\n   *\n   * if value is an object, then create or update the document\n   * if value is null, then delete the document\n   *\n   * @param {string} pid - project id\n   * @param {string} path - path to the document\n   * @param {object} value - the value to set at the path\n   *\n   * @returns {void} - nothing\n   */\n  set: (pid, path, value) => {\n    store(KEYS.doc(path), value);\n\n    // We need to keep track of the documents in the project\n    let paths = retrieve(KEYS.docs(pid));\n    paths = Array.isArray(paths) ? paths : [];\n\n    // If the document is being deleted, then we need to remove it from the docs array\n    if (value === null) {\n      const newDocs = paths.filter((docPath) => docPath !== path);\n      store(KEYS.docs(pid), newDocs);\n    }\n\n    // If the document is being created or updated, we need to make sure it's in the docs array\n    if (value !== null && !paths.includes(path)) {\n      store(KEYS.docs(pid), [...paths, path]);\n    }\n\n    // Open the new document\n    store(KEYS.selectedDoc(pid), path);\n  },\n\n  /**\n   * Wrapper for set that only updates the document keys\n   *\n   * @param {string} pid - project id\n   * @param {string} path - path to the document\n   * @param {object} value - the value to set at the path\n   * @returns {void} - nothing\n   *\n   * @example\n   * // This will update the document title, without afecting the content\n   * handle[\"document\"].update(projectId, path, { title: \"New Title\" });\n   */\n  update: (pid, path, value) => {\n    const doc = retrieve(KEYS.doc(path));\n    console.log(\"doc\", doc);\n    // TODO need to fix the structure\n    handleDocument.set(pid, path, {\n      data: {\n        ...doc.data,\n        ...value,\n      },\n      metadata: {\n        ...doc.metadata,\n        updatedAt: new Date().toISOString(),\n      },\n      _: {\n        inBuffer: true,\n      },\n    });\n  },\n\n  /**\n   * Wrapper for set that creates a new document under parent path\n   * @param {string} pid - project id (root id)\n   * @param {string} parentPath - optional path to the parent document\n   * @param {object} value - optional value to set at the path\n   */\n  create: (pid, parentPath, value) => {\n    if (!value) value = { title: \"\", content: \"\" };\n    if (!parentPath) parentPath = \"\";\n    const did = UUID.generate(\"xxxxxxx\");\n\n    const document = {\n      // I'm doing it this funny nested away cuz I'm trying to figure out a generic createThing\n      [did]: {\n        data: value,\n        metadata: {\n          createdAt: new Date().toISOString(),\n          type: \"create.near/type/document\",\n        },\n      },\n    };\n    const path = `${parentPath}${parentPath && DOC_SEPARATOR}${did}`;\n\n    // Now just using pid to help with Storage\n    handleDocument.set(pid, path, {\n      ...document[did],\n      _: {\n        inBuffer: true,\n      },\n    });\n  },\n\n  /**\n   * Wrapper for set that deletes a document\n   * @param {string} pid - project id\n   * @param {string} path - path to the document\n   * @returns {void} - nothing\n   */\n  delete: (pid, path) => handleDocument.set(pid, path, undefined),\n\n  /**\n   * Get a document from Local Storage\n   * @param {string} path - path to the document\n   * @returns {object} - the document\n   */\n  get: (path) => retrieve(KEYS.doc(path)),\n  // TODO: this should get from local storage first and then from SocialDB if not found\n\n  /**\n   * Get project documents from Local Storage\n   * @param {string} pid - project id\n   * @returns {object} - the documents\n   */\n  getAll: (pid) => {\n    let paths = retrieve(KEYS.docs(pid)) || [];\n    paths = Array.isArray(paths) ? paths : [];\n\n    let docs = {};\n    paths.forEach((path) => {\n      const doc = retrieve(KEYS.doc(path));\n      if (doc) docs[path] = retrieve(KEYS.doc(path));\n    });\n    return docs;\n  },\n\n  /**\n   * Get the selected document from Local Storage, if none is selected, then return the first document and open it\n   * @param {string} pid - project id\n   * @returns {path} - the path to the selected document\n   */\n  getSelected: (pid) => {\n    const selected = retrieve(KEYS.selectedDoc(pid));\n    if (selected) return selected;\n\n    const docs = handleDocument.getAll(pid);\n    const firstDoc = Object.keys(docs)[0];\n    if (firstDoc) {\n      handleDocument.open(pid, firstDoc);\n      return firstDoc;\n    }\n  },\n\n  // TODO\n  fetch: (did) => {\n    const doc = Social.get(`${accountId}/thing/${did}/**`);\n    return doc;\n  },\n\n  // TODO\n  fetchAll: (pid) => {\n    const docs = JSON.parse(Social.get(`${accountId}/thing/${pid}/documents`) || \"null\");\n    return docs;\n  },\n\n  // TODO\n  fetchAllTitles: (pid, path) => {\n    const docs = Social.get(`${accountId}/document/${pid}/*/title`);\n    return docs;\n  },\n\n  /**\n   * Set the selected document in Local Storage\n   * @param {string} pid - project id\n   * @param {string} path - path to the document\n   */\n  open: (pid, path) => store(KEYS.selectedDoc(pid), path),\n\n  /**\n   * Saves the document to SocialDB\n   * @param {string} pid - project id\n   * @param {string} path - path to the document\n   */\n  publish: (pid, path) => {\n    const doc = handleDocument.get(path);\n    delete doc._;\n    const did = path.split(DOC_SEPARATOR).pop();\n    \n    // TODO: check if document has already been added\n    function addDocumentToProject() {\n      const project = handleProject.get(pid);\n      const documents = JSON.parse(project.documents) || [];\n      // this holds the heirachical data\n      return {\n        thing: {\n          [pid]: {\n            documents: [...documents, path],\n          },\n        },\n      };\n    }\n\n    // TODO: check if project has already been added\n    function addProjectToDocument() {\n      const projects = JSON.parse(document[did].projects) || [];\n      return {\n        thing: {\n          [did]: {\n            projects: [...projects, pid],\n          },\n        },\n      };\n    }\n\n    const projectToDoc = addProjectToDocument(did, pid);\n    const docToProject = addDocumentToProject(pid, did);\n\n    //combine the json from createThing and addDocumentToProject\n    const combined = deepMerge(\n      deepMerge({ thing: { [did]: doc } }, projectToDoc),\n      docToProject\n    );\n\n    Social.set(combined, {\n      onCommit: () => {\n        handleDocument.set(pid, path, {\n          ...doc,\n          _: {\n            inBuffer: false,\n          },\n        });\n      },\n    });\n  },\n\n  /**\n   * Generates a new UID\n   * @returns {string} - the new UID\n   */\n  generateId: () => UUID.generate(\"xxxxxxx\"),\n};\n\nconst handleProject = {\n  getAll: () => {\n    return getAllThings(\"create.near/type/project\", [accountId]);\n  },\n  get: (pid) => {\n    return getThing(pid, [accountId]);\n  },\n  create: (project) => {\n    // TODO: this should be prehandled by the form\n    const tags = {};\n    project.tags.forEach((tag) => {\n      tags[tag] = \"\";\n    });\n    // currently setting project as metadata, need to match with typical metadata\n    Social.set({\n      thing: createThing(\"create.near/type/project\", {}, project),\n    });\n  },\n  delete: (pid) => {\n    Social.set({\n      thing: {\n        [pid]: null,\n      },\n    });\n  },\n  update: (pid, project) => {\n    Social.set({\n      thing: {\n        [pid]: project,\n      },\n    });\n  },\n\n  /**\n   * Fetches project documents from SocialDB and stores them in Local Storage,\n   * it does not override the local documents if updatedAt is more recent,\n   *\n   * @note I'm not sure if it's okay to store all documents in Local Storage, it may be too much data for big projects,\n   * I think it's better to use fetchTitle and fetch to get the document when user opens it, and then store it in Local Storage\n   * if edited.\n   *\n   * @param {string} pid - project id\n   * @returns {void} - nothing\n   */\n  init: (pid, force) => {\n    if (!pid) return;\n    if (!force) {\n      const lastInit = retrieve(KEYS.init(pid));\n      // if the project has already been initialized in the past 24 hours, then don't do it again\n      if (lastInit && new Date(lastInit) > new Date(Date.now() - 86400000))\n        return;\n    }\n\n    const docs = handleDocument.fetchAll(pid);\n    if (docs === null) return;\n\n    docs.forEach((path) => {\n      const doc = docs[path];\n      const localDoc = handleDocument.get(path);\n      if (!localDoc || new Date(doc.updatedAt) > new Date(localDoc.updatedAt)) {\n        handleDocument.set(pid, path, doc);\n      }\n    });\n\n    store(KEYS.init(pid), new Date().toISOString());\n    console.log(\"Project initialized\");\n  },\n};\n\n/**\n * Initialize\n */\nprops.project && handleProject.init(props.project);\n\nconst handleUtils = {\n  /**\n   * Unflatten the documents object\n   * @param {object} inputObject - the object to unflatten\n   * @returns {object} - the unflattened object\n   * @example\n   * \nconst input = {\n  702250: { title: \"\", content: \"\" },\n  \"702250.3cbbb3\": { title: \"\", content: \"\" },\n  \"702250.3cbbb3.acuont\": { title: \"\", content: \"\" },\n  \"702250.89thao\": { title: \"\", content: \"\" },\n};\n\nconst output = {\n  702250: {\n    title: \"\",\n    content: \"\",\n    children: {\n      \"3cbbb3\": {\n        title: \"\",\n        content: \"\",\n        children: {\n          acuont: { title: \"\", content: \"\" },\n        },\n      },\n      \"89thao\": {\n        title: \"\",\n        content: \"\",\n      },\n    },\n  },\n};\n    */\n  unflattenDocuments: (inputObject) => {\n    const result = {};\n\n    Object.keys(inputObject).forEach((key) => {\n      const keys = key.split(\".\");\n      let currentLevel = result;\n\n      keys.forEach((k, i) => {\n        if (i === keys.length - 1) {\n          // last key\n          currentLevel[k] = inputObject[key];\n        } else {\n          currentLevel[k] = currentLevel[k] || {};\n          currentLevel[k].children = currentLevel[k].children || {};\n          currentLevel = currentLevel[k].children;\n        }\n      });\n    });\n\n    return result;\n  },\n};\n\nconst handle = {\n  document: handleDocument,\n  project: handleProject,\n  utils: handleUtils,\n  other: { DOC_SEPARATOR },\n};\n\nif (Storage.privateGet(\"debug\")) {\n  const selectedDoc = handle[\"document\"].getSelected(props.project);\n  const doc = handle[\"document\"].get(selectedDoc);\n  const projectData = handle[\"project\"].get(props.project);\n\n  return (\n    <>\n      <Children handle={handle} {...theprops} />\n      <hr />\n      <Widget\n        src=\"nearui.near/widget/Input.Select\"\n        props={{\n          label: \"Debug\",\n          value: `${!!Storage.privateGet(\"debug\")}`,\n          onChange: (v) => {\n            Storage.privateSet(\"debug\", v === \"true\");\n          },\n          options: [\n            {\n              title: \"Enabled\",\n              value: true,\n            },\n            {\n              title: \"Disabled\",\n              value: false,\n            },\n          ],\n        }}\n      />\n      <hr />\n      <p>Selected Project: {props.project}</p>\n      Content:\n      <p style={{ maxHeight: 300, overflow: \"auto\" }}>\n        <Markdown text={\"```json \" + JSON.stringify(projectData, null, 2)} />\n      </p>\n      <hr />\n      <p>Selected Doc: {selectedDoc}</p>\n      Local Doc:\n      <p style={{ maxHeight: 300, overflow: \"auto\" }}>\n        <Markdown text={\"```json \" + JSON.stringify(doc, null, 2)} />\n      </p>\n      <hr />\n      All Local Docs:\n      <p style={{ maxHeight: 300, overflow: \"auto\" }}>\n        <Markdown\n          text={\n            \"```json \" +\n            JSON.stringify(handle[\"document\"].getAll(props.project), null, 2)\n          }\n        />\n      </p>\n      <button\n        onClick={() => {\n          store(KEYS.docs(props.project), []);\n        }}\n      >\n        clear local docs\n      </button>\n      <hr />\n      Fetched\n      <p style={{ maxHeight: 300, overflow: \"auto\" }}>\n        <Markdown\n          text={\n            \"```json \" +\n            JSON.stringify(\n              handle[\"document\"].fetch(props.project, selectedDoc),\n              null,\n              2\n            )\n          }\n        />\n      </p>\n      <hr />\n      Fetch All Titles\n      <p style={{ maxHeight: 300, overflow: \"auto\" }}>\n        <Markdown\n          text={\n            \"```json \" +\n            JSON.stringify(\n              handle[\"document\"].fetchAllTitles(props.project),\n              null,\n              2\n            )\n          }\n        />\n      </p>\n      <hr />\n      Fetch All\n      <p style={{ maxHeight: 300, overflow: \"auto\" }}>\n        <Markdown\n          text={\n            \"```json \" +\n            JSON.stringify(handle[\"document\"].fetchAll(props.project), null, 2)\n          }\n        />\n      </p>\n    </>\n  );\n}\n\nreturn (\n  <>\n    <Children handle={handle} {...theprops} />\n    <hr />\n    <Widget\n      src=\"nearui.near/widget/Input.Select\"\n      props={{\n        label: \"Debug\",\n        value: `${!!Storage.privateGet(\"debug\")}`,\n        onChange: (v) => {\n          Storage.privateSet(\"debug\", v === \"true\");\n        },\n        options: [\n          {\n            title: \"Enabled\",\n            value: true,\n          },\n          {\n            title: \"Disabled\",\n            value: false,\n          },\n        ],\n      }}\n    />\n    <hr />\n  </>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/create.near/widget/Provider", "fact_widget_deployments_id": "59674f94f508c77366266d40dafea872", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 0}