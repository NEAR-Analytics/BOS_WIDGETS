{"tx_hash": "Aqv5AWQ585ojiFnaE4eZNtkrs5qsYqwTM54RLiYKycDH", "action_id_social": "HqpwUL786bPUGX5Z6wsCzzPZHGYUQ49Qd91uayQ9tc1A-0-widget", "block_id": 114744787, "block_timestamp": "2024-03-15T08:21:14.901Z", "signer_id": "jass-build.near", "widget_name": "trialAccountWasm", "source_code": "const wasm = VM.require(\"jass-build.near/widget/trialAccountWasm\");\nconst contract = \"v2.keypom.near\";\n\n// Utility function to convert NEAR to YoctoNEAR (assuming it's not already provided)\n// const parseNearAmount = (nearAmount) => {\n//     return new BN(nearAmount).multipliedBy(new BN(\"1000000000000000000000000\")).toString();\n// };\n\nconst parseNearAmount = (nearAmount) => {\n  // YoctoNEAR per NEAR (1 NEAR = 10^24 YoctoNEAR)\n  console.log(nearAmount);\n  const nearToYocto = new Big(\"1000000000000000000000000\");\n  console.log(\n    nearAmount ? new Big(nearAmount).times(nearToYocto).toFixed() : \"0\"\n  );\n  return nearAmount ? new Big(nearAmount).times(nearToYocto).toFixed() : \"0\";\n};\n\nState.init({\n  callableContract: \"\",\n  maxAttachableYoctoPerContract: \"1\",\n  callableMethods: \"*\",\n  startingBalance: \"\",\n  trialEndFloor: \"\",\n});\n\nconst PARAM_START = \"|kP|\";\nconst PARAM_STOP = \"|kS|\";\n\nconst wrapTxnParamsForTrial = (params) => {\n  let newParams = {}; // Initialize newParams inside the function\n  Object.entries(params).forEach(([k, v]) => {\n    if (k === \"args\" && typeof v !== \"string\") {\n      v = JSON.stringify(v);\n    }\n    if (Array.isArray(v)) v = v.join();\n    newParams[PARAM_START + k] = v + PARAM_STOP;\n  });\n  return newParams;\n};\n\n// // What contracts can the trial account call?\n// const callableContracts = [\n//     'social.near'\n// ]\n// // What is the maximum amount of $NEAR that can be attached to a call for each callable contract?\n// const maxAttachableYoctoPerContract = [\n//     '1', //convert this into Yocto\n// ]\n// // What methods can the trial account call?\n// const callableMethods = [\n//     ['*'],\n// ]\n\nconst DROP_CONFIG = {\n  // How many claims can each key have.\n  uses_per_key: 1,\n\n  // Should the drop be automatically deleted when all the keys are used? This is defaulted to false and\n  // Must be overwritten\n  delete_on_empty: true,\n\n  // When this drop is deleted and it is the owner's *last* drop, automatically withdraw their balance.\n  auto_withdraw: true,\n\n  // Minimum block timestamp that keys can be used. If None, keys can be used immediately\n  // Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.\n  start_timestamp: null,\n\n  // How often can a key be used\n  // Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.\n  throttle_timestamp: null,\n\n  // If claim is called, refund the deposit to the owner's balance. If None, default to false.\n  on_claim_refund_deposit: null,\n\n  // Can the access key only call the claim method_name? Default to both method_name callable\n  claim_permission: null,\n\n  // Root account that all sub-accounts will default to. If None, default to the global drop root.\n  drop_root: null,\n};\n\nconst deployTrialAccount = () => {\n  const startingBalanceYocto = parseNearAmount(state.startingBalance);\n  const trialEndFloorYocto = parseNearAmount(state.trialEndFloor);\n\n  const callableContract = state.callableContract;\n  const maxAttachableYoctoPerContract = state.maxAttachableYoctoPerContract;\n  const callableMethods = state.callableMethods;\n\n  //Before you pass callableContract and other two varss to create_drop\n  //You need to add the mapping contract there too.\n  // callableContracts.push('v1.mapping.keypom.near'); ////testnet: 'v1.mapping.keypom.testnet',\n  const attachableForMapping = parseNearAmount(\"0.002\"); // put the equivent yocto amount\n\n  // Generate the proper args for setup:\n  let actualContracts = callableContract + \",v1.mapping.keypom.near\";\n  let actualAmounts =\n    maxAttachableYoctoPerContract + \",\" + attachableForMapping;\n  let actualMethods = callableMethods + \",\" + \"set\";\n\n  //Disclaimer to extend above logic to support Arrays, please refer to original keypom functions.\n\n  //Take the storage cost into consideration for the attached deposit and trial end floor\n  const storageCost = parseNearAmount(\"0.35\"); //Deposit for contract state, put in yocto\n  console.log(\"After storage\");\n  // const attachedDeposit = new BN(startingBalanceYocto).add(new BN(storageCost)).toString();\n  // trialEndFloorYocto = new BN(attachedDeposit).sub(new BN(trialEndFloorYocto)).toString();\n  const attachedDeposit = new Big(startingBalanceYocto)\n    .plus(new Big(storageCost))\n    .toFixed();\n  trialEndFloorYocto = new Big(attachedDeposit)\n    .minus(new Big(trialEndFloorYocto))\n    .toFixed();\n\n  console.log(\"Before storage\");\n\n  const repayAmountYocto = \"0\";\n  const repayTo = context.accountId;\n\n  const fcData = {\n    methods: [\n      [\n        {\n          receiver_id: \"near\",\n          method_name: \"create_account_advanced\",\n          //@ts-ignore\n          attached_deposit: attachedDeposit,\n          args: JSON.stringify({\n            new_account_id: \"INSERT_NEW_ACCOUNT\",\n            options: {\n              contract_bytes: wasm.contractBytes,\n              limited_access_keys: [\n                {\n                  public_key: \"INSERT_TRIAL_PUBLIC_KEY\",\n                  allowance: \"0\",\n                  receiver_id: \"INSERT_NEW_ACCOUNT\",\n                  method_names: \"execute,create_account_and_claim\",\n                },\n              ],\n            },\n          }),\n          user_args_rule: \"UserPreferred\",\n        },\n        {\n          receiver_id: \"\",\n          method_name: \"setup\",\n          attached_deposit: \"0\",\n          args: JSON.stringify(\n            wrapTxnParamsForTrial({\n              contracts: actualContracts,\n              amounts: actualAmounts,\n              methods: actualMethods,\n              funder: repayTo,\n              repay: repayAmountYocto,\n              floor: trialEndFloorYocto,\n            })\n          ),\n          receiver_to_claimer: true,\n        },\n      ],\n    ],\n  };\n\n  const drop_id = Date.now().toString();\n\n  const createDropArgs = {\n    drop_id: drop_id,\n    public_keys: [],\n    deposit_per_use: \"0\", // I don't know was this zero but we take this input from users\n    config: DROP_CONFIG,\n    //metadata,//unique identifer, don't need it for now I guess.\n    required_gas: \"150000000000000\",\n    fc: fcData,\n  };\n\n  Near.call(\n    contract,\n    \"create_drop\",\n    createDropArgs,\n    100000000000000,\n    550000000000000000000000\n  );\n};\n\nreturn (\n  <div class=\"p-3\">\n    <h3 class=\"text-center\">Trial Accounts powered by Keypom</h3>\n    <br />\n    {context.accountId ? (\n      <div class=\"border border-black p-3\">\n        <h3>Configure your trial</h3>\n        <div class=\"row\">\n          <div>\n            <input\n              placeholder=\"Starting Balance (NEAR)\"\n              onChange={(e) =>\n                State.update({ startingBalance: e.target.value })\n              }\n            />\n            <input\n              placeholder=\"Trial End Floor (NEAR)\"\n              onChange={(e) => State.update({ trialEndFloor: e.target.value })}\n            />\n            <input\n              placeholder=\"Callable Contract\"\n              onChange={(e) =>\n                State.update({ callableContract: e.target.value })\n              }\n            />\n          </div>\n        </div>\n        <button\n          class=\"btn btn-primary mt-2\"\n          onClick={async () => {\n            deployTrialAccount();\n          }}\n        >\n          Create Trial Account Drop\n        </button>\n      </div>\n    ) : (\n      <p class=\"text-center py-2\">Please connect your account</p>\n    )}\n    <br />\n  </div>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/jass-build.near/widget/trialAccountWasm", "fact_widget_deployments_id": "31b4f482e1230d5fa7f1f79c7c929307", "inserted_timestamp": "2024-03-15T09:29:45.656Z", "modified_timestamp": "2024-03-15T09:29:45.656Z", "__row_index": 1}