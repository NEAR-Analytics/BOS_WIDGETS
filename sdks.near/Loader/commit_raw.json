{"tx_hash": "BnJ4bBjq4ZGVCno2gB7Z48hsLCwdCtUXDF7RQFU6hiwZ", "action_id_social": "EsddVWLTW395XdbcBaFHDRyWcC2y23R5xNmteJZW95WT-0-widget", "block_id": 112182072, "block_timestamp": "2024-02-05T20:15:21.675Z", "signer_id": "sdks.near", "widget_name": "Loader", "source_code": "let TYPES = {};\nconst TYPE_LIBRARY = \"@\";\nconst TYPE_IMAGE = \"img:\";\nconst TYPE_JSON = \"json:\";\nconst TYPE_URL = \"url:\";\nTYPES[TYPE_LIBRARY] = \"libs\";\nTYPES[TYPE_IMAGE] = \"images\";\nTYPES[TYPE_JSON] = \"data\";\nTYPES[TYPE_URL] = \"links\";\n\nconst getWidgetPath = (account, dependency, version) => `${account}/widget/${dependency}${version ? `@${version}` : \"\"}`;\n\nlet loaders = {};\nloaders[TYPES[TYPE_LIBRARY]] = {\n  string: (account, dependency, version) => {\n    let result = {};\n    result[dependency.split(\".\").pop()] = VM.require(\n      getWidgetPath(account, dependency, version)\n    );\n    return result;\n  },\n  object: (account, dependencies, version) => {\n    let result = {};\n\n    if (Array.isArray(dependencies)) {\n      dependencies.map(\n        (dependency) =>\n          (result[dependency.split(\".\").pop()] = VM.require(\n            getWidgetPath(account, dependency, version)\n          ))\n      );\n    } else {\n      Object.keys(dependencies).map((containerName) =>\n        dependencies[containerName].map(\n          (dependency) =>\n            (result[dependency.split(\".\").pop()] = VM.require(\n              getWidgetPath(account, dependency, version)\n            ))\n        )\n      );\n    }\n\n    return result;\n  },\n  void: () => {},\n};\n\nloaders[TYPES[TYPE_IMAGE]] = {\n  string: (account, value) => value,\n  void: () => {},\n};\n\nloaders[TYPES[TYPE_URL]] = loaders[TYPES[TYPE_IMAGE]];\nloaders[TYPES[TYPE_JSON]] = {\n  string: (account, text) => JSON.parse(text),\n  object: (account, data) => data,\n  void: () => {},\n};\n\nconst getType = (type) => (type in TYPES ? TYPES[type] : null);\nconst getScope = (namespace) =>\n  namespace[0] in TYPES\n    ? namespace[0]\n    : namespace.substring(0, namespace.indexOf(\":\") + 1) in TYPES\n    ? namespace.substring(0, namespace.indexOf(\":\") + 1)\n    : null;\nconst getAccount = (scope, namespace) =>\n  `${namespace.substring(scope.length, namespace.indexOf(\"/\"))}.near`;\nconst getPath = (namespace) =>\n  namespace.substring(namespace.indexOf(\"/\") + 1, namespace.indexOf(\"#\") != -1 ? namespace.indexOf(\"#\") : namespace.length);\nconst getVersion = (namespace) => {\n  return namespace.indexOf(\"#\") != -1 ? namespace.substring(namespace.indexOf(\"#\") + 1, namespace.length) : \"latest\";\n}\n\nconst parseRequest = (namespace) => [\n  getAccount(getScope(namespace), namespace),\n  getType(getScope(namespace)),\n  getPath(namespace),\n  getVersion(namespace)\n];\nconst getManifest = (account) => VM.require(`${account}/widget/Manifest`);\nconst getResource = (manifest, resourceType) =>\n  resourceType in manifest ? manifest[resourceType] : {};\nconst getDependencies = (resource, path) =>\n  path.split(\"/\").reduce((path, nextPath) => (path || {})[nextPath], resource);\nconst loadDependencies = (account, loaderName, dependencies) =>\n  loaders[loaderName || TYPES[TYPE_LIBRARY]][\n    typeof dependencies !== \"undefined\" ? typeof dependencies : \"void\"\n  ](account, dependencies);\n\nconst mapVersion = (version, path, manifest) => {\n  let dependency = path.split(\"/\").shift();\n  let releases = manifest[\"releases\"] || {};\n\n  return version && dependency in releases && version in releases[dependency] ? releases[dependency][version] : null;\n}\n\nconst load = (account, resourceType, path, version) => {\n  const manifest = getManifest(account) || {};\n\n  return loadDependencies(\n    account,\n    resourceType,\n    getDependencies(getResource(manifest, resourceType), path),\n    mapVersion(version, path, manifest)\n  );\n}\n\nconst statefulLoad = (Store, status, namespace) => {\n    let defaultValue = namespace.includes(\"hook\") ? () => {} : {};\n    console.log(namespace, defaultValue, { [namespace]: {defaultValue} })\n\n    Store.update({ [namespace]: defaultValue });\n    let library = load(...parseRequest(namespace));\n    \n    const checkDependencyLoaded = () => {\n      setTimeout(() => {\n        if (library) {\n          Store.update({ [namespace]: library });\n        } else {\n          checkDependencyLoaded();\n        }\n      }, 200);\n    }\n\n    checkDependencyLoaded();\n\n    return status[namespace];\n}\n\nreturn (namespace) => {\n  if (Array.isArray(namespace)) {\n    return (actualNamespace) => {\n        return statefulLoad(namespace[0], namespace[1], actualNamespace);\n    };\n  }\n\n  return load(...parseRequest(namespace));\n}", "metadata": {"fork_of": "sdks.near/widget/Loader@112181633"}, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/sdks.near/widget/Loader", "fact_widget_deployments_id": "50bb783c631580e2b15ff17b63265d03", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 6}