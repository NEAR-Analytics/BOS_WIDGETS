{"tx_hash": "4nsj6Gr1vzEkEgswEKpcrsx7okcqpV2CubbqPzS9bHoF", "action_id_social": "BGjmAbHv9M3cRupzsQKMCXCPXPdhKHNAUjB3P8kLZUiK-0-widget", "block_id": 112184766, "block_timestamp": "2024-02-05T21:07:38.603Z", "signer_id": "sdks.near", "widget_name": "Loader", "source_code": "let TYPES = {};\nconst TYPE_LIBRARY = \"@\";\nconst TYPE_IMAGE = \"img:\";\nconst TYPE_JSON = \"json:\";\nconst TYPE_URL = \"url:\";\nTYPES[TYPE_LIBRARY] = \"libs\";\nTYPES[TYPE_IMAGE] = \"images\";\nTYPES[TYPE_JSON] = \"data\";\nTYPES[TYPE_URL] = \"links\";\n\nconst getWidgetPath = (account, dependency, version) => `${account}/widget/${dependency}${version ? `@${version}` : \"\"}`;\n\nlet loaders = {};\nloaders[TYPES[TYPE_LIBRARY]] = {\n  string: (account, dependency, version) => {\n    let result = {};\n    result[dependency.split(\".\").pop()] = VM.require(\n      getWidgetPath(account, dependency, version)\n    );\n    return result;\n  },\n  object: (account, dependencies, version) => {\n    let result = {};\n\n    if (Array.isArray(dependencies)) {\n      dependencies.map(\n        (dependency) =>\n          (result[dependency.split(\".\").pop()] = VM.require(\n            getWidgetPath(account, dependency, version)\n          ))\n      );\n    } else {\n      Object.keys(dependencies).map((containerName) =>\n        dependencies[containerName].map(\n          (dependency) =>\n            (result[dependency.split(\".\").pop()] = VM.require(\n              getWidgetPath(account, dependency, version)\n            ))\n        )\n      );\n    }\n\n    return result;\n  },\n  void: () => {},\n};\n\nloaders[TYPES[TYPE_IMAGE]] = {\n  string: (account, value) => value,\n  void: () => {},\n};\n\nloaders[TYPES[TYPE_URL]] = loaders[TYPES[TYPE_IMAGE]];\nloaders[TYPES[TYPE_JSON]] = {\n  string: (account, text) => JSON.parse(text),\n  object: (account, data) => data,\n  void: () => {},\n};\n\nconst getType = (type) => (type in TYPES ? TYPES[type] : null);\nconst getScope = (namespace) =>\n  namespace[0] in TYPES\n    ? namespace[0]\n    : namespace.substring(0, namespace.indexOf(\":\") + 1) in TYPES\n    ? namespace.substring(0, namespace.indexOf(\":\") + 1)\n    : null;\nconst getAccount = (scope, namespace) =>\n  `${namespace.substring(scope.length, namespace.indexOf(\"/\"))}.near`;\nconst getPath = (namespace) =>\n  namespace.substring(namespace.indexOf(\"/\") + 1, namespace.indexOf(\"#\") != -1 ? namespace.indexOf(\"#\") : namespace.length);\nconst getVersion = (namespace) => {\n  return namespace.indexOf(\"#\") != -1 ? namespace.substring(namespace.indexOf(\"#\") + 1, namespace.length) : \"latest\";\n}\n\nconst parseRequest = (namespace) => [\n  getAccount(getScope(namespace), namespace),\n  getType(getScope(namespace)),\n  getPath(namespace),\n  getVersion(namespace)\n];\nconst getManifest = (account) => VM.require(`${account}/widget/Manifest`);\nconst getResource = (manifest, resourceType) =>\n  resourceType in manifest ? manifest[resourceType] : {};\nconst getDependencies = (resource, path) =>\n  path.split(\"/\").reduce((path, nextPath) => (path || {})[nextPath], resource);\nconst loadDependencies = (account, loaderName, dependencies) =>\n  loaders[loaderName || TYPES[TYPE_LIBRARY]][\n    typeof dependencies !== \"undefined\" ? typeof dependencies : \"void\"\n  ](account, dependencies);\n\nconst mapVersion = (version, path, manifest) => {\n  let dependency = path.split(\"/\").shift();\n  let releases = manifest[\"releases\"] || {};\n\n  return version && dependency in releases && version in releases[dependency] ? releases[dependency][version] : null;\n}\n\nconst load = (account, resourceType, path, version) => {\n  const manifest = getManifest(account) || {};\n\n  return loadDependencies(\n    account,\n    resourceType,\n    getDependencies(getResource(manifest, resourceType), path),\n    mapVersion(version, path, manifest)\n  );\n}\n\nreturn (namespace, status) => {\n  if (typeof namespace === \"object\" && !Array.isArray(namespace)) {\n    const StatefulLoader = {\n        Store: namespace,\n        status: status,\n        load: (namespace) => {\n            if (!StatefulLoader.status[namespace]) {\n                let defaultValue = namespace.includes(\"hook\") ? () => {} : {};\n\n                StatefulLoader.Store.update({ [namespace]: {} });\n                let library = load(...parseRequest(namespace));\n                console.log(\"Status \", StatefulLoader.status);\n                \n                const checkDependencyLoaded = () => {\n                    setTimeout(() => {\n                        if (library) {\n                            StatefulLoader.Store.update({ [namespace]: library });\n                        } else {\n                            checkDependencyLoaded();\n                        }\n                    }, 200);\n                }\n\n\n                checkDependencyLoaded();\n                return StatefulLoader.status[namespace] || {};\n            }\n\n            return StatefulLoader.status[namespace];\n        }\n    }\n\n    return (actualNamespace) => {\n        return StatefulLoader.load(actualNamespace);\n    };\n  }\n\n  return load(...parseRequest(namespace));\n}", "metadata": {"fork_of": "sdks.near/widget/Loader@112182072"}, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/sdks.near/widget/Loader", "fact_widget_deployments_id": "134e3a611d539bd48670d6a8f0a62933", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 5}