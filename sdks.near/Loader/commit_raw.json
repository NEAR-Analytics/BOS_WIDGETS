{"tx_hash": "2Qs7oQeyt5K1dvKajyiAKbNjge4gWP82Hsgxz2LfU9ZR", "action_id_social": "Hx8ajnuDf66j5ijLrZFzZWq4eBbapDeRwnY8o9eXTD2q-0-widget", "block_id": 112197225, "block_timestamp": "2024-02-06T01:02:43.052Z", "signer_id": "sdks.near", "widget_name": "Loader", "source_code": "let TYPES = {};\nconst TYPE_LIBRARY = \"@\";\nconst TYPE_IMAGE = \"img:\";\nconst TYPE_JSON = \"json:\";\nconst TYPE_URL = \"url:\";\nTYPES[TYPE_LIBRARY] = \"libs\";\nTYPES[TYPE_IMAGE] = \"images\";\nTYPES[TYPE_JSON] = \"data\";\nTYPES[TYPE_URL] = \"links\";\n\nconst getWidgetPath = (account, dependency, version) => `${account}/widget/${dependency}${version ? `@${version}` : \"\"}`;\n\nlet loaders = {};\nloaders[TYPES[TYPE_LIBRARY]] = {\n  string: (account, dependency, version, Store) => {\n    if (Store) {\n      let name = dependency.split(\".\").pop();\n\n      Store.update({\n        [name]: VM.require(getWidgetPath(account, dependency, version))\n      });\n\n      return Store.get(name) || {};\n    } else {\n      let result = {};\n      result[dependency.split(\".\").pop()] = VM.require(\n        getWidgetPath(account, dependency, version)\n      );\n      return result;\n    }\n  },\n  object: (account, dependencies, version) => {\n    let result = {};\n\n    if (Array.isArray(dependencies)) {\n      dependencies.map(\n        (dependency) =>\n          (result[dependency.split(\".\").pop()] = VM.require(\n            getWidgetPath(account, dependency, version)\n          ))\n      );\n    } else {\n      Object.keys(dependencies).map((containerName) =>\n        dependencies[containerName].map(\n          (dependency) =>\n            (result[dependency.split(\".\").pop()] = VM.require(\n              getWidgetPath(account, dependency, version)\n            ))\n        )\n      );\n    }\n\n    return result;\n  },\n  void: () => {},\n};\n\nloaders[TYPES[TYPE_IMAGE]] = {\n  string: (account, value) => value,\n  void: () => {},\n};\n\nloaders[TYPES[TYPE_URL]] = loaders[TYPES[TYPE_IMAGE]];\nloaders[TYPES[TYPE_JSON]] = {\n  string: (account, text) => JSON.parse(text),\n  object: (account, data) => data,\n  void: () => {},\n};\n\nconst getType = (type) => (type in TYPES ? TYPES[type] : null);\nconst getScope = (namespace) =>\n  namespace[0] in TYPES\n    ? namespace[0]\n    : namespace.substring(0, namespace.indexOf(\":\") + 1) in TYPES\n    ? namespace.substring(0, namespace.indexOf(\":\") + 1)\n    : null;\nconst getAccount = (scope, namespace) =>\n  `${namespace.substring(scope.length, namespace.indexOf(\"/\"))}.near`;\nconst getPath = (namespace) =>\n  namespace.substring(namespace.indexOf(\"/\") + 1, namespace.indexOf(\"#\") != -1 ? namespace.indexOf(\"#\") : namespace.length);\nconst getVersion = (namespace) => {\n  return namespace.indexOf(\"#\") != -1 ? namespace.substring(namespace.indexOf(\"#\") + 1, namespace.length) : \"latest\";\n}\n\nconst parseRequest = (namespace) => [\n  getAccount(getScope(namespace), namespace),\n  getType(getScope(namespace)),\n  getPath(namespace),\n  getVersion(namespace)\n];\nconst getManifest = (account) => VM.require(`${account}/widget/Manifest`);\nconst getResource = (manifest, resourceType) =>\n  resourceType in manifest ? manifest[resourceType] : {};\nconst getDependencies = (resource, path) =>\n  path.split(\"/\").reduce((path, nextPath) => (path || {})[nextPath], resource);\nconst loadDependencies = (account, loaderName, dependencies, Store) =>\n  loaders[loaderName || TYPES[TYPE_LIBRARY]][\n    typeof dependencies !== \"undefined\" ? typeof dependencies : \"void\"\n  ](account, dependencies, Store);\n\nconst mapVersion = (version, path, manifest) => {\n  let dependency = path.split(\"/\").shift();\n  let releases = manifest[\"releases\"] || {};\n\n  return version && dependency in releases && version in releases[dependency] ? releases[dependency][version] : null;\n}\n\nconst load = (account, resourceType, path, version, Store) => {\n  const manifest = getManifest(account) || {};\n\n  return loadDependencies(\n    account,\n    resourceType,\n    getDependencies(getResource(manifest, resourceType), path),\n    mapVersion(version, path, manifest),\n    Store\n  );\n}\n\nreturn (namespace, Store) => load(...parseRequest(namespace), Store);", "metadata": {"fork_of": "sdks.near/widget/Loader@112184972"}, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/sdks.near/widget/Loader", "fact_widget_deployments_id": "a91b0e7aae48eb659f7dba821a801a97", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 16}