{"tx_hash": "6UCnAmcfkPAtVdEKPiSMzZJ9FjRFS5tr8PEqouAVLohX", "action_id_social": "3DnrrAjXeeoJXyPd4soM8dGsqJvC1dLTbqyGABojnvnv-0-widget", "block_id": 117455701, "block_timestamp": "2024-04-23T14:31:25.726Z", "signer_id": "sdks.near", "widget_name": "SDKs.Sputnik.DaoSDK", "source_code": "const filterFunction = (item, filterStatusArray, filterKindArray) => {\n  const kind = typeof item.kind === \"string\" ? item.kind : Object.keys(item.kind)[0];\n  if (filterStatusArray.length > 0 && filterKindArray.length > 0) {\n    return filterStatusArray.includes(item.status) && filterKindArray.includes(kind);\n  } else if (filterKindArray.length > 0) {\n    return filterKindArray.includes(kind);\n  } else if (filterStatusArray.length > 0) {\n    return filterStatusArray.includes(item.status);\n  }\n  return true;\n};\n\nreturn (daoId, proposalId, factoryId) => {\n  const DaoSDK = {\n    getDaoVersion: () => {\n      return Near.view(daoId, \"version\");\n    },\n    getPolicy: () => {\n      return Near.view(daoId, \"get_policy\");\n    },\n    getConfig: () => {\n      return Near.view(daoId, \"get_config\");\n    },\n\n    // PROPOSALS\n    getProposalById: ({ proposalId }) => {\n      return Near.view(daoId, \"get_proposal\", {\n        id: parseInt(proposalId),\n      });\n    },\n    getLastProposalId: () => {\n      return Near.view(daoId, \"get_last_proposal_id\");\n    },\n    getProposals: ({ offset, limit }) => {\n      return Near.view(daoId, \"get_proposals\", {\n        from_index: offset,\n        limit: limit,\n      });\n    },\n    // reverse: boolean, resPerPage: number, filterStatusArray:Array<string>, offset: number\n    getFilteredProposalsByStatus: ({ resPerPage, reverse, filterStatusArray, offset }) => {\n      let newLastProposalId = offset ?? 0;\n      let filteredProposals = [];\n      const limit = 30;\n      const lastProposalId = DaoSDK.getLastProposalId();\n      if (reverse && !offset) {\n        newLastProposalId = lastProposalId;\n      }\n      const promiseArray = [];\n      while ((reverse && newLastProposalId > 0) || (!reverse && newLastProposalId < lastProposalId)) {\n        promiseArray.push(\n          Near.asyncView(daoId, \"get_proposals\", {\n            from_index: newLastProposalId - limit > 0 ? newLastProposalId - limit : 0,\n            limit: limit,\n          }),\n        );\n        if (reverse) {\n          newLastProposalId -= limit;\n        } else {\n          newLastProposalId += limit;\n        }\n      }\n      return Promise.all(promiseArray).then((res) => {\n        const proposals = [].concat(...res);\n        filteredProposals = proposals.filter((item) => filterStatusArray.includes(item.status));\n        const newArray = filteredProposals.slice(0, resPerPage);\n        if (reverse) {\n          newArray.reverse();\n        }\n        return {\n          filteredProposals: newArray,\n          totalLength: filteredProposals.length,\n        };\n      });\n    },\n    // reverse: boolean, resPerPage: number, filterKindArray:Array<string>, offset: number\n    getFilteredProposalsByKind: ({ resPerPage, reverse, filterKindArray, offset }) => {\n      let newLastProposalId = offset ?? 0;\n      const limit = 30;\n      const lastProposalId = DaoSDK.getLastProposalId();\n      if (reverse && !offset) {\n        newLastProposalId = lastProposalId;\n      }\n      const promiseArray = [];\n      while ((reverse && newLastProposalId > 0) || (!reverse && newLastProposalId < lastProposalId)) {\n        promiseArray.push(\n          Near.asyncView(daoId, \"get_proposals\", {\n            from_index: newLastProposalId - limit > 0 ? newLastProposalId - limit : 0,\n            limit: limit,\n          }),\n        );\n        if (reverse) {\n          newLastProposalId -= limit;\n        } else {\n          newLastProposalId += limit;\n        }\n      }\n      return Promise.all(promiseArray).then((res) => {\n        const proposals = [].concat(...res);\n        const filteredProposals = proposals.filter((item) => {\n          const kind = typeof kind === \"string\" ? kind : Object.keys(item.kind)[0];\n          return filterKindArray.includes(kind);\n        });\n        const newArray = filteredProposals.slice(0, resPerPage);\n        if (reverse) {\n          newArray.reverse();\n        }\n        return {\n          filteredProposals: newArray,\n          totalLength: filteredProposals.length,\n        };\n      });\n    },\n    getFilteredProposalsByStatusAndkind: ({ resPerPage, reverse, filterKindArray, filterStatusArray, offset }) => {\n      let newLastProposalId = offset ?? 0;\n      let filteredProposals = [];\n      const lastProposalId = DaoSDK.getLastProposalId();\n      const limit = 30;\n      if (reverse && !offset) {\n        newLastProposalId = lastProposalId;\n      }\n      const promiseArray = [];\n      while ((reverse && newLastProposalId > 0) || (!reverse && newLastProposalId < lastProposalId)) {\n        promiseArray.push(\n          Near.asyncView(daoId, \"get_proposals\", {\n            from_index: newLastProposalId - limit > 0 ? newLastProposalId - limit : 0,\n            limit: limit,\n          }),\n        );\n        if (reverse) {\n          newLastProposalId -= limit;\n        } else {\n          newLastProposalId += limit;\n        }\n      }\n      return Promise.all(promiseArray).then((res) => {\n        const proposals = [].concat(...res);\n        filteredProposals = proposals.filter((item) => filterFunction(item, filterStatusArray, filterKindArray));\n        const newArray = filteredProposals.slice(0, resPerPage);\n        if (reverse) {\n          newArray.reverse();\n        }\n        return {\n          filteredProposals: newArray,\n          totalLength: filteredProposals.length,\n        };\n      });\n    },\n    // ROLES + PERMISSIONS + PROPOSALS\n    // returns array of members for a particular groupId\n    getMembersByGroupId: ({ groupId }) => {\n      const policy = DaoSDK.getPolicy(daoId);\n      return Array.isArray(policy.roles)\n        ? policy?.roles\n            .filter((role) => role.name === groupId)\n            .map((role) => {\n              const group = role.kind.Group;\n              return group;\n            })?.[0]\n        : [];\n    },\n    // return [{ members:{},permissions:{},name:\"\" }]\n    getGroupsAndMembers: () => {\n      const policy = DaoSDK.getPolicy(daoId);\n      const data = [];\n      if (Array.isArray(policy.roles)) {\n        policy.roles.map((role) => {\n          data.push({\n            name: role.name,\n            permissions: role.permissions,\n            members: role.kind.Group,\n          });\n        });\n      }\n      return data;\n    },\n    // returns a boolean indicating whether the user has the specified permission or not\n    hasPermission: ({ accountId, kindName, actionType }) => {\n      const isAllowed = false;\n      const policy = DaoSDK.getPolicy(daoId);\n      if (Array.isArray(policy.roles)) {\n        const permissions = policy.roles.map((role) => {\n          if (Array.isArray(role.kind.Group) && role.kind.Group.includes(accountId)) {\n            return (\n              role.permissions.includes(`${DaoSDK.proposalKinds[kindName].toString()}:${actionType.toString()}`) ||\n              role.permissions.includes(`${DaoSDK.proposalKinds[kindName].toString()}:*`) ||\n              role.permissions.includes(`*:${actionType.toString()}`) ||\n              role.permissions.includes(\"*:*\")\n            );\n          }\n        });\n        isAllowed = permissions.some((element) => element === true);\n      }\n      return isAllowed;\n    },\n    getVotersAndThresholdForProposalKind: ({ kindName }) => {\n      const policy = DaoSDK.getPolicy(daoId);\n      let eligibleVotersArray = [];\n      let thresholdVoteCount = 0;\n      if (Array.isArray(policy.roles)) {\n        policy.roles.forEach((role) => {\n          const isRoleAllowedToVote =\n            role.permissions.includes(`${DaoSDK.proposalKinds[kindName]}:VoteApprove`) ||\n            role.permissions.includes(`${DaoSDK.proposalKinds[kindName]}:VoteReject`) ||\n            role.permissions.includes(`${DaoSDK.proposalKinds[kindName]}:*`) ||\n            role.permissions.includes(`*:VoteApprove`) ||\n            role.permissions.includes(`*:VoteReject`) ||\n            role.permissions.includes(\"*:*\");\n          if (isRoleAllowedToVote) {\n            const threshold = (role.vote_policy && role.vote_policy[DaoSDK.proposalKinds[kindName]]?.threshold) ||\n              policy[\"default_vote_policy\"]?.threshold || [0, 0];\n            if (Array.isArray(role.kind.Group)) {\n              for (const account of role.kind.Group) {\n                if (!eligibleVotersArray.includes(account)) {\n                  eligibleVotersArray.push(account);\n                }\n              }\n            }\n            const eligibleVotersLength = role.kind.Group ? role.kind.Group.length : 0;\n            if (eligibleVoters === 0) {\n              return;\n            }\n            const votesNeeded = Math.floor((threshold[0] / threshold[1]) * eligibleVotersLength) + 1;\n            thresholdVoteCount += votesNeeded;\n          }\n        });\n      }\n      return { eligibleVotersArray, thresholdVoteCount };\n    },\n    calculateVoteCountByType: ({ votes }) => {\n      let totalVotes = {\n        approve: 0,\n        reject: 0,\n        spam: 0,\n        total: 0,\n      };\n      for (const vote of Object.values(votes)) {\n        if (vote === \"Approve\") {\n          totalVotes.approve++;\n        } else if (vote === \"Reject\") {\n          totalVotes.reject++;\n        } else if (vote === \"Spam\") {\n          totalVotes.spam++;\n        }\n      }\n      totalVotes.total = totalVotes.approve + totalVotes.reject + totalVotes.spam;\n      return totalVotes;\n    },\n    getProposalExpirationTime: ({ submissionTime }) => {\n      const policy = DaoSDK.getPolicy();\n      const proposalPeriod = policy.proposal_period;\n      let expirationTime = Big(submissionTime).add(Big(proposalPeriod));\n      return expirationTime;\n    },\n    getCommentsByProposalId: ({ proposalId }) => {\n      return Social.index(\"comment\", {\n        type: \"dao_proposal_comment\",\n        path: `${daoId}/proposal/main`,\n        proposal_id: proposalId + \"-beta\",\n      });\n    },\n    // returns user/accountId status about membership of specified roles within a DAO or has an active proposal for membership within a defined search range\n    checkIsMemberOrPending: ({ accountId, rolesToCheck, searchRange }) => {\n      if (!accountId) {\n        return false;\n      }\n      if (!Array.isArray(rolesToCheck)) {\n        rolesToCheck = [\"council\"];\n      }\n      const range = searchRange ?? 100;\n\n      const lastProposalId = DaoSDK.getLastProposalId();\n\n      const policy = DaoSDK.getPolicy();\n      const isDaoMember = false;\n      const lastProposals =\n        DaoSDK.getProposals({\n          offset: lastProposalId - range,\n          limit: range,\n        }) || [];\n\n      const alreadyMadeAProposal =\n        lastProposals.filter((proposal) => {\n          return (\n            proposal.proposer === accountId &&\n            proposal.status === \"InProgress\" &&\n            Object.keys(proposal.kind ?? {})?.[0] === \"AddMemberToRole\"\n          );\n        }).length > 0;\n\n      if (Array.isArray(policy.roles)) {\n        policy.roles\n          .filter((role) => rolesToCheck.includes(role.name))\n          .map((role) => {\n            if (Array.isArray(role.kind.Group) && !isDaoMember) {\n              isDaoMember = role.kind.Group.includes(accountId);\n            }\n          });\n      }\n      return { isDaoMember, alreadyMadeAProposal };\n    },\n\n    // BOUNTIES\n    getBountyById: ({ bountyId }) => {\n      return Near.view(daoId, \"get_bounty\", {\n        id: bountyId,\n      });\n    },\n    getBountyNoOfClaims: ({ bountyId }) => {\n      return Near.view(daoId, \"get_bounty_number_of_claims\", {\n        id: bountyId,\n      });\n    },\n    getBountyClaimsByAccountId: ({ accountId }) => {\n      return Near.view(daoId, \"get_bounty_claims\", {\n        account_id: accountId,\n      });\n    },\n\n    // UTILS\n    call: ({ methodName, args, deposit, gas, additionalCalls }) => {\n      const calls = [\n        {\n          contractName: daoId,\n          methodName,\n          args,\n          deposit: deposit,\n          gas: gas,\n        },\n      ];\n      if (Array.isArray(additionalCalls)) {\n        calls = calls.concat(additionalCalls);\n      }\n      return Near.call(calls);\n    },\n    voteActions: {\n      VoteApprove: \"VoteApprove\",\n      VoteReject: \"VoteReject\",\n      VoteRemove: \"VoteRemove\",\n    },\n    proposalKinds: {\n      ChangeConfig: \"config\",\n      ChangePolicy: \"policy\",\n      AddMemberToRole: \"add_member_to_role\",\n      RemoveMemberFromRole: \"remove_member_from_role\",\n      FunctionCall: \"call\",\n      UpgradeSelf: \"upgrade_self\",\n      UpgradeRemote: \"upgrade_remote\",\n      Transfer: \"transfer\",\n      SetStakingContract: \"set_vote_token\",\n      AddBounty: \"add_bounty\",\n      BountyDone: \"bounty_done\",\n      Vote: \"vote\",\n      FactoryInfoUpdate: \"factory_info_update\",\n      ChangePolicyAddOrUpdateRole: \"policy_add_or_update_role\",\n      ChangePolicyRemoveRole: \"policy_remove_role\",\n      ChangePolicyUpdateDefaultVotePolicy: \"policy_update_default_vote_policy\",\n      ChangePolicyUpdateParameters: \"policy_update_parameters\",\n      Text: \"Text\",\n    },\n    decodeArgs: ({ args }) => {\n      try {\n        const args64 = args;\n        const jsonArgs = JSON.parse(Buffer.from(args64, \"base64\").toString(\"utf-8\"));\n        return JSON.stringify(jsonArgs, undefined, 2);\n      } catch {\n        return \"failed to deserialize\";\n      }\n    },\n\n    // PROPOSALS\n    addProposal: ({ proposal, deposit, gas, additionalCalls }) => {\n      const policy = DaoSDK.getPolicy();\n      if (!policy) {\n        return;\n      }\n      const minDeposit = Big(policy?.proposal_bond);\n      // make sure that the deposit is more/equal than bond amount\n      const finalDeposit = Big(deposit).gt(minDeposit) ? Big(deposit) : minDeposit;\n\n      return DaoSDK.call({\n        methodName: \"add_proposal\",\n        args: {\n          proposal: proposal,\n        },\n        deposit: finalDeposit.toFixed(),\n        gas,\n        additionalCalls,\n      });\n    },\n    createDao: ({ daoName, args, deposit, gas, additionalCalls }) => {\n      const daoArgs = Buffer.from(JSON.stringify(args), \"utf-8\").toString(\"base64\");\n      const calls = [\n        {\n          contractName: \"sputnik-dao.near\",\n          methodName: \"create\",\n          args: {\n            name: daoName,\n            args: daoArgs,\n          },\n          deposit,\n          gas,\n        },\n      ];\n      if (Array.isArray(additionalCalls)) {\n        calls = calls.concat(additionalCalls);\n      }\n      return Near.call(calls);\n    },\n\n    // SPECIFIC PROPOSALS\n    createAddMemberProposal: ({ description, memberId, roleId, gas, deposit, additionalCalls }) => {\n      return DaoSDK.addProposal({\n        proposal: {\n          description: description,\n          kind: {\n            AddMemberToRole: {\n              member_id: memberId,\n              role: roleId,\n            },\n          },\n        },\n        deposit,\n        gas,\n        additionalCalls,\n      });\n    },\n    createRemoveMemberProposal: ({ description, memberId, roleId, gas, deposit, additionalCalls }) => {\n      return DaoSDK.addProposal({\n        proposal: {\n          description: description,\n          kind: {\n            RemoveMemberFromRole: {\n              member_id: memberId,\n              role: roleId,\n            },\n          },\n        },\n        deposit,\n        gas,\n        additionalCalls,\n      });\n    },\n    createPollProposal: ({ description, gas, deposit, additionalCalls }) => {\n      return DaoSDK.addProposal({\n        proposal: {\n          description: description,\n          kind: \"Vote\",\n        },\n        deposit,\n        gas,\n        additionalCalls,\n      });\n    },\n    createTransferProposal: ({ description, tokenId, receiverId, amount, gas, deposit, additionalCalls }) => {\n      return DaoSDK.addProposal({\n        proposal: {\n          description: description,\n          kind: {\n            Transfer: {\n              token_id: tokenId,\n              receiver_id: receiverId,\n              amount,\n            },\n          },\n        },\n        deposit,\n        gas,\n        additionalCalls,\n      });\n    },\n    createBountyProposal: ({ description, bounty, gas, deposit, additionalCalls }) => {\n      return DaoSDK.addProposal({\n        proposal: {\n          description: description,\n          kind: {\n            AddBounty: {\n              bounty,\n            },\n          },\n        },\n        deposit,\n        gas,\n        additionalCalls,\n      });\n    },\n    createSubmitBountyProposal: ({ description, bounty, receiverId, gas, deposit, additionalCalls }) => {\n      return DaoSDK.addProposal({\n        proposal: {\n          description: description,\n          kind: {\n            BountyDone: {\n              receiver_id: receiverId,\n              bounty_id: JSON.parse(bounty.id),\n            },\n          },\n        },\n        deposit,\n        gas,\n        additionalCalls,\n      });\n    },\n    createFunctionCallProposal: ({\n      description,\n      methodName,\n      receiverId,\n      args,\n      proposalGas,\n      proposalDeposit,\n      gas,\n      deposit,\n      additionalCalls,\n    }) => {\n      const proposal_args = Buffer.from(JSON.stringify(args), \"utf-8\").toString(\"base64\");\n      return DaoSDK.addProposal({\n        proposal: {\n          description: description,\n          kind: {\n            FunctionCall: {\n              receiver_id: receiverId,\n              actions: [\n                {\n                  method_name: methodName,\n                  args: proposal_args,\n                  deposit: proposalDeposit,\n                  gas: proposalGas,\n                },\n              ],\n            },\n          },\n        },\n        deposit,\n        gas,\n        additionalCalls,\n      });\n    },\n\n    // VOTE\n    actProposal: ({ proposalId, action, deposit, gas, additionalCalls }) => {\n      return DaoSDK.call({\n        methodName: \"act_proposal\",\n        args: {\n          id: proposalId,\n          action,\n        },\n        deposit,\n        gas,\n        additionalCalls,\n      });\n    },\n\n    // SPECIFIC VOTE TXN\n    approveProposal: ({ proposalId, deposit, gas, additionalCalls }) => {\n      return DaoSDK.actProposal({\n        proposalId,\n        action: DaoSDK.voteActions.VoteApprove,\n        deposit,\n        gas,\n        additionalCalls,\n      });\n    },\n    rejectProposal: ({ proposalId, deposit, gas, additionalCalls }) => {\n      return DaoSDK.actProposal({\n        proposalId,\n        action: DaoSDK.voteActions.VoteReject,\n        deposit,\n        gas,\n        additionalCalls,\n      });\n    },\n    removeProposal: ({ proposalId, deposit, gas, additionalCalls }) => {\n      return DaoSDK.actProposal({\n        id: proposalId,\n        action: DaoSDK.voteActions.VoteRemove,\n        deposit,\n        gas,\n        additionalCalls,\n      });\n    },\n\n    // BOUNTIES\n    claimBounty: ({ bounty, gas, deposit, additionalCalls }) => {\n      return DaoSDK.call({\n        methodName: \"bounty_claim\",\n        args: {\n          id: JSON.parse(bounty.id),\n          deadline: bounty.max_deadline,\n        },\n        deposit,\n        gas,\n        additionalCalls,\n      });\n    },\n    unclaimBounty: ({ bounty, gas, deposit, additionalCalls }) => {\n      return DaoSDK.call({\n        methodName: \"bounty_giveup\",\n        args: {\n          id: JSON.parse(bounty.id),\n        },\n        deposit,\n        gas,\n        additionalCalls,\n      });\n    },\n  };\n  return DaoSDK;\n};\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/sdks.near/widget/SDKs.Sputnik.DaoSDK", "fact_widget_deployments_id": "8a562b65f7e63fed0376e36700ee2b57", "inserted_timestamp": "2024-04-23T17:54:15.847Z", "modified_timestamp": "2024-04-23T17:54:15.847Z", "__row_index": 5}