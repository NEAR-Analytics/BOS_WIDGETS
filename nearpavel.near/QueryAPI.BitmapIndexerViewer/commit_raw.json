{"tx_hash": "Eo6SJyw7WBCXxHVjU5BAgk9LTRpYA2SYSfBphvGggTtW", "action_id_social": "4JMqH4LYuy4SK23NFh65A4LtodgYSaEG4eQ9ZGuuKtnu-0-widget", "block_id": 114299449, "block_timestamp": "2024-03-08T01:26:48.574Z", "signer_id": "nearpavel.near", "widget_name": "QueryAPI.BitmapIndexerViewer", "source_code": "State.init({\n  accountId: \"*.ref-finance.near\",\n  data: [],\n});\n\nconst QUERYAPI_ENDPOINT = `https://near-queryapi.dev.api.pagoda.co/v1/graphql`;\n\nconst query = `query MyQuery {\n    nearpavel_near_bitmap_v1_actions_index(\n      where: {receiver_id: {_ilike: \"${state.accountId.replace(\"*\", \"%\")}\"}}\n    ) {\n      block_date\n      receiver_id\n      bitmap\n      first_block_height\n    }\n  }`;\nfunction fetchGraphQL(operationsDoc, operationName, variables) {\n  return asyncFetch(QUERYAPI_ENDPOINT, {\n    method: \"POST\",\n    headers: { \"x-hasura-role\": `nearpavel_near` },\n    body: JSON.stringify({\n      query: operationsDoc,\n      variables: variables,\n      operationName: operationName,\n    }),\n  });\n}\n\nif (state.loadedAccountId !== state.accountId) {\n  State.update({ loading: true });\n  fetchGraphQL(query, \"MyQuery\", {}).then((result) => {\n    State.update({ loading: false, loadedAccountId: state.accountId });\n    if (result.status === 200) {\n      if (result.body.data) {\n        const data = result.body.data.nearpavel_near_bitmap_v1_actions_index;\n        State.update({ data });\n        console.log(data);\n      }\n    }\n  });\n}\n\nfunction bitmapToString(buffer) {\n  return buffer.reduce((r, b) => r + b.toString(2).padStart(8, \"0\"), \"\");\n}\n\n// bit packing: converts array of indexes to a bitmap packed into Uint8Array\n// example: [0,1,6] -> \"11000010\" -> [194]\nfunction indexArrayToBitmap(arr) {\n  const lastItem = arr[arr.length - 1];\n  return arr.reduce((bytes, bit) => {\n    bytes[Math.floor(bit / 8)] |= 1 << (7 - (bit % 8));\n    return bytes;\n  }, new Uint8Array(Math.floor(lastItem / 8) + 2));\n}\n\n// example: [0,1,6] -> \"11000010\"\nfunction indexArrayToBitmapString(arr) {\n  return bitmapToString(indexArrayToBitmap(arr));\n}\n\n// example: \"0101\" -> [1,3]\nfunction bitmapStringToIndexArray(strBits) {\n  const result = [];\n  for (let i = 0; i < strBits.length; i++) {\n    if (strBits[i] === \"1\") {\n      result.push(i);\n    }\n  }\n  return result;\n}\n\n// returns first number x and corresponding coded string length of the first occurrence of\n// Elias gamma coding. E.g. for \"0101\" returns {x:2,len:3}\nfunction decodeEliasGammaFirstEntry(strBits) {\n  if (strBits === \"\") return { x: 0, len: 0 };\n  const N = strBits.indexOf(\"1\");\n  if (N < 0) {\n    return { x: 0, len: strBits.length };\n  }\n  const remainder = strBits.slice(N + 1, 2 * N + 1);\n  return { x: Math.pow(2, N) + (parseInt(remainder, 2) || 0), len: 2 * N + 1 };\n}\n\nfunction decompressBitmapString(compressedStrBit) {\n  let target = compressedStrBit[0];\n  let result = \"\";\n  let remainder = compressedStrBit.slice(1);\n  while (remainder.length) {\n    const { x, len } = decodeEliasGammaFirstEntry(remainder);\n    result += target.repeat(x);\n    target = target === \"0\" ? \"1\" : \"0\";\n    remainder = remainder.slice(len);\n    if (len === 0) break; // we won't find any Elias gamma here, exiting\n  }\n  return result;\n}\n\nfunction decompressBase64(compressedBase64) {\n  if (!compressedBase64 || compressedBase64 === \"\") {\n    return new Uint8Array(0);\n  }\n  const bitmap = bitmapToString(Buffer.from(compressedBase64, \"base64\"));\n  return decompressBitmapString(bitmap);\n}\n\nfunction indexArrayFromCompressedBase64(compressedBase64) {\n  const decompressedBase64 = decompressBase64(compressedBase64);\n  return bitmapStringToIndexArray(decompressedBase64);\n}\n\nconst renderData = (a) => {\n  if (a.length === 0) {\n    return <div>no blocks found</div>;\n  }\n  return (\n    <div key={a.block_date}>\n      <strong>{a.block_date}</strong>:{\" \"}\n      {indexArrayFromCompressedBase64(a.bitmap)\n        .map((idx) => a.first_block_height + idx)\n        .join(\", \")}\n    </div>\n  );\n};\n\nconst renderedData = state.data.map(renderData);\n\nreturn (\n  <>\n    <h2>QueryAPI Bitmap Indexer</h2>\n    <a href=\"https://near.org/dev-queryapi.dataplatform.near/widget/QueryApi.App?selectedIndexerPath=nearpavel.near/bitmap_v1\">\n      Read source code\n    </a>\n    <Widget\n      src=\"near/widget/DIG.Input\"\n      props={{\n        placeholder: \"Account Id\",\n        onInput: (e) => State.update({ accountId: e.target.value }),\n        value: state.accountId,\n      }}\n    />\n    {state.loading && <div>Fetching QueryAPI Bitmap Index</div>}\n    {!state.loading && state.data.length === 0 && (\n      <div>No blocks found in QueryAPI Bitmap Index</div>\n    )}\n    {state.data.length > 0 && <div>{renderedData}</div>}\n  </>\n);\n", "metadata": {"fork_of": "nearpavel.near/widget/QueryAPI.BitmapIndexerViewer@114298843"}, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/nearpavel.near/widget/QueryAPI.BitmapIndexerViewer", "fact_widget_deployments_id": "0902a8307c8720ac0910a34ed4ccd7b3", "inserted_timestamp": "2024-03-08T02:32:51.558Z", "modified_timestamp": "2024-03-08T02:32:51.558Z", "__row_index": 1}