{"tx_hash": "CimoCxTBnGmF7zS86185uRCpfbeck5n2pYehvdTQPEhK", "action_id_social": "Gmdwzi2Tko4z8igdkLXdRDrmPxVbcSgarL8LVN91V2Xc-0-widget", "block_id": 99880759, "block_timestamp": "2023-08-28T21:44:40.058Z", "signer_id": "mattlock.near", "widget_name": "op-bridge-demo-sepolia", "source_code": "// for Sepolia\nconst OP_BRIDGE_DEPOSIT_CONTRACT = \"0x16Fc5058F25648194471939df75CF27A2fdC48BC\";\nconst OP_BRIDGE_WITHDRAW_CONTRACT =\n  \"0x4200000000000000000000000000000000000010\";\nconst ETH_ADDR = \"0x0000000000000000000000000000000000000000\";\nconst ETH_ADDR_L1 = `0xdeaddeaddeaddeaddeaddeaddeaddeaddead0000`;\nconst DEFAULT_AMOUNT_ETH = \"0.01\";\nconst DEFAULT_AMOUNT = ethers.utils.parseUnits(DEFAULT_AMOUNT_ETH, 18);\nconst L2_OUTPUT_ORACLE_CONTRACT = `0x90E9c4f8a994a250F6aEfd61CAFb4F2e895D458F`;\nconst L1_OPTIMISM_PORTAL_CONTRACT = `0x16Fc5058F25648194471939df75CF27A2fdC48BC`;\nconst HASH_ZERO =\n  \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n// Withdrawal target TX info\n// Call initiateWithdraw so the L2 message is passed\n// Following TX example here: https://goerli-optimism.etherscan.io/tx/0xb59ff0af1db39be0cc03e7410621ed21ce60e5833f8c4bf97d8747bd8d033bc8\n// Manually adjusted amount to 0.01\nconst ETH_WITHDRAWAL_MESSAGE = `0x32b7006d000000000000000000000000deaddeaddeaddeaddeaddeaddeaddeaddead0000000000000000000000000000000000000000000000000000002386f26fc10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000000`;\nconst ETH_WITHDRAWAL_TARGET = `0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000`;\n\n// Storage keys\nconst STORAGE_RECEIPT_HASH = \"__STORAGE_RECEIPT_HASH\";\nconst STORAGE_RESOLVED = \"__STORAGE_RESOLVED\";\nconst STORAGE_MESSAGE_SLOT = \"__STORAGE_MESSAGE_SLOT\";\nconst STORAGE_L2_INDEX = \"__STORAGE_L2_INDEX\";\n\nState.init({\n  console: \"Welcome!\",\n  transactionHash: Storage.privateGet(STORAGE_RECEIPT_HASH),\n  resolved: Storage.privateGet(STORAGE_RESOLVED),\n  messageSlot: Storage.privateGet(STORAGE_MESSAGE_SLOT),\n  l2OutputIndex: Storage.privateGet(STORAGE_L2_INDEX),\n});\n\nconst opSepoliaProvider = new ethers.providers.JsonRpcProvider(\n  \"https://sepolia.optimism.io\"\n);\nconst goerliProvider = new ethers.providers.JsonRpcProvider(\n  \"https://gateway.tenderly.co/public/sepolia\"\n);\n\nconst provider = Ethers.provider();\nconst sender = Ethers.send(\"eth_requestAccounts\", [])[0];\n\nconst { chainId } = state;\n\nif (sender) {\n  Ethers.provider()\n    .getNetwork()\n    .then(({ chainId }) => {\n      State.update({ chainId });\n    });\n  Ethers.provider()\n    .getBalance(sender)\n    .then((rawBalance) => {\n      const balance = ethers.utils.formatEther(rawBalance);\n      State.update({ balance });\n    });\n}\n\nconst isMainnet = chainId === 1 || chainId === 10;\nconst isOPSepolia = chainId === 11155420;\nconst isSepolia = chainId === 11155111;\n\nconst bridgeAbi = [\n  {\n    inputs: [\n      { internalType: \"uint32\", name: \"_l2Gas\", type: \"uint32\" },\n      { internalType: \"bytes\", name: \"_data\", type: \"bytes\" },\n    ],\n    name: \"depositETH\",\n    outputs: [],\n    stateMutability: \"payable\",\n    type: \"function\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"from\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"to\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes\",\n        name: \"extraData\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"ETHDepositInitiated\",\n    type: \"event\",\n  },\n];\nconst bridgeIface = new ethers.utils.Interface(bridgeAbi);\n\nconst withdrawAbi = [\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"_l2Token\",\n        type: \"address\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"_amount\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"uint32\",\n        name: \"_minGasLimit\",\n        type: \"uint32\",\n      },\n      {\n        internalType: \"bytes\",\n        name: \"_extraData\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"withdraw\",\n    outputs: [],\n    stateMutability: \"payable\",\n    type: \"function\",\n  },\n];\nconst withdrawIface = new ethers.utils.Interface(withdrawAbi);\n\nconst outputAbi = [\n  {\n    inputs: [\n      {\n        internalType: \"uint256\",\n        name: \"_l2BlockNumber\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"getL2OutputIndexAfter\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    stateMutability: \"view\",\n    type: \"function\",\n    inputs: [\n      {\n        name: \"_l2OutputIndex\",\n        internalType: \"uint256\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"getL2Output\",\n    outputs: [\n      {\n        name: \"\",\n        internalType: \"struct Types.OutputProposal\",\n        type: \"tuple\",\n        components: [\n          {\n            name: \"outputRoot\",\n            internalType: \"bytes32\",\n            type: \"bytes32\",\n          },\n          {\n            name: \"timestamp\",\n            internalType: \"uint128\",\n            type: \"uint128\",\n          },\n          {\n            name: \"l2BlockNumber\",\n            internalType: \"uint128\",\n            type: \"uint128\",\n          },\n        ],\n      },\n    ],\n  },\n];\nconst outputIface = new ethers.utils.Interface(outputAbi);\n\nconst proofAbi = [\n  {\n    inputs: [\n      {\n        components: [\n          {\n            internalType: \"uint256\",\n            name: \"nonce\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"address\",\n            name: \"sender\",\n            type: \"address\",\n          },\n          {\n            internalType: \"address\",\n            name: \"target\",\n            type: \"address\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"value\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"gasLimit\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"bytes\",\n            name: \"data\",\n            type: \"bytes\",\n          },\n        ],\n        internalType: \"struct Types.WithdrawalTransaction\",\n        name: \"_tx\",\n        type: \"tuple\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"_l2OutputIndex\",\n        type: \"uint256\",\n      },\n      {\n        components: [\n          {\n            internalType: \"bytes32\",\n            name: \"version\",\n            type: \"bytes32\",\n          },\n          {\n            internalType: \"bytes32\",\n            name: \"stateRoot\",\n            type: \"bytes32\",\n          },\n          {\n            internalType: \"bytes32\",\n            name: \"messagePasserStorageRoot\",\n            type: \"bytes32\",\n          },\n          {\n            internalType: \"bytes32\",\n            name: \"latestBlockhash\",\n            type: \"bytes32\",\n          },\n        ],\n        internalType: \"struct Types.OutputRootProof\",\n        name: \"_outputRootProof\",\n        type: \"tuple\",\n      },\n      {\n        internalType: \"bytes[]\",\n        name: \"_withdrawalProof\",\n        type: \"bytes[]\",\n      },\n    ],\n    name: \"proveWithdrawalTransaction\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n];\nconst proofIface = new ethers.utils.Interface(proofAbi);\n\nfunction handleDepositETH() {\n  if (!isSepolia)\n    return State.update({\n      console: `switch to Sepolia Testnet (not Optimism Sepolia, ETH Sepolia) to deposit ETH to OP Sepolia`,\n    });\n\n  const encodedData = bridgeIface.encodeFunctionData(\n    \"depositETH(uint32, bytes)\",\n    [200000, 0]\n  );\n\n  Ethers.provider()\n    .getSigner()\n    .sendTransaction({\n      to: OP_BRIDGE_DEPOSIT_CONTRACT,\n      data: encodedData,\n      value: DEFAULT_AMOUNT,\n      gasLimit,\n    })\n    .then((tx) => {\n      consle.log(\"tx:\", tx);\n    })\n    .catch((e) => {\n      console.log(\"bridge error:\", e);\n    });\n}\n\nfunction handleWithdrawalInitiating() {\n  console.log(\"withdraw\");\n\n  const encodedData = withdrawIface.encodeFunctionData(\n    \"withdraw(address, uint256, uint32, bytes)\",\n    [ETH_WITHDRAWAL_TARGET, DEFAULT_AMOUNT, 0, []]\n  );\n\n  console.log(\"encoded\", encodedData);\n\n  Ethers.provider()\n    .getSigner()\n    .sendTransaction({\n      to: OP_BRIDGE_WITHDRAW_CONTRACT,\n      data: encodedData,\n      value: DEFAULT_AMOUNT,\n      gasLimit,\n    })\n    .then((tx) => {\n      consle.log(\"tx:\", tx);\n    })\n    .catch((e) => {\n      console.log(\"bridge error:\", e);\n    });\n}\n\nconst handleWithdrawalReceipt = () => {\n  if (!isOPSepolia) {\n    return State.update({ console: `please switch to OP Sepolia` });\n  }\n\n  const { transactionHash } = state;\n\n  const receiptError =\n    \"error getting receipt for txHash, check hash and try again\";\n\n  provider\n    .getTransaction(transactionHash)\n    .then((receipt) => {\n      if (!receipt) {\n        return State.update({ console: receiptError });\n      }\n\n      const {\n        nonce: messageNonce,\n        from: sender,\n        to: target,\n        value,\n        data: message,\n        blockNumber,\n      } = receipt;\n\n      const resolved = {\n        messageNonce,\n        sender,\n        target,\n        value: value.toString(),\n        minGasLimit: 0,\n        message,\n        direction: 1,\n        logIndex: 0,\n        blockNumber,\n        transactionHash,\n      };\n\n      Storage.privateSet(STORAGE_RESOLVED, resolved);\n      State.update({ console: \"Receipt Updated \u2705\" });\n      console.log(resolved);\n    })\n    .catch((e) => {\n      console.log(e);\n      State.update({\n        console: receiptError,\n      });\n    });\n};\n\nconst getMessageBedrockOutput = (l2BlockNumber, callback) => {\n  const contract = new ethers.Contract(\n    L2_OUTPUT_ORACLE_CONTRACT,\n    outputAbi,\n    goerliProvider\n  );\n\n  console.log(\"L2_OUTPUT_ORACLE_CONTRACT\", contract);\n\n  contract\n    .getL2OutputIndexAfter(l2BlockNumber)\n    .then((l2OutputIndex) => {\n      console.log(\"l2OutputIndex:\", l2OutputIndex.toString());\n\n      contract\n        .getL2Output(l2OutputIndex.toString())\n        .then((proposal) => {\n          console.log(\"proposal data:\", proposal);\n\n          callback({\n            outputRoot: proposal[0],\n            l1Timestamp: proposal[1].toNumber(),\n            l2BlockNumber: proposal[2].toNumber(),\n            l2OutputIndex: l2OutputIndex.toNumber(),\n          });\n        })\n        .catch((e) => {\n          console.log(\"view error 2:\", e);\n        });\n    })\n    .catch((e) => {\n      console.log(\"view error 1:\", e);\n    });\n};\n\nconst hashLowLevelMessage = (withdrawal) => {\n  const types = [\n    \"uint256\",\n    \"address\",\n    \"address\",\n    \"uint256\",\n    \"uint256\",\n    \"bytes\",\n  ];\n  const encoded = ethers.utils.defaultAbiCoder.encode(types, [\n    withdrawal.messageNonce,\n    withdrawal.sender,\n    withdrawal.target,\n    withdrawal.value,\n    withdrawal.minGasLimit,\n    withdrawal.message,\n  ]);\n  return ethers.utils.keccak256(encoded);\n};\n\nconst hashMessageHash = (messageHash) => {\n  const data = ethers.utils.defaultAbiCoder.encode(\n    [\"bytes32\", \"uint256\"],\n    [ethers.utils.hexlify(messageHash), 0]\n  );\n  return ethers.utils.keccak256(data);\n};\n\nconst handleWithdrawalProof = () => {\n  console.log(\"handleWithdrawalProof\");\n\n  const { resolved } = state;\n  // TODO translate resolved back to Big instead of replacing here\n  resolved.value = DEFAULT_AMOUNT;\n\n  getMessageBedrockOutput(resolved.blockNumber, (output) => {\n    console.log(\"getMessageBedrockOutput:\", output);\n    const hash = hashLowLevelMessage(resolved);\n    console.log(\"hash\", hash);\n    const messageSlot = hashMessageHash(hash);\n    console.log(\"messageSlot\", messageSlot);\n\n    Storage.privateSet(STORAGE_MESSAGE_SLOT, messageSlot);\n    Storage.privateSet(STORAGE_L2_INDEX, output.l2OutputIndex);\n\n    State.update({ console: `Proof data updated \u2705` });\n  });\n};\n\nconst getBedrockMessageProof = (l2BlockNumber, slot, callback) => {\n  l2BlockNumber = l2BlockNumber.replace(\"0x0\", \"0x\");\n  console.log(`getBedrockMessageProof`, l2BlockNumber, slot);\n\n  opSepoliaProvider\n    .send(\"eth_getProof\", [\n      OP_BRIDGE_WITHDRAW_CONTRACT,\n      [slot],\n      l2BlockNumber.replace(\"0x0\", \"0x\"),\n    ])\n    .then((proof) => {\n      const stateTrieProof = {\n        accountProof: proof.accountProof,\n        storageProof: proof.storageProof[0].proof,\n        storageValue: Big(parseInt(proof.storageProof[0].value)),\n        storageRoot: proof.storageHash,\n      };\n      console.log(\"stateTrieProof\", stateTrieProof);\n\n      opSepoliaProvider\n        .send(\"eth_getBlockByNumber\", [l2BlockNumber, false])\n        .then((block) => {\n          console.log(\"block\", block);\n\n          callback({\n            outputRootProof: {\n              version: HASH_ZERO,\n              stateRoot: block.stateRoot,\n              messagePasserStorageRoot: stateTrieProof.storageRoot,\n              latestBlockhash: block.hash,\n            },\n            withdrawalProof: stateTrieProof.storageProof,\n            l2OutputIndex: state.l2OutputIndex,\n          });\n        });\n    });\n};\n\nconst handleWithdrawalProve = () => {\n  const { resolved, messageSlot } = state;\n  const blockNumber = ethers.utils.hexlify(resolved.blockNumber);\n  console.log(\"blockNumber\", blockNumber);\n\n  getBedrockMessageProof(blockNumber, messageSlot, (proof) => {\n    const { resolved: withdrawal, l2OutputIndex } = state;\n\n    const args = [\n      [\n        withdrawal.messageNonce,\n        withdrawal.sender,\n        withdrawal.target,\n        withdrawal.value,\n        withdrawal.minGasLimit,\n        withdrawal.message,\n      ],\n      proof.l2OutputIndex,\n      [\n        proof.outputRootProof.version,\n        proof.outputRootProof.stateRoot,\n        proof.outputRootProof.messagePasserStorageRoot,\n        proof.outputRootProof.latestBlockhash,\n      ],\n      proof.withdrawalProof,\n    ];\n\n    console.log(\"proof args:\", args);\n\n    if (!isSepolia) {\n      const error = \"switch to Sepolia to sign the proof\";\n      console.log(error);\n      return State.update({\n        console: error,\n      });\n    }\n\n    const contract = new ethers.Contract(\n      L1_OPTIMISM_PORTAL_CONTRACT,\n      proofAbi,\n      Ethers.provider().getSigner()\n    );\n\n    contract\n      .proveWithdrawalTransaction(...args)\n      .then((tx) => {\n        console.log(\"tx output:\", tx);\n      })\n      .catch((e) => {\n        console.log(\"error\", e);\n      });\n  });\n};\n\nif (!sender) {\n  return (\n    <div className=\"w3button\">\n      <Web3Connect connectLabel=\"Connect to a wallet\" />\n    </div>\n  );\n}\n\nreturn (\n  <div>\n    <h3>Console:</h3>\n    <p>{state.console}</p>\n    {!isSepolia && !isOPSepolia && (\n      <p>Please switch to ETH Sepolia or OP Sepolia</p>\n    )}\n    {isSepolia && (\n      <>\n        <h3>Network: ETH Sepolia</h3>\n        <p>Balance: {state.balance} ETH</p>\n\n        {/*<h3>Deposits & Withdrawals</h3>\n        <Widget src={`ciocan.near/widget/op-bridge-list`} />*/}\n\n        <button onClick={handleDepositETH}>\n          Deposit {DEFAULT_AMOUNT_ETH} ETH to L2\n        </button>\n        <br />\n        <br />\n        <p>To initiate a withdraw, switch to OP Sepolia network</p>\n\n        {state.messageSlot && (\n          <>\n            <br />\n            <br />\n            <button onClick={handleWithdrawalProve}>\n              Step3. Prove Withdrawal\n            </button>\n          </>\n        )}\n      </>\n    )}\n    {isOPSepolia && (\n      <>\n        <h3>Network: OP Sepolia</h3>\n        <p>Balance: {state.balance} ETH</p>\n        {/*<h3>Deposits & Withdrawals</h3>\n        <Widget src={`ciocan.near/widget/op-bridge-list`} />*/}\n\n        <button onClick={handleWithdrawalInitiating}>\n          Initiate Withdrawal of {DEFAULT_AMOUNT_ETH} ETH on L2\n        </button>\n        <br />\n        <br />\n        <p>\n          To make a deposit, or prove a withdraw, switch to ETH Sepolia network\n        </p>\n\n        <h3>Get Withdrawal Receipt from L2 TX Hash:</h3>\n        <input\n          placeholder=\"withdrawal tx hash\"\n          value={state.transactionHash}\n          onChange={({ target: { value } }) => {\n            State.update({ transactionHash: value });\n            Storage.privateSet(STORAGE_RECEIPT_HASH, value);\n          }}\n          type=\"text\"\n        />\n        <br />\n        <button onClick={handleWithdrawalReceipt}>\n          Step 1. Get Withdrawal Receipt\n        </button>\n\n        {state.transactionHash && (\n          <>\n            <br />\n            <br />\n            <button onClick={handleWithdrawalProof}>\n              Step 2. Get Withdrawal Proof Data\n            </button>\n          </>\n        )}\n        {state.messageSlot && (\n          <>\n            <br />\n            <br />\n            <button onClick={handleWithdrawalProve}>\n              Step3. Prove Withdrawal\n            </button>\n          </>\n        )}\n      </>\n    )}\n  </div>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/mattlock.near/widget/op-bridge-demo-sepolia", "fact_widget_deployments_id": "13e6e821ed6562124ecfff300354c80a", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 0}