{"tx_hash": "BN8Fj7VFW2hcDh8ZZhuSVit6ov9dsyPZUxWhEkTED6Ce", "action_id_social": "5by5QwUCLD32FLVsFL3YmJubkcavWBPsrnPLSMdeGwcR-0-widget", "block_id": 99492695, "block_timestamp": "2023-08-23T18:47:14.188Z", "signer_id": "mattlock.near", "widget_name": "op-bridge-demo", "source_code": "// for goerli\nconst OP_BRIDGE_DEPOSIT_CONTRACT = \"0x636Af16bf2f682dD3109e60102b8E1A089FedAa8\";\nconst OP_BRIDGE_WITHDRAW_CONTRACT =\n  \"0x4200000000000000000000000000000000000010\";\nconst ETH_ADDR = \"0x0000000000000000000000000000000000000000\";\nconst ETH_ADDR_L1 = `0xdeaddeaddeaddeaddeaddeaddeaddeaddead0000`;\nconst DEFAULT_AMOUNT_ETH = \"0.01\";\nconst DEFAULT_AMOUNT = ethers.utils.parseUnits(DEFAULT_AMOUNT_ETH, 18);\nconst L2_OUTPUT_ORACLE_CONTRACT = `0xE6Dfba0953616Bacab0c9A8ecb3a9BBa77FC15c0`;\n\n// Withdrawal target TX info\n// Call initiateWithdraw so the L2 message is passed\n// Following TX example here: https://goerli-optimism.etherscan.io/tx/0xb59ff0af1db39be0cc03e7410621ed21ce60e5833f8c4bf97d8747bd8d033bc8\n// Manually adjusted amount to 0.01\nconst ETH_WITHDRAWAL_MESSAGE = `0x32b7006d000000000000000000000000deaddeaddeaddeaddeaddeaddeaddeaddead0000000000000000000000000000000000000000000000000000002386f26fc10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000000`;\nconst ETH_WITHDRAWAL_CONTRACT = `0x4200000000000000000000000000000000000016`;\nconst ETH_WITHDRAWAL_TARGET = `0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000`;\n\n// Storage keys\nconst STORAGE_RESOLVED = \"__STORAGE_RESOLVED\";\nconst STORAGE_MESSAGE_SLOT = \"__STORAGE_MESSAGE_SLOT\";\nconst STORAGE_L2_INDEX = \"__STORAGE_L2_INDEX\";\n\nState.init({\n  console: \"Welcome!\",\n  transactionHash: `0x38082f56332ef0c5640487a47412aace70db81cdd0bb40e9a896a85953324ba0`,\n  resolved: Storage.privateGet(STORAGE_RESOLVED),\n  messageSlot: Storage.privateGet(STORAGE_MESSAGE_SLOT),\n  l2OutputIndex: Storage.privateGet(STORAGE_L2_INDEX),\n});\n\nconst opGoerliProvider = new ethers.providers.JsonRpcProvider(\n  \"https://goerli.optimism.io\"\n);\nconst goerliProvider = new ethers.providers.JsonRpcProvider(\n  \"https://rpc.ankr.com/eth_goerli\"\n);\n\nconst provider = Ethers.provider();\nconst sender = Ethers.send(\"eth_requestAccounts\", [])[0];\n\nconst { chainId } = state;\n\nif (sender) {\n  Ethers.provider()\n    .getNetwork()\n    .then(({ chainId }) => {\n      State.update({ chainId });\n    });\n}\n\nconst isMainnet = chainId === 1 || chainId === 10;\nconst isOPGoerli = chainId === 420;\nconst isGoerli = chainId === 5;\n\nconst bridgeAbi = [\n  {\n    inputs: [\n      { internalType: \"uint32\", name: \"_l2Gas\", type: \"uint32\" },\n      { internalType: \"bytes\", name: \"_data\", type: \"bytes\" },\n    ],\n    name: \"depositETH\",\n    outputs: [],\n    stateMutability: \"payable\",\n    type: \"function\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"from\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"to\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes\",\n        name: \"extraData\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"ETHDepositInitiated\",\n    type: \"event\",\n  },\n];\nconst bridgeIface = new ethers.utils.Interface(bridgeAbi);\n\nconst withdrawAbi = [\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"_l2Token\",\n        type: \"address\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"_amount\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"uint32\",\n        name: \"_minGasLimit\",\n        type: \"uint32\",\n      },\n      {\n        internalType: \"bytes\",\n        name: \"_extraData\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"withdraw\",\n    outputs: [],\n    stateMutability: \"payable\",\n    type: \"function\",\n  },\n];\nconst withdrawIface = new ethers.utils.Interface(withdrawAbi);\n\nconst outputAbi = [\n  {\n    inputs: [\n      {\n        internalType: \"uint256\",\n        name: \"_l2BlockNumber\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"getL2OutputIndexAfter\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    stateMutability: \"view\",\n    type: \"function\",\n    inputs: [\n      {\n        name: \"_l2OutputIndex\",\n        internalType: \"uint256\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"getL2Output\",\n    outputs: [\n      {\n        name: \"\",\n        internalType: \"struct Types.OutputProposal\",\n        type: \"tuple\",\n        components: [\n          {\n            name: \"outputRoot\",\n            internalType: \"bytes32\",\n            type: \"bytes32\",\n          },\n          {\n            name: \"timestamp\",\n            internalType: \"uint128\",\n            type: \"uint128\",\n          },\n          {\n            name: \"l2BlockNumber\",\n            internalType: \"uint128\",\n            type: \"uint128\",\n          },\n        ],\n      },\n    ],\n  },\n];\nconst outputIface = new ethers.utils.Interface(outputAbi);\n\nconst crossDomainAbi = [\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"_target\",\n        type: \"address\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"_gasLimit\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"bytes\",\n        name: \"_data\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"initiateWithdrawal\",\n    outputs: [],\n    stateMutability: \"payable\",\n    type: \"function\",\n  },\n];\nconst crossDomainIface = new ethers.utils.Interface(crossDomainAbi);\n\nfunction handleDepositETH() {\n  if (!isGoerli)\n    return State.update({\n      console: `switch to Goerli Testnet (not Optimism Goerli, ETH Goerli) to deposit ETH to OP Goerli`,\n    });\n\n  const encodedData = bridgeIface.encodeFunctionData(\n    \"depositETH(uint32, bytes)\",\n    [200000, 0]\n  );\n\n  Ethers.provider()\n    .getSigner()\n    .sendTransaction({\n      to: OP_BRIDGE_DEPOSIT_CONTRACT,\n      data: encodedData,\n      value: DEFAULT_AMOUNT,\n      gasLimit,\n    })\n    .then((tx) => {\n      consle.log(\"tx:\", tx);\n    })\n    .catch((e) => {\n      console.log(\"bridge error:\", e);\n    });\n}\n\nfunction handleWithdrawalInitiating() {\n  if (!isOPGoerli)\n    return State.update({\n      console: `switch to OP Goerli testnet to initiate a withdrawal transaction`,\n    });\n\n  console.log(\"withdraw\");\n\n  const encodedData = crossDomainIface.encodeFunctionData(\n    \"initiateWithdrawal(address, uint256, bytes)\",\n    [ETH_WITHDRAWAL_TARGET, 0, ETH_WITHDRAWAL_MESSAGE]\n  );\n\n  console.log(\"encoded\");\n\n  Ethers.provider()\n    .getSigner()\n    .sendTransaction({\n      to: ETH_WITHDRAWAL_CONTRACT,\n      data: encodedData,\n      value: DEFAULT_AMOUNT,\n      gasLimit,\n    })\n    .then((tx) => {\n      consle.log(\"tx:\", tx);\n    })\n    .catch((e) => {\n      console.log(\"bridge error:\", e);\n    });\n}\n\nconst handleWithdrawalReceipt = () => {\n  if (!isOPGoerli) {\n    return State.update({ console: `please switch to OP Goerli` });\n  }\n\n  const { transactionHash } = state;\n\n  const receiptError =\n    \"error getting receipt for txHash, check hash and try again\";\n\n  provider\n    .getTransaction(transactionHash)\n    .then((receipt) => {\n      if (!receipt) {\n        return State.update({ console: receiptError });\n      }\n\n      const {\n        nonce: messageNonce,\n        from: sender,\n        to: target,\n        value,\n        data: message,\n        blockNumber,\n      } = receipt;\n\n      const resolved = {\n        messageNonce,\n        sender,\n        target,\n        value: value.toString(),\n        minGasLimit: 0,\n        message,\n        direction: 1,\n        logIndex: 0,\n        blockNumber,\n        transactionHash,\n      };\n\n      Storage.privateSet(STORAGE_RESOLVED, resolved);\n      State.update({ console: \"Receipt Updated \u2705\" });\n    })\n    .catch((e) => {\n      console.log(e);\n      State.update({\n        console: receiptError,\n      });\n    });\n};\n\nconst getMessageBedrockOutput = (l2BlockNumber, callback) => {\n  const encodedData = outputIface.encodeFunctionData(\"getL2OutputIndexAfter\", [\n    l2BlockNumber,\n  ]);\n\n  const contract = new ethers.Contract(\n    L2_OUTPUT_ORACLE_CONTRACT,\n    outputAbi,\n    goerliProvider\n  );\n\n  console.log(contract);\n\n  contract\n    .getL2OutputIndexAfter(l2BlockNumber)\n    // Ethers.provider()\n    //   .call({\n    //     to: L2_OUTPUT_ORACLE_CONTRACT,\n    //     data: encodedData,\n    //   })\n    .then((l2OutputIndex) => {\n      console.log(\"l2OutputIndex:\", l2OutputIndex.toString());\n\n      contract\n        .getL2Output(l2OutputIndex.toString())\n        .then((proposal) => {\n          console.log(\"proposal data:\", proposal);\n\n          callback({\n            outputRoot: proposal[0],\n            l1Timestamp: proposal[1].toNumber(),\n            l2BlockNumber: proposal[2].toNumber(),\n            l2OutputIndex: l2OutputIndex.toNumber(),\n          });\n        })\n        .catch((e) => {\n          console.log(\"view error 2:\", e);\n        });\n    })\n    .catch((e) => {\n      console.log(\"view error 1:\", e);\n    });\n};\n\nconst hashLowLevelMessage = (withdrawal) => {\n  const types = [\n    \"uint256\",\n    \"address\",\n    \"address\",\n    \"uint256\",\n    \"uint256\",\n    \"bytes\",\n  ];\n  const encoded = ethers.utils.defaultAbiCoder.encode(types, [\n    withdrawal.messageNonce,\n    withdrawal.sender,\n    withdrawal.target,\n    withdrawal.value,\n    withdrawal.minGasLimit,\n    withdrawal.message,\n  ]);\n  return ethers.utils.keccak256(encoded);\n};\n\nconst hashMessageHash = (messageHash) => {\n  const data = ethers.utils.defaultAbiCoder.encode(\n    [\"bytes32\", \"uint256\"],\n    [ethers.utils.hexlify(messageHash), 0]\n  );\n  return ethers.utils.keccak256(data);\n};\n\nconst handleWithdrawalProof = () => {\n  console.log(\"handleWithdrawalProof\");\n\n  const { resolved } = state;\n  // TODO translate resolved back to Big instead of replacing here\n  resolved.value = DEFAULT_AMOUNT;\n\n  getMessageBedrockOutput(resolved.blockNumber, (output) => {\n    console.log(\"getMessageBedrockOutput:\", output);\n    const hash = hashLowLevelMessage(resolved);\n    console.log(\"hash\", hash);\n    const messageSlot = hashMessageHash(hash);\n    console.log(\"messageSlot\", messageSlot);\n\n    Storage.privateSet(STORAGE_MESSAGE_SLOT, messageSlot);\n    Storage.privateSet(STORAGE_L2_INDEX, output.l2OutputIndex);\n\n    State.update({ console: `Proof data updated \u2705` });\n  });\n};\n\nconst getBedrockMessageProof = (l2BlockNumber, slot, callback) => {\n  opGoerliProvider\n    .send(\"eth_getProof\", [ETH_WITHDRAWAL_CONTRACT, [slot], l2BlockNumber])\n    .then((proof) => {\n      const stateTrieProof = {\n        accountProof: proof.accountProof,\n        storageProof: proof.storageProof[0].proof,\n        storageValue: Big(parseInt(proof.storageProof[0].value)),\n        storageRoot: proof.storageHash,\n      };\n      console.log(\"stateTrieProof\", stateTrieProof);\n\n      opGoerliProvider\n        .send(\"eth_getBlockByNumber\", [l2BlockNumber, false])\n        .then((block) => {\n          console.log(\"block\", block);\n\n          callback({\n            outputRootProof: {\n              version: [],\n              stateRoot: block.stateRoot,\n              messagePasserStorageRoot: stateTrieProof.storageRoot,\n              latestBlockhash: block.hash,\n            },\n            withdrawalProof: stateTrieProof.storageProof,\n            l2OutputIndex: state.l2OutputIndex,\n          });\n        });\n    });\n};\n\nconst handleWithdrawalProve = () => {\n  const { resolved, messageSlot } = state;\n  const blockNumber = ethers.utils.hexlify(resolved.blockNumber);\n  console.log(\"blockNumber\", blockNumber);\n\n  getBedrockMessageProof(blockNumber, messageSlot, (proof) => {\n    const { resolved: withdrawal, l2OutputIndex } = state.resolved;\n\n    const args = [\n      [\n        withdrawal.messageNonce,\n        withdrawal.sender,\n        withdrawal.target,\n        withdrawal.value,\n        withdrawal.minGasLimit,\n        withdrawal.message,\n      ],\n      proof.l2OutputIndex,\n      [\n        proof.outputRootProof.version,\n        proof.outputRootProof.stateRoot,\n        proof.outputRootProof.messagePasserStorageRoot,\n        proof.outputRootProof.latestBlockhash,\n      ],\n      proof.withdrawalProof,\n    ];\n\n    console.log(\"proof args:\", args);\n  });\n};\n\nif (!sender) {\n  return (\n    <div className=\"w3button\">\n      <Web3Connect connectLabel=\"Connect to a wallet\" />\n    </div>\n  );\n}\n\nreturn (\n  <div>\n    <h3>Console:</h3>\n    <p>{state.console}</p>\n    {!isGoerli && !isOPGoerli && (\n      <p>Please switch to ETH Goerli or OP Goerli</p>\n    )}\n    {isGoerli && (\n      <>\n        <h3>Deposits & Withdrawals</h3>\n        <Widget src={`ciocan.near/widget/op-bridge-list`} />\n\n        <button onClick={handleDepositETH}>\n          Deposit {DEFAULT_AMOUNT_ETH} ETH to L2\n        </button>\n        <br />\n        <br />\n        <p>To initiate a withdraw, switch to OP Goerli network</p>\n      </>\n    )}\n    {isOPGoerli && (\n      <>\n        <h3>Deposits & Withdrawals</h3>\n        <Widget src={`ciocan.near/widget/op-bridge-list`} />\n\n        <button onClick={handleWithdrawalInitiating}>\n          Initiate Withdrawal of {DEFAULT_AMOUNT_ETH} ETH on L2\n        </button>\n        <br />\n        <br />\n        <p>\n          To make a deposit, or prove a withdraw, switch to ETH Goerli network\n        </p>\n\n        <h3>Get Withdrawal Receipt from L2 TX Hash:</h3>\n        <input\n          placeholder=\"withdrawal tx hash\"\n          value={state.transactionHash}\n          onChange={(e) => State.update({ transactionHash: e.target.value })}\n          type=\"text\"\n        />\n        <br />\n        <button onClick={handleWithdrawalReceipt}>\n          Step 1. Get Withdrawal Receipt\n        </button>\n\n        {state.transactionHash && (\n          <>\n            <br />\n            <br />\n            <button onClick={handleWithdrawalProof}>\n              Step 2. Get Withdrawal Proof Data\n            </button>\n          </>\n        )}\n        {state.messageSlot && (\n          <>\n            <br />\n            <br />\n            <button onClick={handleWithdrawalProve}>\n              Step3. Prove Withdrawal\n            </button>\n          </>\n        )}\n      </>\n    )}\n  </div>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/mattlock.near/widget/op-bridge-demo", "fact_widget_deployments_id": "28e49992d0ed08e10958a7b4053f6a7c", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 13}