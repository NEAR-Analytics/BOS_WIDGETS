{"tx_hash": "6tyvzCtFvNDLPDfmwfZyDJS4ZAgiAB7SdxHJtTcGwefF", "action_id_social": "8pygrgJEBzRqqNV5iroM5RXySd8uMnCDMG2ZZ9nX4RB3-0-widget", "block_id": 100387825, "block_timestamp": "2023-09-04T16:52:34.133Z", "signer_id": "mattlock.near", "widget_name": "op-bridge-demo", "source_code": "// for goerli\nconst OP_BRIDGE_DEPOSIT_CONTRACT = \"0x636Af16bf2f682dD3109e60102b8E1A089FedAa8\";\nconst OP_BRIDGE_WITHDRAW_CONTRACT =\n  \"0x4200000000000000000000000000000000000010\";\nconst ETH_ADDR = \"0x0000000000000000000000000000000000000000\";\nconst ETH_ADDR_L1 = `0xdeaddeaddeaddeaddeaddeaddeaddeaddead0000`;\nconst DEFAULT_AMOUNT_ETH = \"0.01\";\nconst DEFAULT_AMOUNT = ethers.utils.parseUnits(DEFAULT_AMOUNT_ETH, 18);\nconst L2_OUTPUT_ORACLE_CONTRACT = `0xE6Dfba0953616Bacab0c9A8ecb3a9BBa77FC15c0`;\nconst L1_OPTIMISM_PORTAL_CONTRACT = `0x5b47E1A08Ea6d985D6649300584e6722Ec4B1383`;\nconst HASH_ZERO =\n  \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n// Withdrawal target TX info\n// Call initiateWithdraw so the L2 message is passed\n// Following TX example here: https://goerli-optimism.etherscan.io/tx/0xb59ff0af1db39be0cc03e7410621ed21ce60e5833f8c4bf97d8747bd8d033bc8\n// Manually adjusted amount to 0.01\nconst ETH_WITHDRAWAL_MESSAGE = `0x32b7006d000000000000000000000000deaddeaddeaddeaddeaddeaddeaddeaddead0000000000000000000000000000000000000000000000000000002386f26fc10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000000`;\nconst L2_L1_MESSAGE_PASSER_CONTRACT = `0x4200000000000000000000000000000000000016`;\nconst ETH_WITHDRAWAL_TARGET = `0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000`;\n\n// Storage keys\nconst STORAGE_RESOLVED = \"__STORAGE_RESOLVED\";\nconst STORAGE_MESSAGE_SLOT = \"__STORAGE_MESSAGE_SLOT\";\nconst STORAGE_L2_INDEX = \"__STORAGE_L2_INDEX\";\n\nState.init({\n  console: \"Welcome!\",\n  transactionHash: `0x38082f56332ef0c5640487a47412aace70db81cdd0bb40e9a896a85953324ba0`,\n  resolved: Storage.privateGet(STORAGE_RESOLVED),\n  messageSlot: Storage.privateGet(STORAGE_MESSAGE_SLOT),\n  l2OutputIndex: Storage.privateGet(STORAGE_L2_INDEX),\n  withdrawals: [],\n  gettingWithdrawals: false,\n});\n\nconst opGoerliProvider = new ethers.providers.JsonRpcProvider(\n  \"https://optimism-goerli.gateway.tenderly.co/\"\n);\nconst opGoerliProviderOG = new ethers.providers.JsonRpcProvider(\n  \"https://goerli.optimism.io\"\n);\nconst goerliProvider = new ethers.providers.JsonRpcProvider(\n  \"https://rpc.ankr.com/eth_goerli\"\n);\n\nconst provider = Ethers.provider();\nconst sender = Ethers.send(\"eth_requestAccounts\", [])[0];\nconst { chainId } = state;\n\nif (sender) {\n  Ethers.provider()\n    .getNetwork()\n    .then(({ chainId }) => {\n      State.update({ chainId });\n    });\n\n  function getETHWithdrawals() {\n    if (state.gettingWithdrawals) return;\n    State.update({ gettingWithdrawals: true });\n    console.log(\"getETHWithdrawals\");\n\n    const bridgeAbiWithdrawal = [\n      {\n        anonymous: false,\n        inputs: [\n          {\n            indexed: true,\n            internalType: \"address\",\n            name: \"l1Token\",\n            type: \"address\",\n          },\n          {\n            indexed: true,\n            internalType: \"address\",\n            name: \"l2Token\",\n            type: \"address\",\n          },\n          {\n            indexed: true,\n            internalType: \"address\",\n            name: \"from\",\n            type: \"address\",\n          },\n          {\n            indexed: false,\n            internalType: \"address\",\n            name: \"to\",\n            type: \"address\",\n          },\n          {\n            indexed: false,\n            internalType: \"uint256\",\n            name: \"amount\",\n            type: \"uint256\",\n          },\n          {\n            indexed: false,\n            internalType: \"bytes\",\n            name: \"extraData\",\n            type: \"bytes\",\n          },\n        ],\n        name: \"WithdrawalInitiated\",\n        type: \"event\",\n      },\n    ];\n\n    const bridgeContractWithdrawal = new ethers.Contract(\n      OP_BRIDGE_WITHDRAW_CONTRACT,\n      bridgeAbiWithdrawal,\n      opGoerliProvider\n    );\n\n    const withdrawals = [];\n\n    bridgeContractWithdrawal\n      .queryFilter(\n        bridgeContractWithdrawal.filters.WithdrawalInitiated(\n          undefined,\n          undefined,\n          sender\n        )\n      )\n      .then((events) => {\n        events\n          .sort((a, b) => b.blockNumber - a.blockNumber)\n          .forEach((event) => {\n            const { args, blockNumber, transactionHash } = event;\n\n            const messagePasserAbi = [\n              \"event MessagePassed (uint256 indexed nonce, address indexed sender, address indexed target, uint256 value, uint256 gasLimit, bytes data, bytes32 withdrawalHash)\",\n            ];\n\n            const messagePasserContract = new ethers.Contract(\n              L2_L1_MESSAGE_PASSER_CONTRACT,\n              messagePasserAbi,\n              opGoerliProvider\n            );\n\n            messagePasserContract\n              .queryFilter(\n                messagePasserContract.filters.MessagePassed(\n                  undefined,\n                  undefined,\n                  \"0x5086d1eEF304eb5284A0f6720f79403b4e9bE294\",\n                  undefined,\n                  undefined,\n                  undefined,\n                  undefined\n                ),\n                blockNumber - 150,\n                blockNumber\n              )\n              .then((events) => {\n                const event = events.filter(\n                  ({ data }) => data.indexOf(sender.substring(2)) > -1\n                )[0];\n\n                const [\n                  messageNonce,\n                  sender,\n                  target,\n                  value,\n                  minGasLimit,\n                  message,\n                  withdrawalHash,\n                ] = event.args;\n\n                let withdrawal = {\n                  blockNumber,\n                  transactionHash,\n                  messageNonce,\n                  sender,\n                  target,\n                  value,\n                  minGasLimit,\n                  message,\n                  withdrawalHash,\n                };\n\n                withdrawals.push(withdrawal);\n\n                State.update({\n                  withdrawals,\n                });\n              });\n          });\n      });\n  }\n\n  getETHWithdrawals();\n}\n\nconst isMainnet = chainId === 1 || chainId === 10;\nconst isOPGoerli = chainId === 420;\nconst isGoerli = chainId === 5;\n\nconst bridgeAbi = [\n  {\n    inputs: [\n      { internalType: \"uint32\", name: \"_l2Gas\", type: \"uint32\" },\n      { internalType: \"bytes\", name: \"_data\", type: \"bytes\" },\n    ],\n    name: \"depositETH\",\n    outputs: [],\n    stateMutability: \"payable\",\n    type: \"function\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"from\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"to\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes\",\n        name: \"extraData\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"ETHDepositInitiated\",\n    type: \"event\",\n  },\n];\nconst bridgeIface = new ethers.utils.Interface(bridgeAbi);\n\nconst withdrawAbi = [\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"_l2Token\",\n        type: \"address\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"_amount\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"uint32\",\n        name: \"_minGasLimit\",\n        type: \"uint32\",\n      },\n      {\n        internalType: \"bytes\",\n        name: \"_extraData\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"withdraw\",\n    outputs: [],\n    stateMutability: \"payable\",\n    type: \"function\",\n  },\n];\nconst withdrawIface = new ethers.utils.Interface(withdrawAbi);\n\nconst outputAbi = [\n  {\n    inputs: [\n      {\n        internalType: \"uint256\",\n        name: \"_l2BlockNumber\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"getL2OutputIndexAfter\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    stateMutability: \"view\",\n    type: \"function\",\n    inputs: [\n      {\n        name: \"_l2OutputIndex\",\n        internalType: \"uint256\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"getL2Output\",\n    outputs: [\n      {\n        name: \"\",\n        internalType: \"struct Types.OutputProposal\",\n        type: \"tuple\",\n        components: [\n          {\n            name: \"outputRoot\",\n            internalType: \"bytes32\",\n            type: \"bytes32\",\n          },\n          {\n            name: \"timestamp\",\n            internalType: \"uint128\",\n            type: \"uint128\",\n          },\n          {\n            name: \"l2BlockNumber\",\n            internalType: \"uint128\",\n            type: \"uint128\",\n          },\n        ],\n      },\n    ],\n  },\n];\nconst outputIface = new ethers.utils.Interface(outputAbi);\n\nconst proofAbi = [\n  {\n    inputs: [\n      {\n        components: [\n          {\n            internalType: \"uint256\",\n            name: \"nonce\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"address\",\n            name: \"sender\",\n            type: \"address\",\n          },\n          {\n            internalType: \"address\",\n            name: \"target\",\n            type: \"address\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"value\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"gasLimit\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"bytes\",\n            name: \"data\",\n            type: \"bytes\",\n          },\n        ],\n        internalType: \"struct Types.WithdrawalTransaction\",\n        name: \"_tx\",\n        type: \"tuple\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"_l2OutputIndex\",\n        type: \"uint256\",\n      },\n      {\n        components: [\n          {\n            internalType: \"bytes32\",\n            name: \"version\",\n            type: \"bytes32\",\n          },\n          {\n            internalType: \"bytes32\",\n            name: \"stateRoot\",\n            type: \"bytes32\",\n          },\n          {\n            internalType: \"bytes32\",\n            name: \"messagePasserStorageRoot\",\n            type: \"bytes32\",\n          },\n          {\n            internalType: \"bytes32\",\n            name: \"latestBlockhash\",\n            type: \"bytes32\",\n          },\n        ],\n        internalType: \"struct Types.OutputRootProof\",\n        name: \"_outputRootProof\",\n        type: \"tuple\",\n      },\n      {\n        internalType: \"bytes[]\",\n        name: \"_withdrawalProof\",\n        type: \"bytes[]\",\n      },\n    ],\n    name: \"proveWithdrawalTransaction\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n    inputs: [\n      {\n        name: \"_tx\",\n        internalType: \"struct Types.WithdrawalTransaction\",\n        type: \"tuple\",\n        components: [\n          {\n            name: \"nonce\",\n            internalType: \"uint256\",\n            type: \"uint256\",\n          },\n          {\n            name: \"sender\",\n            internalType: \"address\",\n            type: \"address\",\n          },\n          {\n            name: \"target\",\n            internalType: \"address\",\n            type: \"address\",\n          },\n          {\n            name: \"value\",\n            internalType: \"uint256\",\n            type: \"uint256\",\n          },\n          {\n            name: \"gasLimit\",\n            internalType: \"uint256\",\n            type: \"uint256\",\n          },\n          {\n            name: \"data\",\n            internalType: \"bytes\",\n            type: \"bytes\",\n          },\n        ],\n      },\n    ],\n    name: \"finalizeWithdrawalTransaction\",\n    outputs: [],\n  },\n];\nconst proofIface = new ethers.utils.Interface(proofAbi);\n\nfunction handleDepositETH() {\n  if (!isGoerli)\n    return State.update({\n      console: `switch to Goerli Testnet (not Optimism Goerli, ETH Goerli) to deposit ETH to OP Goerli`,\n    });\n\n  const encodedData = bridgeIface.encodeFunctionData(\n    \"depositETH(uint32, bytes)\",\n    [200000, 0]\n  );\n\n  Ethers.provider()\n    .getSigner()\n    .sendTransaction({\n      to: OP_BRIDGE_DEPOSIT_CONTRACT,\n      data: encodedData,\n      value: DEFAULT_AMOUNT,\n      gasLimit,\n    })\n    .then((tx) => {\n      consle.log(\"tx:\", tx);\n    })\n    .catch((e) => {\n      console.log(\"bridge error:\", e);\n    });\n}\n\nfunction handleWithdrawalInitiating() {\n  console.log(\"withdraw\");\n\n  const encodedData = withdrawIface.encodeFunctionData(\n    \"withdraw(address, uint256, uint32, bytes)\",\n    [ETH_WITHDRAWAL_TARGET, DEFAULT_AMOUNT, 0, []]\n  );\n\n  console.log(\"encoded\", encodedData);\n\n  Ethers.provider()\n    .getSigner()\n    .sendTransaction({\n      to: OP_BRIDGE_WITHDRAW_CONTRACT,\n      data: encodedData,\n      value: DEFAULT_AMOUNT,\n      gasLimit,\n    })\n    .then((tx) => {\n      consle.log(\"tx:\", tx);\n    })\n    .catch((e) => {\n      console.log(\"bridge error:\", e);\n    });\n}\n\nconst getMessageBedrockOutput = (l2BlockNumber, callback) => {\n  const contract = new ethers.Contract(\n    L2_OUTPUT_ORACLE_CONTRACT,\n    outputAbi,\n    goerliProvider\n  );\n\n  contract\n    .getL2OutputIndexAfter(l2BlockNumber)\n    .then((l2OutputIndex) => {\n      console.log(\"l2OutputIndex:\", l2OutputIndex.toString());\n\n      contract\n        .getL2Output(l2OutputIndex.toString())\n        .then((proposal) => {\n          console.log(\"proposal data:\", proposal);\n\n          callback({\n            outputRoot: proposal[0],\n            l1Timestamp: proposal[1].toNumber(),\n            l2BlockNumber: proposal[2].toNumber(),\n            l2OutputIndex: l2OutputIndex.toNumber(),\n          });\n        })\n        .catch((e) => {\n          console.log(\"view error 2:\", e);\n        });\n    })\n    .catch((e) => {\n      console.log(\"view error 1:\", e);\n    });\n};\n\nconst hashLowLevelMessage = (withdrawal) => {\n  const types = [\n    \"uint256\",\n    \"address\",\n    \"address\",\n    \"uint256\",\n    \"uint256\",\n    \"bytes\",\n  ];\n  const encoded = ethers.utils.defaultAbiCoder.encode(types, [\n    withdrawal.messageNonce,\n    withdrawal.sender,\n    withdrawal.target,\n    withdrawal.value,\n    withdrawal.minGasLimit,\n    withdrawal.message,\n  ]);\n  return ethers.utils.keccak256(encoded);\n};\n\nconst hashMessageHash = (messageHash) => {\n  const data = ethers.utils.defaultAbiCoder.encode(\n    [\"bytes32\", \"uint256\"],\n    [ethers.utils.hexlify(messageHash), HASH_ZERO]\n  );\n  return ethers.utils.keccak256(data);\n};\n\nconst getBedrockMessageProof = (l2BlockNumber, slot, callback) => {\n  opGoerliProviderOG\n    .send(\"eth_getProof\", [\n      L2_L1_MESSAGE_PASSER_CONTRACT,\n      [slot],\n      l2BlockNumber,\n    ])\n    .then((proof) => {\n      const stateTrieProof = {\n        accountProof: proof.accountProof,\n        storageProof: proof.storageProof[0].proof,\n        storageValue: Big(parseInt(proof.storageProof[0].value)),\n        storageRoot: proof.storageHash,\n      };\n      console.log(\"stateTrieProof\", stateTrieProof);\n\n      opGoerliProvider\n        .send(\"eth_getBlockByNumber\", [l2BlockNumber, false])\n        .then((block) => {\n          console.log(\"block\", block);\n\n          callback({\n            outputRootProof: {\n              version: HASH_ZERO,\n              stateRoot: block.stateRoot,\n              messagePasserStorageRoot: stateTrieProof.storageRoot,\n              latestBlockhash: block.hash,\n            },\n            withdrawalProof: stateTrieProof.storageProof,\n          });\n        });\n    });\n};\n\nconst handleWithdrawalProve = (which) => {\n  const withdrawal = state.withdrawals[which];\n  console.log(\"handleWithdrawalProve\", withdrawal);\n\n  getMessageBedrockOutput(withdrawal.blockNumber, (output) => {\n    console.log(\"getMessageBedrockOutput:\", output);\n    const hash = hashLowLevelMessage(withdrawal);\n    console.log(\"hash\", hash);\n    const messageSlot = hashMessageHash(hash);\n    console.log(\"messageSlot\", messageSlot);\n    const l2BlockNumber = ethers.utils.hexlify(output.l2BlockNumber);\n    console.log(\"l2BlockNumber\", l2BlockNumber);\n\n    getBedrockMessageProof(l2BlockNumber, messageSlot, (proof) => {\n      const args = [\n        [\n          withdrawal.messageNonce,\n          withdrawal.sender,\n          withdrawal.target,\n          withdrawal.value,\n          withdrawal.minGasLimit,\n          withdrawal.message,\n        ],\n        output.l2OutputIndex,\n        [\n          proof.outputRootProof.version,\n          proof.outputRootProof.stateRoot,\n          proof.outputRootProof.messagePasserStorageRoot,\n          proof.outputRootProof.latestBlockhash,\n        ],\n        proof.withdrawalProof,\n      ];\n\n      console.log(\"proof args:\", args);\n\n      if (!isGoerli) {\n        return State.update({\n          console: \"switch to Goerli to sign the proof\",\n        });\n      }\n\n      const contract = new ethers.Contract(\n        L1_OPTIMISM_PORTAL_CONTRACT,\n        proofAbi,\n        Ethers.provider().getSigner()\n      );\n\n      contract\n        .proveWithdrawalTransaction(...args)\n        .then((tx) => {\n          console.log(\"tx output:\", tx);\n        })\n        .catch((e) => {\n          console.log(\"error\", e);\n        });\n    });\n  });\n};\n\nconst handleWithdrawalClaim = (which) => {\n  const withdrawal = state.withdrawals[which];\n  console.log(\"handleWithdrawalProve\", withdrawal);\n\n  const args = [\n    withdrawal.messageNonce,\n    withdrawal.sender,\n    withdrawal.target,\n    withdrawal.value,\n    withdrawal.minGasLimit,\n    withdrawal.message,\n  ];\n\n  const contract = new ethers.Contract(\n    L1_OPTIMISM_PORTAL_CONTRACT,\n    proofAbi,\n    Ethers.provider().getSigner()\n  );\n\n  contract\n    .finalizeWithdrawalTransaction(args)\n    .then((tx) => {\n      console.log(\"tx output:\", tx);\n    })\n    .catch((e) => {\n      console.log(\"error\", e);\n    });\n};\n\n// end functional\n\nif (!sender) {\n  return (\n    <div className=\"w3button\">\n      <Web3Connect connectLabel=\"Connect to a wallet\" />\n    </div>\n  );\n}\n\nconsole.log(\"state.withdrawals\", Object.values(state.withdrawals));\n\nreturn (\n  <div>\n    <h3>Console:</h3>\n    <p>{state.console}</p>\n    {!isGoerli && !isOPGoerli && (\n      <p>Please switch to ETH Goerli or OP Goerli</p>\n    )}\n    {isGoerli && (\n      <>\n        <h3>Deposits & Withdrawals</h3>\n        <Widget src={`ciocan.near/widget/op-bridge-list`} />\n\n        <button onClick={handleDepositETH}>\n          Deposit {DEFAULT_AMOUNT_ETH} ETH to L2\n        </button>\n        <br />\n        <br />\n        <p>To initiate a withdraw, switch to OP Goerli network</p>\n\n        {state.withdrawals.length === 0 && <h3>Loading Withdrawals</h3>}\n        {!isGoerli && <p>To prove withdrawals switch to ETH Goerli</p>}\n        {state.withdrawals.map(({ blockNumber, transactionHash }, i) => {\n          return (\n            <>\n              <br />\n              <br />\n              <p>TX hash: {transactionHash}</p>\n              <button onClick={() => handleWithdrawalProve(i)}>\n                Prove Withdrawal\n              </button>\n              <button onClick={() => handleWithdrawalClaim(i)}>\n                Claim Withdrawal\n              </button>\n            </>\n          );\n        })}\n      </>\n    )}\n    {isOPGoerli && (\n      <>\n        <h3>Deposits & Withdrawals</h3>\n        <Widget src={`ciocan.near/widget/op-bridge-list`} />\n\n        <button onClick={handleWithdrawalInitiating}>\n          Initiate Withdrawal of {DEFAULT_AMOUNT_ETH} ETH on L2\n        </button>\n        <br />\n        <br />\n        <p>\n          To make a deposit, or prove a withdraw, switch to ETH Goerli network\n        </p>\n      </>\n    )}\n  </div>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/mattlock.near/widget/op-bridge-demo", "fact_widget_deployments_id": "e2e483eb088c489302e73b5612696cc6", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 22}