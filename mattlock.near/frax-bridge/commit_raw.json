{"tx_hash": "DnFrSUwZPY1N4QkWU1PsdzCbv9LGuRnAJEjjEpVsxQNZ", "action_id_social": "GFEQFnDsTiBmVqz7b1K1LNNgNTy6QRQJsCfhmDJb21zD-0-widget", "block_id": 113833959, "block_timestamp": "2024-02-29T18:46:10.167Z", "signer_id": "mattlock.near", "widget_name": "frax-bridge", "source_code": "/*\nTODO\n[x] store all abis in gist\n[x] use a block range op sepolia RPC (blockpi) for subsequent calls after tenderly\n[x] get balances for eth on all networks\n[x] add mainnet contract addresses\n[x] clean up network contracts and remove const contract addresses and contract instances\n[] clean up withdraw and deposits\n[] only get withdraw message data when user clicks prove or claim\n[] add erc20 deposit for usdc\n[] add erc20 withdrawal for usdc\n\nTODO bridge-ui\n[x] update bridge UI to pass in explorer links mapped to network\n[x] add buttons prove and claim withdrawals to bridge-ui\n*/\n\nconst L2StandardBridge = \"0x4200000000000000000000000000000000000010\";\nconst L2_L1_MESSAGE_PASSER_CONTRACT = `0x4200000000000000000000000000000000000016`;\nconst ETH_WITHDRAWAL_TARGET = `0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000`;\nconst HASH_ZERO =\n  \"0x0000000000000000000000000000000000000000000000000000000000000000\";\nconst WITHDRAW_INIT_GAS_LIMIT = 150000;\nconst FRAXTAL_HOLESKY_CHAIN_ID = 2522;\nconst HOLESKY_CHAIN_ID = 17000;\nconst ETH_CHAIN_ID = 1;\nconst FRAXTAL_CHAIN_ID = 252;\nconst VALID_CHAIN_ID = [\n  ETH_CHAIN_ID,\n  FRAXTAL_CHAIN_ID,\n  HOLESKY_CHAIN_ID,\n  FRAXTAL_HOLESKY_CHAIN_ID,\n];\nconst depositDisabledMsg =\n  \"For deposits, please switch to Ethereum mainnet or Holesky testnet.\";\nconst withdrawDisabledMsg =\n  \"For withdrawals, please switch to Fraxtal mainnet or Fraxtal Holesky testnet.\";\nconst abiCoder = new ethers.utils.AbiCoder();\nconst tokens = {\n  eth: {\n    icon: \"https://assets.coingecko.com/coins/images/279/standard/ethereum.png?1696501628\",\n    decimals: 18,\n  },\n  // usdc: {\n  //   icon: \"https://assets.coingecko.com/coins/images/6319/standard/usdc.png?1696506694\",\n  //   decimals: 6,\n  // },\n};\n\n// state\nconst defaultDeposit = {\n  network: {\n    id: \"l1\",\n    name: \"Ethereum\",\n  },\n  assets: [\n    {\n      id: \"eth\",\n      name: \"ETH\",\n      selected: true,\n      balance: \"0.00\",\n    },\n  ],\n};\nconst defaultWithdraw = {\n  network: {\n    id: \"l2\",\n    name: \"Fraxtal\",\n  },\n  assets: [\n    {\n      id: \"eth\",\n      name: \"ETH\",\n      selected: true,\n      balance: \"0.00\",\n    },\n  ],\n};\n\nif (!state.initialized) {\n  console.log(\"INITIALIZED\");\n  initState({\n    initLogs: false,\n    initialized: true,\n    deposit: defaultDeposit,\n    withdraw: defaultWithdraw,\n    amount: \"0.0\",\n    deposits: [],\n    withdrawals: [],\n    ethDeposits: [],\n    ethWithdrawals: [],\n    tokens: [],\n    tab: \"deposit\",\n  });\n  return \"\";\n}\n\n// get account and current provider chainId\n\nconst sender = Ethers.send(\"eth_requestAccounts\", [])[0];\n\nif (!sender) {\n  return (\n    <div className=\"w3button\">\n      <Web3Connect connectLabel=\"Connect to a wallet\" />\n    </div>\n  );\n}\n\nif (!state.chainId) {\n  Ethers.provider()\n    .getNetwork()\n    .then(({ chainId }) => {\n      let network = \"incorrect\",\n        log;\n      if (\n        chainId === HOLESKY_CHAIN_ID ||\n        chainId === FRAXTAL_HOLESKY_CHAIN_ID\n      ) {\n        network = \"testnet\";\n      }\n      if (chainId === ETH_CHAIN_ID || chainId === FRAXTAL_CHAIN_ID) {\n        network = \"mainnet\";\n      }\n      if (\n        chainId === FRAXTAL_HOLESKY_CHAIN_ID ||\n        chainId === FRAXTAL_CHAIN_ID\n      ) {\n        log = depositDisabledMsg;\n      }\n      console.log(\"chainId\", chainId, network);\n\n      const L1ExplorerLink = `https://${\n        network === \"testnet\" ? \"holesky.\" : \"\"\n      }etherscan.io/tx/`;\n      const L2ExplorerLink = `https://${\n        network === \"testnet\" ? \"holesky.\" : \"\"\n      }fraxscan.com/tx/`;\n\n      State.update({ chainId, network, log, L1ExplorerLink, L2ExplorerLink });\n    })\n    .catch((e) => {\n      console.log(e);\n    });\n  return \"\";\n}\nconst { chainId, network } = state;\n\nif (!network) {\n  return \"\";\n}\n\nif (network === \"mainnet\") {\n  return (\n    <p>\n      Mainnet currently in development. Please switch to Holesky or Fraxtal\n      Holesky testnet.\n    </p>\n  );\n}\n\nif (!VALID_CHAIN_ID.includes(chainId)) {\n  return (\n    <p>\n      Please switch to Ethereum or Fraxtal mainnet; or Holesky or Fraxtal\n      Holesky\n    </p>\n  );\n}\n\n// fetch abis\n\nconst L2StandardBridgeAbi = fetch(\n  \"https://gist.githubusercontent.com/mattlockyer/4ecda9c3b707fe7e3328c9d2da9ce3a1/raw/1eae7c74e2d44df2067a1929bb8a3b2647926fde/L2StandardBridge.json\"\n);\n\nconst L1StandardBridgeProxyAbi = fetch(\n  \"https://gist.githubusercontent.com/mattlockyer/b5ddd8070db7479b527674b14b928c4d/raw/39c570a8c53c980482c44502680d0ed3c39e7848/L1StandardBridgeProxy.json\"\n);\n\nconst L2OutputOracleAbi = fetch(\n  \"https://gist.githubusercontent.com/mattlockyer/8f8d9bc4442150d425811ee15c7565de/raw/5ca76848e0febc52fe6d872926b8b3ad2c754664/L2OutputOracle.json\"\n);\n\nconst L1OptimismPortalAbi = fetch(\n  \"https://gist.githubusercontent.com/mattlockyer/186c53a813484225b0e0ed682c4673e4/raw/43be17194b0e4f4dc3611780c8a9a6c8cd12218b/OptimismPortal.json\"\n);\n\n// wait for abi to load\nif (\n  !L2StandardBridgeAbi.ok ||\n  !L1StandardBridgeProxyAbi.ok ||\n  !L2OutputOracleAbi.ok ||\n  !L1OptimismPortalAbi.ok\n) {\n  return \"\";\n}\n\n// TODO UPDATE contracts and mainnet providers\nconst contracts = {\n  mainnet: {\n    L1StandardBridgeProxy: `0x99C9fc46f92E8a1c0deC1b1747d010903E884bE1`,\n    L2OutputOracleProxy: `0xdfe97868233d1aa22e815a266982f2cf17685a27`,\n    L1OptimismPortalProxy: `0xbEb5Fc579115071764c7423A4f12eDde41f106Ed`,\n    eth: {\n      decimals: 18,\n      deposit: \"0x32400084C286CF3E17e7B677ea9583e60a000324\",\n      withdraw: \"0x000000000000000000000000000000000000800A\",\n    },\n  },\n  testnet: {\n    L1StandardBridgeProxy: `0x0BaafC217162f64930909aD9f2B27125121d6332`,\n    L2OutputOracleProxy: `0x715EA64DA13F4d0831ece4Ad3E8c1aa013167F32`,\n    L1OptimismPortalProxy: `0xB9c64BfA498d5b9a8398Ed6f46eb76d90dE5505d`,\n    L2toL1MessagePasser: `0x45A98115D5722C6cfC48D711e0053758E7C0b8ad`,\n    eth: {\n      deposit: \"0x0BaafC217162f64930909aD9f2B27125121d6332\",\n      withdraw: \"0x000000000000000000000000000000000000800A\",\n      decimals: 18,\n    },\n  },\n};\nif (network === \"mainnet\") {\n  Object.assign(contracts.mainnet, {\n    l1Provider: new ethers.providers.JsonRpcProvider(\n      `https://ethereum.blockpi.network/v1/rpc/public`\n    ),\n    l1ProviderFilter: new ethers.providers.JsonRpcProvider(\n      `https://mainnet.gateway.tenderly.co`\n    ),\n    l1ProviderRange: new ethers.providers.JsonRpcProvider(\n      `https://ethereum-holesky-rpc.publicnode.com`\n    ),\n    l2Provider: new ethers.providers.JsonRpcProvider(\n      `https://mainnet.optimism.io`\n    ),\n    l2ProviderFilter: new ethers.providers.JsonRpcProvider(\n      `https://optimism.gateway.tenderly.co\t`\n    ),\n    l2ProviderRange: new ethers.providers.JsonRpcProvider(\n      `https://optimism.blockpi.network/v1/rpc/public`\n    ),\n  });\n} else {\n  Object.assign(contracts.testnet, {\n    l1Provider: new ethers.providers.JsonRpcProvider(\n      `https://ethereum-holesky.publicnode.com`\n    ),\n    l1ProviderFilter: new ethers.providers.JsonRpcProvider(\n      `https://holesky.gateway.tenderly.co`\n    ),\n    l2Provider: new ethers.providers.JsonRpcProvider(\n      `https://rpc.testnet.frax.com`\n    ),\n    l2ProviderFilter: new ethers.providers.JsonRpcProvider(\n      `https://rpc.testnet.frax.com`\n    ),\n    l2ProviderRange: new ethers.providers.JsonRpcProvider(\n      `https://rpc.testnet.frax.com`\n    ),\n  });\n}\n\n// contract instances\n\nconst L2StandardBridgeContract = new ethers.Contract(\n  L2StandardBridge,\n  L2StandardBridgeAbi.body,\n  contracts[network].l2ProviderFilter\n);\nconst L2StandardBridgeAbiIface = new ethers.utils.Interface(\n  L2StandardBridgeAbi.body\n);\n\nconst L1StandardBridgeProxyContract = new ethers.Contract(\n  contracts[network].L1StandardBridgeProxy,\n  L1StandardBridgeProxyAbi.body,\n  contracts[network].l1ProviderFilter\n);\nconst L1StandardBridgeProxyIface = new ethers.utils.Interface(\n  L1StandardBridgeProxyAbi.body\n);\n\n// get logs\n\nif (sender && chainId && !state.initLogs) {\n  State.update({ initLogs: true });\n\n  function getEthWithdrawals() {\n    L2StandardBridgeContract.queryFilter(\n      L2StandardBridgeContract.filters.WithdrawalInitiated(\n        undefined,\n        ETH_WITHDRAWAL_TARGET,\n        sender\n      )\n    ).then((events) => {\n      console.log(\"withdrawal events\", events);\n\n      return State.update({\n        ethWithdrawals: events.map((e) => ({\n          ...e,\n          isEth: true,\n          gotStatus: false,\n        })),\n      });\n    });\n  }\n\n  function getEthDeposits() {\n    L1StandardBridgeProxyContract.queryFilter(\n      L1StandardBridgeProxyContract.filters.ETHDepositInitiated(\n        sender,\n        sender,\n        undefined,\n        undefined\n      )\n    ).then((events) => {\n      console.log(\"deposit events\", events);\n      State.update({\n        ethDeposits: events.map((e) => ({ ...e, isEth: true })),\n      });\n    });\n  }\n\n  getEthWithdrawals();\n  getEthDeposits();\n  return \"\";\n}\n\n// user actions\n\nfunction getWithdrawalStatus(event) {\n  const { blockNumber, transactionHash } = event;\n\n  const messagePasserAbi = [\n    \"event MessagePassed (uint256 indexed nonce, address indexed sender, address indexed target, uint256 value, uint256 gasLimit, bytes data, bytes32 withdrawalHash)\",\n  ];\n\n  const messagePasserContract = new ethers.Contract(\n    L2_L1_MESSAGE_PASSER_CONTRACT,\n    messagePasserAbi,\n    contracts[network].l2ProviderRange\n  );\n\n  messagePasserContract\n    .queryFilter(\n      messagePasserContract.filters.MessagePassed(\n        undefined,\n        undefined,\n        contracts[network].L2toL1MessagePasser\n      ),\n      blockNumber - 150,\n      blockNumber\n    )\n    .then((events) => {\n      console.log(\"messagePasserContract events\".events);\n\n      const event = events.filter(\n        ({ data }) => data.indexOf(sender.substring(2)) > -1\n      )[0];\n\n      const [\n        messageNonce,\n        sender,\n        target,\n        value,\n        minGasLimit,\n        message,\n        withdrawalHash,\n      ] = event.args;\n\n      let withdrawal = {\n        blockNumber,\n        transactionHash,\n        messageNonce,\n        sender,\n        target,\n        value,\n        minGasLimit,\n        message,\n        withdrawalHash,\n        proven: !!event ? false : undefined,\n        claimed: false,\n        isEth: true,\n        gotStatus: true,\n      };\n\n      const portalContract = new ethers.Contract(\n        contracts[network].L1OptimismPortalProxy,\n        L1OptimismPortalAbi.body,\n        contracts[network].l1ProviderFilter\n      );\n\n      const update = () => {\n        const ethWithdrawals = [...state.ethWithdrawals];\n        ethWithdrawals[\n          ethWithdrawals.findIndex(\n            (w) => w.transactionHash === withdrawal.transactionHash\n          )\n        ] = withdrawal;\n        State.update({\n          ethWithdrawals,\n        });\n      };\n\n      portalContract\n        .queryFilter(\n          portalContract.filters.WithdrawalProven(withdrawal.withdrawalHash)\n        )\n        .then((res) => {\n          if (res) {\n            withdrawal.proven = true;\n          }\n          update();\n          portalContract\n            .queryFilter(\n              portalContract.filters.WithdrawalProven(withdrawal.withdrawalHash)\n            )\n            .then((res2) => {\n              if (res2) {\n                withdrawal.claimed = true;\n              }\n              update();\n            })\n            .catch(update);\n        })\n        .catch(update);\n    });\n}\n\nfunction handleDepositEth(data) {\n  const encodedData = L1StandardBridgeProxyIface.encodeFunctionData(\n    \"depositETH(uint32, bytes)\",\n    [200000, []]\n  );\n\n  Ethers.provider()\n    .getSigner()\n    .sendTransaction({\n      to: contracts[network].L1StandardBridgeProxy,\n      data: encodedData,\n      value: ethers.utils.parseUnits(data.amount),\n      gasLimit,\n    })\n    .then((tx) => {\n      console.log(\"tx:\", tx);\n      State.update({\n        log: \"Deposit \" + state.L1ExplorerLink + tx.hash,\n      });\n    })\n    .catch((e) => {\n      console.log(\"bridge error:\", e);\n    });\n}\n\nfunction handleDeposit(data) {\n  console.log(\"handleDeposit\", data);\n  State.update({ isLoading: true, log: undefined, explorerLink: undefined });\n\n  if (data.assetId === \"eth\") {\n    return handleDepositEth(data);\n  }\n}\n\nfunction handleWithdrawalInitiatingEth(data) {\n  const value = ethers.utils.parseUnits(data.amount);\n  const encodedData = L2StandardBridgeAbiIface.encodeFunctionData(\n    \"withdraw(address, uint256, uint32, bytes)\",\n    [ETH_WITHDRAWAL_TARGET, value, 0, []]\n  );\n\n  Ethers.provider()\n    .getSigner()\n    .sendTransaction({\n      to: L2StandardBridge,\n      data: encodedData,\n      value,\n      gasLimit: WITHDRAW_INIT_GAS_LIMIT,\n    })\n    .then((tx) => {\n      console.log(\"tx:\", tx);\n      // todo turn into rendered link\n      State.update({\n        log: \"Withdrawal \" + state.L2ExplorerLink + tx.hash,\n      });\n    })\n    .catch((e) => {\n      console.log(\"bridge error:\", e);\n    });\n}\n\nfunction handleWithdrawalInitiating(data) {\n  console.log(\"handleWithdrawalInitiating\", data);\n  if (data.assetId === \"eth\") {\n    return handleWithdrawalInitiatingEth(data);\n  }\n}\n\nconst getMessageBedrockOutput = (l2BlockNumber, callback) => {\n  const contract = new ethers.Contract(\n    contracts[network].L2OutputOracleProxy,\n    L2OutputOracleAbi.body,\n    contracts[network].l1Provider\n  );\n\n  contract\n    .getL2OutputIndexAfter(l2BlockNumber)\n    .then((l2OutputIndex) => {\n      console.log(\"l2OutputIndex:\", l2OutputIndex.toString());\n\n      contract\n        .getL2Output(l2OutputIndex.toString())\n        .then((proposal) => {\n          console.log(\"proposal data:\", proposal);\n\n          callback({\n            outputRoot: proposal[0],\n            l1Timestamp: proposal[1].toNumber(),\n            l2BlockNumber: proposal[2].toNumber(),\n            l2OutputIndex: l2OutputIndex.toNumber(),\n          });\n        })\n        .catch((e) => {\n          console.log(\"view error 2:\", e);\n        });\n    })\n    .catch((e) => {\n      console.log(\"view error 1:\", e);\n    });\n};\n\nconst hashLowLevelMessage = (withdrawal) => {\n  console.log(\"hashLowLevelMessage\", withdrawal);\n  const types = [\n    \"uint256\",\n    \"address\",\n    \"address\",\n    \"uint256\",\n    \"uint256\",\n    \"bytes\",\n  ];\n  const encoded = abiCoder.encode(types, [\n    withdrawal.messageNonce,\n    withdrawal.sender,\n    withdrawal.target,\n    withdrawal.value,\n    withdrawal.minGasLimit,\n    withdrawal.message,\n  ]);\n  return ethers.utils.keccak256(encoded);\n};\n\nconst hashMessageHash = (messageHash) => {\n  const data = abiCoder.encode(\n    [\"bytes32\", \"uint256\"],\n    [ethers.utils.hexlify(messageHash), HASH_ZERO]\n  );\n  return ethers.utils.keccak256(data);\n};\n\nconst getBedrockMessageProof = (l2BlockNumber, slot, callback) => {\n  console.log(\"getBedrockMessageProof\", l2BlockNumber);\n  contracts[network].l2Provider\n    .send(\"eth_getProof\", [\n      L2_L1_MESSAGE_PASSER_CONTRACT,\n      [slot],\n      l2BlockNumber,\n    ])\n    .then((proof) => {\n      const stateTrieProof = {\n        accountProof: proof.accountProof,\n        storageProof: proof.storageProof[0].proof,\n        storageValue: Big(parseInt(proof.storageProof[0].value)),\n        storageRoot: proof.storageHash,\n      };\n      console.log(\"stateTrieProof\", stateTrieProof);\n\n      contracts[network].l2Provider\n        .send(\"eth_getBlockByNumber\", [l2BlockNumber, false])\n        .then((block) => {\n          console.log(\"block\", block);\n\n          callback({\n            outputRootProof: {\n              version: HASH_ZERO,\n              stateRoot: block.stateRoot,\n              messagePasserStorageRoot: stateTrieProof.storageRoot,\n              latestBlockhash: block.hash,\n            },\n            withdrawalProof: stateTrieProof.storageProof,\n          });\n        });\n    });\n};\n\nconst handleWithdrawalProve = (withdrawal) => {\n  console.log(\"handleWithdrawalProve\", withdrawal);\n\n  getMessageBedrockOutput(withdrawal.blockNumber, (output) => {\n    console.log(\"getMessageBedrockOutput:\", output);\n    const hash = hashLowLevelMessage(withdrawal);\n    console.log(\"hash\", hash);\n    const messageSlot = hashMessageHash(hash);\n    console.log(\"messageSlot\", messageSlot);\n    const l2BlockNumber = ethers.utils.hexlify(output.l2BlockNumber);\n    console.log(\"l2BlockNumber\", l2BlockNumber);\n\n    getBedrockMessageProof(l2BlockNumber, messageSlot, (proof) => {\n      const args = [\n        [\n          withdrawal.messageNonce,\n          withdrawal.sender,\n          withdrawal.target,\n          withdrawal.value,\n          withdrawal.minGasLimit,\n          withdrawal.message,\n        ],\n        output.l2OutputIndex,\n        [\n          proof.outputRootProof.version,\n          proof.outputRootProof.stateRoot,\n          proof.outputRootProof.messagePasserStorageRoot,\n          proof.outputRootProof.latestBlockhash,\n        ],\n        proof.withdrawalProof,\n      ];\n\n      console.log(\"proof args:\", args);\n\n      const contract = new ethers.Contract(\n        contracts[network].L1OptimismPortalProxy,\n        L1OptimismPortalAbi.body,\n        Ethers.provider().getSigner()\n      );\n\n      contract\n        .proveWithdrawalTransaction(...args)\n        .then((tx) => {\n          console.log(\"tx output:\", tx);\n          State.update({\n            log:\n              \"Withdrawal Proving Transaction \" +\n              state.L1ExplorerLink +\n              tx.hash,\n          });\n        })\n        .catch((e) => {\n          console.log(\"error\", e);\n        });\n    });\n  });\n};\n\nconst handleWithdrawalClaim = (withdrawal) => {\n  console.log(\"handleWithdrawalClaim\", withdrawal);\n\n  const args = [\n    withdrawal.messageNonce,\n    withdrawal.sender,\n    withdrawal.target,\n    withdrawal.value,\n    withdrawal.minGasLimit,\n    withdrawal.message,\n  ];\n\n  const contract = new ethers.Contract(\n    contracts[network].L1OptimismPortalProxy,\n    L1OptimismPortalAbi.body,\n    Ethers.provider().getSigner()\n  );\n\n  contract\n    .finalizeWithdrawalTransaction(args)\n    .then((tx) => {\n      console.log(\"tx output:\", tx);\n    })\n    .catch((e) => {\n      console.log(\"error\", e);\n    });\n};\n\nconst tab = !state.tab || state.tab === \"deposit\" ? \"deposit\" : \"withdraw\";\nconst clone = (o) => JSON.parse(JSON.stringify(o));\nconst { deposit, withdraw } = state;\n\n// balances\n\nconst getTokenBalance = (sender, isL1, tokenAddress, decimals, callback) => {\n  if (!sender) return;\n  const encodedData = erc20IFace.encodeFunctionData(\"balanceOf\", [sender]);\n  const provider = isL1\n    ? contracts[network].l1Provider\n    : contracts[network].l2Provider;\n\n  provider\n    .call({\n      to: tokenAddress,\n      data: encodedData,\n    })\n    .then((rawBalance) => {\n      if (rawBalance === \"0x\") {\n        return callback(0);\n      }\n      const receiverBalanceHex = erc20IFace.decodeFunctionResult(\n        \"balanceOf\",\n        rawBalance\n      );\n      const balance = Big(receiverBalanceHex.toString())\n        .div(Big(10).pow(decimals))\n        .toFixed(2)\n        .replace(/\\d(?=(\\d{3})+\\.)/g, \"$&,\");\n\n      callback(balance);\n    });\n};\n\nconst withdrawalActions = [\n  {\n    labelComplete: \"\",\n    completeKey: \"gotStatus\",\n    actionLabel: \"Get Status\",\n    action: getWithdrawalStatus,\n  },\n  {\n    labelComplete: \"(proven)\",\n    completeKey: \"proven\",\n    actionLabel: \"Prove\",\n    action: handleWithdrawalProve,\n  },\n  {\n    labelComplete: \"(claimed)\",\n    completeKey: \"claimed\",\n    actionLabel: \"claim\",\n    action: handleWithdrawalClaim,\n  },\n];\n\nif (sender && !state.balancesUpdated) {\n  // l1\n  contracts[network].l1Provider.getBalance(sender).then((balance) => {\n    const cloned = clone(deposit || defaultDeposit);\n    const formatted = ethers.utils.formatUnits(balance);\n    cloned.assets[0].balance = formatted.substring(\n      0,\n      formatted.indexOf(\".\") + 5\n    );\n    State.update({ deposit: cloned });\n  });\n\n  //l2;\n  contracts[network].l2Provider.getBalance(sender).then((balance) => {\n    const cloned = clone(withdraw || defaultWithdraw);\n    const formatted = ethers.utils.formatUnits(balance);\n    cloned.assets[0].balance = formatted.substring(\n      0,\n      formatted.indexOf(\".\") + 5\n    );\n    State.update({ withdraw: cloned });\n  });\n\n  State.update({ balancesUpdated: true });\n  return \"\";\n}\n\n// bridge-ui functions\n\nconst onAction = (data) => {\n  if (!data.amount) return;\n  if (data.action === \"deposit\") handleDeposit(data);\n  if (data.action === \"withdraw\") handleWithdrawalInitiating(data);\n};\n\nconst onTabChange = (tab) => {\n  let log = null;\n\n  const depositDisabled =\n    tab === \"deposit\" &&\n    (chainId === FRAXTAL_CHAIN_ID || chainId === FRAXTAL_HOLESKY_CHAIN_ID);\n  const withdrawDisabled =\n    tab === \"withdraw\" &&\n    (chainId === ETH_CHAIN_ID || chainId === HOLESKY_CHAIN_ID);\n\n  if (depositDisabled) {\n    log = depositDisabledMsg;\n  }\n  if (withdrawDisabled) {\n    log = withdrawDisabledMsg;\n  }\n\n  State.update({\n    deposit: clone(withdraw),\n    withdraw: clone(deposit),\n    depositDisabled,\n    withdrawDisabled,\n    tab,\n    log,\n  });\n};\n\nconst allWithdrawals = [...state.ethWithdrawals];\nconst allDeposits = [...state.ethDeposits];\n\nreturn (\n  <>\n    <Widget\n      src=\"mattlock.near/widget/bridge-ui\"\n      props={{\n        ...state,\n        onTabChange,\n        onAction,\n        title: \"Fraxtal Bridge\",\n        tokens,\n        allDeposits,\n        allWithdrawals,\n        withdrawalActions,\n      }}\n    />\n  </>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/mattlock.near/widget/frax-bridge", "fact_widget_deployments_id": "e3cc7bc6e1d46b5b951d2ea985600cd9", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 0}