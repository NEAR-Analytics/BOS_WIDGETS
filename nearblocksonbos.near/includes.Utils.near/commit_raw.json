{"tx_hash": "xggMQcEapA6NzoKU75QbxvgetjgJujxzWivBg9pfYUv", "action_id_social": "41FrMFfBstW3r92zRmB4sVDHKFJLvajK6GRbL33cNtBQ-0-widget", "block_id": 117885739, "block_timestamp": "2024-04-29T13:27:32.457Z", "signer_id": "nearblocksonbos.near", "widget_name": "includes.Utils.near", "source_code": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction MainComponent() {\n  function localFormat(number) {\n    const bigNumber = Big(number);\n    const formattedNumber = bigNumber\n      .toFixed(5)\n      .replace(/(\\d)(?=(\\d{3})+\\.)/g, '$1,'); // Add commas before the decimal point\n    return formattedNumber.replace(/\\.?0*$/, ''); // Remove trailing zeros and the dot\n  }\n  function dollarFormat(number) {\n    const bigNumber = new Big(number);\n\n    // Format to two decimal places without thousands separator\n    const formattedNumber = bigNumber.toFixed(2);\n\n    // Add comma as a thousands separator\n    const parts = formattedNumber.split('.');\n    parts[0] = parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',');\n\n    const dollarFormattedNumber = `${parts.join('.')}`;\n\n    return dollarFormattedNumber;\n  }\n  function yoctoToNear(yocto, format) {\n    const YOCTO_PER_NEAR = Big(10).pow(24).toString();\n\n    const near = Big(yocto).div(YOCTO_PER_NEAR).toString();\n\n    return format ? localFormat(near) : near;\n  }\n  function gasPrice(yacto) {\n    const near = Big(yoctoToNear(yacto, false)).mul(Big(10).pow(12)).toString();\n\n    return `${localFormat(near)} \u24c3 / Tgas`;\n  }\n\n  function encodeArgs(args) {\n    if (!args || typeof args === 'undefined') return '';\n\n    return Buffer.from(JSON.stringify(args)).toString('base64');\n  }\n\n  function decodeArgs(args) {\n    if (!args || typeof args === 'undefined') return {};\n\n    return JSON.parse(Buffer.from(args, 'base64').toString());\n  }\n\n  function tokenAmount(amount, decimal, format) {\n    if (amount === undefined || amount === null) return 'N/A';\n\n    const near = Big(amount).div(Big(10).pow(decimal));\n\n    const formattedValue = format\n      ? near.toFixed(8).replace(/\\.?0+$/, '')\n      : near.toFixed(Big(decimal, 10)).replace(/\\.?0+$/, '');\n\n    return formattedValue;\n  }\n\n  function txnMethod(\n    actions,\n    t,\n  ) {\n    const count = actions?.length || 0;\n\n    if (!count) return t ? t('txns:unknownType') : 'Unknown';\n    if (count > 1) return t ? t('txns:batchTxns') : 'Batch Transaction';\n\n    const action = actions[0];\n\n    if (action.action === 'FUNCTION_CALL') {\n      return action.method;\n    }\n\n    return action.action;\n  }\n\n  function price(amount, decimal, price) {\n    const nearAmount = Big(amount).div(Big(10).pow(decimal));\n    return dollarFormat(nearAmount.mul(Big(price || 0)).toString());\n  }\n\n  function tokenPercentage(supply, amount, decimal) {\n    const nearAmount = Big(amount).div(Big(10).pow(decimal));\n    const nearSupply = Big(supply);\n\n    return nearAmount.div(nearSupply).mul(Big(100)).toFixed(2);\n  }\n\n  function txnLogs(txn) {\n    let txLogs = [];\n\n    const outcomes = txn?.receipts_outcome || [];\n\n    for (let i = 0; i < outcomes.length; i++) {\n      const outcome = outcomes[i];\n      let logs = outcome?.outcome?.logs || [];\n\n      if (logs.length > 0) {\n        const mappedLogs = logs.map((log) => ({\n          contract: outcome?.outcome?.executor_id || '',\n          logs: log,\n        }));\n        txLogs = [...txLogs, ...mappedLogs];\n      }\n    }\n    return txLogs;\n  }\n\n  function mapRpcActionToAction(action) {\n    if (action === 'CreateAccount') {\n      return {\n        action_kind: 'CreateAccount',\n        args: {},\n      };\n    }\n\n    if (typeof action === 'object') {\n      const kind = action && Object.keys(action)[0];\n\n      return {\n        action_kind: kind,\n        args: action[kind],\n      };\n    }\n\n    return null;\n  }\n\n  function txnActions(txn) {\n    const txActions = [];\n    const receipts = txn?.receipts || [];\n\n    for (let i = 0; i < receipts.length; i++) {\n      const receipt = receipts[i];\n      const from = receipt?.predecessor_id;\n      const to = receipt?.receiver_id;\n\n      if (from === 'system') continue;\n\n      if (Array.isArray(receipt?.receipt)) {\n        const actions = receipt.receipt;\n\n        for (let j = 0; j < actions.length; j++) {\n          const action = actions[j];\n\n          txActions.push({ from, to, ...action });\n        }\n      } else {\n        const actions = receipt?.receipt?.Action?.actions || [];\n\n        for (let j = 0; j < actions.length; j++) {\n          const action = mapRpcActionToAction(actions[j]);\n\n          txActions.push({ from, to, ...action });\n        }\n      }\n    }\n\n    return txActions;\n  }\n\n  function valueFromObj(obj) {\n    const keys = obj && Object.keys(obj);\n\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      const value = obj[key];\n\n      if (typeof value === 'string') {\n        return value;\n      }\n\n      if (typeof value === 'object') {\n        const nestedValue = valueFromObj(value );\n        if (nestedValue) {\n          return nestedValue;\n        }\n      }\n    }\n\n    return undefined;\n  }\n\n  function txnErrorMessage(txn) {\n    const kind = txn?.status?.Failure?.ActionError?.kind;\n\n    if (typeof kind === 'string') return kind;\n    if (typeof kind === 'object') {\n      return valueFromObj(kind);\n    }\n\n    return null;\n  }\n\n  function collectNestedReceiptWithOutcomeOld(\n    idOrHash,\n    parsedMap,\n  ) {\n    const parsedElement = parsedMap && parsedMap.get(idOrHash);\n    if (!parsedElement) {\n      return { id: idOrHash };\n    }\n    const { receiptIds, ...restOutcome } = parsedElement.outcome;\n    return {\n      ...parsedElement,\n      outcome: {\n        ...restOutcome,\n        nestedReceipts: receiptIds.map((id) =>\n          collectNestedReceiptWithOutcomeOld(id, parsedMap),\n        ),\n      },\n    };\n  }\n\n  function parseReceipt(\n    receipt,\n    outcome,\n    transaction,\n  ) {\n    if (!receipt) {\n      return {\n        id: outcome.id,\n        predecessorId: transaction.signer_id,\n        receiverId: transaction.receiver_id,\n        actions:\n          transaction.actions && transaction.actions.map(mapRpcActionToAction1),\n      };\n    }\n    return {\n      id: receipt.receipt_id,\n      predecessorId: receipt.predecessor_id,\n      receiverId: receipt.receiver_id,\n      actions:\n        'Action' in receipt.receipt\n          ? receipt.receipt.Action.actions &&\n            receipt.receipt.Action.actions.map(mapRpcActionToAction1)\n          : [],\n    };\n  }\n\n  function mapNonDelegateRpcActionToAction(\n    rpcAction,\n  ) {\n    if (rpcAction === 'CreateAccount') {\n      return {\n        kind: 'createAccount',\n        args: {},\n      };\n    }\n    if ('DeployContract' in rpcAction) {\n      return {\n        kind: 'deployContract',\n        args: rpcAction.DeployContract,\n      };\n    }\n    if ('FunctionCall' in rpcAction) {\n      return {\n        kind: 'functionCall',\n        args: {\n          methodName: rpcAction.FunctionCall.method_name,\n          args: rpcAction.FunctionCall.args,\n          deposit: rpcAction.FunctionCall.deposit,\n          gas: rpcAction.FunctionCall.gas,\n        },\n      };\n    }\n    if ('Transfer' in rpcAction) {\n      return {\n        kind: 'transfer',\n        args: rpcAction.Transfer,\n      };\n    }\n    if ('Stake' in rpcAction) {\n      return {\n        kind: 'stake',\n        args: {\n          publicKey: rpcAction.Stake.public_key,\n          stake: rpcAction.Stake.stake,\n        },\n      };\n    }\n    if ('AddKey' in rpcAction) {\n      return {\n        kind: 'addKey',\n        args: {\n          publicKey: rpcAction.AddKey.public_key,\n          accessKey: {\n            nonce: rpcAction.AddKey.access_key.nonce,\n            permission:\n              rpcAction.AddKey.access_key.permission === 'FullAccess'\n                ? {\n                    type: 'fullAccess',\n                  }\n                : {\n                    type: 'functionCall',\n                    contractId:\n                      rpcAction.AddKey.access_key.permission.FunctionCall\n                        .receiver_id,\n                    methodNames:\n                      rpcAction.AddKey.access_key.permission.FunctionCall\n                        .method_names,\n                  },\n          },\n        },\n      };\n    }\n    if ('DeleteKey' in rpcAction) {\n      return {\n        kind: 'deleteKey',\n        args: {\n          publicKey: rpcAction.DeleteKey.public_key,\n        },\n      };\n    }\n    return {\n      kind: 'deleteAccount',\n      args: {\n        beneficiaryId: rpcAction.DeleteAccount.beneficiary_id,\n      },\n    };\n  }\n  function mapRpcInvalidAccessKeyError(error) {\n    const UNKNOWN_ERROR = { type: 'unknown' };\n\n    if (error === 'DepositWithFunctionCall') {\n      return {\n        type: 'depositWithFunctionCall',\n      };\n    }\n    if (error === 'RequiresFullAccess') {\n      return {\n        type: 'requiresFullAccess',\n      };\n    }\n    if ('AccessKeyNotFound' in error) {\n      const { account_id, public_key } = error.AccessKeyNotFound;\n      return {\n        type: 'accessKeyNotFound',\n        accountId: account_id,\n        publicKey: public_key,\n      };\n    }\n    if ('ReceiverMismatch' in error) {\n      const { ak_receiver, tx_receiver } = error.ReceiverMismatch;\n      return {\n        type: 'receiverMismatch',\n        akReceiver: ak_receiver,\n        transactionReceiver: tx_receiver,\n      };\n    }\n    if ('MethodNameMismatch' in error) {\n      const { method_name } = error.MethodNameMismatch;\n      return {\n        type: 'methodNameMismatch',\n        methodName: method_name,\n      };\n    }\n    if ('NotEnoughAllowance' in error) {\n      const { account_id, allowance, cost, public_key } =\n        error.NotEnoughAllowance;\n      return {\n        type: 'notEnoughAllowance',\n        accountId: account_id,\n        allowance: allowance,\n        cost: cost,\n        publicKey: public_key,\n      };\n    }\n\n    return UNKNOWN_ERROR;\n  }\n\n  function mapRpcCompilationError(error) {\n    const UNKNOWN_ERROR = { type: 'unknown' };\n    if ('CodeDoesNotExist' in error) {\n      return {\n        type: 'codeDoesNotExist',\n        accountId: error.CodeDoesNotExist.account_id,\n      };\n    }\n    if ('PrepareError' in error) {\n      return {\n        type: 'prepareError',\n      };\n    }\n    if ('WasmerCompileError' in error) {\n      return {\n        type: 'wasmerCompileError',\n        msg: error.WasmerCompileError.msg,\n      };\n    }\n    if ('UnsupportedCompiler' in error) {\n      return {\n        type: 'unsupportedCompiler',\n        msg: error.UnsupportedCompiler.msg,\n      };\n    }\n    return UNKNOWN_ERROR;\n  }\n\n  function mapRpcFunctionCallError(error) {\n    const UNKNOWN_ERROR = { type: 'unknown' };\n    if ('CompilationError' in error) {\n      return {\n        type: 'compilationError',\n        error: mapRpcCompilationError(error.CompilationError),\n      };\n    }\n    if ('LinkError' in error) {\n      return {\n        type: 'linkError',\n        msg: error.LinkError.msg,\n      };\n    }\n    if ('MethodResolveError' in error) {\n      return {\n        type: 'methodResolveError',\n      };\n    }\n    if ('WasmTrap' in error) {\n      return {\n        type: 'wasmTrap',\n      };\n    }\n    if ('WasmUnknownError' in error) {\n      return {\n        type: 'wasmUnknownError',\n      };\n    }\n    if ('HostError' in error) {\n      return {\n        type: 'hostError',\n      };\n    }\n    if ('_EVMError' in error) {\n      return {\n        type: 'evmError',\n      };\n    }\n    if ('ExecutionError' in error) {\n      return {\n        type: 'executionError',\n        error: error.ExecutionError,\n      };\n    }\n    return UNKNOWN_ERROR;\n  }\n  function mapRpcNewReceiptValidationError(\n    error,\n  ) {\n    const UNKNOWN_ERROR = { type: 'unknown' };\n    if ('InvalidPredecessorId' in error) {\n      return {\n        type: 'invalidPredecessorId',\n        accountId: error.InvalidPredecessorId.account_id,\n      };\n    }\n    if ('InvalidReceiverId' in error) {\n      return {\n        type: 'invalidReceiverId',\n        accountId: error.InvalidReceiverId.account_id,\n      };\n    }\n    if ('InvalidSignerId' in error) {\n      return {\n        type: 'invalidSignerId',\n        accountId: error.InvalidSignerId.account_id,\n      };\n    }\n    if ('InvalidDataReceiverId' in error) {\n      return {\n        type: 'invalidDataReceiverId',\n        accountId: error.InvalidDataReceiverId.account_id,\n      };\n    }\n    if ('ReturnedValueLengthExceeded' in error) {\n      return {\n        type: 'returnedValueLengthExceeded',\n        length: error.ReturnedValueLengthExceeded.length,\n        limit: error.ReturnedValueLengthExceeded.limit,\n      };\n    }\n    if ('NumberInputDataDependenciesExceeded' in error) {\n      return {\n        type: 'numberInputDataDependenciesExceeded',\n        numberOfInputDataDependencies:\n          error.NumberInputDataDependenciesExceeded\n            .number_of_input_data_dependencies,\n        limit: error.NumberInputDataDependenciesExceeded.limit,\n      };\n    }\n    if ('ActionsValidation' in error) {\n      return {\n        type: 'actionsValidation',\n      };\n    }\n    return UNKNOWN_ERROR;\n  }\n\n  function mapRpcReceiptActionError(error) {\n    const UNKNOWN_ERROR = { type: 'unknown' };\n    const { kind } = error;\n    if (kind === 'DelegateActionExpired') {\n      return {\n        type: 'delegateActionExpired',\n      };\n    }\n    if (kind === 'DelegateActionInvalidSignature') {\n      return {\n        type: 'delegateActionInvalidSignature',\n      };\n    }\n    if ('DelegateActionSenderDoesNotMatchTxReceiver' in kind) {\n      return {\n        type: 'delegateActionSenderDoesNotMatchTxReceiver',\n        receiverId: kind.DelegateActionSenderDoesNotMatchTxReceiver.receiver_id,\n        senderId: kind.DelegateActionSenderDoesNotMatchTxReceiver.sender_id,\n      };\n    }\n    if ('DelegateActionAccessKeyError' in kind) {\n      return {\n        type: 'delegateActionAccessKeyError',\n        error: mapRpcInvalidAccessKeyError(kind.DelegateActionAccessKeyError),\n      };\n    }\n    if ('DelegateActionInvalidNonce' in kind) {\n      return {\n        type: 'delegateActionInvalidNonce',\n        akNonce: kind.DelegateActionInvalidNonce.ak_nonce,\n        delegateNonce: kind.DelegateActionInvalidNonce.delegate_nonce,\n      };\n    }\n    if ('DelegateActionNonceTooLarge' in kind) {\n      return {\n        type: 'delegateActionNonceTooLarge',\n        delegateNonce: kind.DelegateActionNonceTooLarge.delegate_nonce,\n        upperBound: kind.DelegateActionNonceTooLarge.upper_bound,\n      };\n    }\n    if ('AccountAlreadyExists' in kind) {\n      return {\n        type: 'accountAlreadyExists',\n        accountId: kind.AccountAlreadyExists.account_id,\n      };\n    }\n    if ('AccountDoesNotExist' in kind) {\n      return {\n        type: 'accountDoesNotExist',\n        accountId: kind.AccountDoesNotExist.account_id,\n      };\n    }\n    if ('CreateAccountOnlyByRegistrar' in kind) {\n      return {\n        type: 'createAccountOnlyByRegistrar',\n        accountId: kind.CreateAccountOnlyByRegistrar.account_id,\n        registrarAccountId:\n          kind.CreateAccountOnlyByRegistrar.registrar_account_id,\n        predecessorId: kind.CreateAccountOnlyByRegistrar.predecessor_id,\n      };\n    }\n    if ('CreateAccountNotAllowed' in kind) {\n      return {\n        type: 'createAccountNotAllowed',\n        accountId: kind.CreateAccountNotAllowed.account_id,\n        predecessorId: kind.CreateAccountNotAllowed.predecessor_id,\n      };\n    }\n    if ('ActorNoPermission' in kind) {\n      return {\n        type: 'actorNoPermission',\n        accountId: kind.ActorNoPermission.account_id,\n        actorId: kind.ActorNoPermission.actor_id,\n      };\n    }\n    if ('DeleteKeyDoesNotExist' in kind) {\n      return {\n        type: 'deleteKeyDoesNotExist',\n        accountId: kind.DeleteKeyDoesNotExist.account_id,\n        publicKey: kind.DeleteKeyDoesNotExist.public_key,\n      };\n    }\n    if ('AddKeyAlreadyExists' in kind) {\n      return {\n        type: 'addKeyAlreadyExists',\n        accountId: kind.AddKeyAlreadyExists.account_id,\n        publicKey: kind.AddKeyAlreadyExists.public_key,\n      };\n    }\n    if ('DeleteAccountStaking' in kind) {\n      return {\n        type: 'deleteAccountStaking',\n        accountId: kind.DeleteAccountStaking.account_id,\n      };\n    }\n    if ('LackBalanceForState' in kind) {\n      return {\n        type: 'lackBalanceForState',\n        accountId: kind.LackBalanceForState.account_id,\n        amount: kind.LackBalanceForState.amount,\n      };\n    }\n    if ('TriesToUnstake' in kind) {\n      return {\n        type: 'triesToUnstake',\n        accountId: kind.TriesToUnstake.account_id,\n      };\n    }\n    if ('TriesToStake' in kind) {\n      return {\n        type: 'triesToStake',\n        accountId: kind.TriesToStake.account_id,\n        stake: kind.TriesToStake.stake,\n        locked: kind.TriesToStake.locked,\n        balance: kind.TriesToStake.balance,\n      };\n    }\n    if ('InsufficientStake' in kind) {\n      return {\n        type: 'insufficientStake',\n        accountId: kind.InsufficientStake.account_id,\n        stake: kind.InsufficientStake.stake,\n        minimumStake: kind.InsufficientStake.minimum_stake,\n      };\n    }\n    if ('FunctionCallError' in kind) {\n      return {\n        type: 'functionCallError',\n        error: mapRpcFunctionCallError(kind.FunctionCallError),\n      };\n    }\n    if ('NewReceiptValidationError' in kind) {\n      return {\n        type: 'newReceiptValidationError',\n        error: mapRpcNewReceiptValidationError(kind.NewReceiptValidationError),\n      };\n    }\n    if ('OnlyImplicitAccountCreationAllowed' in kind) {\n      return {\n        type: 'onlyImplicitAccountCreationAllowed',\n        accountId: kind.OnlyImplicitAccountCreationAllowed.account_id,\n      };\n    }\n    if ('DeleteAccountWithLargeState' in kind) {\n      return {\n        type: 'deleteAccountWithLargeState',\n        accountId: kind.DeleteAccountWithLargeState.account_id,\n      };\n    }\n    return UNKNOWN_ERROR;\n  }\n\n  function mapRpcReceiptInvalidTxError(error) {\n    const UNKNOWN_ERROR = { type: 'unknown' };\n    if ('InvalidAccessKeyError' in error) {\n      return {\n        type: 'invalidAccessKeyError',\n        error: mapRpcInvalidAccessKeyError(error.InvalidAccessKeyError),\n      };\n    }\n    if ('InvalidSignerId' in error) {\n      return {\n        type: 'invalidSignerId',\n        signerId: error.InvalidSignerId.signer_id,\n      };\n    }\n    if ('SignerDoesNotExist' in error) {\n      return {\n        type: 'signerDoesNotExist',\n        signerId: error.SignerDoesNotExist.signer_id,\n      };\n    }\n    if ('InvalidNonce' in error) {\n      return {\n        type: 'invalidNonce',\n        transactionNonce: error.InvalidNonce.tx_nonce,\n        akNonce: error.InvalidNonce.ak_nonce,\n      };\n    }\n    if ('NonceTooLarge' in error) {\n      return {\n        type: 'nonceTooLarge',\n        transactionNonce: error.NonceTooLarge.tx_nonce,\n        upperBound: error.NonceTooLarge.upper_bound,\n      };\n    }\n    if ('InvalidReceiverId' in error) {\n      return {\n        type: 'invalidReceiverId',\n        receiverId: error.InvalidReceiverId.receiver_id,\n      };\n    }\n    if ('InvalidSignature' in error) {\n      return {\n        type: 'invalidSignature',\n      };\n    }\n    if ('NotEnoughBalance' in error) {\n      return {\n        type: 'notEnoughBalance',\n        signerId: error.NotEnoughBalance.signer_id,\n        balance: error.NotEnoughBalance.balance,\n        cost: error.NotEnoughBalance.cost,\n      };\n    }\n    if ('LackBalanceForState' in error) {\n      return {\n        type: 'lackBalanceForState',\n        signerId: error.LackBalanceForState.signer_id,\n        amount: error.LackBalanceForState.amount,\n      };\n    }\n    if ('CostOverflow' in error) {\n      return {\n        type: 'costOverflow',\n      };\n    }\n    if ('InvalidChain' in error) {\n      return {\n        type: 'invalidChain',\n      };\n    }\n    if ('Expired' in error) {\n      return {\n        type: 'expired',\n      };\n    }\n    if ('ActionsValidation' in error) {\n      return {\n        type: 'actionsValidation',\n      };\n    }\n    if ('TransactionSizeExceeded' in error) {\n      return {\n        type: 'transactionSizeExceeded',\n        size: error.TransactionSizeExceeded.size,\n        limit: error.TransactionSizeExceeded.limit,\n      };\n    }\n    return UNKNOWN_ERROR;\n  }\n\n  function mapRpcReceiptError(error) {\n    let UNKNOWN_ERROR = { type: 'unknown' };\n    if ('ActionError' in error) {\n      return {\n        type: 'action',\n        error: mapRpcReceiptActionError(error.ActionError),\n      };\n    }\n    if ('InvalidTxError' in error) {\n      return {\n        type: 'transaction',\n        error: mapRpcReceiptInvalidTxError(error.InvalidTxError),\n      };\n    }\n    return UNKNOWN_ERROR;\n  }\n\n  function mapRpcReceiptStatus(status) {\n    if ('SuccessValue' in status) {\n      return { type: 'successValue', value: status.SuccessValue };\n    }\n    if ('SuccessReceiptId' in status) {\n      return { type: 'successReceiptId', receiptId: status.SuccessReceiptId };\n    }\n    if ('Failure' in status) {\n      return { type: 'failure', error: mapRpcReceiptError(status.Failure) };\n    }\n    return { type: 'unknown' };\n  }\n\n  function mapRpcActionToAction1(rpcAction) {\n    if (typeof rpcAction === 'object' && 'Delegate' in rpcAction) {\n      return {\n        kind: 'delegateAction',\n        args: {\n          actions: rpcAction.Delegate.delegate_action.actions.map(\n            (subaction, index) => ({\n              ...mapNonDelegateRpcActionToAction(subaction),\n              delegateIndex: index,\n            }),\n          ),\n          receiverId: rpcAction.Delegate.delegate_action.receiver_id,\n          senderId: rpcAction.Delegate.delegate_action.sender_id,\n        },\n      };\n    }\n    return mapNonDelegateRpcActionToAction(rpcAction);\n  }\n\n  function parseOutcomeOld(outcome) {\n    return {\n      blockHash: outcome.block_hash,\n      tokensBurnt: outcome.outcome.tokens_burnt,\n      gasBurnt: outcome.outcome.gas_burnt,\n      status: mapRpcReceiptStatus(outcome.outcome.status),\n      logs: outcome.outcome.logs,\n      receiptIds: outcome.outcome.receipt_ids,\n    };\n  }\n\n  return {\n    gasPrice,\n    encodeArgs,\n    decodeArgs,\n    tokenAmount,\n    txnMethod,\n    price,\n    tokenPercentage,\n    txnLogs,\n    txnActions,\n    txnErrorMessage,\n    parseOutcomeOld,\n    collectNestedReceiptWithOutcomeOld,\n    parseReceipt,\n    mapRpcActionToAction,\n  };\n}\n\nreturn MainComponent(props, context);", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/nearblocksonbos.near/widget/includes.Utils.near", "fact_widget_deployments_id": "0d63518a3b301a14a2c1f007311b57fd", "inserted_timestamp": "2024-04-29T14:40:45.686Z", "modified_timestamp": "2024-04-29T14:40:45.686Z", "__row_index": 1}