{"tx_hash": "394qsKmBGXELwsVCZHde6mt7uzKsRU7EtfirGKNZvw8u", "action_id_social": "4zPbDdcugaxF5z6ex8TNJFadmC7iYqWe1Lc14bnTQPjN-0-widget", "block_id": 105289338, "block_timestamp": "2023-11-09T11:01:41.886Z", "signer_id": "0xfafa.near", "widget_name": "Avalanche.Swap.SwapButton", "source_code": "const TraderJoeRouterAbi = [\n  {\n    inputs: [],\n    name: \"WETH\",\n    outputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"factory\",\n    outputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"bytes[]\", name: \"data\", type: \"bytes[]\" }],\n    name: \"multicall\",\n    outputs: [{ internalType: \"bytes[]\", name: \"results\", type: \"bytes[]\" }],\n    stateMutability: \"payable\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"refundEth\",\n    outputs: [],\n    stateMutability: \"payable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"int256\", name: \"deltaQty0\", type: \"int256\" },\n      { internalType: \"int256\", name: \"deltaQty1\", type: \"int256\" },\n      { internalType: \"bytes\", name: \"data\", type: \"bytes\" },\n    ],\n    name: \"swapCallback\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { internalType: \"bytes\", name: \"path\", type: \"bytes\" },\n          { internalType: \"address\", name: \"recipient\", type: \"address\" },\n          { internalType: \"uint256\", name: \"deadline\", type: \"uint256\" },\n          { internalType: \"uint256\", name: \"amountIn\", type: \"uint256\" },\n          { internalType: \"uint256\", name: \"minAmountOut\", type: \"uint256\" },\n        ],\n        internalType: \"struct IRouter.ExactInputParams\",\n        name: \"params\",\n        type: \"tuple\",\n      },\n    ],\n    name: \"swapExactInput\",\n    outputs: [{ internalType: \"uint256\", name: \"amountOut\", type: \"uint256\" }],\n    stateMutability: \"payable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { internalType: \"address\", name: \"tokenIn\", type: \"address\" },\n          { internalType: \"address\", name: \"tokenOut\", type: \"address\" },\n          { internalType: \"uint24\", name: \"fee\", type: \"uint24\" },\n          { internalType: \"address\", name: \"recipient\", type: \"address\" },\n          { internalType: \"uint256\", name: \"deadline\", type: \"uint256\" },\n          { internalType: \"uint256\", name: \"amountIn\", type: \"uint256\" },\n          { internalType: \"uint256\", name: \"minAmountOut\", type: \"uint256\" },\n          { internalType: \"uint160\", name: \"limitSqrtP\", type: \"uint160\" },\n        ],\n        internalType: \"struct IRouter.ExactInputSingleParams\",\n        name: \"params\",\n        type: \"tuple\",\n      },\n    ],\n    name: \"swapExactInputSingle\",\n    outputs: [{ internalType: \"uint256\", name: \"amountOut\", type: \"uint256\" }],\n    stateMutability: \"payable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { internalType: \"bytes\", name: \"path\", type: \"bytes\" },\n          { internalType: \"address\", name: \"recipient\", type: \"address\" },\n          { internalType: \"uint256\", name: \"deadline\", type: \"uint256\" },\n          { internalType: \"uint256\", name: \"amountOut\", type: \"uint256\" },\n          { internalType: \"uint256\", name: \"maxAmountIn\", type: \"uint256\" },\n        ],\n        internalType: \"struct IRouter.ExactOutputParams\",\n        name: \"params\",\n        type: \"tuple\",\n      },\n    ],\n    name: \"swapExactOutput\",\n    outputs: [{ internalType: \"uint256\", name: \"amountIn\", type: \"uint256\" }],\n    stateMutability: \"payable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { internalType: \"address\", name: \"tokenIn\", type: \"address\" },\n          { internalType: \"address\", name: \"tokenOut\", type: \"address\" },\n          { internalType: \"uint24\", name: \"fee\", type: \"uint24\" },\n          { internalType: \"address\", name: \"recipient\", type: \"address\" },\n          { internalType: \"uint256\", name: \"deadline\", type: \"uint256\" },\n          { internalType: \"uint256\", name: \"amountOut\", type: \"uint256\" },\n          { internalType: \"uint256\", name: \"maxAmountIn\", type: \"uint256\" },\n          { internalType: \"uint160\", name: \"limitSqrtP\", type: \"uint160\" },\n        ],\n        internalType: \"struct IRouter.ExactOutputSingleParams\",\n        name: \"params\",\n        type: \"tuple\",\n      },\n    ],\n    name: \"swapExactOutputSingle\",\n    outputs: [{ internalType: \"uint256\", name: \"amountIn\", type: \"uint256\" }],\n    stateMutability: \"payable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"token\", type: \"address\" },\n      { internalType: \"uint256\", name: \"minAmount\", type: \"uint256\" },\n      { internalType: \"address\", name: \"recipient\", type: \"address\" },\n    ],\n    name: \"transferAllTokens\",\n    outputs: [],\n    stateMutability: \"payable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"token\", type: \"address\" },\n      { internalType: \"uint256\", name: \"minAmount\", type: \"uint256\" },\n      { internalType: \"address\", name: \"recipient\", type: \"address\" },\n      { internalType: \"uint256\", name: \"feeUnits\", type: \"uint256\" },\n      { internalType: \"address\", name: \"feeRecipient\", type: \"address\" },\n    ],\n    name: \"transferAllTokensWithFee\",\n    outputs: [],\n    stateMutability: \"payable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"uint256\", name: \"minAmount\", type: \"uint256\" },\n      { internalType: \"address\", name: \"recipient\", type: \"address\" },\n    ],\n    name: \"unwrapWeth\",\n    outputs: [],\n    stateMutability: \"payable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"uint256\", name: \"minAmount\", type: \"uint256\" },\n      { internalType: \"address\", name: \"recipient\", type: \"address\" },\n      { internalType: \"uint256\", name: \"feeUnits\", type: \"uint256\" },\n      { internalType: \"address\", name: \"feeRecipient\", type: \"address\" },\n    ],\n    name: \"unwrapWethWithFee\",\n    outputs: [],\n    stateMutability: \"payable\",\n    type: \"function\",\n  },\n  { stateMutability: \"payable\", type: \"receive\" },\n];\n\nconst SwapButton = styled.button`\n  width: 100%;\n  height: 60px;\n  border-radius: 10px;\n  background-color: #ea3431;\n  color: #fff;\n  font-size: 18px;\n  line-height: 22px;\n  border: none;\n  transition: 0.5s;\n  cursor: pointer;\n  :hover {\n    opacity: 0.8;\n  }\n  &:disabled {\n    opacity: 0.5;\n    pointer-events: none;\n  }\n  @media (max-width: 900px) {\n    height: 40px;\n    font-size: 16px;\n  }\n`;\nconst account = Ethers.send(\"eth_requestAccounts\", [])[0];\nif (props.noPair) {\n  return <SwapButton disabled>Insufficient Liquidity</SwapButton>;\n}\n\nif (props.loading) {\n  return <SwapButton disabled>Getting Trade Info...</SwapButton>;\n}\n\nconst {\n  inputCurrency,\n  outputCurrency,\n  inputCurrencyAmount,\n  outputCurrencyAmount,\n  maxInputBalance,\n  onSuccess,\n  routerAddress,\n  wethAddress,\n  title,\n  fee,\n  uniType,\n} = props;\nconsole.log(\"props: \", props);\n\nconst expandToken = (value, decimals) => {\n  return new Big(value).mul(new Big(10).pow(decimals));\n};\n\nif (Big(inputCurrencyAmount || 0).eq(0)) {\n  return <SwapButton disabled>Enter An Amount</SwapButton>;\n}\nif (!inputCurrency || !outputCurrency) {\n  return <SwapButton disabled>Select a token</SwapButton>;\n}\nif (Big(inputCurrencyAmount || 0).gt(maxInputBalance)) {\n  return (\n    <SwapButton disabled>\n      Insufficient {inputCurrency?.symbol} Balance\n    </SwapButton>\n  );\n}\n\nState.init({\n  isApproved: false,\n  approving: false,\n  swapping: false,\n  wrapping: false,\n});\n\nconst getAllowance = () => {\n  const TokenContract = new ethers.Contract(\n    inputCurrency.address,\n    [\n      {\n        constant: true,\n        inputs: [\n          {\n            name: \"_owner\",\n            type: \"address\",\n          },\n          {\n            name: \"_spender\",\n            type: \"address\",\n          },\n        ],\n        name: \"allowance\",\n        outputs: [\n          {\n            name: \"\",\n            type: \"uint256\",\n          },\n        ],\n        payable: false,\n        stateMutability: \"view\",\n        type: \"function\",\n      },\n    ],\n    Ethers.provider().getSigner()\n  );\n  TokenContract.allowance(account, routerAddress).then((allowanceRaw) => {\n    State.update({\n      isApproved: !Big(Number(allowanceRaw._hex)).eq(0),\n    });\n  });\n};\n\nif (inputCurrency.address !== \"native\") {\n  getAllowance();\n} else {\n  State.update({ isApproved: true });\n}\n\nconst wrapType =\n  inputCurrency.address === \"native\" && outputCurrency.symbol === \"WAVAX\"\n    ? 1\n    : inputCurrency.symbol === \"WAVAX\" && outputCurrency.address === \"native\"\n    ? 2\n    : 0;\n\nconst handleApprove = () => {\n  State.update({\n    approving: true,\n  });\n  const TokenContract = new ethers.Contract(\n    inputCurrency.address,\n    [\n      {\n        constant: false,\n        inputs: [\n          {\n            name: \"_spender\",\n            type: \"address\",\n          },\n          {\n            name: \"_value\",\n            type: \"uint256\",\n          },\n        ],\n        name: \"approve\",\n        outputs: [\n          {\n            name: \"\",\n            type: \"bool\",\n          },\n        ],\n        payable: false,\n        stateMutability: \"nonpayable\",\n        type: \"function\",\n      },\n    ],\n    Ethers.provider().getSigner()\n  );\n  TokenContract.approve(\n    routerAddress,\n    ethers.utils.parseUnits(inputCurrencyAmount, inputCurrency.decimals)\n  )\n    .then((tx) => {\n      tx.wait().then((res) => {\n        const { status, transactionHash } = res;\n        State.update({\n          isApproved: status === 1,\n          approving: false,\n        });\n      });\n    })\n    .catch(() => {\n      State.update({\n        approving: false,\n      });\n    });\n};\n\nif (!state.isApproved && wrapType === 0) {\n  return (\n    <SwapButton onClick={handleApprove} disabled={state.approving}>\n      {state.approving ? \" Approving...\" : \" Approve\"}\n    </SwapButton>\n  );\n}\n\nfunction add_action(param_body) {\n  asyncFetch(\"https://bos-api.delink.one/add-action-data\", {\n    method: \"post\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify(param_body),\n  });\n}\n\nfunction successCallback(res, callback) {\n  const { status, transactionHash } = res;\n  callback?.();\n  const uuid = Storage.get(\n    \"zkevm-warm-up-uuid\",\n    \"bluebiu.near/widget/ZKEVMWarmUp.generage-uuid\"\n  );\n  add_action({\n    action_title: `Swap ${inputCurrencyAmount} ${inputCurrency.symbol} on ${title}`,\n    action_type: \"Swap\",\n    action_tokens: JSON.stringify([\n      `${inputCurrency.symbol}`,\n      `${outputCurrency.symbol}`,\n    ]),\n    action_amount: inputCurrencyAmount,\n    account_id: account,\n    account_info: uuid,\n    template: title,\n    action_status: status === 1 ? \"Success\" : \"Failed\",\n    tx_id: transactionHash,\n    action_network_id: \"Base\",\n  });\n  if (status === 1) {\n    onSuccess?.();\n  }\n}\n\nconst handleWrap = (type, onSuccess, onError) => {\n  const WethContract = new ethers.Contract(\n    wethAddress,\n    [\n      {\n        constant: false,\n        inputs: [],\n        name: \"deposit\",\n        outputs: [],\n        payable: true,\n        stateMutability: \"payable\",\n        type: \"function\",\n      },\n      {\n        constant: false,\n        inputs: [{ internalType: \"uint256\", name: \"wad\", type: \"uint256\" }],\n        name: \"withdraw\",\n        outputs: [],\n        payable: false,\n        stateMutability: \"nonpayable\",\n        type: \"function\",\n      },\n    ],\n    Ethers.provider().getSigner()\n  );\n\n  if (type === 1) {\n    WethContract.deposit({\n      value: ethers.utils.parseEther(inputCurrencyAmount),\n    })\n      .then((tx) => {\n        tx.wait().then((res) => {\n          onSuccess?.(res);\n        });\n      })\n      .catch((err) => {\n        onError?.();\n      });\n  } else {\n    WethContract.withdraw(ethers.utils.parseEther(inputCurrencyAmount))\n      .then((tx) => {\n        tx.wait().then((res) => {\n          onSuccess?.(res);\n        });\n      })\n      .catch((err) => {\n        onError?.();\n      });\n  }\n};\n\nif (wrapType) {\n  return (\n    <SwapButton\n      onClick={() => {\n        State.update({\n          wrapping: true,\n        });\n        handleWrap(\n          wrapType,\n          (res) => {\n            successCallback(res, () => {\n              State.update({ wrapping: false });\n            });\n          },\n          () => {\n            State.update({\n              wrapping: false,\n            });\n          }\n        );\n      }}\n      disabled={state.wrapping}\n    >\n      {wrapType === 1\n        ? state.wrapping\n          ? \"Wrapping...\"\n          : \"Wrap\"\n        : state.wrapping\n        ? \"Unwrapping...\"\n        : \"Unwrap\"}\n    </SwapButton>\n  );\n}\n\nconst handleSwap = () => {\n  const type =\n    inputCurrency.address === \"native\"\n      ? 1\n      : outputCurrency.address === \"native\"\n      ? 2\n      : 0;\n  const RouterContract = new ethers.Contract(\n    routerAddress,\n    [\n      {\n        inputs: [\n          {\n            internalType: \"uint256\",\n            name: \"amountOut\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"amountInMax\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"address[]\",\n            name: \"path\",\n            type: \"address[]\",\n          },\n          {\n            internalType: \"address\",\n            name: \"to\",\n            type: \"address\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"deadline\",\n            type: \"uint256\",\n          },\n        ],\n        name: \"swapExactTokensForTokens\",\n        outputs: [\n          {\n            internalType: \"uint256[]\",\n            name: \"amounts\",\n            type: \"uint256[]\",\n          },\n        ],\n        stateMutability: \"nonpayable\",\n        type: \"function\",\n      },\n      {\n        inputs: [\n          { internalType: \"uint256\", name: \"amountOutMin\", type: \"uint256\" },\n          { internalType: \"address[]\", name: \"path\", type: \"address[]\" },\n          { internalType: \"address\", name: \"to\", type: \"address\" },\n          { internalType: \"uint256\", name: \"deadline\", type: \"uint256\" },\n        ],\n        name: \"swapExactETHForTokens\",\n        outputs: [\n          { internalType: \"uint256[]\", name: \"amounts\", type: \"uint256[]\" },\n        ],\n        stateMutability: \"payable\",\n        type: \"function\",\n      },\n      {\n        inputs: [\n          { internalType: \"uint256\", name: \"amountIn\", type: \"uint256\" },\n          { internalType: \"uint256\", name: \"amountOutMin\", type: \"uint256\" },\n          { internalType: \"address[]\", name: \"path\", type: \"address[]\" },\n          { internalType: \"address\", name: \"to\", type: \"address\" },\n          { internalType: \"uint256\", name: \"deadline\", type: \"uint256\" },\n        ],\n        name: \"swapExactTokensForETH\",\n        outputs: [\n          { internalType: \"uint256[]\", name: \"amounts\", type: \"uint256[]\" },\n        ],\n        stateMutability: \"nonpayable\",\n        type: \"function\",\n      },\n    ],\n    Ethers.provider().getSigner()\n  );\n\n  State.update({\n    swapping: true,\n  });\n  if (type === 0) {\n    RouterContract.swapExactTokensForTokens(\n      ethers.utils.parseUnits(inputCurrencyAmount, inputCurrency.decimals),\n      \"0\",\n      [inputCurrency.address, outputCurrency.address],\n      account,\n      Math.ceil(Date.now() / 1000) + 60,\n      { gasLimit: 5000000 }\n    )\n      .then((res) => {\n        successCallback(res, () => {\n          State.update({ swapping: false });\n        });\n      })\n      .catch((err) => {\n        State.update({\n          swapping: false,\n        });\n      });\n    return;\n  }\n  if (type === 1) {\n    RouterContract.swapExactETHForTokens(\n      \"0\",\n      [wethAddress, outputCurrency.address],\n      account,\n      Math.ceil(Date.now() / 1000) + 60,\n      {\n        gasLimit: 5000000,\n        value: ethers.utils.parseEther(inputCurrencyAmount),\n      }\n    )\n      .then((res) => {\n        successCallback(res, () => {\n          State.update({ swapping: false });\n        });\n      })\n      .catch((err) => {\n        State.update({\n          swapping: false,\n        });\n      });\n    return;\n  }\n  if (type === 2) {\n    RouterContract.swapExactTokensForETH(\n      ethers.utils.parseUnits(inputCurrencyAmount, inputCurrency.decimals),\n      \"0\",\n      [inputCurrency.address, wethAddress],\n      account,\n      Math.ceil(Date.now() / 1000) + 60,\n      { gasLimit: 5000000 }\n    )\n      .then((res) => {\n        successCallback(res, () => {\n          State.update({ swapping: false });\n        });\n      })\n      .catch((err) => {\n        console.log(err);\n        State.update({\n          swapping: false,\n        });\n      });\n  }\n};\n\nconst handleSwapV3 = () => {\n  const value = expandToken(\n    inputCurrencyAmount,\n    inputCurrency.decimals\n  ).toFixed(0);\n\n  const signer = Ethers.provider().getSigner();\n\n  const abi = TraderJoeRouterAbi;\n  const iface = new ethers.utils.Interface(abi);\n\n  const deadline = new Big(Math.floor(Date.now() / 1000)).add(new Big(1800));\n\n  const tokenIn =\n    inputCurrency.address === \"native\" ? wethAddress : inputCurrency.address;\n\n  const tokenOut =\n    outputCurrency.address === \"native\" ? wethAddress : outputCurrency.address;\n\n  const options = {\n    gasLimit: gasLimit ?? 300000,\n    value: inputCurrency.address === \"native\" ? value : \"0\",\n  };\n\n  const inputs = [\n    {\n      tokenIn,\n      tokenOut,\n      fee: fee,\n      recipient:\n        outputCurrency.address === \"native\"\n          ? \"0x0000000000000000000000000000000000000000\"\n          : account,\n      deadline: deadline.toFixed(),\n      amountIn: value,\n      minAmountOut: \"0\",\n      limitSqrtP: \"0\",\n    },\n  ];\n\n  const multicallParams = [];\n\n  const encodedDataCallSwap = iface.encodeFunctionData(\n    \"swapExactInputSingle\",\n    inputs\n  );\n\n  multicallParams.push(encodedDataCallSwap);\n\n  if (outputCurrency.address === \"native\") {\n    multicallParams.push(\n      iface.encodeFunctionData(\"unwrapWeth\", [\"0\", account])\n    );\n  }\n\n  const multicallContract = new ethers.Contract(routerAddress, abi, signer);\n\n  multicallContract\n    .multicall(multicallParams, options)\n    .then((res) => {\n      successCallback(res, () => {\n        State.update({ swapping: false });\n      });\n    })\n    .catch((err) => {\n      console.log(err);\n      State.update({\n        swapping: false,\n      });\n    });\n};\n\nreturn (\n  <SwapButton\n    onClick={uniType === \"v3\" && !wrapType ? handleSwapV3 : handleSwap}\n    disabled={state.swapping}\n  >\n    {state.swapping ? \"Swapping...\" : \"Swap\"}\n  </SwapButton>\n);\n", "metadata": {"platform": "jutsu.ai"}, "branch": {"draft": null}, "widget_modules_used": null, "widget_url": "https://near.social/#/0xfafa.near/widget/Avalanche.Swap.SwapButton", "fact_widget_deployments_id": "cd5fc1b9e4351ba7701ddd2ce7a42967", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 0}