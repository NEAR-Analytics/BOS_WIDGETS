{"tx_hash": "91ndr4C67wKLR7pR9AjqRVup1R81qNPLjpGoBtoKx2Sn", "action_id_social": "FiJDyLqfGHgtXrf7bnRkwBz2usHD3VZAGUk9xg6tKbhn-0-widget", "block_id": 101276668, "block_timestamp": "2023-09-16T20:09:07.040Z", "signer_id": "wendersonpires.near", "widget_name": "NearSocialBridgeCore", "source_code": "/**\n * This Component is part of the NEAR Social Bridge library.\n * Visit https://github.com/wpdas/near-social-bridge to get to know more.\n */\n\n// Crucial checks\nif (!props.externalAppUrl) {\n  return (\n    <div>\n      <p\n        style={{ fontWeight: 600, color: \"#AB2E28\", fontFamily: \"Courier new\" }}\n      >\n        This Component is part of the{\" \"}\n        <a href=\"https://github.com/wpdas/near-social-bridge\" target=\"_blank\">\n          \"near-social-bridge\"\n        </a>{\" \"}\n        library that makes it possible to develop common ReactJS applications\n        and inject them into the BOS having access to all Discovery API\n        resources.\n      </p>\n      <p\n        style={{ fontWeight: 600, color: \"#AB2E28\", fontFamily: \"Courier new\" }}\n      >\n        Learn more here:{\" \"}\n        <a href=\"https://github.com/wpdas/near-social-bridge\" target=\"_blank\">\n          https://github.com/wpdas/near-social-bridge\n        </a>\n      </p>\n    </div>\n  );\n}\n\n/**\n * Load React, React Dom and the Core Bridge library\n *\n * It's recommended to use VSCode to edit this code.\n * Save this code in the core.js file as well.\n */\nconst code = `\n<script src=\"https://unpkg.com/react@18/umd/react.development.js\" crossorigin></script>\n<script src=\"https://unpkg.com/react-dom@18/umd/react-dom.development.js\" crossorigin></script>\n<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/reseter.css/1.0.8/reseter.min.css\">\n<div id=\"bridge-root\"></div>\n<script src=\"https://unpkg.com/near-social-bridge@1.3.0/widget/core.min.js\" crossorigin></script>\n`;\n\n// (i) Discovery API uses cached data structure\nconst Utils = {\n  /**\n   * Send message\n   */\n  sendMessage: (message) => {\n    State.update({\n      currentMessage: message,\n    });\n  },\n  /**\n   * Call resolve or reject for a given caller\n   * E.g:\n   * var timeout = 5000 // 5sec\n   * Utils.promisify(() => getCachedObject(), (res) => console.log(res), (err) => console.log(err), timeout)\n   *\n   * Default timeout is 10 seconds\n   */\n  promisify: (caller, resolve, reject, _timeout) => {\n    const timer = 1000;\n    const timeout = _timeout || timer * 10;\n    let timeoutCheck = 0;\n\n    const find = () => {\n      const response = caller();\n      if (response !== undefined && response !== null) {\n        resolve(response);\n      } else {\n        if (timeoutCheck < timeout) {\n          // try again\n          setTimeout(find, 1000);\n          timeoutCheck += timer;\n        } else {\n          reject(null);\n        }\n      }\n    };\n\n    // Fist attempt\n    find();\n  },\n};\n\n// External App Url\nconst externalAppUrl = props.externalAppUrl;\n\n// User Info\nconst accountId = context.accountId;\nconst userInfo = { accountId };\n\n// Initial Path\nconst initialPath = props.path;\n\n// Initial iframe height\nconst initialIframeHeight = props.initialViewHeight || 500;\n\n// Initial Payload (optional)\nconst initialPayload = props.initialPayload || {};\n\n// Initial State\nState.init({\n  iframeHeight: initialIframeHeight,\n  // (i) DON'T send async data, it's going to randonly fail\n  // If you need to get new info, use \"request\" for that\n  currentMessage: {\n    type: \"connect-view\",\n    externalAppUrl,\n    userInfo,\n    initialPath,\n    initialPayload,\n    initialIframeHeight,\n  },\n});\n\n// Answer Factory\nconst buildAnswer = (requestType, payload) => {\n  return {\n    from: \"view\",\n    type: \"answer\",\n    requestType,\n    payload,\n    created_at: Date.now(),\n  };\n};\n\n/**\n * BOS Component's response factory - closure\n *\n * E.g:\n * const response = responseFactory.build()\n * response({type: 'request-type'}).send({myPayloadHere: 123})\n */\nconst responseFactory = {\n  build: () => {\n    return (request) => {\n      return {\n        send: (payload) => {\n          const responseBody = buildAnswer(request.type, payload);\n          Utils.sendMessage(responseBody);\n        },\n      };\n    };\n  },\n};\n\nconst onMessageHandler = (message) => {\n  // Handles core calls\n  if (message.type.includes(\"nsb:\")) {\n    handlerCoreRequests(message);\n    return;\n  }\n\n  // Handles BOS Component's request calls:\n  // - request: payload sent by External App\n  // - response: method to send the answer back to the External App\n  // - utils: Utils features like: promisify, ...\n  const request = {\n    type: message.type,\n    payload: message.payload,\n  };\n  const utils = {\n    promisify: Utils.promisify,\n  };\n\n  if (props.requestHandler) {\n    props.requestHandler(request, responseFactory.build(), utils);\n  }\n};\n\n// REQUEST HANDLERS BELOW\nconst handlerCoreRequests = (message) => {\n  switch (message.type) {\n    case \"nsb:session-storage:hydrate-viewer\":\n      sessionStorageHydrateViewer(message.type, message.payload);\n      break;\n    case \"nsb:session-storage:hydrate-app\":\n      sessionStorageHydrateApp(message.type, message.payload);\n      break;\n    case \"nsb:navigation:sync-content-height\":\n      setIframeHeight(message.type, message.payload);\n      break;\n    case \"nsb:auth:get-user-info\":\n      getUserInfo(message.type, message.payload);\n      break;\n\n    // API NEAR\n    case \"nsb:near:view\":\n      nearView(message.type, message.payload);\n      break;\n    case \"nsb:near:call\":\n      nearCall(message.type, message.payload);\n      break;\n\n    // API Social\n    case \"nsb:social:get\":\n      socialGet(message.type, message.payload);\n      break;\n    case \"nsb:social:getr\":\n      socialGetr(message.type, message.payload);\n      break;\n    case \"nsb:social:keys\":\n      socialKeys(message.type, message.payload);\n      break;\n    case \"nsb:social:index\":\n      socialIndex(message.type, message.payload);\n      break;\n    case \"nsb:social:set\":\n      socialSet(message.type, message.payload);\n      break;\n\n    // API Storage\n    case \"nsb:storage:get\":\n      storageGet(message.type, message.payload);\n      break;\n    case \"nsb:storage:set\":\n      storageSet(message.type, message.payload);\n      break;\n    case \"nsb:storage:private-get\":\n      storagePrivateGet(message.type, message.payload);\n      break;\n    case \"nsb:storage:private-set\":\n      storagePrivateSet(message.type, message.payload);\n      break;\n\n    // API Fetch\n    case \"nsb:fetch:async-fetch\":\n      fetchAsyncFetch(message.type, message.payload);\n      break;\n  }\n};\n\nconst CORE_STORAGE_KEY = \"app:storage\";\n// Store data\nconst sessionStorageHydrateViewer = (requestType, payload) => {\n  if (payload) {\n    // store data\n    Storage.privateSet(CORE_STORAGE_KEY, payload);\n\n    const responseBody = buildAnswer(requestType, payload);\n    Utils.sendMessage(responseBody);\n  }\n};\n\n// Retrieve stored data\nconst sessionStorageHydrateApp = (requestType) => {\n  Utils.promisify(\n    // get stored data\n    () => Storage.privateGet(CORE_STORAGE_KEY),\n    (storageData) => {\n      const responseBody = buildAnswer(requestType, storageData);\n      Utils.sendMessage(responseBody);\n    },\n    () => {\n      // After 3 seconds, if no data is found, just send\n      // an empty answer\n      const responseBody = buildAnswer(requestType);\n      Utils.sendMessage(responseBody);\n    },\n    3000\n  );\n};\n\n// Set thew new iFrame height based on the new screen/route\nconst setIframeHeight = (requestType, payload) => {\n  State.update({ iframeHeight: payload.height + 20 });\n  const responseBody = buildAnswer(requestType, {});\n  Utils.sendMessage(responseBody);\n};\n\n// Get user info\nconst getUserInfo = (requestType) => {\n  // check if user is signed in\n  if (!accountId) {\n    const responseBody = buildAnswer(requestType, {\n      error: \"user is not signed in\",\n    });\n    Utils.sendMessage(responseBody);\n    return;\n  }\n\n  Utils.promisify(\n    () => Social.getr(`${accountId}/profile`), // profile info\n    (res) => {\n      const responseBody = buildAnswer(requestType, {\n        accountId,\n        profileInfo: res,\n      });\n      Utils.sendMessage(responseBody);\n    },\n    () => {\n      // Send the accountId only\n      Utils.sendMessage({ accountId });\n    }\n  );\n};\n\n// NEAR.view\nconst nearView = (requestType, payload) => {\n  const { contractName, methodName, args, blockId } = payload;\n\n  Utils.promisify(\n    () => Near.view(contractName, methodName, args, blockId),\n    (data) => {\n      const response = buildAnswer(requestType, data);\n      Utils.sendMessage(response);\n    },\n    () => {\n      const response = buildAnswer(requestType);\n      Utils.sendMessage(response);\n    }\n  );\n};\n\n// NEAR.call\nconst nearCall = (requestType, payload) => {\n  const { contractName, methodName, args, gas, deposit } = payload;\n\n  // Make the call\n  Near.call(contractName, methodName, args, gas, deposit);\n\n  // Send an immediate answer back to say it was done.\n  // It's not possible for the time being to get the immediate result because the page is\n  // going to refresh after the user accepts the transaction\n  const response = buildAnswer(requestType);\n  Utils.sendMessage(response);\n};\n\n// Social.get\nconst socialGet = (requestType, payload) => {\n  const { patterns, finality } = payload;\n\n  Utils.promisify(\n    () => Social.get(patterns, finality),\n    (data) => {\n      const response = buildAnswer(requestType, data);\n      Utils.sendMessage(response);\n    },\n    () => {\n      const response = buildAnswer(requestType);\n      Utils.sendMessage(response);\n    }\n  );\n};\n\n// Social.getr\nconst socialGetr = (requestType, payload) => {\n  const { patterns, finality } = payload;\n\n  Utils.promisify(\n    () => Social.getr(patterns, finality),\n    (data) => {\n      const response = buildAnswer(requestType, data);\n      Utils.sendMessage(response);\n    },\n    () => {\n      const response = buildAnswer(requestType);\n      Utils.sendMessage(response);\n    }\n  );\n};\n\n// Social.keys\nconst socialKeys = (requestType, payload) => {\n  const { patterns, finality, options } = payload;\n\n  Utils.promisify(\n    () => Social.keys(patterns, finality, options),\n    (data) => {\n      const response = buildAnswer(requestType, data);\n      Utils.sendMessage(response);\n    },\n    () => {\n      const response = buildAnswer(requestType);\n      Utils.sendMessage(response);\n    }\n  );\n};\n\n// Social.index\nconst socialIndex = (requestType, payload) => {\n  const { action, key, options } = payload;\n\n  Utils.promisify(\n    () => Social.index(action, key, options),\n    (data) => {\n      const response = buildAnswer(requestType, data);\n      Utils.sendMessage(response);\n    },\n    () => {\n      const response = buildAnswer(requestType);\n      Utils.sendMessage(response);\n    }\n  );\n};\n\n// Social.set\nconst socialSet = (requestType, payload) => {\n  const { data } = payload;\n\n  Social.set(data, {\n    force: true,\n    onCommit: (res) => {\n      const response = buildAnswer(requestType, res);\n      Utils.sendMessage(response);\n    },\n    onCancel: () => {\n      const response = buildAnswer(requestType, {\n        error: \"the action was canceled\",\n      });\n      Utils.sendMessage(response);\n    },\n  });\n};\n\n// Storage.get\nconst storageGet = (requestType, payload) => {\n  const { key, widgetSrc } = payload;\n\n  Utils.promisify(\n    () => Storage.get(key, widgetSrc),\n    (data) => {\n      const response = buildAnswer(requestType, data);\n      Utils.sendMessage(response);\n    },\n    () => {\n      const response = buildAnswer(requestType);\n      Utils.sendMessage(response);\n    }\n  );\n};\n\n// Storage.set\nconst storageSet = (requestType, payload) => {\n  const { key, value } = payload;\n  Storage.set(key, value);\n\n  // Send an immediate answer back to say it was done.\n  const response = buildAnswer(requestType, { ok: true });\n  Utils.sendMessage(response);\n};\n\n// Storage.privateGet\nconst storagePrivateGet = (requestType, payload) => {\n  const { key } = payload;\n\n  Utils.promisify(\n    () => Storage.privateGet(key),\n    (data) => {\n      const response = buildAnswer(requestType, data);\n      Utils.sendMessage(response);\n    },\n    () => {\n      const response = buildAnswer(requestType);\n      Utils.sendMessage(response);\n    }\n  );\n};\n\n// Storage.privateSet\nconst storagePrivateSet = (requestType, payload) => {\n  const { key, value } = payload;\n  Storage.privateSet(key, value);\n\n  // Send an immediate answer back to say it was done.\n  const response = buildAnswer(requestType, { ok: true });\n  Utils.sendMessage(response);\n};\n\n// Fetch.asyncFetch\nconst fetchAsyncFetch = (requestType, payload) => {\n  const { url, options } = payload;\n\n  asyncFetch(url, options).then((res) => {\n    const response = buildAnswer(requestType, res);\n    Utils.sendMessage(response);\n  });\n};\n\nreturn (\n  <div>\n    <iframe\n      className=\"w-100\"\n      style={{ height: `${state.iframeHeight}px` }}\n      srcDoc={code}\n      message={state.currentMessage}\n      onMessage={onMessageHandler}\n    />\n  </div>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/wendersonpires.near/widget/NearSocialBridgeCore", "fact_widget_deployments_id": "54c20ee7bdb1562b4b18e2e3211dc7a0", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 0}