{"tx_hash": "B8L3XEymvrxj6z7DrpJSBHVZwnBVABpNzzXhzGfZepJM", "action_id_social": "8g6fQuVMot9WzvgP9r1zEbY3dWYGWVHkbLeCz1gBmK4m-0-widget", "block_id": 101780144, "block_timestamp": "2023-09-23T14:40:52.550Z", "signer_id": "weige.near", "widget_name": "gen-claim-action", "source_code": "const { config, txHash, onLoadExecute } = props;\n\nconst arb_sys_abi = [\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: false,\n        internalType: \"address\",\n        name: \"caller\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"destination\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"uint256\",\n        name: \"uniqueId\",\n        type: \"uint256\",\n      },\n      {\n        indexed: true,\n        internalType: \"uint256\",\n        name: \"batchNumber\",\n        type: \"uint256\",\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"indexInBatch\",\n        type: \"uint256\",\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"arbBlockNum\",\n        type: \"uint256\",\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"ethBlockNum\",\n        type: \"uint256\",\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"timestamp\",\n        type: \"uint256\",\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"callvalue\",\n        type: \"uint256\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes\",\n        name: \"data\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"L2ToL1Transaction\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: false,\n        internalType: \"address\",\n        name: \"caller\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"destination\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"uint256\",\n        name: \"hash\",\n        type: \"uint256\",\n      },\n      {\n        indexed: true,\n        internalType: \"uint256\",\n        name: \"position\",\n        type: \"uint256\",\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"arbBlockNum\",\n        type: \"uint256\",\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"ethBlockNum\",\n        type: \"uint256\",\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"timestamp\",\n        type: \"uint256\",\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"callvalue\",\n        type: \"uint256\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes\",\n        name: \"data\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"L2ToL1Tx\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"uint256\",\n        name: \"reserved\",\n        type: \"uint256\",\n      },\n      {\n        indexed: true,\n        internalType: \"bytes32\",\n        name: \"hash\",\n        type: \"bytes32\",\n      },\n      {\n        indexed: true,\n        internalType: \"uint256\",\n        name: \"position\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"SendMerkleUpdate\",\n    type: \"event\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"uint256\",\n        name: \"arbBlockNum\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"arbBlockHash\",\n    outputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"\",\n        type: \"bytes32\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"arbBlockNumber\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"arbChainID\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"arbOSVersion\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"getStorageGasAvailable\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"isTopLevelCall\",\n    outputs: [\n      {\n        internalType: \"bool\",\n        name: \"\",\n        type: \"bool\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"sender\",\n        type: \"address\",\n      },\n      {\n        internalType: \"address\",\n        name: \"unused\",\n        type: \"address\",\n      },\n    ],\n    name: \"mapL1SenderContractAddressToL2Alias\",\n    outputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\",\n      },\n    ],\n    stateMutability: \"pure\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"myCallersAddressWithoutAliasing\",\n    outputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"sendMerkleTreeState\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"size\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"root\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32[]\",\n        name: \"partials\",\n        type: \"bytes32[]\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"destination\",\n        type: \"address\",\n      },\n      {\n        internalType: \"bytes\",\n        name: \"data\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"sendTxToL1\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"payable\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"wasMyCallersAddressAliased\",\n    outputs: [\n      {\n        internalType: \"bool\",\n        name: \"\",\n        type: \"bool\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"destination\",\n        type: \"address\",\n      },\n    ],\n    name: \"withdrawEth\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"payable\",\n    type: \"function\",\n  },\n];\n\nconst outbox_executeTransaction_abi = [\n  {\n    inputs: [\n      {\n        internalType: \"bytes32[]\",\n        name: \"proof\",\n        type: \"bytes32[]\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"index\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"address\",\n        name: \"l2Sender\",\n        type: \"address\",\n      },\n      {\n        internalType: \"address\",\n        name: \"to\",\n        type: \"address\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"l2Block\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"l1Block\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"l2Timestamp\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"value\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"bytes\",\n        name: \"data\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"executeTransaction\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n];\n\nState.init({\n  claimable: false,\n});\n\nconst l2NodeUrl = \"https://arb1.arbitrum.io/rpc\";\n\nconst l1NodeUrl = \"https://rpc.ankr.com/eth\";\n\nconst l2Provider = new ethers.providers.JsonRpcProvider(l2NodeUrl);\n\nconst l1Provider = new ethers.providers.JsonRpcProvider(l1NodeUrl);\n\nconst loadL2toL1event = () => {\n  l2Provider\n    .getTransactionReceipt(txHash)\n    .then((txReceipt) => {\n      if (txReceipt && txReceipt.logs) {\n        const contractInterface = new ethers.utils.Interface(arb_sys_abi);\n\n        const tempEvent = contractInterface.getEvent(\"L2ToL1Tx\");\n        const topic = contractInterface.getEventTopic(tempEvent);\n\n        txReceipt.logs.forEach((log, index) => {\n          if (log.topics[0] === topic) {\n          }\n        });\n        const events = [];\n\n        const findTrueLog = txReceipt.logs.find(\n          (log) => log.topics[0] === topic\n        );\n        const args = contractInterface.parseLog(findTrueLog).args;\n\n        const l2tol1Event = {\n          arbBlockNum: args.arbBlockNum.toString(),\n          caller: args.caller,\n          callvalue: args.callvalue.toString(),\n          data: args.data,\n          destination: args.destination,\n          ethBlockNum: args.ethBlockNum.toString(),\n          hash: args.hash.toString(),\n          position: args.position.toString(),\n          timestamp: args.timestamp.toString(),\n          transactionHash: log.transactionHash,\n        };\n\n        events.push(l2tol1Event);\n\n        State.update({\n          l2tol1Event: events?.[0] || null,\n        });\n      }\n    })\n    .finally(() =>\n      State.update({\n        eventLoadDone: true,\n      })\n    );\n};\n\nconst getSendProps = () => {\n  const rollupAddress = config.ethBridges.rollup;\n\n  const abi = [\n    {\n      inputs: [],\n      name: \"latestConfirmed\",\n      outputs: [\n        {\n          internalType: \"uint64\",\n          name: \"\",\n          type: \"uint64\",\n        },\n      ],\n      stateMutability: \"view\",\n      type: \"function\",\n    },\n    {\n      inputs: [\n        {\n          internalType: \"uint64\",\n          name: \"nodeNum\",\n          type: \"uint64\",\n        },\n      ],\n      name: \"getNode\",\n      outputs: [\n        {\n          components: [\n            {\n              internalType: \"bytes32\",\n              name: \"stateHash\",\n              type: \"bytes32\",\n            },\n            {\n              internalType: \"bytes32\",\n              name: \"challengeHash\",\n              type: \"bytes32\",\n            },\n            {\n              internalType: \"bytes32\",\n              name: \"confirmData\",\n              type: \"bytes32\",\n            },\n            {\n              internalType: \"uint64\",\n              name: \"prevNum\",\n              type: \"uint64\",\n            },\n            {\n              internalType: \"uint64\",\n              name: \"deadlineBlock\",\n              type: \"uint64\",\n            },\n            {\n              internalType: \"uint64\",\n              name: \"noChildConfirmedBeforeBlock\",\n              type: \"uint64\",\n            },\n            {\n              internalType: \"uint64\",\n              name: \"stakerCount\",\n              type: \"uint64\",\n            },\n            {\n              internalType: \"uint64\",\n              name: \"childStakerCount\",\n              type: \"uint64\",\n            },\n            {\n              internalType: \"uint64\",\n              name: \"firstChildBlock\",\n              type: \"uint64\",\n            },\n            {\n              internalType: \"uint64\",\n              name: \"latestChildNumber\",\n              type: \"uint64\",\n            },\n            {\n              internalType: \"uint64\",\n              name: \"createdAtBlock\",\n              type: \"uint64\",\n            },\n            {\n              internalType: \"bytes32\",\n              name: \"nodeHash\",\n              type: \"bytes32\",\n            },\n          ],\n          internalType: \"struct Node\",\n          name: \"\",\n          type: \"tuple\",\n        },\n      ],\n      stateMutability: \"view\",\n      type: \"function\",\n    },\n    {\n      anonymous: false,\n      inputs: [\n        {\n          indexed: true,\n          internalType: \"uint64\",\n          name: \"nodeNum\",\n          type: \"uint64\",\n        },\n        {\n          indexed: true,\n          internalType: \"bytes32\",\n          name: \"parentNodeHash\",\n          type: \"bytes32\",\n        },\n        {\n          indexed: true,\n          internalType: \"bytes32\",\n          name: \"nodeHash\",\n          type: \"bytes32\",\n        },\n        {\n          indexed: false,\n          internalType: \"bytes32\",\n          name: \"executionHash\",\n          type: \"bytes32\",\n        },\n        {\n          components: [\n            {\n              components: [\n                {\n                  components: [\n                    {\n                      internalType: \"bytes32[2]\",\n                      name: \"bytes32Vals\",\n                      type: \"bytes32[2]\",\n                    },\n                    {\n                      internalType: \"uint64[2]\",\n                      name: \"u64Vals\",\n                      type: \"uint64[2]\",\n                    },\n                  ],\n                  internalType: \"struct GlobalState\",\n                  name: \"globalState\",\n                  type: \"tuple\",\n                },\n                {\n                  internalType: \"enum MachineStatus\",\n                  name: \"machineStatus\",\n                  type: \"uint8\",\n                },\n              ],\n              internalType: \"struct RollupLib.ExecutionState\",\n              name: \"beforeState\",\n              type: \"tuple\",\n            },\n            {\n              components: [\n                {\n                  components: [\n                    {\n                      internalType: \"bytes32[2]\",\n                      name: \"bytes32Vals\",\n                      type: \"bytes32[2]\",\n                    },\n                    {\n                      internalType: \"uint64[2]\",\n                      name: \"u64Vals\",\n                      type: \"uint64[2]\",\n                    },\n                  ],\n                  internalType: \"struct GlobalState\",\n                  name: \"globalState\",\n                  type: \"tuple\",\n                },\n                {\n                  internalType: \"enum MachineStatus\",\n                  name: \"machineStatus\",\n                  type: \"uint8\",\n                },\n              ],\n              internalType: \"struct RollupLib.ExecutionState\",\n              name: \"afterState\",\n              type: \"tuple\",\n            },\n            {\n              internalType: \"uint64\",\n              name: \"numBlocks\",\n              type: \"uint64\",\n            },\n          ],\n          indexed: false,\n          internalType: \"struct RollupLib.Assertion\",\n          name: \"assertion\",\n          type: \"tuple\",\n        },\n        {\n          indexed: false,\n          internalType: \"bytes32\",\n          name: \"afterInboxBatchAcc\",\n          type: \"bytes32\",\n        },\n        {\n          indexed: false,\n          internalType: \"bytes32\",\n          name: \"wasmModuleRoot\",\n          type: \"bytes32\",\n        },\n        {\n          indexed: false,\n          internalType: \"uint256\",\n          name: \"inboxMaxCount\",\n          type: \"uint256\",\n        },\n      ],\n      name: \"NodeCreated\",\n      type: \"event\",\n    },\n  ];\n\n  const rollup = new ethers.Contract(rollupAddress, abi, l1Provider);\n\n  rollup\n    .latestConfirmed()\n    .then((res) => {\n      const latestConfirmedNodeNum = res.toString();\n      return rollup.getNode(latestConfirmedNodeNum);\n    })\n    .then((res) => {\n      const createdAtBlock = res[10].toString();\n\n      const filter = {\n        address: rollupAddress,\n        fromBlock: Number(createdAtBlock),\n        toBlock: Number(createdAtBlock),\n      };\n\n      return l1Provider.getLogs(filter);\n    })\n    .then((logs) => {\n      if (logs.length !== 1) throw new Error();\n\n      const log = logs[0];\n\n      const rollupInterface = new ethers.utils.Interface(abi);\n\n      const pLog = rollupInterface.parseLog(log);\n\n      const nodeCreatedEvent = {\n        event: pLog.args,\n        topic: pLog.topic,\n        name: pLog.name,\n        blockNumber: log.blockNumber,\n        blockHash: log.blockHash,\n        transactionHash: log.transactionHash,\n\n        address: log.address,\n        topics: log.topics,\n        data: log.data,\n      };\n\n      const afterState = {\n        blockHash:\n          nodeCreatedEvent.event.assertion.afterState.globalState\n            .bytes32Vals[0],\n        sendRoot:\n          nodeCreatedEvent.event.assertion.afterState.globalState\n            .bytes32Vals[1],\n      };\n\n      const l2Block = Ethers.send(\"eth_getBlockByHash\", [\n        afterState.blockHash,\n        true,\n      ]);\n\n      State.update({\n        sendProps: {\n          senCount: Big(Number(l2Block?.sendCount || 0)).toFixed(),\n          sendRootHash: l2Block.sendRoot,\n        },\n        sendPropsLoadDone: !!l2Block,\n      });\n    });\n};\n\nconst checkIfConfirmedAndExecuted = () => {\n  const outboxAddress = config.ethBridges.outbox;\n  const abi = [\n    {\n      inputs: [\n        {\n          internalType: \"uint256\",\n          name: \"index\",\n          type: \"uint256\",\n        },\n      ],\n      name: \"isSpent\",\n      outputs: [\n        {\n          internalType: \"bool\",\n          name: \"\",\n          type: \"bool\",\n        },\n      ],\n      stateMutability: \"view\",\n      type: \"function\",\n    },\n  ];\n\n  const isPending = !Big(Number(state.l2tol1Event.position || 0)).lt(\n    state.sendProps.senCount\n  );\n\n  if (isPending) {\n    State.update({\n      claimable: false,\n      isPending: true,\n      checkDone: true,\n    });\n\n    return;\n  }\n\n  const outboxContract = new ethers.Contract(outboxAddress, abi, l1Provider);\n\n  outboxContract.isSpent(state.l2tol1Event.position).then((isSpent) => {\n    State.update({\n      claimable: !isSpent,\n      checkDone: true,\n      isPending: false,\n    });\n  });\n};\n\nconst getProof = () => {\n  const sendRootSize = state.l2tol1Event.senCount;\n\n  const nodeInterfaceAddress = config.ethBridges.nodeInterface;\n\n  const abi = [\n    {\n      inputs: [\n        {\n          internalType: \"uint64\",\n          name: \"size\",\n          type: \"uint64\",\n        },\n        {\n          internalType: \"uint64\",\n          name: \"leaf\",\n          type: \"uint64\",\n        },\n      ],\n      name: \"constructOutboxProof\",\n      outputs: [\n        {\n          internalType: \"bytes32\",\n          name: \"send\",\n          type: \"bytes32\",\n        },\n        {\n          internalType: \"bytes32\",\n          name: \"root\",\n          type: \"bytes32\",\n        },\n        {\n          internalType: \"bytes32[]\",\n          name: \"proof\",\n          type: \"bytes32[]\",\n        },\n      ],\n      stateMutability: \"view\",\n      type: \"function\",\n    },\n  ];\n\n  const nodeInterfaceContract = new ethers.Contract(\n    nodeInterfaceAddress,\n    abi,\n    l2Provider\n  );\n\n  return nodeInterfaceContract\n    .constructOutboxProof(\n      Number(sendRootSize),\n      Number(state.l2tol1Event.position)\n    )\n    .then((outboxProof) => {\n      State.update({\n        proof: outboxProof.proof,\n        proofLoadDone: true,\n      });\n    });\n};\n\nconst execute = () => {\n  const outboxAddress = config.ethBridges.outbox;\n\n  const abi = outbox_executeTransaction_abi;\n\n  const signer = Ethers.provider().getSigner();\n\n  const outboxContract = new ethers.Contract(outboxAddress, abi, signer);\n\n  outboxContract\n    .executeTransaction(\n      state.proof,\n      state.l2tol1Event.position,\n      state.l2tol1Event.caller,\n      state.l2tol1Event.destination,\n      state.l2tol1Event.arbBlockNum,\n      state.l2tol1Event.ethBlockNum,\n      state.l2tol1Event.timestamp,\n      state.l2tol1Event.callvalue,\n      state.l2tol1Event.data\n    )\n    .then((tx) => {\n      return tx.wait();\n    })\n    .then((receipt) => {\n      if (receipt.status === 1) {\n        props?.successCallback?.();\n      } else {\n        props.failCallback?.();\n      }\n    })\n    .catch((e) => {\n      props.failCallback?.();\n    });\n};\n\nif (txHash && !state.eventLoadDone) {\n  loadL2toL1event();\n}\n\nif (txHash && !state.sendPropsLoadDone && state.eventLoadDone) {\n  getSendProps();\n}\n\nif (txHash && state.sendPropsLoadDone && state.eventLoadDone) {\n  checkIfConfirmedAndExecuted();\n}\n\nif (txHash && state.eventLoadDone && state.checkDone && state.claimable) {\n  getProof();\n}\n\nif (state.sendPropsLoadDone && !state.loadExecuteDone) {\n  State.update({\n    loadExecuteDone: true,\n  });\n\n  onLoadExecute({\n    ...state,\n    claimable: state.claimable,\n    isPending: state.isPending,\n    checkDone: state.checkDone,\n    execute,\n  });\n}\n\nreturn \"\";\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/weige.near/widget/gen-claim-action", "fact_widget_deployments_id": "475134de0a3aac3456d5914b68027c86", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 0}