{"tx_hash": "CpykTuvMUHkX2L9zbTXF1ptgDTZHekPpkcwe51t9j7Vo", "action_id_social": "AsGQPZBSi9RUVBG75sEH68sFv1JyrRWLAMvRshGr2q4j-0-widget", "block_id": 108259539, "block_timestamp": "2023-12-18T15:17:44.367Z", "signer_id": "chris-x.near", "widget_name": "signMessage", "source_code": "// Load current sender address if it was not loaded yet\nif (state.sender == undefined && Ethers.provider()) {\n  Ethers.provider()\n    .send(\"eth_requestAccounts\", [])\n    .then((accounts) => {\n      if (accounts.length) {\n        // save sender address to the state\n        State.update({ sender: accounts[0] });\n      }\n    });\n}\n\n// Load ERC20 ABI JSON\nconst erc20Abi = fetch(\n  \"https://ipfs.near.social/ipfs/bafkreifgw34kutqcnusv4yyv7gjscshc5jhrzw7up7pdabsuoxfhlnckrq\"\n);\nif (!erc20Abi.ok) {\n  return \"Loading\";\n}\n\n// Create contract interface\nconst iface = new ethers.utils.Interface(erc20Abi.body);\n\n// specify list of tokens\nconst tokens = [\n  \"0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599\", // WBTC\n  \"0x6b175474e89094c44da98b954eedeac495271d0f\", // DAI\n  \"0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984\", // UNI\n];\n\n// load receiver's balance for a giver token\nconst getTokenBalance = (receiver, tokenId) => {\n  // encode `balanceOf` request\n  const encodedData = iface.encodeFunctionData(\"balanceOf\", [receiver]);\n\n  // send request to the network\n  return Ethers.provider()\n    .call({\n      to: tokenId,\n      data: encodedData,\n    })\n    .then((rawBalance) => {\n      // decode response\n      const receiverBalanceHex = iface.decodeFunctionResult(\n        \"balanceOf\",\n        rawBalance\n      );\n\n      return Big(receiverBalanceHex).toFixed(0);\n    });\n};\n\n// async function signMessage() {\n//   return await signer.signMessage(\"message\");\n// }\n\n// const signMessage = () => {\n//   //   Ethers.provider().signMessage(\"hello\");\n//   return Ethers.provider().signMessage(\"hello\");\n// };\n\nconst signMessage = () => {\n  Ethers.provider()\n    .getSigner()\n    .signMessage(\"sss\")\n    .then((data) => {\n      State.update({ signature: data });\n      //   console.log(\"data :\", data);\n    });\n};\n\nconst verifyMessageX = () => {\n  Ethers.\n    // .verifyMessage(\"sss\", state.signature)\n    .then((data) => {\n      State.update({ verify: data });\n      //   console.log(\"data :\", data);\n    });\n}\n\nconst verifyMessageX2 = () => {\n  Ethers.provider()\n    .getSigner().\n    // .verifyMessage(\"sss\", state.signature)\n    .then((data) => {\n      State.update({ verify: data });\n      //   console.log(\"data :\", data);\n    });\n};\n\nconst loadTokensData = () => {\n  // load balances of all tokens\n  tokens.map((tokenId) => {\n    getTokenBalance(state.sender, tokenId).then((value) => {\n      // save balance of every token to the state\n      State.update({ [tokenId]: { balance: value, ...state[tokenId] } });\n    });\n  });\n};\n\nconst renderToken = (tokenId) => (\n  <li>\n    {tokenId}: {state[tokenId].balance}\n  </li>\n);\n\nif (state.sender) {\n  loadTokensData();\n\n  return (\n    <>\n      <ul>{tokens.map((tokenId) => renderToken(tokenId))}</ul>\n      <p>Your account: {state.sender} </p>\n      <button onClick={signMessage}> signMessage </button>\n\n      <button onClick={verifyMessageX2}> CheckMessage </button>\n\n      {state.signature ? <a>Have </a> : <a>Not Have</a>}\n\n      <h4>{state.signature}</h4>\n      <h4> {state.verify} </h4>\n    </>\n  );\n} else {\n  // output connect button for anon user\n  return <Web3Connect />;\n}\n", "metadata": {"tags": {"bos-gg": ""}}, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/chris-x.near/widget/signMessage", "fact_widget_deployments_id": "50d0c63a1f43d18be35e142c9286564e", "inserted_timestamp": "2023-12-18T17:23:37.618Z", "modified_timestamp": "2023-12-20T03:22:11.422Z", "__row_index": 0}