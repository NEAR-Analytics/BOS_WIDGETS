{"tx_hash": "Hi5zgM1ahiSQ7yUvJPxtipQ8MgTcteRuF7WP8Ksy9iBK", "action_id_social": "7MppnWeW6scYYoSZrkPW3FXVzvSezHTpj586mSFtSNkZ-0-widget", "block_id": 118099456, "block_timestamp": "2024-05-02T15:40:14.611Z", "signer_id": "events-committee.near", "widget_name": "devhub.components.organism.Feed.NearQueryApi", "source_code": "const LIMIT = 10;\nconst filteredAccountIds = props.filteredAccountIds;\nconst setPostExists = props.setPostExists ?? (() => {});\nconst GRAPHQL_ENDPOINT =\n  props.GRAPHQL_ENDPOINT ?? \"https://near-queryapi.api.pagoda.co\";\n\nconst sort = props.sort || \"desc\";\n\n// get the full list of posts that the current user has flagged so\n// they can be hidden\nconst selfFlaggedPosts = context.accountId\n  ? Social.index(\"flag\", \"main\", {\n      accountId: context.accountId,\n    }) ?? []\n  : [];\n\n// V2 self moderation data, structure is like:\n// { moderate: {\n//     \"account1.near\": \"report\",\n//     \"account2.near\": {\n//         \".post.main\": { // slashes are not allowed in keys\n//           \"100000123\": \"spam\", // post ids are account/blockHeight\n//         }\n//     },\n//   }\n// }\nconst selfModeration = context.accountId\n  ? Social.getr(`${context.accountId}/moderate`, \"optimistic\") ?? []\n  : [];\nconst postsModerationKey = \".post.main\";\nconst commentsModerationKey = \".post.comment\";\nconst matchesModeration = (moderated, socialDBObjectType, item) => {\n  if (!moderated) return false;\n  const accountFound = moderated[item.account_id];\n  if (typeof accountFound === \"undefined\") {\n    return false;\n  }\n  if (typeof accountFound === \"string\" || accountFound[\"\"]) {\n    return true;\n  }\n  const moderatedItemsOfType = accountFound[socialDBObjectType];\n  return (\n    moderatedItemsOfType &&\n    typeof moderatedItemsOfType[item.block_height] !== \"undefined\"\n  );\n};\n\nconst shouldFilter = (item, socialDBObjectType) => {\n  return (\n    selfFlaggedPosts.find((flagged) => {\n      return (\n        flagged?.value?.blockHeight === item.block_height &&\n        flagged?.value?.path.includes(item.account_id)\n      );\n    }) || matchesModeration(selfModeration, socialDBObjectType, item)\n  );\n};\nfunction fetchGraphQL(operationsDoc, operationName, variables) {\n  return asyncFetch(`${GRAPHQL_ENDPOINT}/v1/graphql`, {\n    method: \"POST\",\n    headers: { \"x-hasura-role\": \"dataplatform_near\" },\n    body: JSON.stringify({\n      query: operationsDoc,\n      variables: variables,\n      operationName: operationName,\n    }),\n  });\n}\n\nconst createQuery = (type, isUpdate) => {\n  let querySortOption = \"\";\n  switch (sort) {\n    case \"recentcommentdesc\":\n      querySortOption = `{ last_comment_timestamp: desc_nulls_last },`;\n      break;\n    default:\n      querySortOption = \"\";\n  }\n\n  let queryFilter = \"\";\n  let timeOperation = \"_lte\";\n  if (isUpdate) {\n    timeOperation = \"_gt\";\n  }\n\n  const queryTime = initialQueryTime ? initialQueryTime : Date.now() * 1000000;\n\n  if (filteredAccountIds) {\n    queryFilter = `where: {\n          _and: [\n            {account_id: {_in: \"${filteredAccountIds}\"}},\n            {block_timestamp: {${timeOperation}: ${queryTime}}}\n          ]\n        }, `;\n  } else {\n    queryFilter = `where: {\n          _and: [\n            {block_timestamp: {${timeOperation}: ${queryTime}}}\n          ]\n        }, `;\n  }\n\n  return `\nquery FeedQuery($offset: Int, $limit: Int) {\n  dataplatform_near_social_feed_moderated_posts(${queryFilter} order_by: [${querySortOption} { block_height: desc }], offset: $offset, limit: $limit) {\n    account_id\n    block_height\n    block_timestamp\n    content\n    receipt_id\n    accounts_liked\n    last_comment_timestamp\n    comments(order_by: {block_height: asc}) {\n      account_id\n      block_height\n      block_timestamp\n      content\n    }\n    verifications {\n      human_provider\n      human_valid_until\n      human_verification_level\n    }\n\n  }\n  dataplatform_near_social_feed_moderated_posts_aggregate(${queryFilter} order_by: {id: asc}) {\n    aggregate {\n      count\n    }\n  }\n}\n`;\n};\n\nconst loadMorePosts = (isUpdate) => {\n  const queryName = \"FeedQuery\";\n\n  if (!isUpdate) {\n    setIsLoading(true);\n  }\n  const offset = isUpdate ? 0 : postsData.posts.length;\n  const limit = isUpdate ? 100 : LIMIT;\n  const query = createQuery(\"\", isUpdate);\n  fetchGraphQL(query, queryName, {\n    offset: offset,\n    limit: limit,\n  }).then((result) => {\n    if (result.status === 200 && result.body) {\n      if (result.body.errors) {\n        console.log(\"error:\", result.body.errors);\n        return;\n      }\n      let data = result.body.data;\n      if (data) {\n        const newPosts = data.dataplatform_near_social_feed_moderated_posts;\n        const postsCountLeft =\n          data.dataplatform_near_social_feed_moderated_posts_aggregate.aggregate\n            .count;\n        if (newPosts.length > 0) {\n          let filteredPosts = newPosts.filter(\n            (i) => !shouldFilter(i, postsModerationKey)\n          );\n          filteredPosts = filteredPosts.map((post) => {\n            const prevComments = post.comments;\n            const filteredComments = prevComments.filter(\n              (comment) => !shouldFilter(comment, commentsModerationKey)\n            );\n            post.comments = filteredComments;\n            return post;\n          });\n\n          if (isUpdate) {\n            setNewUnseenPosts(filteredPosts);\n          } else {\n            setPostsData({\n              posts: [...postsData.posts, ...filteredPosts],\n              postsCountLeft,\n            });\n            setIsLoading(false);\n          }\n        }\n      }\n    }\n    if (!isUpdate && initialQueryTime === null) {\n      const newTime =\n        postsData.posts && postsData.posts[0]\n          ? postsData.posts[0].block_timestamp\n          : Date.now() * 1000000;\n      setInitialQueryTime(newTime + 1000);\n    }\n  });\n};\n\nconst startFeedUpdates = () => {\n  if (initialQueryTime === null) return;\n\n  clearInterval(feedInterval);\n  const newFeedInterval = setInterval(() => {\n    loadMorePosts(true);\n  }, 5000);\n  setFeedInterval(newFeedInterval);\n};\n\nconst stopFeedUpdates = () => {\n  clearInterval(feedInterval);\n};\n\nconst [initialized, setInitialized] = useState(false);\nconst [initialQueryTime, setInitialQueryTime] = useState(null);\nconst [feedInterval, setFeedInterval] = useState(null);\nconst [newUnseenPosts, setNewUnseenPosts] = useState([]);\nconst [postsData, setPostsData] = useState({ posts: [], postsCountLeft: 0 });\nconst [isLoading, setIsLoading] = useState(false);\n\nuseEffect(() => {\n  loadMorePosts(false);\n}, []);\n\nuseEffect(() => {\n  if (postsData.posts.length > 0) {\n    setPostExists(true);\n  }\n}, [postsData]);\n\nuseEffect(() => {\n  if (initialQueryTime === null) {\n    clearInterval(feedInterval);\n  } else {\n    startFeedUpdates();\n  }\n}, [initialQueryTime]);\n\nuseEffect(() => {\n  if (newUnseenPosts && newUnseenPosts.length > 0) {\n    stopFeedUpdates();\n    const initialQueryTime = newUnseenPosts[0].block_timestamp + 1000; // timestamp is getting rounded by 3 digits\n    const newTotalCount = postsData.postsCountLeft + newUnseenPosts.length;\n    setPostsData({\n      posts: [...newUnseenPosts, ...postsData.posts],\n      postsCountLeft: newTotalCount,\n    });\n    if (props.onNewUnseenPosts) {\n      props.onNewUnseenPosts(newUnseenPosts);\n    }\n    setNewUnseenPosts([]);\n    setInitialQueryTime(initialQueryTime);\n  }\n}, [newUnseenPosts]);\n\nconst hasMore =\n  postsData.postsCountLeft !== postsData.posts.length &&\n  postsData.posts.length > 0;\n\nif (!initialized && sort) {\n  setInitialized(true);\n}\n\nreturn (\n  <>\n    <Widget\n      src=\"near/widget/Posts.Feed\"\n      props={{\n        hasMore,\n        isLoading,\n        loadMorePosts: () => {\n          if (!isLoading) {\n            loadMorePosts(false);\n          }\n        },\n        posts: postsData.posts,\n        showFlagAccountFeature: props.showFlagAccountFeature,\n      }}\n    />\n  </>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/events-committee.near/widget/devhub.components.organism.Feed.NearQueryApi", "fact_widget_deployments_id": "8458ce51bcdfce63c8dd821680638252", "inserted_timestamp": "2024-05-02T17:39:26.862Z", "modified_timestamp": "2024-05-02T17:39:26.862Z", "__row_index": 10}