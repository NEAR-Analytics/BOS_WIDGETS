{"tx_hash": "4A2Zw7ocJo3EcDzHWjF4uyNs7B9YAy1mf6LMBspf6Zh6", "action_id_social": "HQymMHQjvYEJ3KDFXZCBbzkc84iz2oGtdw86StfYBu8n-0-widget", "block_id": 98758587, "block_timestamp": "2023-08-14T03:52:55.644Z", "signer_id": "james.near", "widget_name": "search", "source_code": "const SEARCH_API_KEY = props.searchApiKey ?? \"0e42c01107b8f555a41bcc0fa7f2a4df\";\nconst APPLICATION_ID = props.appId ?? \"B6PI9UKKJT\";\nconst INDEX = props.index ?? \"prod_near-social-feed\";\nconst API_URL =\n  props.apiUrl ??\n  `https://${APPLICATION_ID}-dsn.algolia.net/1/indexes/${INDEX}/query?`;\nconst INITIAL_PAGE = props.initialPage ?? 0;\nconst facets = props.facets ?? [\"Components\", \"People\", \"Posts\"];\nconst tab = props.tab ?? \"Components\";\nconst showSearchBar = props.showSearchBar ?? true;\nconst showFacets = props.showFacets ?? true;\nconst showPagination = props.showPagination ?? true;\nconst userId = props.accountId ?? context.accountId;\n\nconst componentsUrl = `/near/widget/ComponentsPage`;\nconst peopleUrl = `/near/widget/PeoplePage`;\n\nState.init({\n  facet: tab,\n});\n\nconst Wrapper =\n  props.wrapper ??\n  styled.div`\n    display: flex;\n    flex-direction: column;\n    gap: 23px;\n    margin: 0 auto;\n  `;\n\nconst Group = styled.div`\n  display: flex;\n  flex-direction: column;\n  gap: 12px;\n`;\n\nconst Items =\n  props.styles.Items ??\n  styled.div`\n    display: flex;\n    flex-direction: column;\n    align-items: stretch;\n    gap: 12px;\n  `;\n\nconst Item = props.styles.Item ?? styled.div``;\n\nconst resetSearcheHits = () => {\n  State.update({\n    currentPage: 0,\n    search: undefined,\n    paginate: undefined,\n    facet: undefined,\n  });\n};\n\nconst writeStateTerm = (term) => {\n  State.update({\n    term,\n  });\n\n  if (term === \"\") {\n    resetSearcheHits();\n  }\n};\n\nconst profiles = (records) => {\n  const profiles = [];\n  for (const [i, record] of records ?? []) {\n    profiles.push({\n      accountId: record.author,\n      profile_name: record.profile_name,\n      searchPosition: i,\n    });\n  }\n  return profiles;\n};\n\nconst posts = (content, postType) => {\n  const posts = [];\n  for (const [i, post] of content || []) {\n    const accountId = post.author;\n    const blockHeight = post.objectID.split(\"/\").slice(-1)[0];\n\n    let snipContent = true;\n    let text = post.content;\n    if (post._highlightResult.content.matchLevel === \"full\") {\n      // Use algolia provided snipped content:\n      snipContent = false;\n      text = post._snippetResult.content.value\n        .replaceAll(\"<em>\", \"\")\n        .replaceAll(\"</em>\", \"\");\n    }\n\n    const postContent = {\n      type: \"md\",\n      text,\n    };\n\n    posts.push({\n      accountId,\n      blockHeight,\n      postContent,\n      postType,\n      snipContent,\n      searchPosition: i,\n    });\n  }\n  return posts;\n};\n\nconst components = (records) => {\n  const components = [];\n  for (const [i, component] of records || []) {\n    const idParts = component.objectID.split(\"/\");\n    const widgetName = idParts[idParts.length - 1];\n    const accountId = component.author;\n    components.push({\n      accountId,\n      widgetName,\n      searchPosition: i,\n    });\n  }\n  return components;\n};\n\nconst categorizeSearchHits = (rawResp) => {\n  const results = {};\n  for (const [i, result] of rawResp.hits?.entries()) {\n    const { categories: categories_raw } = result;\n    if (categories_raw.length > 1) {\n      categories_raw.sort();\n    }\n\n    const categories = categories_raw.join(\", \");\n    results[categories] = results[categories] || [];\n    results[categories].push([i + 1, result]);\n  }\n  return {\n    results,\n    hitsTotal: rawResp.nbHits,\n    hitsPerPage: rawResp.hitsPerPage,\n  };\n};\n\nconst debounce = (callable, timeout) => {\n  return (args) => {\n    clearTimeout(state.timer);\n    State.update({\n      timer: setTimeout(() => callable(args), timeout ?? 250),\n    });\n  };\n};\n\nconst fetchSearchHits = (query, { pageNumber, configs, optionalFilters }) => {\n  configs = configs ?? configsPerFacet(state.facet);\n  let body = {\n    query,\n    page: pageNumber ?? 0,\n    optionalFilters: optionalFilters ?? [\n      \"categories:profile<score=3>\",\n      \"categories:widget<score=2>\",\n      \"categories:post<score=1>\",\n      \"categories:comment<score=0>\",\n    ],\n    clickAnalytics: true,\n    ...configs,\n  };\n\n  return asyncFetch(API_URL, {\n    body: JSON.stringify(body),\n    headers: {\n      \"Content-Type\": \"application/json; charset=UTF-8\",\n      \"X-Algolia-Api-Key\": SEARCH_API_KEY,\n      \"X-Algolia-Application-Id\": APPLICATION_ID,\n    },\n    method: \"POST\",\n  });\n};\n\nconst updateSearchHits = debounce(({ term, pageNumber, configs }) => {\n  fetchSearchHits(term, { pageNumber, configs }).then((resp) => {\n    const { results, hitsTotal, hitsPerPage } = categorizeSearchHits(resp.body);\n    State.update({\n      search: {\n        profiles: profiles(results[\"profile\"]),\n        components: components(results[\"app, widget\"]).concat(\n          components(results[\"widget\"])\n        ),\n        postsAndComments: posts(results[\"post\"], \"post\").concat(\n          posts(results[\"comment, post\"], \"post-comment\")\n        ),\n      },\n      currentPage: pageNumber,\n      paginate: {\n        hitsTotal,\n        hitsPerPage,\n      },\n      queryID: resp.body.queryID,\n    });\n  });\n});\n\nconst onSearchChange = ({ term }) => {\n  writeStateTerm(term);\n  updateSearchHits({ term, pageNumber: INITIAL_PAGE });\n};\n\nconst onPageChange = (pageNumber) => {\n  const algoliaPageNumber = pageNumber - 1;\n  if (algoliaPageNumber === state.currentPage) {\n    console.log(`Selected the same page number as before: ${pageNumber}`);\n    return;\n  }\n  // Need to clear out old search data otherwise we'll get multiple entries\n  // from the previous pages as well. Seems to be cache issue on near.social.\n  State.update({\n    search: undefined,\n    currentPage: algoliaPageNumber,\n  });\n  updateSearchHits({ term: state.term, pageNumber: algoliaPageNumber });\n};\n\nconst FACET_TO_CATEGORY = {\n  People: \"profile\",\n  Components: \"widget\",\n  Posts: \"post\",\n};\n\nconst searchFilters = (facet) => {\n  const category = FACET_TO_CATEGORY[facet];\n  let filters = category ? `categories:${category}` : undefined;\n  if (category === \"post\") {\n    filters = `(${filters} OR categories:comment)`;\n  }\n  if (filters) {\n    filters = `${filters} AND `;\n  }\n  filters = `${filters}NOT author:hypefairy.near AND NOT _tags:hidden`;\n\n  return filters;\n};\n\nconst restrictSearchable = (facet) => {\n  const category = FACET_TO_CATEGORY[facet];\n  let restrictSearchableAttrs = undefined;\n  if (category === \"post\") {\n    // Only the content should be searchable when the posts facet is selected.\n    restrictSearchableAttrs = [\"content\"];\n  }\n  return restrictSearchableAttrs;\n};\n\nconst configsPerFacet = (facet) => {\n  return {\n    filters: searchFilters(facet),\n    restrictSearchableAttributes: restrictSearchable(facet),\n  };\n};\n\nconst onFacetClick = (facet) => {\n  if (facet === state.facet) {\n    console.log(\"Clicked the same facet\");\n    return;\n  }\n\n  State.update({\n    facet,\n  });\n\n  updateSearchHits({\n    term: state.term,\n    configs: configsPerFacet(facet),\n  });\n};\n\nconst onSearchResultClick = ({ searchPosition, objectID, eventName }) => {\n  const position =\n    searchPosition + state.currentPage * state.paginate.hitsPerPage;\n  const event = {\n    type: \"clickedObjectIDsAfterSearch\",\n    data: {\n      eventName,\n      userToken: userId.replace(\".\", \"+\"),\n      queryID: state.queryID,\n      objectIDs: [objectID],\n      positions: [position],\n      timestamp: Date.now(),\n    },\n  };\n  setTimeout(() => {\n    State.update({ event });\n  }, 50);\n};\n\nreturn (\n  <Wrapper>\n    <br />\n    {showSearchBar && (\n      <Widget\n        src=\"james.near/widget/search.input\"\n        props={{\n          onChange: onSearchChange,\n          term: props.term,\n        }}\n      />\n    )}\n\n    {showFacets && state.search && (\n      <Widget\n        src=\"near/widget/Search.FullPage.Facets\"\n        props={{\n          facets,\n          onFacetClick,\n          defaultFacet: facets[0],\n          initialFacet: tab,\n        }}\n      />\n    )}\n\n    {state.paginate?.hitsTotal == 0 && (\n      <h3>no matches were found for \"{state.term}\".</h3>\n    )}\n\n    {state.search?.profiles.length > 0 && (\n      <Group>\n        <h3>people</h3>\n        <a href={peopleUrl}>view all</a>\n\n        <Items>\n          {state.search.profiles.map((profile, i) => (\n            <Item key={profile.accountId}>\n              <Widget\n                src=\"near/widget/Search.FullPage.AccountProfileCard\"\n                props={{\n                  accountId: profile.accountId,\n                  onClick: () =>\n                    onSearchResultClick({\n                      searchPosition: profile.searchPosition,\n                      objectID: `${profile.accountId}/profile`,\n                      eventName: \"clicked profile after search\",\n                    }),\n                }}\n              />\n            </Item>\n          ))}\n        </Items>\n      </Group>\n    )}\n\n    {state.search?.components.length > 0 && (\n      <Group>\n        <h3>components</h3>\n        <a href={componentsUrl}>view all</a>\n\n        <Items>\n          {state.search.components.map((component, i) => (\n            <Item key={component.accountId + component.widgetName}>\n              <Widget\n                src=\"near/widget/Search.FullPage.ComponentCard\"\n                props={{\n                  src: `${component.accountId}/widget/${component.widgetName}`,\n                  onClick: () =>\n                    onSearchResultClick({\n                      searchPosition: component.searchPosition,\n                      objectID: `${component.accountId}/widget/${component.widgetName}`,\n                      eventName: \"clicked profile after search\",\n                    }),\n                }}\n              />\n            </Item>\n          ))}\n        </Items>\n      </Group>\n    )}\n\n    {state.search?.postsAndComments.length > 0 && (\n      <Group>\n        <h3>posts and comments</h3>\n\n        <Items>\n          {state.search.postsAndComments.map((post, i) => (\n            <Item\n              key={`${post.accountId}/${post.postType}/${post.blockHeight}`}\n            >\n              <Widget\n                src=\"near/widget/Search.FullPage.PostCard\"\n                props={{\n                  accountId: post.accountId,\n                  blockHeight: post.blockHeight,\n                  content: post.postContent,\n                  snipContent: post.snipContent,\n                  postType: post.postType,\n                  onClick: () =>\n                    onSearchResultClick({\n                      searchPosition: post.searchPosition,\n                      objectID: `${post.accountId}/${post.postType}/${post.blockHeight}`,\n                      eventName: \"clicked profile after search\",\n                    }),\n                }}\n              />\n            </Item>\n          ))}\n        </Items>\n      </Group>\n    )}\n\n    {showPagination &&\n      state.paginate &&\n      state.paginate.hitsTotal > state.paginate.hitsPerPage && (\n        <Widget\n          src=\"near/widget/Search.Paginate\"\n          props={{\n            totalCount: state.paginate.hitsTotal,\n            pageSize: state.paginate.hitsPerPage,\n            onPageChange,\n          }}\n        />\n      )}\n\n    {!state.term && <Widget src=\"james.near/widget/apps\" />}\n  </Wrapper>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/james.near/widget/search", "fact_widget_deployments_id": "b86e2de5a93fa1e5a924b38f605d7cfe", "inserted_timestamp": "2023-08-14T05:30:59.260Z", "modified_timestamp": "2023-08-14T05:30:59.260Z", "__row_index": 3}