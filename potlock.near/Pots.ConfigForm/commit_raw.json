{"tx_hash": "4F67tTqHEcbjVY7dkaEq52LaxjLCVa4w2gPoisxvH5P3", "action_id_social": "CxnCsGHzG2PF56EFJxCsdnpo94tBuC4RqdpB96TsNqLD-0-widget", "block_id": 112315621, "block_timestamp": "2024-02-07T15:14:37.125Z", "signer_id": "potlock.near", "widget_name": "Pots.ConfigForm", "source_code": "const { ownerId, potDetail, potId, POT_FACTORY_CONTRACT_ID } = props;\n\nconst DEFAULT_REGISTRY_PROVIDER = \"registry.potlock.near:is_registered\";\nconst DEFAULT_SYBIL_WRAPPER_PROVIDER = \"sybil.potlock.near:is_human\";\nconst DEFAULT_PROTOCOL_CONFIG_PROVIDER = `${POT_FACTORY_CONTRACT_ID}:get_protocol_config`;\nconst CURRENT_SOURCE_CODE_VERSION = \"0.1.0\";\nconst SOURCE_CODE_LINK = \"https://github.com/PotLock/core\"; // for use in contract source metadata\nconst POT_CODE_LINK = \"https://github.com/PotLock/core/tree/main/contracts/pot\"; // for directing user to view source code for Pot\n\nconst IPFS_BASE_URL = \"https://nftstorage.link/ipfs/\";\nconst ADD_ADMINS_ICON_URL =\n  IPFS_BASE_URL + \"bafkreig6c7m2z2lupreu2br4pm3xx575mv6uvmuy2qkij4kzzfpt7tipcq\";\nconst CLOSE_ICON_URL =\n  IPFS_BASE_URL + \"bafkreifyg2vvmdjpbhkylnhye5es3vgpsivhigkjvtv2o4pzsae2z4vi5i\";\nconst DEFAULT_PROFILE_IMAGE_URL =\n  IPFS_BASE_URL + \"bafkreifel4bfm6hxmklcsqjilk3bhvi3acf2rxqepcgglluhginbttkyqm\";\n\nconst getImageUrlFromSocialImage = (image) => {\n  if (image.url) {\n    return image.url;\n  } else if (image.ipfs_cid) {\n    return IPFS_BASE_URL + image.ipfs_cid;\n  }\n};\n\nBig.PE = 100;\n\nconst FormBody = styled.div`\n  display: flex;\n  flex-direction: column;\n  padding: 32px 68px;\n  width: 100%;\n\n  @media screen and (max-width: 768px) {\n    padding: 320px 32px 32px 32px;\n  }\n`;\n\nconst FormDivider = styled.div`\n  height: 2px;\n  width: 100%;\n  background-color: #ebebeb;\n`;\n\nconst FormSectionContainer = styled.div`\n  display: flex;\n  flex-direction: row;\n  gap: 160px;\n  margin: 48px 0 48px 0;\n\n  @media screen and (max-width: 768px) {\n    flex-direction: column;\n    gap: 32px;\n  }\n`;\n\nconst FormSectionLeftDiv = styled.div`\n  //   flex: 1;\n  width: 30%;\n  display: flex;\n  flex-direction: column;\n  // background-color: yellow;\n  gap: 16px;\n`;\n\nconst FormSectionRightDiv = styled.div`\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  gap: 26px;\n`;\n\nconst FormSectionTitle = styled.div`\n  color: #2e2e2e;\n  font-size: 16;\n  font-weight: 600;\n  word-wrap: break-word;\n`;\n\nconst FormSectionDescription = styled.div`\n  color: #2e2e2e;\n  font-size: 16;\n  font-weight: 400;\n  word-wrap: break-word;\n`;\n\nconst Row = styled.div`\n  display: flex;\n  flex-direction: row;\n  gap: 24px;\n  align-items: center;\n  justify-content: flex-start;\n`;\n\nconst Label = styled.label`\n  font-weight: 500;\n  font-size: 14px;\n  line-height: 16px;\n  word-wrap: break-word;\n  color: #2e2e2e;\n`;\n\nconst isUpdate = !!potDetail;\n\n// TODO: take values from props.potDetail if present\n// State.init({\n//   owner:  context.accountId,\n//   ownerError: \"\",\n//   name: \"\",\n//   nameError: \"\",\n//   description: \"\",\n//   descriptionError: \"\",\n//   referrerFeeMatchingPoolBasisPoints: \"\",\n//   referrerFeeMatchingPoolBasisPointsError: \"\",\n//   referrerFeePublicRoundBasisPoints: \"\",\n//   referrerFeePublicRoundBasisPointsError: \"\",\n//   protocolFeeBasisPoints: \"\",\n//   protocolFeeBasisPointsError: \"\",\n//   applicationStartDate: \"\",\n//   applicationStartDateError: \"\",\n//   applicationEndDate: \"\",\n//   applicationEndDateError: \"\",\n//   matchingRoundStartDate: \"\",\n//   matchingRoundStartDateError: \"\",\n//   matchingRoundEndDate: \"\",\n//   matchingRoundEndDateError: \"\",\n//   chef: \"\",\n//   chefError: \"\",\n//   chefFeeBasisPoints: \"\",\n//   chefFeeBasisPointsError: \"\",\n//   maxProjects: \"\",\n//   maxProjectsError: \"\",\n//   latestSourceCodeCommitHash: \"\",\n//   deploymentSuccess: false,\n// });\n\nconst convertToUTCTimestamp = (localDateTime) => {\n  if (!localDateTime) {\n    return;\n  }\n  return new Date(localDateTime).getTime();\n};\n\nconst formatTimestampForDateTimeLocal = (timestamp) => {\n  const date = new Date(timestamp);\n\n  const year = date.getFullYear();\n  const month = (date.getMonth() + 1).toString().padStart(2, \"0\"); // months are 0-indexed\n  const day = date.getDate().toString().padStart(2, \"0\");\n  const hours = date.getHours().toString().padStart(2, \"0\");\n  const minutes = date.getMinutes().toString().padStart(2, \"0\");\n\n  return `${year}-${month}-${day}T${hours}:${minutes}`;\n};\n\nState.init({\n  owner: isUpdate ? potDetail.owner : context.accountId,\n  ownerError: \"\",\n  admin: \"\",\n  admins: isUpdate ? potDetail.admins : [],\n  adminsError: \"\",\n  isAdminsModalOpen: false,\n  name: isUpdate ? potDetail.pot_name : \"\",\n  nameError: \"\",\n  description: isUpdate ? potDetail.pot_description : \"\",\n  descriptionError: \"\",\n  referrerFeeMatchingPoolBasisPoints: isUpdate\n    ? potDetail.referral_fee_matching_pool_basis_points\n    : \"\",\n  referrerFeeMatchingPoolBasisPointsError: \"\",\n  referrerFeePublicRoundBasisPoints: isUpdate\n    ? potDetail.referral_fee_public_round_basis_points\n    : \"\",\n  referrerFeePublicRoundBasisPointsError: \"\",\n  protocolFeeBasisPoints: isUpdate ? potDetail.protocol_fee_basis_points : \"\",\n  protocolFeeBasisPointsError: \"\",\n  applicationStartDate: isUpdate\n    ? formatTimestampForDateTimeLocal(potDetail.application_start_ms)\n    : \"\",\n  applicationStartDateError: \"\",\n  applicationEndDate: isUpdate ? formatTimestampForDateTimeLocal(potDetail.application_end_ms) : \"\",\n  applicationEndDateError: \"\",\n  matchingRoundStartDate: isUpdate\n    ? formatTimestampForDateTimeLocal(potDetail.public_round_start_ms)\n    : \"\",\n  matchingRoundStartDateError: \"\",\n  matchingRoundEndDate: isUpdate\n    ? formatTimestampForDateTimeLocal(potDetail.public_round_end_ms)\n    : \"\",\n  matchingRoundEndDateError: \"\",\n  chef: isUpdate ? potDetail.chef : \"\",\n  chefError: \"\",\n  chefFeeBasisPoints: isUpdate ? potDetail.chef_fee_basis_points : \"\",\n  chefFeeBasisPointsError: \"\",\n  maxProjects: isUpdate ? potDetail.max_projects : \"\",\n  maxProjectsError: \"\",\n  baseCurrency: isUpdate ? potDetail.base_currency : \"\",\n  baseCurrencyError: \"\",\n  minMatchingPoolDonationAmount: isUpdate\n    ? potDetail.min_matching_pool_donation_amount\n    : \"1000000000000000000000000\", // 1 NEAR\n  minMatchingPoolDonationAmountError: \"\",\n  latestSourceCodeCommitHash: \"\",\n  deploymentSuccess: false,\n});\n\nconst MAX_DESCRIPTION_LENGTH = 320;\n\nconst userIsWhitelisted = props.QF_WHITELISTED_ACCOUNTS.includes(context.accountId);\n\nif (!isUpdate && !userIsWhitelisted) return \"Unauthorized\";\n\nif (!isUpdate && !state.latestSourceCodeCommitHash) {\n  const res = fetch(\"https://api.github.com/repos/PotLock/core/commits\");\n  if (res.ok && res.body.length > 0) {\n    State.update({\n      latestSourceCodeCommitHash: res.body[0].sha,\n    });\n  }\n}\n\n// TODO: GET PROTOCOL FEES FROM POTFACTORY CONTRACT AND SET ON STATE & DISPLAY IN FORM AS READ-ONLY INPUTS\n\nconst getDeployArgsFromState = () => {\n  return {\n    owner: state.owner,\n    admins: state.admins.filter((admin) => !admin.remove).map((admin) => admin.accountId),\n    chef: state.chef,\n    pot_name: state.name,\n    pot_description: state.description,\n    max_projects: parseInt(state.maxProjects),\n    application_start_ms: convertToUTCTimestamp(state.applicationStartDate),\n    application_end_ms: convertToUTCTimestamp(state.applicationEndDate),\n    public_round_start_ms: convertToUTCTimestamp(state.matchingRoundStartDate),\n    public_round_end_ms: convertToUTCTimestamp(state.matchingRoundEndDate),\n    registry_provider: DEFAULT_REGISTRY_PROVIDER,\n    sybil_wrapper_provider: DEFAULT_SYBIL_WRAPPER_PROVIDER,\n    custom_sybil_checks: null, // not necessary to include null values but doing so for clarity\n    custom_min_threshold_score: null,\n    referral_fee_matching_pool_basis_points: state.referrerFeeMatchingPoolBasisPoints,\n    referral_fee_public_round_basis_points: state.referrerFeePublicRoundBasisPoints,\n    chef_fee_basis_points: state.chefFeeBasisPoints,\n    protocol_config_provider: DEFAULT_PROTOCOL_CONFIG_PROVIDER, // TODO: this should not be passed in here, as it's too easy to override. Should be set by factory contract when deploying.\n    source_metadata: {\n      version: CURRENT_SOURCE_CODE_VERSION,\n      commit_hash: state.latestSourceCodeCommitHash,\n      link: SOURCE_CODE_LINK,\n    },\n  };\n};\n\nconst getUpdateArgsFromState = () => {\n  // pub owner: Option<AccountId>,\n  // pub admins: Option<Vec<AccountId>>,\n  // pub chef: Option<AccountId>,\n  // pub pot_name: Option<String>,\n  // pub pot_description: Option<String>,\n  // pub max_projects: Option<u32>,\n  // pub application_start_ms: Option<TimestampMs>,\n  // pub application_end_ms: Option<TimestampMs>,\n  // pub public_round_start_ms: Option<TimestampMs>,\n  // pub public_round_end_ms: Option<TimestampMs>,\n  // pub registry_provider: Option<ProviderId>,\n  // pub min_matching_pool_donation_amount: Option<U128>,\n  // pub sybil_wrapper_provider: Option<ProviderId>,\n  // pub custom_sybil_checks: Option<Vec<CustomSybilCheck>>,\n  // pub custom_min_threshold_score: Option<u32>,\n  // pub referral_fee_matching_pool_basis_points: Option<u32>,\n  // pub referral_fee_public_round_basis_points: Option<u32>,\n  // pub chef_fee_basis_points: Option<u32>,\n  return {\n    owner: context.accountId === potDetail.owner ? state.owner : null,\n    admins: state.admins.filter((admin) => !admin.remove).map((admin) => admin.accountId),\n    chef: state.chef,\n    pot_name: state.name,\n    pot_description: state.description,\n    max_projects: parseInt(state.maxProjects),\n    application_start_ms: convertToUTCTimestamp(state.applicationStartDate),\n    application_end_ms: convertToUTCTimestamp(state.applicationEndDate),\n    public_round_start_ms: convertToUTCTimestamp(state.matchingRoundStartDate),\n    public_round_end_ms: convertToUTCTimestamp(state.matchingRoundEndDate),\n    // TODO: add registry_provider, sybil_wrapper_provider, custom_sybil_checks, custom_min_threshold_score\n    min_matching_pool_donation_amount: state.minMatchingPoolDonationAmount,\n    referral_fee_matching_pool_basis_points: state.referrerFeeMatchingPoolBasisPoints,\n    referral_fee_public_round_basis_points: state.referrerFeePublicRoundBasisPoints,\n    chef_fee_basis_points: state.chefFeeBasisPoints,\n  };\n};\n\nconst handleDeploy = () => {\n  // create deploy pot args\n  const deployArgs = getDeployArgsFromState();\n  //   console.log(\"deployargs: \", deployArgs);\n\n  Near.asyncView(POT_FACTORY_CONTRACT_ID, \"calculate_min_deployment_deposit\", {\n    args: deployArgs,\n  }).then((amount) => {\n    const amountYoctos = Big(amount).plus(Big(\"20000000000000000000000\")); // add extra 0.02 NEAR as buffer\n    const transactions = [\n      {\n        contractName: POT_FACTORY_CONTRACT_ID,\n        methodName: \"deploy_pot\",\n        deposit: amountYoctos,\n        args: { pot_args: deployArgs },\n        gas: props.ONE_TGAS.mul(300),\n      },\n    ];\n    const now = Date.now();\n    Near.call(transactions);\n    // NB: we won't get here if user used a web wallet, as it will redirect to the wallet\n    // <---- EXTENSION WALLET HANDLING ---->\n    // poll for updates\n    const pollIntervalMs = 1000;\n    // const totalPollTimeMs = 60000; // consider adding in to make sure interval doesn't run indefinitely\n    const pollId = setInterval(() => {\n      Near.asyncView(POT_FACTORY_CONTRACT_ID, \"get_pots\", {}).then((pots) => {\n        // console.log(\"pots: \", pots);\n        const pot = pots.find(\n          (pot) => pot.deployed_by === context.accountId && pot.deployed_at_ms > now\n        );\n        if (pot) {\n          clearInterval(pollId);\n          State.update({ deploymentSuccess: true });\n        }\n      });\n    }, pollIntervalMs);\n  });\n};\n\nconst handleUpdate = () => {\n  // create update pot args\n  const updateArgs = getUpdateArgsFromState();\n  updateArgs.source_metadata = potDetail.source_metadata;\n  //   console.log(\"updateArgs: \", updateArgs);\n  const transactions = [\n    {\n      contractName: potId,\n      methodName: \"admin_dangerously_set_pot_config\",\n      //   deposit: Big(0.1).mul(Big(10).pow(24)),\n      deposit: 0,\n      args: { update_args: updateArgs },\n      gas: props.ONE_TGAS.mul(100),\n    },\n  ];\n  Near.call(transactions);\n  // NB: we won't get here if user used a web wallet, as it will redirect to the wallet\n  // <---- EXTENSION WALLET HANDLING ---->\n  // TODO: IMPLEMENT\n};\n\n// console.log(\"state: \", state);\n\nconst validateAndUpdatePercentages = (percent, stateKey, errorKey) => {\n  // TODO: move this to separate component for percentage input that accepts \"basisPoints\" bool parameter\n  const percentFloat = parseFloat(percent);\n  const updates = {\n    [errorKey]: \"\",\n  };\n  if (!percent) {\n    updates[stateKey] = \"\";\n  } else if (percentFloat && percentFloat <= 100) {\n    updates[stateKey] = percentFloat * 100;\n  }\n  State.update(updates);\n};\n\nconst handleAddAdmin = () => {\n  let isValid = props.validateNearAddress(state.admin);\n  if (!isValid) {\n    State.update({\n      adminsError: \"Invalid NEAR account ID\",\n    });\n    return;\n  }\n  if (!state.admins.find((admin) => admin.accountId == state.admin && !admin.remove)) {\n    // TODO: if already in state.admins with remove = true, set remove = false\n    // get data from social.near\n    // const profileImageUrl = DEFAULT_PROFILE_IMAGE_URL;\n    const newAdmin = {\n      accountId: state.admin.toLowerCase(),\n      // imageUrl: profileImageUrl,\n    };\n    const admins = [...state.admins, newAdmin];\n    console.log(\"admins: \", admins);\n    State.update({\n      admins,\n      admin: \"\",\n      adminsError: \"\",\n    });\n  }\n};\n\nconst handleRemoveAdmin = (accountId) => {\n  State.update({\n    admins: state.admins.map((admin) => {\n      if (admin.accountId == accountId) {\n        return { ...admin, remove: true };\n      }\n      return admin;\n    }),\n  });\n};\n\nconst FormSectionLeft = (title, description) => {\n  return (\n    <FormSectionLeftDiv>\n      <FormSectionTitle>{title}</FormSectionTitle>\n      <FormSectionDescription>{description}</FormSectionDescription>\n    </FormSectionLeftDiv>\n  );\n};\n\nreturn (\n  <FormBody>\n    <props.ToDo>Add validation to all fields (currently only %'s are validated)</props.ToDo>\n    <FormDivider />\n    <FormSectionContainer>\n      {FormSectionLeft(\"Pot details\", \"\")}\n      <FormSectionRightDiv>\n        {isUpdate && <props.ToDo>Only allow owner edit if logged in account is owner</props.ToDo>}\n        <Widget\n          src={`${ownerId}/widget/Inputs.Text`}\n          props={{\n            label: \"Owner *\",\n            placeholder: `E.g. ${context.accountId}`,\n            value: state.owner,\n            onChange: (owner) => State.update({ owner, ownerError: \"\" }),\n            validate: () => {\n              // **CALLED ON BLUR**\n              // TODO: validate owner\n              State.update({ ownerError: \"\" });\n            },\n            error: state.ownerError,\n          }}\n        />\n        {/* <props.ToDo>ADD ADMINS multi-entry</props.ToDo> */}\n        <Label>Admins</Label>\n        <Widget\n          src={`${ownerId}/widget/Components.AccountsList`}\n          props={{\n            accountIds: state.admins\n              .filter((account) => !account.remove)\n              .map((account) => account.accountId),\n            allowRemove: true,\n            handleRemoveAccount: handleRemoveAdmin,\n          }}\n        />\n        <Widget\n          src={`${ownerId}/widget/Components.Button`}\n          props={{\n            type: \"tertiary\",\n            text: \"Add admins\",\n            style: { width: \"fit-content\" },\n            onClick: () => State.update({ isAdminsModalOpen: true }),\n          }}\n        />\n        <Widget\n          src={`${ownerId}/widget/Inputs.Text`}\n          props={{\n            label: \"Name *\",\n            placeholder: \"E.g. DeFi Center\",\n            value: state.name,\n            onChange: (name) => State.update({ name, nameError: \"\" }),\n            validate: () => {\n              // **CALLED ON BLUR**\n              // TODO: validate name\n              State.update({ nameError: \"\" });\n            },\n            error: state.nameError,\n          }}\n        />\n        <Widget\n          src={`${ownerId}/widget/Inputs.TextArea`}\n          props={{\n            label: \"Description\",\n            placeholder: \"Type description\",\n            value: state.description,\n            onChange: (description) => State.update({ description }),\n            validate: () => {\n              if (state.description.length > MAX_DESCRIPTION_LENGTH) {\n                State.update({\n                  descriptionError: `Description must be less than ${MAX_DESCRIPTION_LENGTH} characters`,\n                });\n                return;\n              }\n\n              State.update({ descriptionError: \"\" });\n            },\n            error: state.descriptionError,\n          }}\n        />\n        <Row>\n          <Widget\n            src={`${ownerId}/widget/Inputs.Text`}\n            props={{\n              label: \"Referrer fee % (matching pool)\",\n              placeholder: \"% 0\",\n              value: state.referrerFeeMatchingPoolBasisPoints\n                ? state.referrerFeeMatchingPoolBasisPoints / 100\n                : \"\",\n              onChange: (percent) => {\n                validateAndUpdatePercentages(\n                  percent,\n                  \"referrerFeeMatchingPoolBasisPoints\",\n                  \"referrerFeeMatchingPoolBasisPointsError\"\n                );\n              },\n              validate: () => {\n                // **CALLED ON BLUR**\n                // TODO: validate percent\n                State.update({ referrerFeeMatchingPoolBasisPointsError: \"\" });\n              },\n              error: state.referrerFeeMatchingPoolBasisPointsError,\n            }}\n          />\n          <Widget\n            src={`${ownerId}/widget/Inputs.Text`}\n            props={{\n              label: \"Referrer fee % (public round)\",\n              placeholder: \"% 0\",\n              value: state.referrerFeePublicRoundBasisPoints\n                ? state.referrerFeePublicRoundBasisPoints / 100\n                : \"\",\n              onChange: (percent) => {\n                validateAndUpdatePercentages(\n                  percent,\n                  \"referrerFeePublicRoundBasisPoints\",\n                  \"referrerFeePublicRoundBasisPointsError\"\n                );\n              },\n              validate: () => {\n                // **CALLED ON BLUR**\n                // TODO: validate percent\n                State.update({ referrerFeePublicRoundBasisPointsError: \"\" });\n              },\n              error: state.referrerFeePublicRoundBasisPointsError,\n            }}\n          />\n          {/* <Widget\n              src={`${ownerId}/widget/Inputs.Text`}\n              props={{\n                label: \"Protocol fee %\",\n                placeholder: \"% 0\",\n                value: state.protocolFeeBasisPoints ? state.protocolFeeBasisPoints / 100 : \"\",\n                onChange: (percent) =>\n                  State.update({\n                    protocolFeeBasisPoints: parseFloat(percent) * 100,\n                    protocolFeeBasisPointsError: \"\",\n                  }),\n                validate: () => {\n                  // **CALLED ON BLUR**\n                  // TODO: validate percent\n                  State.update({ protocolFeeBasisPointsError: \"\" });\n                },\n                error: state.protocolFeeBasisPointsError,\n              }}\n            /> */}\n        </Row>\n        <Row>\n          <Widget\n            src={`${ownerId}/widget/Inputs.Date`}\n            props={{\n              label: \"Application start date\",\n              //   placeholder: \"% 0\", // TODO: possibly add this back in\n              selectTime: true,\n              value: state.applicationStartDate,\n              onChange: (date) => {\n                State.update({ applicationStartDate: date });\n              },\n              validate: () => {\n                // **CALLED ON BLUR**\n                // TODO: validate date\n                State.update({ applicationStartDateError: \"\" });\n              },\n              error: state.applicationStartDateError,\n            }}\n          />\n          <Widget\n            src={`${ownerId}/widget/Inputs.Date`}\n            props={{\n              label: \"Application end date\",\n              //   placeholder: \"% 0\", // TODO: possibly add this back in\n              selectTime: true,\n              value: state.applicationEndDate,\n              onChange: (date) => State.update({ applicationEndDate: date }),\n              validate: () => {\n                // **CALLED ON BLUR**\n                // TODO: validate date\n                State.update({ applicationEndDateError: \"\" });\n              },\n              error: state.applicationEndDateError,\n            }}\n          />\n        </Row>\n        <Row>\n          <Widget\n            src={`${ownerId}/widget/Inputs.Date`}\n            props={{\n              label: \"Matching round start date\",\n              selectTime: true,\n              value: state.matchingRoundStartDate,\n              onChange: (date) => State.update({ matchingRoundStartDate: date }),\n              validate: () => {\n                // **CALLED ON BLUR**\n                // TODO: validate date\n                State.update({ matchingRoundStartDateError: \"\" });\n              },\n              error: state.matchingRoundStartDateError,\n            }}\n          />\n          <Widget\n            src={`${ownerId}/widget/Inputs.Date`}\n            props={{\n              label: \"Matching round end date\",\n              //   placeholder: \"% 0\", // TODO: possibly add this back in\n              selectTime: true,\n              value: state.matchingRoundEndDate,\n              onChange: (date) => State.update({ matchingRoundEndDate: date }),\n              validate: () => {\n                // **CALLED ON BLUR**\n                // TODO: validate date\n                State.update({ matchingRoundEndDateError: \"\" });\n              },\n              error: state.matchingRoundEndDateError,\n            }}\n          />\n        </Row>\n      </FormSectionRightDiv>\n    </FormSectionContainer>\n    {/* <FormDivider /> */}\n    <FormSectionContainer>\n      {FormSectionLeft(\"Chef details\", \"\")}\n      <FormSectionRightDiv>\n        <Row>\n          <Widget\n            src={`${ownerId}/widget/Inputs.Text`}\n            props={{\n              label: \"Assign chef\",\n              value: state.chef,\n              onChange: (chef) => State.update({ chef }),\n              validate: () => {\n                // **CALLED ON BLUR**\n                // TODO: validate chef\n                State.update({ chefError: \"\" });\n              },\n              error: state.chefError,\n            }}\n          />\n          <Widget\n            src={`${ownerId}/widget/Inputs.Text`}\n            props={{\n              label: \"Chef fee %\",\n              placeholder: \"% 0\",\n              value: state.chefFeeBasisPoints ? state.chefFeeBasisPoints / 100 : \"\",\n              onChange: (percent) => {\n                validateAndUpdatePercentages(\n                  percent,\n                  \"chefFeeBasisPoints\",\n                  \"chefFeeBasisPointsError\"\n                );\n              },\n              validate: () => {\n                // **CALLED ON BLUR**\n                // TODO: validate percent\n                State.update({ chefFeeBasisPointsError: \"\" });\n              },\n              error: state.chefFeeBasisPointsError,\n            }}\n          />\n        </Row>\n      </FormSectionRightDiv>\n    </FormSectionContainer>\n    {/* <FormDivider /> */}\n    <FormSectionContainer>\n      {FormSectionLeft(\"Application details\", \"\")}\n      <FormSectionRightDiv>\n        <Widget\n          src={`${ownerId}/widget/Inputs.Text`}\n          props={{\n            label: \"Max. approved applicants\",\n            placeholder: \"4\",\n            value: state.maxProjects,\n            onChange: (maxProjects) => State.update({ maxProjects }),\n            validate: () => {\n              // **CALLED ON BLUR**\n              // TODO: validate maxProjects\n              State.update({ maxProjectsError: \"\" });\n            },\n            error: state.maxProjectsError,\n          }}\n        />\n      </FormSectionRightDiv>\n    </FormSectionContainer>\n    <FormSectionContainer>\n      {FormSectionLeft(\"Donor Requirements\", \"\")}\n      <FormSectionRightDiv>\n        <props.ToDo>Add donor requirements as per latest sybil contract</props.ToDo>\n        <props.ToDo>Add Pot images upload (main & background/cover)</props.ToDo>\n        <Row style={{ justifyContent: \"flex-end\", marginTop: \"36px\" }}>\n          {!isUpdate && (\n            <Widget\n              src={`${ownerId}/widget/Components.Button`}\n              props={{\n                type: \"tertiary\",\n                text: \"Cancel\",\n                style: props.style || {},\n                onClick: () => {\n                  // TODO: handle click\n                },\n              }}\n            />\n          )}\n          <Widget\n            src={`${ownerId}/widget/Components.Button`}\n            props={{\n              type: \"primary\",\n              text: isUpdate ? \"Save changes\" : \"Deploy\",\n              style: props.style || {},\n              onClick: isUpdate ? handleUpdate : handleDeploy,\n            }}\n          />\n        </Row>\n      </FormSectionRightDiv>\n    </FormSectionContainer>\n    <Widget\n      src={`${ownerId}/widget/Components.ModalMultiAccount`}\n      props={{\n        ...props,\n        isModalOpen: state.isAdminsModalOpen,\n        onClose: () => State.update({ isAdminsModalOpen: false }),\n        titleText: \"Add admins\",\n        descriptionText: \"Add NEAR account IDs for your admins.\",\n        inputValue: state.admin,\n        onInputChange: (admin) => {\n          State.update({ admin, adminsError: \"\" });\n        },\n        handleAddAccount: handleAddAdmin,\n        handleRemoveAccount: handleRemoveAdmin,\n        accountError: state.adminsError,\n        accounts: state.admins,\n        unitText: \"admin\",\n      }}\n    />\n  </FormBody>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/potlock.near/widget/Pots.ConfigForm", "fact_widget_deployments_id": "c3c3722a4b7d74e47725d92603055c03", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 2}