{"tx_hash": "BqeM3Ywrc6fsJGRBfTmgj9VLZufr74kUFAWeWG4uzbeu", "action_id_social": "CbcXWw3Bg8VRMuq2gTqPrRBAjKnvCgLnqJrKCkR4mXx5-0-widget", "block_id": 115722656, "block_timestamp": "2024-03-29T14:20:36.213Z", "signer_id": "potlock.near", "widget_name": "Pots.ConfigForm", "source_code": "const { potDetail, potId, NADABOT_CONTRACT_ID } = props;\nconst { validateNearAddress } = VM.require(\"potlock.near/widget/utils\") || {\n  validateNearAddress: () => \"\",\n};\nconst {\n  NADABOT_HUMAN_METHOD,\n  ownerId,\n  ONE_TGAS,\n  SUPPORTED_FTS: { NEAR },\n} = VM.require(\"potlock.near/widget/constants\") || {\n  NADABOT_HUMAN_METHOD: \"\",\n  ownerId: \"\",\n  ONE_TGAS: 0,\n  SUPPORTED_FTS: {},\n};\n\nlet PotFactorySDK =\n  VM.require(\"potlock.near/widget/SDK.potfactory\") ||\n  (() => ({\n    getContractId: () => {},\n    getProtocolConfig: () => {},\n    asyncGetPots: () => {},\n  }));\nPotFactorySDK = PotFactorySDK({ env: props.env });\nconst potFactoryContractId = PotFactorySDK.getContractId();\nconst protocolConfig = PotFactorySDK.getProtocolConfig();\n// console.log(\"props in config form: \", props);\n\nlet ListsSDK =\n  VM.require(\"potlock.near/widget/SDK.lists\") ||\n  (() => ({\n    getContractId: () => \"\",\n  }));\nListsSDK = ListsSDK({ env: props.env });\n\nconst DEFAULT_REGISTRY_PROVIDER = `${ListsSDK.getContractId()}:is_registered`;\nconst DEFAULT_SYBIL_WRAPPER_PROVIDER = `${NADABOT_CONTRACT_ID}:${NADABOT_HUMAN_METHOD}`;\nconst CURRENT_SOURCE_CODE_VERSION = \"0.1.0\";\nconst SOURCE_CODE_LINK = \"https://github.com/PotLock/core\"; // for use in contract source metadata\nconst POT_CODE_LINK = \"https://github.com/PotLock/core/tree/main/contracts/pot\"; // for directing user to view source code for Pot\n\nconst IPFS_BASE_URL = \"https://nftstorage.link/ipfs/\";\n// const ADD_ADMINS_ICON_URL =\n//   IPFS_BASE_URL + \"bafkreig6c7m2z2lupreu2br4pm3xx575mv6uvmuy2qkij4kzzfpt7tipcq\";\n// const CLOSE_ICON_URL =\n//   IPFS_BASE_URL + \"bafkreifyg2vvmdjpbhkylnhye5es3vgpsivhigkjvtv2o4pzsae2z4vi5i\";\nconst DEFAULT_PROFILE_IMAGE_URL =\n  IPFS_BASE_URL + \"bafkreifel4bfm6hxmklcsqjilk3bhvi3acf2rxqepcgglluhginbttkyqm\";\n\nconst MAX_POT_NAME_LENGTH = 64;\nconst MAX_POT_DESCRIPTION_LENGTH = 256;\nconst MAX_MAX_PROJECTS = 100;\nconst MAX_REFERRAL_FEE_MATCHING_POOL_BASIS_POINTS = 1000; // 10%\nconst MAX_REFERRAL_FEE_PUBLIC_ROUND_BASIS_POINTS = 1000; // 10%\nconst MAX_CHEF_FEE_BASIS_POINTS = 1000; // 10%\n\nconst getImageUrlFromSocialImage = (image) => {\n  if (image.url) {\n    return image.url;\n  } else if (image.ipfs_cid) {\n    return IPFS_BASE_URL + image.ipfs_cid;\n  }\n};\n\nBig.PE = 100;\n\nconst FormBody = styled.div`\n  display: flex;\n  flex-direction: column;\n  padding: 32px 0px;\n  width: 100%;\n\n  @media screen and (max-width: 880px) {\n    padding: 10px 10px;\n  }\n`;\n\nconst FormDivider = styled.div`\n  height: 2px;\n  width: 100%;\n  background-color: #ebebeb;\n  @media screen and (max-width: 768px) {\n    display: none;\n  }\n`;\n\nconst FormSectionContainer = styled.div`\n  display: flex;\n  flex-direction: row;\n  margin: 48px 0;\n  @media screen and (max-width: 768px) {\n    flex-direction: column;\n    gap: 32px;\n  }\n`;\n\nconst FormSectionLeftDiv = styled.div`\n  //   flex: 1;\n  width: 30%;\n  display: flex;\n  flex-direction: column;\n  // background-color: yellow;\n  gap: 16px;\n  @media screen and (max-width: 768px) {\n    width: 100%;\n  }\n`;\n\nconst FormSectionRightDiv = styled.div`\n  width: 70%;\n  display: flex;\n  flex-direction: column;\n  gap: 26px;\n  @media screen and (max-width: 768px) {\n    width: 100%;\n  }\n`;\n\nconst FormSectionTitle = styled.div`\n  color: #2e2e2e;\n  font-size: 16;\n  font-weight: 600;\n  word-wrap: break-word;\n`;\n\nconst FormSectionDescription = styled.div`\n  color: #2e2e2e;\n  font-size: 16;\n  font-weight: 400;\n  word-wrap: break-word;\n`;\n\nconst Row = styled.div`\n  display: flex;\n  flex-direction: row;\n  gap: 24px;\n  align-items: end;\n  justify-content: flex-start;\n  @media screen and (max-width: 768px) {\n    flex-direction: column;\n    align-items: flex-start;\n  }\n`;\n\nconst Checkbox = styled.div`\n  display: flex;\n  @media screen and (max-width: 768px) {\n    flex-direction: row;\n  }\n`;\n\nconst Label = styled.label`\n  font-weight: 500;\n  font-size: 14px;\n  line-height: 16px;\n  word-wrap: break-word;\n  color: #2e2e2e;\n`;\n\nconst isUpdate = !!potDetail;\n\nconst convertToUTCTimestamp = (localDateTime) => {\n  if (!localDateTime) {\n    return;\n  }\n  return new Date(localDateTime).getTime();\n};\n\nconst formatTimestampForDateTimeLocal = (timestamp) => {\n  const date = new Date(timestamp);\n\n  const year = date.getFullYear();\n  const month = (date.getMonth() + 1).toString().padStart(2, \"0\"); // months are 0-indexed\n  const day = date.getDate().toString().padStart(2, \"0\");\n  const hours = date.getHours().toString().padStart(2, \"0\");\n  const minutes = date.getMinutes().toString().padStart(2, \"0\");\n\n  return `${year}-${month}-${day}T${hours}:${minutes}`;\n};\n\n// console.log(\"potDetail: \", potDetail);\n\nState.init({\n  owner: isUpdate ? potDetail.owner : context.accountId,\n  ownerError: \"\",\n  admin: \"\",\n  admins: isUpdate ? potDetail.admins.map((accountId) => ({ accountId })) : [],\n  adminsError: \"\",\n  isAdminsModalOpen: false,\n  name: isUpdate ? potDetail.pot_name : \"\",\n  nameError: \"\",\n  customHandle: isUpdate ? potId.split(`.${potFactoryContractId}`)[0] : \"\",\n  customHandleError: \"\",\n  description: isUpdate ? potDetail.pot_description : \"\",\n  descriptionError: \"\",\n  // referrerFeeMatchingPoolPercent * 100: isUpdate\n  //   ? potDetail.referral_fee_matching_pool_basis_points\n  //   : \"\",\n  // referrerFeeMatchingPoolPercent * 100Error: \"\",\n  referrerFeeMatchingPoolPercent: isUpdate\n    ? potDetail.referral_fee_matching_pool_basis_points / 100\n    : \"\",\n  referrerFeeMatchingPoolPercentError: \"\",\n  referrerFeePublicRoundPercent: isUpdate\n    ? potDetail.referral_fee_public_round_basis_points / 100\n    : \"\",\n  referrerFeePublicRoundPercentError: \"\",\n  protocolFeeBasisPoints: isUpdate ? potDetail.protocol_fee_basis_points : \"\",\n  protocolFeeBasisPointsError: \"\",\n  applicationStartDate: isUpdate\n    ? formatTimestampForDateTimeLocal(potDetail.application_start_ms)\n    : \"\",\n  applicationStartDateError: \"\",\n  applicationEndDate: isUpdate ? formatTimestampForDateTimeLocal(potDetail.application_end_ms) : \"\",\n  applicationEndDateError: \"\",\n  matchingRoundStartDate: isUpdate\n    ? formatTimestampForDateTimeLocal(potDetail.public_round_start_ms)\n    : \"\",\n  matchingRoundStartDateError: \"\",\n  matchingRoundEndDate: isUpdate\n    ? formatTimestampForDateTimeLocal(potDetail.public_round_end_ms)\n    : \"\",\n  matchingRoundEndDateError: \"\",\n  chef: isUpdate ? potDetail.chef : \"\",\n  chefError: \"\",\n  chefFeePercent: isUpdate ? potDetail.chef_fee_basis_points / 100 : \"\",\n  chefFeePercentError: \"\",\n  maxProjects: isUpdate ? potDetail.max_projects : \"\",\n  maxProjectsError: \"\",\n  baseCurrency: isUpdate ? potDetail.base_currency : \"\",\n  baseCurrencyError: \"\",\n  minMatchingPoolDonationAmount: NEAR.fromIndivisible(\n    isUpdate ? potDetail.min_matching_pool_donation_amount : \"1\"\n  ),\n  minMatchingPoolDonationAmountError: \"\",\n  useNadabotSybil: isUpdate\n    ? potDetail.sybil_wrapper_provider == DEFAULT_SYBIL_WRAPPER_PROVIDER\n    : true,\n  usePotlockRegistry: isUpdate ? potDetail.registry_provider == DEFAULT_REGISTRY_PROVIDER : true,\n  latestSourceCodeCommitHash: \"\",\n  deploymentSuccess: false,\n});\n\nif (!isUpdate && !state.latestSourceCodeCommitHash) {\n  const res = fetch(\"https://api.github.com/repos/PotLock/core/commits\");\n  if (res.ok && res.body.length > 0) {\n    State.update({\n      latestSourceCodeCommitHash: res.body[0].sha,\n    });\n  }\n}\n\nconst getPotDetailArgsFromState = () => {\n  const args = {\n    owner: state.owner,\n    admins: state.admins.filter((admin) => !admin.remove).map((admin) => admin.accountId),\n    chef: state.chef || null,\n    pot_name: state.name,\n    pot_description: state.description,\n    max_projects: parseInt(state.maxProjects) || null,\n    application_start_ms: convertToUTCTimestamp(state.applicationStartDate),\n    application_end_ms: convertToUTCTimestamp(state.applicationEndDate),\n    public_round_start_ms: convertToUTCTimestamp(state.matchingRoundStartDate),\n    public_round_end_ms: convertToUTCTimestamp(state.matchingRoundEndDate),\n    min_matching_pool_donation_amount: NEAR.toIndivisible(\n      state.minMatchingPoolDonationAmount\n    ).toString(),\n    registry_provider: state.usePotlockRegistry ? DEFAULT_REGISTRY_PROVIDER : null,\n    sybil_wrapper_provider: state.useNadabotSybil ? DEFAULT_SYBIL_WRAPPER_PROVIDER : null,\n    custom_sybil_checks: null, // not necessary to include null values but doing so for clarity\n    custom_min_threshold_score: null, // not necessary to include null values but doing so for clarity\n    referral_fee_matching_pool_basis_points: parseInt(\n      (state.referrerFeeMatchingPoolPercent * 100).toFixed(0)\n    ),\n    referral_fee_public_round_basis_points: parseInt(\n      (state.referrerFeePublicRoundPercent * 100).toFixed(0)\n    ),\n    chef_fee_basis_points: parseInt((state.chefFeePercent * 100).toFixed(0)),\n    source_metadata: isUpdate\n      ? null\n      : {\n          // TODO: think about the best way to handle this so that it keeps up to date with the latest source code\n          version: CURRENT_SOURCE_CODE_VERSION,\n          commit_hash: state.latestSourceCodeCommitHash,\n          link: SOURCE_CODE_LINK,\n        },\n  };\n  return args;\n};\n\n// console.log(\"state; \", state);\n\nconst canDeploy = useMemo(() => {\n  if (\n    !state.owner ||\n    state.ownerError ||\n    !state.name ||\n    state.nameError ||\n    !state.description ||\n    state.descriptionError ||\n    !state.referrerFeeMatchingPoolPercent ||\n    state.referrerFeeMatchingPoolPercentError ||\n    !state.applicationStartDate ||\n    state.applicationStartDateError ||\n    !state.applicationEndDate ||\n    state.applicationEndDateError ||\n    !state.matchingRoundStartDate ||\n    state.matchingRoundStartDateError ||\n    !state.matchingRoundEndDate ||\n    state.matchingRoundEndDateError ||\n    !state.chef ||\n    state.chefError ||\n    !state.chefFeePercent ||\n    state.chefFeePercentError ||\n    !state.maxProjects ||\n    state.maxProjectsError\n  ) {\n    return false;\n  }\n  return true;\n}, [state]);\n\nconst handleDeploy = () => {\n  // create deploy pot args\n  const deployArgs = getPotDetailArgsFromState();\n  console.log(\"deployArgs: \", deployArgs);\n\n  Near.asyncView(potFactoryContractId, \"calculate_min_deployment_deposit\", {\n    args: deployArgs,\n  }).then((amount) => {\n    // console.log(\"amount: \", amount);\n    const amountYoctos = Big(amount).plus(Big(\"20000000000000000000000\")); // add extra 0.02 NEAR as buffer\n    const args = { pot_args: deployArgs };\n    if (state.customHandle) {\n      args.pot_handle = state.customHandle;\n    }\n    const transactions = [\n      {\n        contractName: potFactoryContractId,\n        methodName: \"deploy_pot\",\n        deposit: amountYoctos,\n        args,\n        gas: ONE_TGAS.mul(300),\n      },\n    ];\n    const now = Date.now();\n    Near.call(transactions);\n    // NB: we won't get here if user used a web wallet, as it will redirect to the wallet\n    // <---- EXTENSION WALLET HANDLING ---->\n    // poll for updates\n    const pollIntervalMs = 1000;\n    // const totalPollTimeMs = 60000; // consider adding in to make sure interval doesn't run indefinitely\n    const pollId = setInterval(() => {\n      PotFactorySDK.asyncGetPots().then((pots) => {\n        // console.log(\"pots: \", pots);\n        const pot = pots.find(\n          (pot) => pot.deployed_by === context.accountId && pot.deployed_at_ms > now\n        );\n        if (pot) {\n          clearInterval(pollId);\n          State.update({ deploymentSuccess: true });\n        }\n      });\n    }, pollIntervalMs);\n  });\n};\n\nconst handleUpdate = () => {\n  // create update pot args\n  const updateArgs = getPotDetailArgsFromState();\n  // console.log(\"updateArgs: \", updateArgs);\n  const depositFloat = JSON.stringify(updateArgs).length * 0.00003;\n  const deposit = Big(depositFloat).mul(Big(10).pow(24));\n  const transactions = [\n    {\n      contractName: potId,\n      methodName: \"admin_dangerously_set_pot_config\",\n      deposit: Big(0.1).mul(Big(10).pow(24)),\n      deposit,\n      args: { update_args: updateArgs },\n      gas: ONE_TGAS.mul(100),\n    },\n  ];\n  Near.call(transactions);\n  // NB: we won't get here if user used a web wallet, as it will redirect to the wallet\n  // <---- EXTENSION WALLET HANDLING ---->\n  // TODO: IMPLEMENT\n};\n\n// console.log(\"state: \", state);\n\nconst validateAndUpdatePercentages = (percent, stateKey, errorKey, maxVal) => {\n  // TODO: move this to separate component for percentage input that accepts \"basisPoints\" bool parameter\n  const updates = {\n    [errorKey]: \"\",\n  };\n  if (!percent) {\n    updates[stateKey] = \"0\";\n  } else {\n    const split = percent.split(\".\");\n    if (split.length > 2) {\n      return;\n    }\n    if (split.length === 2 && split[1].length > 2) {\n      return;\n    }\n    // if it ends with a period and this is the only period in the string, set on state\n    if (percent.endsWith(\".\") && percent.indexOf(\".\") === percent.length - 1) {\n      State.update({\n        [stateKey]: percent,\n      });\n      return;\n    }\n    // otherwise, parse into a float\n    const percentFloat = parseFloat(percent);\n    if (percentFloat) {\n      updates[stateKey] = percentFloat.toString();\n      if (percentFloat > maxVal) {\n        updates[errorKey] = `Maximum ${maxVal}%`;\n      }\n    }\n  }\n  State.update(updates);\n};\n\nconst handleAddAdmin = () => {\n  let isValid = validateNearAddress(state.admin);\n  if (!isValid) {\n    State.update({\n      adminsError: \"Invalid NEAR account ID\",\n    });\n    return;\n  }\n  if (!state.admins.find((admin) => admin.accountId == state.admin && !admin.remove)) {\n    // TODO: if already in state.admins with remove = true, set remove = false\n    // get data from social.near\n    // const profileImageUrl = DEFAULT_PROFILE_IMAGE_URL;\n    const newAdmin = {\n      accountId: state.admin.toLowerCase(),\n      // imageUrl: profileImageUrl,\n    };\n    const admins = [...state.admins, newAdmin];\n    // console.log(\"admins: \", admins);\n    State.update({\n      admins,\n      admin: \"\",\n      adminsError: \"\",\n    });\n  }\n};\n\nconst handleRemoveAdmin = (accountId) => {\n  State.update({\n    admins: state.admins.map((admin) => {\n      if (admin.accountId == accountId) {\n        return { ...admin, remove: true };\n      }\n      return admin;\n    }),\n  });\n};\n\nconst userIsOwner = context.accountId === potDetail.owner;\nconst userIsAdmin = isUpdate && potDetail.admins.includes(context.accountId);\nconst isAdminOrGreater = userIsOwner || userIsAdmin;\n\nconst FormSectionLeft = (title, description) => {\n  return (\n    <FormSectionLeftDiv>\n      <FormSectionTitle>{title}</FormSectionTitle>\n      <FormSectionDescription>{description}</FormSectionDescription>\n    </FormSectionLeftDiv>\n  );\n};\n\nreturn (\n  <FormBody>\n    <FormSectionContainer>\n      {FormSectionLeft(\"Pot details\", \"\")}\n      <FormSectionRightDiv>\n        <Widget\n          src={`${ownerId}/widget/Inputs.Text`}\n          props={{\n            label: \"Owner *\",\n            placeholder: `E.g. ${context.accountId}`,\n            value: state.owner,\n            onChange: (owner) => State.update({ owner, ownerError: \"\" }),\n            validate: () => {\n              // **CALLED ON BLUR**\n              const valid = validateNearAddress(state.owner);\n              State.update({ ownerError: valid ? \"\" : \"Invalid NEAR account ID\" });\n            },\n            error: state.ownerError,\n            disabled: isUpdate ? !userIsOwner : true,\n          }}\n        />\n        {/* <props.ToDo>ADD ADMINS multi-entry</props.ToDo> */}\n        <Label>Admins</Label>\n        <Widget\n          src={`${ownerId}/widget/Components.AccountsList`}\n          props={{\n            accountIds: state.admins\n              .filter((account) => !account.remove)\n              .map((account) => account.accountId),\n            allowRemove: isUpdate ? userIsOwner : true,\n            handleRemoveAccount: handleRemoveAdmin,\n          }}\n        />\n        {(!isUpdate || userIsOwner) && (\n          <Widget\n            src={`${ownerId}/widget/Components.Button`}\n            props={{\n              type: \"tertiary\",\n              text: \"Add admins\",\n              style: { width: \"fit-content\" },\n              onClick: () => State.update({ isAdminsModalOpen: true }),\n            }}\n          />\n        )}\n        <Widget\n          src={`${ownerId}/widget/Inputs.Text`}\n          props={{\n            label: \"Name *\",\n            placeholder: \"E.g. DeFi Center\",\n            value: state.name,\n            onChange: (name) => State.update({ name, nameError: \"\" }),\n            validate: () => {\n              // **CALLED ON BLUR**\n              const valid = state.name.length <= MAX_POT_NAME_LENGTH;\n              State.update({\n                nameError: valid ? \"\" : `Name must be ${MAX_POT_NAME_LENGTH} characters or less`,\n              });\n            },\n            error: state.nameError,\n            disabled: isUpdate ? !isAdminOrGreater : false,\n          }}\n        />\n        <Widget\n          src={`${ownerId}/widget/Inputs.Text`}\n          props={{\n            label: \"Custom handle (optional - will slugify name by default)\",\n            placeholder: \"e.g. my-pot-handle\",\n            value: state.customHandle,\n            onChange: (customHandle) => State.update({ customHandle, customHandleError: \"\" }),\n            validate: () => {\n              // **CALLED ON BLUR**\n              const suffix = `.${potFactoryContractId}`;\n              const fullAddress = `${state.customHandle}${suffix}`;\n              let customHandleError = \"\";\n              if (fullAddress.length > 64) {\n                customHandleError = `Handle must be ${64 - suffix.length} characters or less`;\n              } else {\n                const valid = validateNearAddress(fullAddress);\n                customHandleError = valid\n                  ? \"\"\n                  : `Invalid handle (can only contain lowercase alphanumeric symbols +  _ or -)`;\n              }\n              State.update({\n                customHandleError,\n              });\n            },\n            error: state.customHandleError,\n            disabled: isUpdate,\n          }}\n        />\n        <Widget\n          src={`${ownerId}/widget/Inputs.TextArea`}\n          props={{\n            label: \"Description\",\n            placeholder: \"Type description\",\n            value: state.description,\n            onChange: (description) => State.update({ description }),\n            validate: () => {\n              // **CALLED ON BLUR**\n              const valid = state.description.length <= MAX_POT_DESCRIPTION_LENGTH;\n              State.update({\n                descriptionError: valid\n                  ? \"\"\n                  : `Description must be ${MAX_POT_DESCRIPTION_LENGTH} characters or less`,\n              });\n            },\n            error: state.descriptionError,\n            disabled: isUpdate ? !isAdminOrGreater : false,\n          }}\n        />\n        <Row>\n          <Widget\n            src={`${ownerId}/widget/Inputs.Text`}\n            props={{\n              label: \"Referrer fee % (matching pool)\",\n              placeholder: \"0\",\n              percent: true,\n              value: state.referrerFeeMatchingPoolPercent,\n              onChange: (percent) => {\n                validateAndUpdatePercentages(\n                  percent,\n                  \"referrerFeeMatchingPoolPercent\",\n                  \"referrerFeeMatchingPoolPercentError\",\n                  MAX_REFERRAL_FEE_MATCHING_POOL_BASIS_POINTS / 100\n                );\n              },\n              validate: () => {\n                // **CALLED ON BLUR**\n              },\n              error: state.referrerFeeMatchingPoolPercentError,\n              disabled: isUpdate ? !isAdminOrGreater : false,\n            }}\n          />\n          <Widget\n            src={`${ownerId}/widget/Inputs.Text`}\n            props={{\n              label: \"Referrer fee % (public round)\",\n              placeholder: \"0\",\n              percent: true,\n              value: state.referrerFeePublicRoundPercent,\n              onChange: (percent) => {\n                validateAndUpdatePercentages(\n                  percent,\n                  \"referrerFeePublicRoundPercent\",\n                  \"referrerFeePublicRoundPercentError\",\n                  MAX_REFERRAL_FEE_PUBLIC_ROUND_BASIS_POINTS / 100\n                );\n              },\n              validate: () => {\n                // **CALLED ON BLUR**\n              },\n              error: state.referrerFeeMatchingPoolPercentError,\n              disabled: isUpdate ? !isAdminOrGreater : false,\n            }}\n          />\n          <Widget\n            src={`${ownerId}/widget/Inputs.Text`}\n            props={{\n              label: \"Protocol fee %\",\n              value: protocolConfig ? protocolConfig.basis_points / 100 : \"-\",\n              disabled: true,\n              percent: true,\n            }}\n          />\n        </Row>\n        <Widget\n          src={`${ownerId}/widget/Inputs.Date`}\n          props={{\n            label: \"Application start date\",\n            //   placeholder: \"0\", // TODO: possibly add this back in\n            selectTime: true,\n            value: state.applicationStartDate,\n            onChange: (date) => {\n              State.update({ applicationStartDate: date });\n            },\n            validate: () => {\n              // **CALLED ON BLUR**\n              // must be after now & before application end date\n              // const now = Date.now();\n              const now = new Date().getTime();\n              const applicationStartDate = new Date(state.applicationStartDate).getTime();\n              const applicationEndDate = new Date(state.applicationEndDate).getTime();\n              const valid =\n                applicationStartDate > now &&\n                (!applicationEndDate || applicationStartDate < applicationEndDate);\n              State.update({\n                applicationStartDateError: valid ? \"\" : \"Invalid application start date\",\n              });\n            },\n            error: state.applicationStartDateError,\n            disabled: isUpdate ? !isAdminOrGreater : false,\n          }}\n        />\n        <Widget\n          src={`${ownerId}/widget/Inputs.Date`}\n          props={{\n            label: \"Application end date\",\n            //   placeholder: \"0\", // TODO: possibly add this back in\n            selectTime: true,\n            value: state.applicationEndDate,\n            onChange: (date) => State.update({ applicationEndDate: date }),\n            validate: () => {\n              // **CALLED ON BLUR**\n              // must be before matching round start date\n              const valid =\n                (!state.matchingRoundStartDate ||\n                  state.applicationEndDate < state.matchingRoundStartDate) &&\n                (!state.applicationStartDate ||\n                  state.applicationEndDate > state.applicationStartDate);\n              State.update({\n                applicationEndDateError: valid ? \"\" : \"Invalid application end date\",\n              });\n            },\n            error: state.applicationEndDateError,\n            disabled: isUpdate ? !isAdminOrGreater : false,\n          }}\n        />\n        <Widget\n          src={`${ownerId}/widget/Inputs.Date`}\n          props={{\n            label: \"Matching round start date\",\n            selectTime: true,\n            value: state.matchingRoundStartDate,\n            onChange: (date) => State.update({ matchingRoundStartDate: date }),\n            validate: () => {\n              // **CALLED ON BLUR**\n              // must be after application end and before matching round end\n              const valid =\n                (!state.applicationEndDate ||\n                  state.matchingRoundStartDate > state.applicationEndDate) &&\n                (!state.matchingRoundEndDate ||\n                  state.matchingRoundStartDate < state.matchingRoundEndDate);\n              State.update({\n                matchingRoundStartDateError: valid ? \"\" : \"Invalid round start date\",\n              });\n            },\n            error: state.matchingRoundStartDateError,\n            disabled: isUpdate ? !isAdminOrGreater : false,\n          }}\n        />\n        <Widget\n          src={`${ownerId}/widget/Inputs.Date`}\n          props={{\n            label: \"Matching round end date\",\n            //   placeholder: \"0\", // TODO: possibly add this back in\n            selectTime: true,\n            value: state.matchingRoundEndDate,\n            onChange: (date) => State.update({ matchingRoundEndDate: date }),\n            validate: () => {\n              // **CALLED ON BLUR**\n              // must be after matching round start\n              const valid =\n                !state.matchingRoundStartDate ||\n                state.matchingRoundEndDate > state.matchingRoundStartDate;\n              State.update({ matchingRoundEndDateError: valid ? \"\" : \"Invalid round end date\" });\n            },\n            error: state.matchingRoundEndDateError,\n            disabled: isUpdate ? !isAdminOrGreater : false,\n          }}\n        />\n        <Row>\n          <Widget\n            src={`${ownerId}/widget/Inputs.Text`}\n            props={{\n              label: \"Optional: Min matching pool donation amount (in NEAR)\",\n              placeholder: \"0\",\n              value: state.minMatchingPoolDonationAmount,\n              onChange: (amountNear) => {\n                State.update({ minMatchingPoolDonationAmount: amountNear });\n              },\n              validate: () => {\n                // **CALLED ON BLUR**\n              },\n              error: state.referrerFeeMatchingPoolPercentError,\n              disabled: isUpdate ? !isAdminOrGreater : false,\n            }}\n          />\n        </Row>\n      </FormSectionRightDiv>\n    </FormSectionContainer>\n    {/* <FormDivider /> */}\n    <FormSectionContainer>\n      {FormSectionLeft(\"Chef details\", \"\")}\n      <FormSectionRightDiv>\n        <Row>\n          <Widget\n            src={`${ownerId}/widget/Inputs.Text`}\n            props={{\n              label: \"Assign chef\",\n              placeholder: \"E.g. user.near\",\n              value: state.chef,\n              onChange: (chef) => State.update({ chef }),\n              validate: () => {\n                // **CALLED ON BLUR**\n                const valid = validateNearAddress(state.chef);\n                State.update({ chefError: valid ? \"\" : \"Invalid NEAR account ID\" });\n              },\n              error: state.chefError,\n              disabled: isUpdate ? !isAdminOrGreater : false,\n            }}\n          />\n          <Widget\n            src={`${ownerId}/widget/Inputs.Text`}\n            props={{\n              label: \"Chef fee %\",\n              placeholder: \"0\",\n              percent: true,\n              value: state.chefFeePercent,\n              onChange: (percent) => {\n                validateAndUpdatePercentages(\n                  percent,\n                  \"chefFeePercent\",\n                  \"chefFeePercentError\",\n                  MAX_CHEF_FEE_BASIS_POINTS / 100\n                );\n              },\n              validate: () => {\n                // **CALLED ON BLUR**\n              },\n              error: state.chefFeePercentError,\n              disabled: isUpdate ? !isAdminOrGreater : false,\n            }}\n          />\n        </Row>\n      </FormSectionRightDiv>\n    </FormSectionContainer>\n    {/* <FormDivider /> */}\n    <FormSectionContainer>\n      {FormSectionLeft(\"Application details\", \"\")}\n      <FormSectionRightDiv>\n        <Widget\n          src={`${ownerId}/widget/Inputs.Text`}\n          props={{\n            label: \"Max. approved projects\",\n            placeholder: \"e.g. 20\",\n            value: state.maxProjects,\n            onChange: (maxProjects) => State.update({ maxProjects }),\n            validate: () => {\n              // **CALLED ON BLUR**\n              const valid = parseInt(state.maxProjects) <= MAX_MAX_PROJECTS;\n              State.update({ maxProjectsError: valid ? \"\" : `Maximum ${MAX_MAX_PROJECTS}` });\n            },\n            error: state.maxProjectsError,\n            disabled: isUpdate ? !isAdminOrGreater : false,\n          }}\n        />\n      </FormSectionRightDiv>\n    </FormSectionContainer>\n    <FormSectionContainer>\n      {FormSectionLeft(\"Project Registration\", \"\")}\n      <FormSectionRightDiv>\n        <Row>\n          <Checkbox>\n            <Widget\n              src={`${ownerId}/widget/Inputs.Checkbox`}\n              props={{\n                id: \"registrationSelector\",\n                checked: state.usePotlockRegistry,\n                onClick: (e) => {\n                  State.update({\n                    usePotlockRegistry: e.target.checked,\n                  });\n                },\n                disabled: isUpdate ? !isAdminOrGreater : false,\n              }}\n            />\n            <Label htmlFor=\"sybilSelector\">\n              Require approval on PotLock registry (recommended)\n            </Label>\n          </Checkbox>\n        </Row>\n      </FormSectionRightDiv>\n    </FormSectionContainer>\n    <FormSectionContainer>\n      {FormSectionLeft(\"Donor Sybil Resistance\", \"\")}\n      <FormSectionRightDiv>\n        <Row>\n          <Checkbox>\n            <Widget\n              src={`${ownerId}/widget/Inputs.Checkbox`}\n              props={{\n                id: \"sybilSelector\",\n                checked: state.useNadabotSybil,\n                onClick: (e) => {\n                  State.update({\n                    useNadabotSybil: e.target.checked,\n                  });\n                },\n                disabled: isUpdate ? !isAdminOrGreater : false,\n              }}\n            />\n            <Label htmlFor=\"sybilSelector\">\ud83e\udd16 nada.bot human verification (recommended)</Label>\n          </Checkbox>\n        </Row>\n        <Row style={{ justifyContent: \"flex-end\", marginTop: \"36px\" }}>\n          {!isUpdate && isAdminOrGreater && (\n            <Widget\n              src={`${ownerId}/widget/Components.Button`}\n              props={{\n                type: \"tertiary\",\n                text: \"Cancel\",\n                style: props.style || {},\n                onClick: () => {\n                  // TODO: handle click\n                },\n              }}\n            />\n          )}\n          {((isUpdate && isAdminOrGreater) || !isUpdate) && (\n            <Widget\n              src={`${ownerId}/widget/Components.Button`}\n              props={{\n                type: \"primary\",\n                text: isUpdate ? \"Save changes\" : \"Deploy\",\n                style: props.style || {},\n                onClick: isUpdate ? handleUpdate : handleDeploy,\n                // disabled: !canDeploy,\n              }}\n            />\n          )}\n        </Row>\n      </FormSectionRightDiv>\n    </FormSectionContainer>\n    <Widget\n      src={`${ownerId}/widget/Components.ModalMultiAccount`}\n      props={{\n        ...props,\n        isModalOpen: state.isAdminsModalOpen,\n        onClose: () => State.update({ isAdminsModalOpen: false }),\n        titleText: \"Add admins\",\n        descriptionText: \"Add NEAR account IDs for your admins.\",\n        inputValue: state.admin,\n        onInputChange: (admin) => {\n          State.update({ admin, adminsError: \"\" });\n        },\n        handleAddAccount: handleAddAdmin,\n        handleRemoveAccount: handleRemoveAdmin,\n        accountError: state.adminsError,\n        accountIds: state.admins.map((admin) => admin.accountId),\n        unitText: \"admin\",\n      }}\n    />\n  </FormBody>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/potlock.near/widget/Pots.ConfigForm", "fact_widget_deployments_id": "5226a030688c3ca8327a74ad0ddfdda2", "inserted_timestamp": "2024-03-29T15:31:57.070Z", "modified_timestamp": "2024-03-29T15:31:57.070Z", "__row_index": 0}