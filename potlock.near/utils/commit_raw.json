{"tx_hash": "4WVT78iHmS9mpwGpGeqeu6R2UJ2cnBaDybxQFwxdqe9z", "action_id_social": "4cefHP77UXENEjSEHoA6CyAsotbdnmy9SRX6jXQzvmMJ-0-widget", "block_id": 113765453, "block_timestamp": "2024-02-28T17:47:18.837Z", "signer_id": "potlock.near", "widget_name": "utils", "source_code": "const IPFS_BASE_URL = \"https://ipfs.near.social/ipfs/\";\nconst nearToUsd = useCache(\n  () =>\n    asyncFetch(\"https://api.coingecko.com/api/v3/simple/price?ids=near&vs_currencies=usd\").then(\n      (res) => {\n        if (res.ok) {\n          return res.body.near.usd;\n        }\n      }\n    ),\n  \"nearToUsd\"\n);\n\nconst formatWithCommas = (amount) => {\n  // Convert to a number and use toLocaleString to add commas\n  return Number(amount).toLocaleString(undefined, {\n    minimumFractionDigits: 2,\n    maximumFractionDigits: 2,\n  });\n};\n\nreturn {\n  formatDate: (timestamp) => {\n    const months = [\n      \"Jan\",\n      \"Feb\",\n      \"Mar\",\n      \"Apr\",\n      \"May\",\n      \"Jun\",\n      \"Jul\",\n      \"Aug\",\n      \"Sep\",\n      \"Oct\",\n      \"Nov\",\n      \"Dec\",\n    ];\n    const date = new Date(timestamp);\n\n    const year = date.getFullYear();\n    const month = months[date.getMonth()];\n    const day = date.getDate();\n    let hour = date.getHours();\n    const minute = date.getMinutes();\n    const ampm = hour >= 12 ? \"pm\" : \"am\";\n\n    // Convert hour to 12-hour format\n    hour = hour % 12;\n    hour = hour ? hour : 12; // the hour '0' should be '12'\n\n    // Minutes should be two digits\n    const minuteFormatted = minute < 10 ? \"0\" + minute : minute;\n\n    return `${month} ${day}, ${year} ${hour}:${minuteFormatted}${ampm}`;\n  },\n  daysAgo: (timestamp) => {\n    const now = new Date();\n    const pastDate = new Date(timestamp);\n    const differenceInTime = now - pastDate;\n\n    // Convert time difference from milliseconds to days\n    const differenceInDays = Math.floor(differenceInTime / (1000 * 3600 * 24));\n    return differenceInDays === 0\n      ? \"< 1 day ago\"\n      : `${differenceInDays} ${differenceInDays === 1 ? \"day\" : \"days\"} ago`;\n  },\n  daysUntil: (timestamp) => {\n    const now = new Date();\n    const futureDate = new Date(timestamp);\n    const differenceInTime = futureDate - now;\n\n    // Convert time difference from milliseconds to days\n    const differenceInDays = Math.ceil(differenceInTime / (1000 * 3600 * 24));\n\n    return `${differenceInDays} ${differenceInDays === 1 ? \"day\" : \"days\"}`;\n  },\n  getTagsFromSocialProfileData: (profileData) => {\n    // first try to get tags from plCategories, then category (deprecated/old format), then default to empty array\n    if (!profileData) return [];\n    const DEPRECATED_CATEGORY_MAPPINGS = {\n      \"social-impact\": \"Social Impact\",\n      \"non-profit\": \"NonProfit\",\n      climate: \"Climate\",\n      \"public-good\": \"Public Good\",\n      \"de-sci\": \"DeSci\",\n      \"open-source\": \"Open Source\",\n      community: \"Community\",\n      education: \"Education\",\n    };\n    const tags = profileData.plCategories\n      ? JSON.parse(profileData.plCategories)\n      : profileData.category\n      ? [profileData.category.text ?? DEPRECATED_CATEGORY_MAPPINGS[profileData.category] ?? \"\"]\n      : [];\n    return tags;\n  },\n  getTeamMembersFromSocialProfileData: (profileData) => {\n    if (!profileData) return [];\n    const team = profileData.plTeam\n      ? JSON.parse(profileData.plTeam)\n      : profileData.team\n      ? Object.entries(profileData.team)\n          .filter(([_, v]) => v !== null)\n          .map(([k, _]) => k)\n      : [];\n    return team;\n  },\n  doesUserHaveDaoFunctionCallProposalPermissions: (policy) => {\n    // TODO: break this out (NB: duplicated in Project.CreateForm)\n    const userRoles = policy.roles.filter((role) => {\n      if (role.kind === \"Everyone\") return true;\n      return role.kind.Group && role.kind.Group.includes(context.accountId);\n    });\n    const kind = \"call\";\n    const action = \"AddProposal\";\n    // Check if the user is allowed to perform the action\n    const allowed = userRoles.some(({ permissions }) => {\n      return (\n        permissions.includes(`${kind}:${action}`) ||\n        permissions.includes(`${kind}:*`) ||\n        permissions.includes(`*:${action}`) ||\n        permissions.includes(\"*:*\")\n      );\n    });\n    return allowed;\n  },\n  basisPointsToPercent: (basisPoints) => {\n    return basisPoints / 100;\n  },\n  ipfsUrlFromCid: (cid) => {\n    return `${IPFS_BASE_URL}${cid}`;\n  },\n  validateNearAddress: (address) => {\n    const NEAR_ACCOUNT_ID_REGEX = /^(?=.{2,64}$)(?!.*\\.\\.)(?!.*-$)(?!.*_$)[a-z\\d._-]+$/i;\n    let isValid = NEAR_ACCOUNT_ID_REGEX.test(address);\n    // Additional \".near\" check for IDs less than 64 characters\n    if (address.length < 64 && !address.endsWith(\".near\")) {\n      isValid = false;\n    }\n    return isValid;\n  },\n  validateEVMAddress: (address) => {\n    // Check if the address is defined and the length is correct (42 characters, including '0x')\n    if (!address || address.length !== 42) {\n      return false;\n    }\n    // Check if the address starts with '0x' and contains only valid hexadecimal characters after '0x'\n    const re = /^0x[a-fA-F0-9]{40}$/;\n    return re.test(address);\n  },\n  validateGithubRepoUrl: (url) => {\n    // Regular expression to match the GitHub repository URL pattern\n    // This regex checks for optional \"www.\", a required \"github.com/\", and then captures the username and repo name segments\n    const githubRepoUrlPattern =\n      /^(https?:\\/\\/)?(www\\.)?github\\.com\\/[a-zA-Z0-9-]+\\/[a-zA-Z0-9_.-]+\\/?$/;\n    return githubRepoUrlPattern.test(url);\n  },\n  nearToUsd,\n  yoctosToNear: (amountYoctos, abbreviate) => {\n    return new Big(amountYoctos).div(1e24).toNumber().toFixed(2) + (abbreviate ? \" N\" : \" NEAR\");\n  },\n  yoctosToUsd: (amount) => {\n    return nearToUsd\n      ? \"~$\" + formatWithCommas(new Big(amount).mul(nearToUsd).div(1e24).toFixed(2))\n      : null;\n  },\n  nearToUsdWithFallback: (amountNear, abbreviate) => {\n    return nearToUsd\n      ? \"~$\" + formatWithCommas((amountNear * nearToUsd).toFixed(2))\n      : formatWithCommas(amountNear) + (abbreviate ? \" N\" : \" NEAR\");\n  },\n  yoctosToUsdWithFallback: (amountYoctos, abbreviate) => {\n    return nearToUsd\n      ? \"~$\" + formatWithCommas(new Big(amountYoctos).mul(nearToUsd).div(1e24).toFixed(2))\n      : formatWithCommas(new Big(amountYoctos).div(1e24).toFixed(2)) +\n          (abbreviate ? \" N\" : \" NEAR\");\n  },\n  calculatePayouts: (allPotDonations, totalMatchingPool) => {\n    // first, flatten the list of donations into a list of contributions\n    // const projectContributions = convertDonationsToProjectContributions(allPotDonations);\n    const projectContributions = [];\n    for (const d of allPotDonations) {\n      const amount = new Big(d.total_amount);\n      const val = [d.project_id, d.donor_id, amount];\n      projectContributions.push(val);\n    }\n    // take the flattened list of contributions and aggregate\n    // the amounts contributed by each user to each project.\n    // create a dictionary where each key is a projectId and its value\n    // is another dictionary of userIds and their aggregated contribution amounts.\n    const contributions = {};\n    for (const [proj, user, amount] of projectContributions) {\n      if (!contributions[proj]) {\n        contributions[proj] = {};\n      }\n      contributions[proj][user] = Big(contributions[proj][user] || 0).plus(amount);\n    }\n    console.log(\"contributions: \", contributions);\n    // calculate the total overlapping contribution amounts between pairs of users for each project.\n    // create a nested dictionary where the outer keys are userIds and the inner keys are also userIds,\n    // and the inner values are the total overlap between these two users' contributions.\n    // type PairTotals = { [key: UserId]: { [key: UserId]: YoctoBig } };\n    const pairTotals = {};\n    for (const contribz of Object.values(contributions)) {\n      for (const [k1, v1] of Object.entries(contribz)) {\n        if (!pairTotals[k1]) {\n          pairTotals[k1] = {};\n        }\n        for (const [k2, v2] of Object.entries(contribz)) {\n          if (!pairTotals[k1][k2]) {\n            pairTotals[k1][k2] = Big(0);\n          }\n          pairTotals[k1][k2] = pairTotals[k1][k2].plus(v1.times(v2).sqrt());\n        }\n      }\n    }\n    // Compute the CLR (Contribution Matching) amount for each project\n    // using the aggregated contributions, the total overlaps between user pairs,\n    // a threshold value, and the total pot available for matching.\n    // Then, calculate the matching amount for each project using the quadratic formula\n    // and returns a list of objects containing the projectId, the number of contributions,\n    // the total contributed amount, and the matching amount.\n    const threshold = Big(\"25000000000000000000000000\"); // TODO: play around with adjusting this value\n    const totalPot = Big(totalMatchingPool);\n    let bigtot = Big(0);\n    const totals = [];\n    for (const [proj, contribz] of Object.entries(contributions)) {\n      let tot = Big(0);\n      let _num = 0;\n      let _sum = Big(0);\n      for (const [k1, v1] of Object.entries(contribz)) {\n        _num += 1;\n        _sum = _sum.plus(v1);\n        for (const [k2, v2] of Object.entries(contribz)) {\n          // if (k2 > k1) { // TODO: potentially add this \"if\" statement back in, not sure of its purpose as the values being compared are account IDs. Originally taken from Gitcoin's CLR logic (see link at top of file)\n          const sqrt = v1.times(v2).sqrt();\n          tot = tot.plus(sqrt.div(pairTotals[k1][k2].div(threshold)));\n          // }\n        }\n      }\n      bigtot = bigtot.plus(tot);\n      totals.push({\n        id: proj,\n        number_contributions: _num,\n        contribution_amount_str: _sum.toFixed(0),\n        matching_amount_str: tot.toFixed(0),\n      });\n    }\n    console.log(\"totals: \", totals);\n    // if we reach saturation, we need to normalize\n    if (bigtot.gte(totalPot)) {\n      console.log(\"NORMALIZING\");\n      for (const t of totals) {\n        t.matching_amount_str = Big(t.matching_amount_str).div(bigtot).times(totalPot).toFixed(0);\n      }\n    }\n    const payouts = totals.reduce((acc, t) => {\n      acc[t.id] = {\n        matchingAmount: t.matching_amount_str,\n        donorCount: t.number_contributions,\n      };\n      return acc;\n    }, {});\n    return payouts;\n  },\n};\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/potlock.near/widget/utils", "fact_widget_deployments_id": "91ec881e38b6eaf0f5942cdd32174b5b", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 20}