{"tx_hash": "Giucm5fwtVPL8Mw7ifYjeyh8hn3URRcMr1c4PC7mGGr3", "action_id_social": "Ei5dTBXXiXFksk9fYJav4f5xxsCFwJs35eGZ61SCQ8eA-0-widget", "block_id": 113439476, "block_timestamp": "2024-02-23T19:56:52.745Z", "signer_id": "potlock.near", "widget_name": "Pots.CalculateSetPayoutsButton", "source_code": "// * QF/CLR logic taken from https://github.com/gitcoinco/quadratic-funding/blob/master/quadratic-funding/clr.py *\n\nconst { potId, potDetail } = props;\nconst { ONE_TGAS, ownerId } = VM.require(\"potlock.near/widget/constants\") || {\n  ONE_TGAS: 0,\n  ownerId: \"\",\n};\nconst convertDonationsToProjectContributions = (donations) => {\n  const projectContributionsList = [];\n  for (const d of donations) {\n    const amount = new Big(d.total_amount);\n    const val = [d.project_id, d.donor_id, amount];\n    projectContributionsList.push(val);\n  }\n  return projectContributionsList;\n};\n\nconst handleCalculateAndSetPayouts = () => {\n  // get all public donations (TODO: ADD PAGINATION (ok without until 500+ donations))\n  Near.asyncView(potId, \"get_public_round_donations\", {})\n    .then((donations) => {\n      // first, flatten the list of donations into a list of contributions\n      const projectContributions = convertDonationsToProjectContributions(donations);\n\n      // take the flattened list of contributions and aggregate\n      // the amounts contributed by each user to each project.\n      // create a dictionary where each key is a projectId and its value\n      // is another dictionary of userIds and their aggregated contribution amounts.\n      const contributions = {};\n      for (const [proj, user, amount] of projectContributions) {\n        if (!contributions[proj]) {\n          contributions[proj] = {};\n        }\n        contributions[proj][user] = Big(contributions[proj][user] || 0).plus(amount);\n      }\n\n      // calculate the total overlapping contribution amounts between pairs of users for each project.\n      // create a nested dictionary where the outer keys are userIds and the inner keys are also userIds,\n      // and the inner values are the total overlap between these two users' contributions.\n      // type PairTotals = { [key: UserId]: { [key: UserId]: YoctoBig } };\n      const pairTotals = {};\n      for (const contribz of Object.values(contributions)) {\n        for (const [k1, v1] of Object.entries(contribz)) {\n          if (!pairTotals[k1]) {\n            pairTotals[k1] = {};\n          }\n          for (const [k2, v2] of Object.entries(contribz)) {\n            if (!pairTotals[k1][k2]) {\n              pairTotals[k1][k2] = Big(0);\n            }\n            pairTotals[k1][k2] = pairTotals[k1][k2].plus(v1.times(v2).sqrt());\n          }\n        }\n      }\n\n      // Compute the CLR (Contribution Matching) amount for each project\n      // using the aggregated contributions, the total overlaps between user pairs,\n      // a threshold value, and the total pot available for matching.\n      // Then, calculate the matching amount for each project using the quadratic formula\n      // and returns a list of objects containing the projectId, the number of contributions,\n      // the total contributed amount, and the matching amount.\n      const threshold = Big(\"25000000000000000000000000\"); // TODO: play around with adjusting this value\n      const totalPot = Big(potDetail.matching_pool_balance);\n      let bigtot = Big(0);\n      const totals = [];\n      for (const [proj, contribz] of Object.entries(contributions)) {\n        let tot = Big(0);\n        let _num = 0;\n        let _sum = Big(0);\n\n        for (const [k1, v1] of Object.entries(contribz)) {\n          _num += 1;\n          _sum = _sum.plus(v1);\n          for (const [k2, v2] of Object.entries(contribz)) {\n            // if (k2 > k1) { // TODO: potentially add this \"if\" statement back in, not sure of its purpose as the values being compared are account IDs. Originally taken from Gitcoin's CLR logic (see link at top of file)\n            const sqrt = v1.times(v2).sqrt();\n            tot = tot.plus(sqrt.div(pairTotals[k1][k2].div(threshold)));\n            // }\n          }\n        }\n        bigtot = bigtot.plus(tot);\n        totals.push({\n          id: proj,\n          number_contributions: _num,\n          contribution_amount_str: _sum.toString(),\n          matching_amount_str: tot.toString(),\n        });\n      }\n      console.log(\"totals: \", totals);\n\n      // if we reach saturation, we need to normalize\n      if (bigtot.gte(totalPot)) {\n        console.log(\"NORMALIZING\");\n        for (const t of totals) {\n          t.matching_amount_str = Big(t.matching_amount_str).div(bigtot).times(totalPot).toFixed();\n        }\n      }\n\n      // create payouts to send to Pot\n      const payouts = totals.map((t) => {\n        return {\n          project_id: t.id,\n          amount: t.matching_amount_str,\n        };\n      });\n      console.log(\"payouts: \", payouts);\n\n      // set payouts on Pot\n      const args = {\n        payouts,\n      };\n      const transactions = [\n        {\n          contractName: potId,\n          methodName: \"chef_set_payouts\",\n          deposit: \"0\",\n          args,\n          gas: ONE_TGAS.mul(100),\n        },\n      ];\n      Near.call(transactions);\n      // NB: we won't get here if user used a web wallet, as it will redirect to the wallet\n      // <---- EXTENSION WALLET HANDLING ----> TODO: IMPLEMENT\n      //   // poll for updates\n      //   const pollIntervalMs = 1000;\n      //   // const totalPollTimeMs = 60000; // consider adding in to make sure interval doesn't run indefinitely\n      //   const pollId = setInterval(() => {\n      //     Near.asyncView(potId, \"get_applications\", {}).then((applications) => {\n      //       const application = applications.find(\n      //         (application) => application.project_id === context.accountId\n      //       );\n      //       if (application) {\n      //         clearInterval(pollId);\n      //         State.update({ applicationSuccess: true });\n      //       }\n      //     });\n      //   }, pollIntervalMs);\n    })\n    .catch((e) => {\n      console.log(\"error getting donations: \", e);\n      // TODO: handl error in UI\n    });\n};\n\nreturn (\n  <Widget\n    src={`${ownerId}/widget/Components.Button`}\n    props={{\n      type: \"primary\",\n      text: \"Calculate & Set Payouts\",\n      onClick: handleCalculateAndSetPayouts,\n    }}\n  />\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/potlock.near/widget/Pots.CalculateSetPayoutsButton", "fact_widget_deployments_id": "d27b016beb3d42f1b14c150126b2c02e", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 1}