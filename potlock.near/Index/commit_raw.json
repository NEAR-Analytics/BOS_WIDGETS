{"tx_hash": "B4FyUDS4Mc8NxtcoRFkw6f1jjwLWqzXkkd6ivbuWX25o", "action_id_social": "EpkSuYCuvnDDagJrtcZqv8BxT6nQp83x6g4hpvBy8bc3-0-widget", "block_id": 112824504, "block_timestamp": "2024-02-14T16:31:00.498Z", "signer_id": "potlock.near", "widget_name": "Index", "source_code": "const ownerId = \"potlock.near\";\nconst registryContractId =\n  props.env === \"staging\" ? \"registry.staging.potlock.near\" : \"registry.potlock.near\";\nconst donationContractId = \"donate.potlock.near\";\n\nconst CREATE_PROJECT_TAB = \"createproject\";\nconst EDIT_PROJECT_TAB = \"editproject\";\nconst PROJECTS_LIST_TAB = \"projects\";\nconst PROJECT_DETAIL_TAB = \"project\";\nconst CART_TAB = \"cart\";\nconst FEED_TAB = \"feed\";\nconst POTS_TAB = \"pots\";\nconst DEPLOY_POT_TAB = \"deploypot\";\nconst POT_DETAIL_TAB = \"pot\";\nconst DONORS_TAB = \"donors\";\n\nconst Theme = styled.div`\n  position: relative;\n  * {\n    font-family: \"Mona-Sans\";\n    font-style: normal;\n    font-weight: 400;\n  }\n  @font-face {\n    font-family: mona-sans;\n    font-style: normal;\n    font-weight: 400;\n    src: local(\"Mona-Sans\"),\n      url(https://fonts.cdnfonts.com/s/91271/Mona-Sans-Regular.woff) format(\"woff\");\n  }\n  @font-face {\n    font-family: mona-sans;\n    font-style: normal;\n    font-weight: 500;\n    src: local(\"Mona-Sans\"),\n      url(https://fonts.cdnfonts.com/s/91271/Mona-Sans-Medium.woff) format(\"woff\");\n  }\n  @font-face {\n    font-family: mona-sans;\n    font-style: normal;\n    font-weight: 600;\n    src: local(\"Mona-Sans\"),\n      url(https://fonts.cdnfonts.com/s/91271/Mona-Sans-SemiBold.woff) format(\"woff\");\n  }\n  @font-face {\n    font-family: mona-sans;\n    font-style: normal;\n    font-weight: 700;\n    src: local(\"Mona-Sans\"),\n      url(https://fonts.cdnfonts.com/s/91271/Mona-Sans-Bold.woff) format(\"woff\");\n  }\n`;\n\nconst NEAR_ACCOUNT_ID_REGEX = /^(?=.{2,64}$)(?!.*\\.\\.)(?!.*-$)(?!.*_$)[a-z\\d._-]+$/i;\n\nState.init({\n  registeredProjects: null,\n  cart: null,\n  checkoutSuccess: false,\n  checkoutSuccessTxHash: null,\n  donations: null,\n  // previousCart: null,\n  nearToUsd: null,\n  isCartModalOpen: false,\n  isNavMenuOpen: false,\n  registryConfig: null,\n  userIsRegistryAdmin: null,\n  registeredProjects: null,\n  donnorProjectId: null,\n  amount: null,\n  note: null,\n  referrerId: null,\n  currency: null,\n  // isSybilModalOpen: false,\n});\n\nconst NEAR_USD_CACHE_KEY = \"NEAR_USD\";\nconst nearUsdCache = Storage.get(NEAR_USD_CACHE_KEY);\nconst EXCHANGE_RATE_VALIDITY_MS = 1000 * 60 * 60; // 1 hour\n\nif (!state.nearToUsd) {\n  if (\n    nearUsdCache === undefined ||\n    (nearUsdCache && nearUsdCache.ts < Date.now() - EXCHANGE_RATE_VALIDITY_MS)\n  ) {\n    // undefined means it's not in the cache\n    // this case handles the first time fetching the rate, and also if the rate is expired\n    console.log(\"fetching near to usd rate\");\n    asyncFetch(\"https://api.coingecko.com/api/v3/simple/price?ids=near&vs_currencies=usd\").then(\n      (res) => {\n        if (res.ok) {\n          State.update({ nearToUsd: res.body.near.usd });\n          Storage.set(NEAR_USD_CACHE_KEY, { rate: res.body.near.usd, ts: Date.now() });\n        }\n      }\n    );\n  } else if (nearUsdCache) {\n    // valid cache value\n    console.log(\"using cached near to usd rate\");\n    State.update({ nearToUsd: nearUsdCache.rate });\n  }\n}\n\n// console.log(\"state in Index: \", state);\n\nif (!state.registeredProjects) {\n  State.update({ registeredProjects: Near.view(registryContractId, \"get_projects\", {}) });\n}\n\nif (!state.registeredProjects) return \"\";\n\nif (!state.donations) {\n  State.update({\n    donations: Near.view(donationContractId, \"get_donations\", {}), // TODO: ADD PAGINATION\n  });\n}\n\nconst IPFS_BASE_URL = \"https://nftstorage.link/ipfs/\";\n\nconst getImageUrlFromSocialImage = (image) => {\n  if (image.url) {\n    return image.url;\n  } else if (image.ipfs_cid) {\n    return IPFS_BASE_URL + image.ipfs_cid;\n  }\n};\n\nif (!state.registeredProjects) {\n  Near.asyncView(registryContractId, \"get_projects\", {})\n    .then((projects) => {\n      // get social data for each project\n      Near.asyncView(\"social.near\", \"get\", {\n        keys: projects.map((project) => `${project.id}/profile/**`),\n      }).then((socialData) => {\n        const formattedProjects = projects.map((project) => {\n          const profileData = socialData[project.id]?.profile;\n          let profileImageUrl = DEFAULT_PROFILE_IMAGE_URL;\n          if (profileData.image) {\n            const imageUrl = getImageUrlFromSocialImage(profileData.image);\n            if (imageUrl) profileImageUrl = imageUrl;\n          }\n          // get banner image URL\n          let bannerImageUrl = DEFAULT_BANNER_IMAGE_URL;\n          if (profileData.backgroundImage) {\n            const imageUrl = getImageUrlFromSocialImage(profileData.backgroundImage);\n            if (imageUrl) bannerImageUrl = imageUrl;\n          }\n          const formatted = {\n            id: project.id,\n            name: profileData.name ?? \"\",\n            description: profileData.description ?? \"\",\n            bannerImageUrl,\n            profileImageUrl,\n            status: project.status,\n            tags: [profileData.category.text ?? CATEGORY_MAPPINGS[profileData.category] ?? \"\"],\n          };\n          return formatted;\n        });\n        State.update({\n          registeredProjects: formattedProjects,\n        });\n      });\n    })\n    .catch((e) => {\n      console.log(\"error getting projects: \", e);\n      State.update({ getRegisteredProjectsError: e });\n    });\n}\n\nif (state.registryConfig === null) {\n  const registryConfig = Near.view(registryContractId, \"get_config\", {});\n  if (registryConfig) {\n    State.update({\n      registryConfig,\n      userIsRegistryAdmin: registryConfig.admins.includes(context.accountId),\n    });\n  }\n}\n\nconst tabContentWidget = {\n  [CREATE_PROJECT_TAB]: \"Project.Create\",\n  [EDIT_PROJECT_TAB]: \"Project.Create\",\n  [PROJECTS_LIST_TAB]: \"Project.ListPage\",\n  [PROJECT_DETAIL_TAB]: \"Project.Detail\",\n  [CART_TAB]: \"Cart.Checkout\",\n  [FEED_TAB]: \"Components.Feed\",\n  [POTS_TAB]: \"Pots.Home\",\n  [DEPLOY_POT_TAB]: \"Pots.Deploy\",\n  [POT_DETAIL_TAB]: \"Pots.Detail\",\n  [DONORS_TAB]: \"Components.Donors\",\n};\n\nconst getTabWidget = (tab) => {\n  const defaultTabWidget = tabContentWidget[PROJECTS_LIST_TAB];\n  if (tab in tabContentWidget) {\n    return tabContentWidget[props.tab];\n  }\n  return defaultTabWidget;\n};\n\nconst CART_KEY = \"cart\";\n\n// const PREVIOUS_CART_KEY = \"previousCart\";\nconst storageCart = Storage.get(CART_KEY);\nconst StorageCurrency = Storage.get(\"currency\");\nconst StorageNote = Storage.get(\"note\");\nconst StorageAmount = Storage.get(\"amount\");\nconst StorageProjectId = Storage.get(\"projectId\");\nconst StorageReferrerId = Storage.get(\"referrerId\");\n// const storagePreviousCart = Storage.get(PREVIOUS_CART_KEY);\nconst DEFAULT_CART = {};\n\nconst props = {\n  ...props,\n  ...state,\n  ownerId: \"potlock.near\",\n  referrerId: props.referrerId,\n  setCurrency: (cur) => {\n    const currency = state.currency ?? cur;\n    State.update({ currency: currency });\n    Storage.set(\"currency\", currency);\n  },\n  setNote: (n) => {\n    const note = state.note ?? n;\n    State.update({ note: note });\n    Storage.set(\"note\", note);\n  },\n  setAmount: (value) => {\n    const amount = state.amount ?? value;\n    State.update({ amount: amount });\n    Storage.set(\"amount\", amount);\n  },\n  setProjectId: (id) => {\n    const donnorProjectId = state.donnorProjectId ?? id;\n    State.update({ donnorProjectId: donnorProjectId });\n    Storage.set(\"projectId\", donnorProjectId);\n  },\n  setReferrerId: (ref) => {\n    const referrerId = state.referrerId ?? ref;\n    State.update({ referrerId: referrerId });\n    Storage.set(\"referrerId\", referrerId);\n  },\n  addProjectsToCart: (projects) => {\n    const cart = state.cart ?? {};\n    projects.forEach((item) => {\n      if (!item.ft) item.ft = \"NEAR\"; // default to NEAR\n      cart[item.id] = item; // default to NEAR\n    });\n    State.update({ cart });\n    Storage.set(CART_KEY, JSON.stringify(cart));\n  },\n  removeProjectsFromCart: (projectIds) => {\n    const cart = state.cart ?? {};\n    projectIds.forEach((projectId) => {\n      delete cart[projectId];\n    });\n    State.update({ cart });\n    Storage.set(CART_KEY, JSON.stringify(cart));\n  },\n  updateCartItem: ({ projectId, amount, ft, price, referrerId, potId, potDetail, note }) => {\n    const cart = state.cart ?? {};\n    const updated = {};\n    // if (amount === \"\") updated.amount = \"0\";\n    if (amount || amount === \"\") updated.amount = amount;\n    if (ft) updated.ft = ft;\n    if (price) updated.price = price;\n    if (referrerId) updated.referrerId = referrerId;\n    if (potId) updated.potId = potId;\n    if (potDetail) updated.potDetail = potDetail;\n    if (note) updated.note = note;\n    cart[projectId] = updated;\n    State.update({ cart });\n    Storage.set(CART_KEY, JSON.stringify(cart));\n  },\n  clearCart: () => {\n    State.update({ cart: {} });\n    Storage.set(CART_KEY, JSON.stringify(DEFAULT_CART));\n  },\n  setCheckoutSuccess: (checkoutSuccess) => {\n    State.update({ checkoutSuccess });\n  },\n  setIsCartModalOpen: (isOpen) => {\n    State.update({ isCartModalOpen: isOpen });\n  },\n  setIsNavMenuOpen: (isOpen) => {\n    State.update({ isNavMenuOpen: isOpen });\n  },\n  validateNearAddress: (address) => {\n    let isValid = NEAR_ACCOUNT_ID_REGEX.test(address);\n    // Additional \".near\" check for IDs less than 64 characters\n    if (address.length < 64 && !address.endsWith(\".near\")) {\n      isValid = false;\n    }\n    return isValid;\n  },\n  validateEVMAddress: (address) => {\n    // Check if the address is defined and the length is correct (42 characters, including '0x')\n    if (!address || address.length !== 42) {\n      return false;\n    }\n    // Check if the address starts with '0x' and contains only valid hexadecimal characters after '0x'\n    const re = /^0x[a-fA-F0-9]{40}$/;\n    return re.test(address);\n  },\n  validateGithubRepoUrl: (url) => {\n    // Regular expression to match the GitHub repository URL pattern\n    // This regex checks for optional \"www.\", a required \"github.com/\", and then captures the username and repo name segments\n    const githubRepoUrlPattern =\n      /^(https?:\\/\\/)?(www\\.)?github\\.com\\/[a-zA-Z0-9-]+\\/[a-zA-Z0-9_.-]+\\/?$/;\n    return githubRepoUrlPattern.test(url);\n  },\n  PROJECT_STATUSES: [\"Pending\", \"Approved\", \"Rejected\", \"Graylisted\", \"Blacklisted\"],\n  SUPPORTED_FTS: {\n    // TODO: move this to state to handle selected FT once we support multiple FTs\n    NEAR: {\n      iconUrl: IPFS_BASE_URL + \"bafkreicwkm5y7ojxnnfnmuqcs6ykftq2jvzg6nfeqznzbhctgl4w3n6eja\",\n      toIndivisible: (amount) => new Big(amount).mul(new Big(10).pow(24)),\n      fromIndivisible: (amount, decimals) =>\n        Big(amount)\n          .div(Big(10).pow(24))\n          .toFixed(decimals || 2),\n    },\n    USD: {\n      iconUrl: \"$\",\n      toIndivisible: (amount) => new Big(amount).mul(new Big(10).pow(24)),\n      fromIndivisible: (amount, decimals) =>\n        Big(amount)\n          .div(Big(10).pow(24))\n          .toFixed(decimals || 2),\n    },\n  },\n  DONATION_CONTRACT_ID: donationContractId,\n  REGISTRY_CONTRACT_ID: registryContractId,\n  POT_FACTORY_CONTRACT_ID:\n    props.env === \"staging\" ? \"potfactory.staging.potlock.near\" : \"v1.potfactory.potlock.near\",\n  NADABOT_CONTRACT_ID: props.env === \"staging\" ? \"v1.staging.nadabot.near\" : \"v1.nadabot.near\",\n  ToDo: styled.div`\n    position: relative;\n\n    &::before {\n      content: \"TODO: \";\n      position: absolute;\n      left: 0;\n      top: 0;\n      transform: translate(-110%, 0);\n      background-color: yellow;\n    }\n  `,\n  ONE_TGAS: Big(1_000_000_000_000),\n  MAX_DONATION_MESSAGE_LENGTH: 100,\n  hrefWithEnv: (href) => {\n    // add env=staging to params\n    if (props.env === \"staging\") {\n      return `${href}${href.includes(\"?\") ? \"&\" : \"?\"}env=staging`;\n    }\n    return href;\n  },\n  nearToUsdWithFallback: (amountNear) => {\n    return state.nearToUsd\n      ? \"~$\" + (amountNear * state.nearToUsd).toFixed(2)\n      : amountNear + \" NEAR\";\n  },\n  yoctosToUsdWithFallback: (amountYoctos) => {\n    return state.nearToUsd\n      ? \"~$\" + new Big(amountYoctos).mul(state.nearToUsd).div(1e24).toNumber().toFixed(2)\n      : new Big(amountYoctos).div(1e24).toNumber().toFixed(2) + \" NEAR\";\n  },\n  yoctosToUsd: (amountYoctos) => {\n    return state.nearToUsd\n      ? \"~$\" + new Big(amountYoctos).mul(state.nearToUsd).div(1e24).toNumber().toFixed(2)\n      : null;\n  },\n  yoctosToNear: (amountYoctos, abbreviate) => {\n    return new Big(amountYoctos).div(1e24).toNumber().toFixed(2) + (abbreviate ? \" N\" : \"NEAR\");\n  },\n  formatDate: (timestamp) => {\n    const months = [\n      \"Jan\",\n      \"Feb\",\n      \"Mar\",\n      \"Apr\",\n      \"May\",\n      \"Jun\",\n      \"Jul\",\n      \"Aug\",\n      \"Sep\",\n      \"Oct\",\n      \"Nov\",\n      \"Dec\",\n    ];\n    const date = new Date(timestamp);\n\n    const year = date.getFullYear();\n    const month = months[date.getMonth()];\n    const day = date.getDate();\n    let hour = date.getHours();\n    const minute = date.getMinutes();\n    const ampm = hour >= 12 ? \"pm\" : \"am\";\n\n    // Convert hour to 12-hour format\n    hour = hour % 12;\n    hour = hour ? hour : 12; // the hour '0' should be '12'\n\n    // Minutes should be two digits\n    const minuteFormatted = minute < 10 ? \"0\" + minute : minute;\n\n    return `${month} ${day}, ${year} ${hour}:${minuteFormatted}${ampm}`;\n  },\n  daysAgo: (timestamp) => {\n    const now = new Date();\n    const pastDate = new Date(timestamp);\n    const differenceInTime = now - pastDate;\n\n    // Convert time difference from milliseconds to days\n    const differenceInDays = Math.floor(differenceInTime / (1000 * 3600 * 24));\n    return differenceInDays === 0\n      ? \"< 1 day ago\"\n      : `${differenceInDays} ${differenceInDays === 1 ? \"day\" : \"days\"} ago`;\n  },\n  daysUntil: (timestamp) => {\n    const now = new Date();\n    const futureDate = new Date(timestamp);\n    const differenceInTime = futureDate - now;\n\n    // Convert time difference from milliseconds to days\n    const differenceInDays = Math.ceil(differenceInTime / (1000 * 3600 * 24));\n\n    return `${differenceInDays} ${differenceInDays === 1 ? \"day\" : \"days\"}`;\n  },\n  NADA_BOT_URL: \"https://app.nada.bot\",\n  // openSybilModal: () => {\n  //   State.update({ isSybilModalOpen: true });\n  // },\n  getTagsFromSocialProfileData: (profileData) => {\n    // first try to get tags from plCategories, then category (deprecated/old format), then default to empty array\n    if (!profileData) return [];\n    const DEPRECATED_CATEGORY_MAPPINGS = {\n      \"social-impact\": \"Social Impact\",\n      \"non-profit\": \"NonProfit\",\n      climate: \"Climate\",\n      \"public-good\": \"Public Good\",\n      \"de-sci\": \"DeSci\",\n      \"open-source\": \"Open Source\",\n      community: \"Community\",\n      education: \"Education\",\n    };\n    const tags = profileData.plCategories\n      ? JSON.parse(profileData.plCategories)\n      : profileData.category\n      ? [profileData.category.text ?? DEPRECATED_CATEGORY_MAPPINGS[profileData.category] ?? \"\"]\n      : [];\n    return tags;\n  },\n  doesUserHaveDaoFunctionCallProposalPermissions: (policy) => {\n    // TODO: break this out (NB: duplicated in Project.CreateForm)\n    const userRoles = policy.roles.filter((role) => {\n      if (role.kind === \"Everyone\") return true;\n      return role.kind.Group && role.kind.Group.includes(context.accountId);\n    });\n    const kind = \"call\";\n    const action = \"AddProposal\";\n    // Check if the user is allowed to perform the action\n    const allowed = userRoles.some(({ permissions }) => {\n      return (\n        permissions.includes(`${kind}:${action}`) ||\n        permissions.includes(`${kind}:*`) ||\n        permissions.includes(`*:${action}`) ||\n        permissions.includes(\"*:*\")\n      );\n    });\n    return allowed;\n  },\n};\n\nif (props.transactionHashes && props.tab === CART_TAB) {\n  // if transaction hashes are in URL but haven't been added to props, override state:\n  props.checkoutSuccessTxHash = props.transactionHashes;\n  props.checkoutSuccess = true;\n}\n\nif (props.transactionHashes && props.tab === DEPLOY_POT_TAB) {\n  // if transaction hashes are in URL but haven't been added to props, override state:\n  props.deploymentSuccessTxHash = props.transactionHashes;\n  props.deploymentSuccess = true;\n}\n\nif (state.cart === null && storageCart !== null) {\n  // cart hasn't been set on state yet, and storageCart has been fetched\n  // if storageCart isn't undefined, set it on state\n  // otherwise, set default cart on state\n  let cart = DEFAULT_CART;\n  if (storageCart) {\n    cart = JSON.parse(storageCart);\n  }\n  State.update({ cart });\n}\n\nif (\n  state.currency === null &&\n  state.donnorProjectId === null &&\n  state.amount === null &&\n  StorageCurrency !== null &&\n  StorageAmount !== null &&\n  StorageProjectId !== null\n) {\n  State.update({ currency: StorageCurrency });\n  State.update({ amount: StorageAmount });\n  State.update({ donnorProjectId: StorageProjectId });\n  State.update({ note: StorageNote });\n  State.update({ referrerId: StorageReferrerId });\n}\n\n// if (state.previousCart === null && storagePreviousCart !== null) {\n//   // previousCart hasn't been set on state yet, and storagePreviousCart has been fetched\n//   // if storagePreviousCart isn't undefined, set it on state\n//   if (storagePreviousCart && Object.keys(JSON.parse(storagePreviousCart)).length > 0) {\n//     console.log(\"updating previous cart\");\n//     State.update({ previousCart: JSON.parse(storagePreviousCart) });\n//   }\n// }\n\n// console.log(\"state in Index: \", state);\n\nif (state.checkoutSuccessTxHash && state.cart && Object.keys(state.cart).length > 0) {\n  // if checkout was successful after wallet redirect, clear cart\n  // store previous cart in local storage to show success message\n  // console.log(\"previous cart: \", state.cart);\n  props.clearCart();\n}\n\nif (props.tab === EDIT_PROJECT_TAB) {\n  props.edit = true;\n}\n\nconst tabContent = <Widget src={`${ownerId}/widget/${getTabWidget(props.tab)}`} props={props} />;\n\nconst Content = styled.div`\n  width: 100%;\n  height: 100%;\n  background: #ffffff;\n  // padding: 3em;\n  border-radius: 0rem 0rem 1.5rem 1.5rem;\n  border-top: 1px solid var(--ui-elements-light, #eceef0);\n  background: var(--base-white, #fff);\n\n  &.form {\n    border: none;\n    background: #fafafa;\n  }\n`;\n\nconst isForm = [CREATE_PROJECT_TAB].includes(props.tab);\n\nif (!state.cart || !state.registeredProjects) {\n  return \"\";\n}\n\nreturn (\n  <Theme>\n    <Widget src={`${ownerId}/widget/Components.Nav`} props={props} />\n    <Content className={isForm ? \"form\" : \"\"}>{tabContent}</Content>\n    {/* <Widget\n      src={`${ownerId}/widget/Pots.ModalSybil`}\n      props={{\n        ...props,\n        isModalOpen: state.isSybilModalOpen,\n        onClose: () => State.update({ isSybilModalOpen: false }),\n      }}\n    /> */}\n  </Theme>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/potlock.near/widget/Index", "fact_widget_deployments_id": "bebd2298e43c0d8169d5f12ec3882e77", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 119}