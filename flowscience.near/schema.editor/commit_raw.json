{"tx_hash": "8uw8ZyHjnv2fc4FckaPWU1skqnMuBGpqtwX7V64K8zjD", "action_id_social": "4KiLhnjCYNUKPcexsKuSvN9qNT7DTUnMk4mLjZxFu4hk-0-widget", "block_id": 112520555, "block_timestamp": "2024-02-10T06:44:18.680Z", "signer_id": "flowscience.near", "widget_name": "schema.editor", "source_code": "const typeSrc = props.typeSrc || \"every.near\";\nconst schemaSrc = props.schemaSrc ?? \"attestations.near\";\nconst blockHeight = props.blockHeight || \"final\";\nconst selectedSchema = props.selectedSchema ?? \"attestations.near/type/isTrue\";\nconst [resolverPath, setResolverPath] = useState(\n  \"flowscience.near/widget/attester.resolver\"\n);\nconst [resolverData, setResolverData] = Social.get(resolverPath.accountIds) || [\n  \"james.near\",\n  \"build.near\",\n];\n\nlet type = {\n  name: \"\",\n  properties: [],\n  widgets: {},\n};\n\nlet schemaType = {\n  UID: \"\",\n  resolver: {\n    resolverPath: state.resolverPath,\n    resolverData: state.resolverData,\n  },\n  revocable: boolean,\n  schema: Social.get(`${schemaSrc}/schema/**`, \"final\"),\n};\n\nconst { generateUID } = VM.require(\"flowscience.near/widget/generateUID\");\n\nState.init({\n  newType: typeSrc,\n  typeName: type.name || \"\",\n  properties: type.properties || [],\n  widgets: type.widgets || {},\n  newPropertyName: \"\",\n  newPropertyType: \"string\",\n  newWidgetKey: \"\",\n  newWidgetSrc: \"\",\n  newTypeSrc: \"\",\n  typeSrc: typeSrc,\n  expanded: false,\n  selectedSchema: selectedSchema,\n  schemaUID: state.selectedSchema.UID,\n});\n\nlet importedTypes = [];\nif (state.typeSrc !== \"\") {\n  const defaultTypes = Social.get(`every.near/type/**`, \"final\");\n  const hyperfilesTypes = Social.get(`hyperfiles.near/type/**`, \"final\");\n  const types = Social.get(`${state.typeSrc}/type/**`, \"final\");\n  if (!types) {\n    return <></>;\n  }\n  importedTypes =\n    Object.keys(types)?.map((it) => `${state.typeSrc}/type/${it}`) || [];\n}\n\nconst availableTypes = JSON.parse(props.availableTypes) || [\n  \"string\",\n  \"boolean\",\n  \"number\",\n  \"date\",\n  \"time\",\n  \"tags\",\n  ...importedTypes,\n];\n\nconst Container = styled.div`\n  margin: 20px 0;\n`;\n\nconst FormContainer = styled.div`\n  border: 1px solid #ccc;\n  padding: 20px;\n`;\n\nconst Row = styled.div`\n  display: flex;\n  gap: 10px;\n`;\n\nconst Input = styled.input`\n  flex: 1;\n  max-width: 200px;\n  margin-bottom: 10px;\n  height: 30px;\n`;\n\nconst Select = styled.select`\n  height: 30px;\n`;\n\nconst Button = styled.button`\n  height: 30px;\n`;\n\nconst Text = styled.p`\n  display: inline-block;\n  margin-right: 10px;\n`;\n\nconst loadType = () => {\n  const parts = state.newType.split(\"/\");\n  type = JSON.parse(Social.get(state.newType, blockHeight) || null);\n  if (type) {\n    type.name = parts[2];\n    State.update({\n      typeName: type.name,\n      properties: type.properties,\n      widgets: type.widgets,\n    });\n  }\n};\n\nif (prop.typeSrc !== \"\" && state.typeName === \"\") {\n  loadType();\n}\n\nconst loadSchema = () => {\n  const parts = state.newSchema.split(\"/\");\n  schema = JSON.parse(Social.get(state.newSchema, blockHeight) || null);\n  if (schema) {\n    schema.name = parts[2];\n    State.update({\n      schemaUID: schema.UID,\n      properties: schema.properties,\n      resolver: schema.resolver,\n      revocable: schema.revocable,\n    });\n  }\n};\n\nif (prop.schemaSrc !== \"\" && state.schemaName === \"\") {\n  loadSchema();\n}\n\nconst handleAddProperty = () => {\n  if (state.newPropertyName.trim() === \"\") return;\n\n  const newProperty = {\n    name: state.newPropertyName,\n    type: state.newPropertyType,\n    required: state.newPropertyRequired,\n    isMulti: state.newPropertyIsMulti,\n  };\n\n  State.update({\n    properties: [...state.properties, newProperty],\n    newPropertyName: \"\",\n    newPropertyType: \"string\",\n    newPropertyIsMulti: false,\n  });\n};\n\nconst handleRemoveProperty = (index) => {\n  const updatedProperties = [...state.properties];\n  updatedProperties.splice(index, 1);\n  State.update({ properties: updatedProperties });\n};\n\nconst handlePropertyChange = (e, index) => {\n  const updatedProperties = [...state.properties];\n  updatedProperties[index].name = e.target.value;\n  State.update({ properties: updatedProperties });\n};\n\nconst handleTypeChange = (e, index) => {\n  const updatedProperties = [...state.properties];\n  updatedProperties[index].type = e.target.value;\n  State.update({ properties: updatedProperties });\n};\n\nconst handleMultiChange = (e, index) => {\n  const updatedProperties = [...state.properties];\n  updatedProperties[index].isMulti = e.target.value;\n  State.update({ properties: updatedProperties });\n};\n\nconst handleTypeNameChange = (e) => {\n  State.update({ typeName: e.target.value.toLowerCase() });\n};\n\nconst handleWidgetKeyChange = (e) => {\n  State.update({ newWidgetKey: e.target.value.toLowerCase() });\n};\n\nconst handleWidgetSrcChange = (e) => {\n  State.update({ newWidgetSrc: e.target.value });\n};\n\nconst handleAddWidget = () => {\n  if (state.newWidgetKey.trim() === \"\" || state.newWidgetSrc.trim() === \"\")\n    return;\n\n  const newWidget = {\n    [state.newWidgetKey]: state.newWidgetSrc,\n  };\n\n  State.update({\n    widgets: { ...state.widgets, ...newWidget },\n    newWidgetKey: \"\",\n    newWidgetSrc: \"\",\n  });\n};\n\nconst handleRemoveWidget = (key) => {\n  const updatedWidgets = { ...state.widgets };\n  delete updatedWidgets[key];\n  State.update({ widgets: updatedWidgets });\n};\n\nconst schemaData = () => {\n  const data = {\n    schemas: {\n      [state.selectedSchema]: JSON.stringify({\n        schemaUID: generateUID(),\n        properties: state.properties,\n        resolverPath: state.resolverPath,\n        resolver: {\n          type: resolverPath,\n          data: resolverData,\n        },\n      }),\n    },\n  };\n  return data;\n};\n\nfunction TypeSelect({ value, onChange }) {\n  return (\n    <Select value={value} onChange={onChange}>\n      {availableTypes.map((it) => (\n        <option value={it} key={it}>\n          {it}\n        </option>\n      ))}\n    </Select>\n  );\n}\n\nfunction MultiSelect({ value, onChange }) {\n  return (\n    <Select value={value} onChange={onChange}>\n      <option value={false}>single</option>\n      <option value={true}>multi</option>\n    </Select>\n  );\n}\n\nconst handleResolverPathChange = (e) => {\n  setResolverPath(e.target.value);\n};\n\nconst handleResolverDataChange = (newData) => {\n  setResolverData(newData);\n};\n\nreturn (\n  <Container>\n    <Row>\n      <Text>\n        <b>Import Schema:</b>\n      </Text>\n      <Input\n        type=\"text\"\n        value={state.newSchema}\n        onChange={(e) => State.update({ newSchema: e.target.value })}\n        placeholder={\"accountId/type/schemaId\"}\n      />\n      <Button onClick={loadSchema}>load</Button>\n    </Row>\n    <Row>\n      <Text>\n        <b>Import Types:</b>\n      </Text>\n      <Input\n        type=\"text\"\n        value={state.newTypeSrc}\n        onChange={(e) => State.update({ newTypeSrc: e.target.value })}\n        placeholder={\"hyperfiles.near\"}\n      />\n      <Button onClick={() => State.update({ typeSrc: state.newTypeSrc })}>\n        apply\n      </Button>\n    </Row>\n    <FormContainer>\n      <Row>\n        <Text>\n          <b>Schema Id:</b>\n        </Text>\n        <Input\n          type=\"text\"\n          placeholder=\"schemaId\"\n          value={state.typeName}\n          onChange={handleTypeNameChange}\n        />\n        <i>*overwrites existing path</i>\n      </Row>\n      <hr></hr>\n      <Text>\n        <h4>Schema Fields</h4>\n        <i>*Add fields below that are relevant to your use case.</i>\n        <br></br>\n        <b>1.</b> [Field Name]: give a meaningful name to the data<br></br>\n        <b>2.</b> [Field Type]: select an appropriate primitive for the data.{\" \"}\n        <a href=\"https://everything.dev/every.near/widget/every.type.create\">\n          <i>[Define new types]</i>\n        </a>\n        <br></br>\n        <b>3.</b> [Single/Multi]: will the data contain multiple objects of the\n        selected type?\n      </Text>\n      {state.properties?.map((property, index) => (\n        <Row key={index}>\n          <Input\n            type=\"text\"\n            value={property.name}\n            onChange={(e) => handlePropertyChange(e, index)}\n          />\n          <TypeSelect\n            value={property.type}\n            onChange={(e) => handleTypeChange(e, index)}\n          />\n          <MultiSelect\n            value={property.isMulti}\n            onChange={(e) => handleMultiChange(e, index)}\n          />\n          <Button onClick={() => handleRemoveProperty(index)}>Remove</Button>\n        </Row>\n      ))}\n      <Row>\n        <Input\n          type=\"text\"\n          placeholder=\"Field Name\"\n          value={state.newPropertyName}\n          onChange={(e) => State.update({ newPropertyName: e.target.value })}\n        />\n        <TypeSelect\n          value={state.newPropertyType}\n          onChange={(e) => State.update({ newPropertyType: e.target.value })}\n        />\n        <MultiSelect\n          value={state.newPropertyIsMulti}\n          onChange={(e) => State.update({ newPropertyIsMulti: e.target.value })}\n        />\n        <Button\n          onClick={handleAddProperty}\n          disabled={state.newPropertyName.trim() === \"\"}\n        >\n          +\n        </Button>\n      </Row>\n      <hr></hr>\n      <Text>\n        <b>Widgets (optional):</b>\n      </Text>\n      {Object.entries(state.widgets)?.map(([key, src]) => (\n        <Row key={key}>\n          <Text>{key}:</Text>\n          <Input type=\"text\" value={src} onChange={() => {}} />\n          <Button onClick={() => handleRemoveWidget(key)}>Remove</Button>\n        </Row>\n      ))}\n      <Row>\n        <Input\n          type=\"text\"\n          placeholder=\"Widget Name\"\n          value={state.newWidgetKey}\n          onChange={handleWidgetKeyChange}\n        />\n        {\":\"}\n        <Input\n          type=\"text\"\n          placeholder=\"accountId/widget/name\"\n          value={state.newWidgetSrc}\n          onChange={handleWidgetSrcChange}\n        />\n        <Button\n          onClick={handleAddWidget}\n          disabled={\n            state.newWidgetKey.trim() === \"\" || state.newWidgetSrc.trim() === \"\"\n          }\n        >\n          +\n        </Button>\n      </Row>\n      <hr></hr>\n      <Row>\n        <Text>\n          <b>Resolver:</b>\n        </Text>\n        <Select value={resolverPath} onChange={handleResolverPathChange}>\n          <option value=\"\">None</option>\n          <option value=\"attester.resolver\">Attester Resolver</option>\n          {/* ... (other resolver options) */}\n        </Select>\n        {resolverPath === \"attester.resolver\" && (\n          <Widget\n            src=\"flowscience.near/widget/attester.resolver\"\n            props={{\n              item: {\n                type: item.resolverPath,\n                value: item.resolverData,\n              },\n              onChange: handleResolverDataChange,\n            }}\n          />\n        )}\n      </Row>\n      <i>\n        *Optional logic that gets executed with every attestation of this type.\n        (Can be used to verify, limit, act upon any attestation)\n      </i>\n      <hr></hr>\n      <Row>\n        <Text>\n          <b>Is Revocable?</b>\n        </Text>\n        <Input\n          type=\"checkbox\"\n          defaultChecked=\"true\"\n          onChange={(e) => State.update({ isRevocable: e.target.checked })}\n        />\n      </Row>\n      <i>*Determine if attestations of this schema can be revocable.</i>\n      <hr></hr>\n      <Row>\n        <CommitButton\n          force\n          data={schemaData()}\n          disabled={state.properties.length === 0}\n          className=\"styless\"\n        >\n          Publish/Update Schema\n        </CommitButton>\n      </Row>\n    </FormContainer>\n  </Container>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/flowscience.near/widget/schema.editor", "fact_widget_deployments_id": "7ccaffe1d24d3a7df8ceac72565e1441", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 9}