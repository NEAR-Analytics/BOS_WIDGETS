{"tx_hash": "D66pp5GDyrHrFkspUuqgD9oxyF8iFvo8pyEpohrrYXM8", "action_id_social": "3ZzhrWNJj6GNMN4i367vy64rjqKVnMaDCH2D6JJuMbQC-0-widget", "block_id": 113344850, "block_timestamp": "2024-02-22T09:15:40.217Z", "signer_id": "flowscience.near", "widget_name": "JSON-Schema.editor", "source_code": "const typeSrc = props.typeSrc || \"every.near\";\r\nconst schemaSrc = context.accountId ?? props.schemaSrc ?? \"attestations.near\";\r\nconst blockHeight = props.blockHeight || \"final\";\r\nconst selectedSchema = props.selectedSchema;\r\nconst [resolverPath, setResolverPath] = useState(\r\n  \"flowscience.near/widget/attester.resolver\"\r\n);\r\nconst [resolverData, setResolverData] = Social.get(resolverPath.accountIds) || [\r\n  \"hyperfiles.near\",\r\n];\r\nconst [revocable, setRevocable] = useState(true);\r\n\r\nlet type = {\r\n  name: \"\",\r\n  properties: [],\r\n  widgets: {},\r\n};\r\n\r\nlet jsonSchema = {\r\n  schema: \"\", // Path\r\n  id: \"\", // UID\r\n  title: \"\", // Name\r\n  description: \"\", // String\r\n  type: \"\", // object or boolean\r\n  properties: {}, // description, type, and modifiers\r\n  required: [], // list of required properties\r\n};\r\n\r\n//define the schema type, not currently being used\r\nlet schemaType = {\r\n  UID: \"\",\r\n  resolver: {\r\n    resolverPath: state.resolverPath,\r\n    resolverData: state.resolverData,\r\n  },\r\n  revocable: revocable,\r\n  schemaData: Social.get(`${schemaSrc}/schema/**`, \"final\"),\r\n};\r\n\r\nconst { generateUID } = VM.require(\"flowscience.near/widget/generateUID\");\r\n\r\nState.init({\r\n  newType: typeSrc,\r\n  typeName: type.name || \"\",\r\n  properties: type.properties || [],\r\n  widgets: type.widgets || {},\r\n  newPropertyName: \"\",\r\n  newPropertyType: \"string\",\r\n  newTypeSrc: \"\",\r\n  typeSrc: typeSrc,\r\n  schemaSrc: schemaSrc,\r\n  expanded: false,\r\n  selectedSchema: selectedSchema,\r\n  schemaData: schema.properties || [],\r\n  revocable: revocable,\r\n  schemaUID: state.selectedSchema.UID,\r\n});\r\n\r\nlet importedTypes = [];\r\nif (state.typeSrc !== \"\") {\r\n  const defaultTypes = Social.get(`every.near/type/**`, \"final\");\r\n  const hyperfilesTypes = Social.get(`hyperfiles.near/type/**`, \"final\");\r\n  const types = Social.get(`${state.typeSrc}/type/**`, \"final\");\r\n  if (!types) {\r\n    return <></>;\r\n  }\r\n  importedTypes =\r\n    Object.keys(types)?.map((it) => `${state.typeSrc}/type/${it}`) || [];\r\n}\r\n\r\nconst availableTypes = JSON.parse(props.availableTypes) || [\r\n  \"string\",\r\n  \"boolean\",\r\n  \"number\",\r\n  \"date\",\r\n  \"time\",\r\n  \"tags\",\r\n  ...importedTypes,\r\n];\r\n\r\nconst Container = styled.div`\r\n  margin: 20px 0;\r\n`;\r\n\r\nconst FormContainer = styled.div`\r\n  border: 1px solid #ccc;\r\n  padding: 20px;\r\n`;\r\n\r\nconst Row = styled.div`\r\n  display: flex;\r\n  gap: 10px;\r\n`;\r\n\r\nconst Input = styled.input`\r\n  flex: 1;\r\n  max-width: 200px;\r\n  margin-bottom: 10px;\r\n  height: 30px;\r\n`;\r\n\r\nconst Select = styled.select`\r\n  height: 30px;\r\n`;\r\n\r\nconst Button = styled.button`\r\n  height: 30px;\r\n`;\r\n\r\nconst Text = styled.p`\r\n  display: inline-block;\r\n  margin-right: 10px;\r\n`;\r\n\r\nconst loadType = () => {\r\n  const parts = state.newType.split(\"/\");\r\n  type = JSON.parse(Social.get(state.newType, blockHeight) || null);\r\n  if (type) {\r\n    type.name = parts[2];\r\n    State.update({\r\n      typeName: type.name,\r\n      properties: type.properties,\r\n      widgets: type.widgets,\r\n    });\r\n  }\r\n};\r\n\r\nif (prop.typeSrc !== \"\" && state.typeName === \"\") {\r\n  loadType();\r\n}\r\n\r\nconst loadSchema = () => {\r\n  State.update({ selectedSchema: newSchema });\r\n  const parts = state.newSchema.split(\"/\");\r\n  schema = JSON.parse(Social.get(state.newSchema, blockHeight) || null);\r\n  if (schema) {\r\n    schema.name = parts[2];\r\n    State.update({\r\n      schemaName: schema.name,\r\n      schemaData: schema.properties,\r\n      widgets: type.widgets,\r\n    });\r\n  }\r\n};\r\n\r\nif (prop.schemaSrc !== \"\" && state.schemaName === \"\") {\r\n  loadSchema();\r\n}\r\n\r\nconst handleAddProperty = () => {\r\n  if (state.newPropertyName.trim() === \"\") return;\r\n\r\n  const newProperty = {\r\n    name: state.newPropertyName,\r\n    type: state.newPropertyType,\r\n    required: state.newPropertyRequired,\r\n    isMulti: state.newPropertyIsMulti,\r\n  };\r\n\r\n  State.update({\r\n    properties: [...state.properties, newProperty],\r\n    newPropertyName: \"\",\r\n    newPropertyType: \"string\",\r\n    newPropertyIsMulti: false,\r\n  });\r\n};\r\n\r\nconst handleRemoveProperty = (index) => {\r\n  const updatedProperties = [...state.properties];\r\n  updatedProperties.splice(index, 1);\r\n  State.update({ properties: updatedProperties });\r\n};\r\n\r\nconst handlePropertyChange = (e, index) => {\r\n  const updatedProperties = [...state.properties];\r\n  updatedProperties[index].name = e.target.value;\r\n  State.update({ properties: updatedProperties });\r\n};\r\n\r\nconst handleTypeChange = (e, index) => {\r\n  const updatedProperties = [...state.properties];\r\n  updatedProperties[index].type = e.target.value;\r\n  State.update({ properties: updatedProperties });\r\n};\r\n\r\nconst handleMultiChange = (e, index) => {\r\n  const updatedProperties = [...state.properties];\r\n  updatedProperties[index].isMulti = e.target.value;\r\n  State.update({ properties: updatedProperties });\r\n};\r\n\r\nconst handleTypeNameChange = (e) => {\r\n  State.update({ typeName: e.target.value.toLowerCase() });\r\n};\r\n\r\nconst handleSchemaNameChange = (e) => {\r\n  State.update({ schemaName: e.target.value });\r\n};\r\n\r\nconst schemaData = () => {\r\n  const data = {\r\n    schema: {\r\n      [state.selectedSchema]: JSON.stringify({\r\n        schemaUID: generateUID(),\r\n        properties: state.properties,\r\n        resolver: {\r\n          type: resolverPath,\r\n          data: resolverData,\r\n        },\r\n        revocable: revocable,\r\n      }),\r\n    },\r\n  };\r\n  return data;\r\n};\r\n\r\nfunction TypeSelect({ value, onChange }) {\r\n  return (\r\n    <Select value={value} onChange={onChange}>\r\n      {availableTypes.map((it) => (\r\n        <option value={it} key={it}>\r\n          {it}\r\n        </option>\r\n      ))}\r\n    </Select>\r\n  );\r\n}\r\n\r\nfunction MultiSelect({ value, onChange }) {\r\n  return (\r\n    <Select value={value} onChange={onChange}>\r\n      <option value={false}>single</option>\r\n      <option value={true}>multi</option>\r\n    </Select>\r\n  );\r\n}\r\n\r\nconst handleResolverPathChange = (e) => {\r\n  setResolverPath(e.target.value);\r\n};\r\n\r\nconst handleResolverDataChange = (newData) => {\r\n  setResolverData(newData);\r\n};\r\n\r\nconst handleRevocableChange = (e) => {\r\n  setRevocable(e.target.checked);\r\n};\r\n\r\nreturn (\r\n  <Container>\r\n    <Row>\r\n      <Text>\r\n        <b>Import Schema:</b>\r\n      </Text>\r\n      <Input\r\n        type=\"text\"\r\n        value={state.newSchema}\r\n        onChange={(e) => State.update({ newSchema: e.target.value })}\r\n        placeholder={\"accountId/schema/schemaId\"}\r\n      />\r\n      <Button onClick={loadSchema}>load</Button>\r\n    </Row>\r\n    <Row>\r\n      <Text>\r\n        <b>Import Types:</b>\r\n      </Text>\r\n      <Input\r\n        type=\"text\"\r\n        value={state.newTypeSrc}\r\n        onChange={(e) => State.update({ newTypeSrc: e.target.value })}\r\n        placeholder={\"hyperfiles.near\"}\r\n      />\r\n      <Button onClick={() => State.update({ typeSrc: state.newTypeSrc })}>\r\n        apply\r\n      </Button>\r\n    </Row>\r\n    <FormContainer>\r\n      <Row>\r\n        <Text>\r\n          <b>Schema Id:</b>\r\n        </Text>\r\n        <Input\r\n          type=\"text\"\r\n          placeholder=\"schemaId\"\r\n          value={state.schemaName}\r\n          onChange={handleSchemaNameChange}\r\n        />\r\n        <i>*overwrites existing path</i>\r\n      </Row>\r\n      <hr></hr>\r\n      <Text>\r\n        <h4>Schema Fields</h4>\r\n        <i>*Add fields below that are relevant to your use case.</i>\r\n        <br></br>\r\n        <b>1.</b> [Field Name]: give a meaningful name to the data<br></br>\r\n        <b>2.</b> [Field Type]: select an appropriate primitive for the data.{\" \"}\r\n        <a href=\"https://everything.dev/every.near/widget/every.type.create\">\r\n          <i>[Define new types]</i>\r\n        </a>\r\n        <br></br>\r\n        <b>3.</b> [Single/Multi]: will the data contain multiple objects of the\r\n        selected type?\r\n      </Text>\r\n      {state.properties?.map((property, index) => (\r\n        <Row key={index}>\r\n          <Input\r\n            type=\"text\"\r\n            value={property.name}\r\n            onChange={(e) => handlePropertyChange(e, index)}\r\n          />\r\n          <TypeSelect\r\n            value={property.type}\r\n            onChange={(e) => handleTypeChange(e, index)}\r\n          />\r\n          <MultiSelect\r\n            value={property.isMulti}\r\n            onChange={(e) => handleMultiChange(e, index)}\r\n          />\r\n          <Button onClick={() => handleRemoveProperty(index)}>Remove</Button>\r\n        </Row>\r\n      ))}\r\n      <Row>\r\n        <Input\r\n          type=\"text\"\r\n          placeholder=\"Field Name\"\r\n          value={state.newPropertyName}\r\n          onChange={(e) => State.update({ newPropertyName: e.target.value })}\r\n        />\r\n        <TypeSelect\r\n          value={state.newPropertyType}\r\n          onChange={(e) => State.update({ newPropertyType: e.target.value })}\r\n        />\r\n        <MultiSelect\r\n          value={state.newPropertyIsMulti}\r\n          onChange={(e) => State.update({ newPropertyIsMulti: e.target.value })}\r\n        />\r\n        <Button\r\n          onClick={handleAddProperty}\r\n          disabled={state.newPropertyName.trim() === \"\"}\r\n        >\r\n          +\r\n        </Button>\r\n      </Row>\r\n      <hr></hr>\r\n      <Row>\r\n        <Text>\r\n          <b>Resolver:</b>\r\n        </Text>\r\n        <Select value={resolverPath} onChange={handleResolverPathChange}>\r\n          <option value=\"\">None</option>\r\n          <option value=\"attester.resolver\">Attester Resolver</option>\r\n          {/* ... (other resolver options) */}\r\n        </Select>\r\n        {resolverPath === \"attester.resolver\" && (\r\n          <Widget\r\n            src=\"flowscience.near/widget/attester.resolver\"\r\n            props={{\r\n              item: {\r\n                type: item.resolverPath,\r\n                value: item.resolverData,\r\n              },\r\n              onChange: handleResolverDataChange,\r\n            }}\r\n          />\r\n        )}\r\n      </Row>\r\n      <i>\r\n        *Optional logic that gets executed with every attestation of this type.\r\n        (Can be used to verify, limit, act upon any attestation)\r\n      </i>\r\n      <hr></hr>\r\n      <Row>\r\n        <Text>\r\n          <b>Is Revocable?</b>\r\n        </Text>\r\n        <Input\r\n          type=\"checkbox\"\r\n          defaultChecked=\"true\"\r\n          checked={revocable}\r\n          onChange={handleRevocableChange}\r\n        />\r\n      </Row>\r\n      <i>*Determine if attestations of this schema can be revocable.</i>\r\n      <hr></hr>\r\n      <Row>\r\n        <CommitButton\r\n          force\r\n          data={schemaData()}\r\n          disabled={state.properties.length === 0}\r\n          className=\"styless\"\r\n        >\r\n          Publish/Update Schema\r\n        </CommitButton>\r\n      </Row>\r\n    </FormContainer>\r\n  </Container>\r\n);\r\n", "metadata": {"fork_of": "flowscience.near/widget/schema.editor@112520555"}, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/flowscience.near/widget/JSON-Schema.editor", "fact_widget_deployments_id": "e37cbd0d860eea9cdd5b535d1f2c0c0c", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 0}