{"tx_hash": "DM9FezeasLXZbwjhoU2v4SZNQ5nytPotxuvNXbGQL2AN", "action_id_social": "3GPkLRh4az1q75KZhFCEnSjeSccYADC8HoegtKqbkiMG-0-widget", "block_id": 112340725, "block_timestamp": "2024-02-07T23:24:22.963Z", "signer_id": "flowscience.near", "widget_name": "attest", "source_code": "const item = props.item;\r\nconst onChange = props.onChange;\r\nconst selectedSchema = props.selectedSchema ?? \"\";\r\nconst recipientId = props.recipientId;\r\nconst expireDate = props.expireDate;\r\nconst expireTime = props.expireTime;\r\nconst revokeDate = props.revokeDate;\r\nconst refUID = props.refUID;\r\nconst payload = props.payload;\r\n\r\nconst Input = styled.input`\r\n  height: 30px;\r\n`;\r\n\r\nconst Select = styled.select`\r\n  height: 30px;\r\n`;\r\n\r\nconst Button = styled.button`\r\n  text-transform: lowercase !important;\r\n  padding: 8px;\r\n`;\r\n\r\nconst Container = styled.div`\r\n  display: flex;\r\n  flex-direction: column;\r\n  gap: 4px;\r\n`;\r\n\r\nconst Row = styled.div`\r\n  display: flex;\r\n  flex-direction: row;\r\n`;\r\n\r\nconst Label = styled.label`\r\n`;\r\n\r\nfunction generateUID() {\r\n  const length = 42; // This will create a 168-bit number (42 hexadecimal characters)\r\n  // randomly change the case of a character\r\n  const randomCase = (char) =>\r\n    Math.random() > 0.5 ? char.toUpperCase() : char.toLowerCase();\r\n  // Generate a random hexadecimal number and convert it to a string\r\n  let uid = \"\";\r\n  for (let i = 0; i < length; i++) {\r\n    const randomChar = Math.floor(Math.random() * 16).toString(16); // Generate a single random hexadecimal character\r\n    uid += randomCase(randomChar); // Append the character in either case to the UID\r\n  }\r\n  return uid;\r\n}\r\n\r\nconst fetchSchema = (schemaId) => {\r\n  // Simulate fetching schema details asynchronously\r\n  return new Promise((resolve, reject) => {\r\n    setTimeout(() => {\r\n      const schemaDetails = {\r\n        /* mock schema details based on schemaId */\r\n      };\r\n      resolve(schemaDetails);\r\n    }, 1000); // Simulate network request delay\r\n  });\r\n};\r\n\r\nState.init({\r\n  ...item.value,\r\n  objectUID: generateUID(),\r\n  selectedSchema: selectedSchema,\r\n  schemaDetails: schemaDetails,\r\n  recipientId: state.recipientId,\r\n  expireDate: state.expireDate,\r\n  expireTime: state.expireTime,\r\n  revokeDate: state.revokeDate,\r\n  revokeTime: state.revokeTime,\r\n  refUID: state.refUID,\r\n  payload: state.payload,\r\n  data: state.data,\r\n  metadata: \"\",\r\n});\r\n\r\nuseEffect(() => {\r\n  if (!state.initialFetchCompleted) {\r\n    // Assuming you introduce a flag like this\r\n    fetchSchema(state.selectedSchema)\r\n      .then((schemaDetails) => {\r\n        State.update({ schemaDetails, initialFetchCompleted: true });\r\n      })\r\n      .catch((error) => {\r\n        console.error(\"Failed to fetch schema details:\", error);\r\n      });\r\n  }\r\n}, [state.selectedSchema]);\r\n\r\nconst data = {\r\n  attestation: {\r\n    [selectedSchema]: JSON.stringify({\r\n      fields: {\r\n        objectUID: state.objectUID,\r\n        attestor: context.accountId,\r\n        recipientId: state.recipientId,\r\n        expireDate: state.expireDate,\r\n        expireTime: state.expireTime,\r\n        revokeDate: state.revokeDate,\r\n        revokeTime: state.revokeTime,\r\n        refUID: state.refUID,\r\n        payload: state.payload,\r\n        schema: state.selectedSchema,\r\n      },\r\n    }),\r\n  },\r\n};\r\n\r\nconst DynamicInput = ({ type, onChange, value, placeholder }) => {\r\n  if (type === \"boolean\") {\r\n    return (\r\n      <Select onChange={onChange} value={value}>\r\n        <option value=\"true\">true</option>\r\n        <option value=\"false\">false</option>\r\n      </Select>\r\n    );\r\n  } else {\r\n    return (\r\n      <Input\r\n        type={type}\r\n        onChange={onChange}\r\n        value={value}\r\n        placeholder={placeholder}\r\n      />\r\n    );\r\n  }\r\n};\r\n\r\n// Primitive checks\r\nif ([\"string\", \"number\", \"date\", \"time\", \"boolean\"].includes(item.type)) {\r\n  return (\r\n    <DynamicInput\r\n      type={item.type === \"string\" ? \"text\" : item.type}\r\n      onChange={onChange}\r\n      value={item.value}\r\n    />\r\n  );\r\n}\r\n\r\n// On-chain Type\r\nconst type = JSON.parse(Social.get(item.type, \"final\") || \"null\");\r\nconst properties = type.properties || [];\r\nconst createWidgetSrc = type.widgets?.create;\r\n\r\nfunction Property({ property, value }) {\r\n  // If property is multiple values\r\n  if (property.isMulti === \"true\") {\r\n    // Build an array (recursively calls this Widget)\r\n    return (\r\n      <Widget\r\n        src=\"efiz.near/widget/every.array.build\"\r\n        props={{\r\n          item: { ...property, value },\r\n          onChange: (val) => handleInputChange(property.name, val),\r\n        }}\r\n      />\r\n    );\r\n  }\r\n  // Else check for primitives\r\n  if ([\"string\", \"number\", \"date\", \"time\", \"boolean\"].includes(property.type)) {\r\n    return (\r\n      <DynamicInput\r\n        type={property.type === \"string\" ? \"text\" : property.type}\r\n        onChange={(e) => handleInputChange(property.name, e.target.value)}\r\n        value={state[property.name] || \"\"}\r\n        placeholder={property.name}\r\n      />\r\n    );\r\n  } else {\r\n    // This requires a specific type of creator\r\n    // (like image upload)\r\n    // TODO: I don't think this does what I want it to yet...\r\n    const propertyType = JSON.parse(\r\n      Social.get(property.type, \"final\") || \"null\"\r\n    );\r\n    const widgetSrc = propertyType?.widgets?.create;\r\n    // it would be great to modify the onChange function\r\n    return (\r\n      <Widget\r\n        src={widgetSrc}\r\n        props={{ onChange: (e) => handleInputChange(property.name, e) }}\r\n      />\r\n    );\r\n  }\r\n}\r\n\r\nconst handleSave = () => {\r\n  // Check if selectedSchema is correctly set in the state before saving\r\n  if (!state.selectedSchema) {\r\n    console.error(\"Selected schema is undefined\");\r\n    return;\r\n  }\r\n\r\n  // Use the selectedSchema from state\r\n  const attestationData = {\r\n    data: JSON.stringify({\r\n      fields: {\r\n        objectUID: state.objectUID,\r\n        attestor: context.accountId,\r\n        recipientId: state.recipientId,\r\n        expireDate: state.expireDate,\r\n        expireTime: state.expireTime,\r\n        revokeDate: state.revokeDate,\r\n        revokeTime: state.revokeTime,\r\n        refUID: state.refUID,\r\n        payload: state.payload,\r\n        schemaState: state.schemaState,\r\n      },\r\n      schema: state.selectedSchema,\r\n    }),\r\n  };\r\n\r\n  // Construct the final data structure to save\r\n  const saveData = {\r\n    attestation: attestationData,\r\n  };\r\n\r\n  Social.set(saveData)\r\n    .then(() => {\r\n      // Handle the success of the operation\r\n      console.log(\"Attestation saved successfully\");\r\n    })\r\n    .catch((error) => {\r\n      // Handle any errors that occur during the save\r\n      console.error(\"Error saving attestation:\", error);\r\n    });\r\n};\r\n\r\n// Update handleTypeChange to handle full schema including nested types\r\nconst handleSchemaChange = (e) => {\r\n  const newSchema = e.target.value;\r\n  State.update({\r\n    selectedSchema: newSchema,\r\n    templateVal: \"\",\r\n    data: {},\r\n    loading: true,\r\n  });\r\n};\r\n\r\nconst renderSchemaSelection = () => {\r\n  return (\r\n    <FormContainer>\r\n      <Label>Schema Owner:</Label>\r\n      <Input\r\n        type=\"text\"\r\n        value={State.schemaSrc}\r\n        onChange={handleSchemaOwnerChange}\r\n      />\r\n      <Label>Schema:</Label>\r\n      <Select value={State.selectedSchema} onChange={handleSchemaChange}>\r\n        {State.schemasList.map((schema) => (\r\n          <option key={schema} value={schema}>\r\n            {schema}\r\n          </option>\r\n        ))}\r\n      </Select>\r\n      {/* Additional form elements here */}\r\n    </FormContainer>\r\n  );\r\n};\r\n\r\n// Dynamically render input fields based on the fetched schema details\r\nconst renderSchemaInputs = () => {\r\n  const { schemaDetails } = State;\r\n  if (!schemaDetails || !schemaDetails.properties) return null;\r\n\r\n  return schemaDetails.properties.map((property) => (\r\n    <div key={property.name}>\r\n      <Label>{property.name}</Label>\r\n      <Input\r\n        type=\"text\" // Adjust the type based on the property type\r\n        value={State.data[property.name] || \"\"}\r\n        onChange={(e) => handleInputChange(property.name, e.target.value)}\r\n      />\r\n    </div>\r\n  ));\r\n};\r\n\r\n// Handle input changes for dynamically rendered fields\r\nconst handleInputChange = (propertyName, value) => {\r\n  const newData = { ...State.data, [propertyName]: value };\r\n  State.update({ data: newData });\r\n};\r\n\r\n// A function to render properties, adjusted to use stored schemas from the state\r\nconst renderProperties = (properties, data, onChange) => {\r\n  if (state.loading) {\r\n    return <div>Loading...</div>; // Show loading indicator while data is being fetched\r\n  }\r\n  if (!properties) {\r\n    return <div>No properties to display</div>; // Add a condition for no properties\r\n  }\r\n  return properties.map((property) => {\r\n    const propertyType = property.type;\r\n    if (\r\n      propertyType.startsWith(\"${typeSrc}.near/type/\") &&\r\n      state.schemas[propertyType]\r\n    ) {\r\n      // Use the stored schema from the state\r\n      const nestedSchema = state.schemas[propertyType];\r\n      if (nestedSchema && nestedSchema.properties) {\r\n        return renderProperties(\r\n          nestedSchema.properties,\r\n          data[property.name],\r\n          onChange\r\n        );\r\n      } else {\r\n        // Handle the case where the nested schema is not available yet\r\n        // This could be a placeholder or a loading indicator\r\n        return <div>Loading...</div>;\r\n      }\r\n    } else {\r\n      // Render a simple input for primitive types\r\n      return (\r\n        <Input\r\n          key={property.name}\r\n          type={property.type === \"string\" ? \"text\" : property.type}\r\n          value={data[property.name] || \"\"}\r\n          placeholder={property.name}\r\n          onChange={(e) => onChange(property.name, e.target.value)}\r\n        />\r\n      );\r\n    }\r\n  });\r\n};\r\n\r\nreturn (\r\n  <Container>\r\n    <Label>\r\n      <b>UID:</b> {state.objectUID}\r\n    </Label>\r\n    <Label>\r\n      <b>Attestor:</b> {context.accountId}\r\n    </Label>\r\n    <Label>\r\n      <b>Recipient: </b>\r\n    </Label>\r\n    <Input\r\n      type=\"text\"\r\n      value={recipientId}\r\n      onChange={(e) => State.update({ recipientId: e.target.value })}\r\n      placeholder=\"recipient.near\"\r\n    />\r\n    <Label>\r\n      <b>Expiration Date: </b>\r\n    </Label>\r\n    <Input\r\n      type=\"date\"\r\n      value={expireDate}\r\n      onChange={(e) => State.update({ expireDate: e.target.value })}\r\n      placeholder=\"\"\r\n    />\r\n    <Label>\r\n      <b>Expiration Time: </b>\r\n    </Label>\r\n    <Input\r\n      type=\"time\"\r\n      value={expireTime}\r\n      onChange={(e) => State.update({ expireTime: e.target.value })}\r\n      placeholder=\"\"\r\n    />\r\n    <Label>\r\n      <b>refUID: </b>\r\n    </Label>\r\n    <Input\r\n      type=\"text\"\r\n      value={refUID}\r\n      onChange={(e) => State.update({ refUID: e.target.value })}\r\n      placeholder=\"attestations.near/thing/0123456789123456\"\r\n    />\r\n    <Label>\r\n      <b>Data: </b>\r\n    </Label>\r\n    <Input\r\n      type=\"text\"\r\n      value={payload}\r\n      onChange={(e) => State.update({ payload: e.target.value })}\r\n      placeholder=\"# This is markdown text.\"\r\n    />\r\n    {createWidgetSrc ? (\r\n      <>\r\n        <Widget src={createWidgetSrc} props={{ onChange }} />\r\n      </>\r\n    ) : (\r\n      <>\r\n        {properties?.map((property) => (\r\n          <div key={property.name}>\r\n            <Label>{property.name}</Label>\r\n            <Row>\r\n              <Property property={property} value={item.value[property.name]} />\r\n            </Row>\r\n          </div>\r\n        ))}\r\n      </>\r\n    )}\r\n    {renderSchemaInputs()}\r\n    <Button onClick={handleSave}>Save</Button>\r\n    <hr></hr>Preview:\r\n    <Widget\r\n      src=\"efiz.near/widget/Every.Raw.View\"\r\n      props={{\r\n        value: data,\r\n      }}\r\n    />\r\n  </Container>\r\n);\r\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/flowscience.near/widget/attest", "fact_widget_deployments_id": "adc6c52b03b5de3e4ba12d252aae5736", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 19}