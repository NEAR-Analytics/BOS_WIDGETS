{"tx_hash": "6P57m6cjT71Vo5w4WJYycZzwFzU7waYnSRnBjzQcPLuL", "action_id_social": "G6BoW9iwSoPSVq26dLi87yQtXfgZBiJWVDfg47rfpqzo-0-widget", "block_id": 113321929, "block_timestamp": "2024-02-22T00:51:50.314Z", "signer_id": "flowscience.near", "widget_name": "NAS.view", "source_code": "const path = props.path; // every piece of data on social contract has a path\nconst blockHeight = props.blockHeight || \"final\"; // and a blockHeight (~version)\nconst options = props.options;\n\n// split the path\nconst parts = path.split(\"/\");\nconst creatorId = parts[0];\n\nlet type;\nlet schema;\nif (parts.length === 1) {\n  if (parts[0].charAt(0) === \"#\") {\n    // hashtag\n    type = \"hashtag\";\n  } else {\n    // every root of a path is an account\n    type = \"account\";\n  }\n} else {\n  // otherwise the \"standard\" is the type (widget, post, type, thing...)\n  // for thing, we'll extract the actual \"Type\" later\n  type = parts[1];\n}\n\nState.init({});\n\nconst Container = styled.div`\n  border: 1px solid #ccc;\n  height: fit-content;\n`;\n\nconst Content = styled.div`\n  padding: 1px;\n  min-height: 300px;\n`;\n\nfunction Thing() {\n  console.log(`Type before switch: ${type}`); // Logs the initial type determined from the path\n  console.log(`Path before switch: ${path}`);\n  // Renders the path according to type\n  switch (type) {\n    case \"thing\": {\n      // get the thing data\n      const thing = JSON.parse(Social.get(path, blockHeight) || \"null\");\n      type = thing.type || null;\n      // get the type data\n      const typeObj = JSON.parse(Social.get(type, blockHeight) || \"null\");\n      if (typeObj === null) {\n        console.log(\n          `edge case: thing ${path} had an invalid type: ${thingType}`\n        );\n      }\n      // determine the widget to render this thing (is there a default view?)\n      const widgetSrc =\n        options?.templateOverride ||\n        thing.template?.src ||\n        typeObj?.widgets?.view;\n      // Template\n      return (\n        <Widget\n          src={widgetSrc}\n          props={{ data: thing.data, path, blockHeight }}\n        />\n      );\n    }\n    case \"post\": {\n      return (\n        <Widget\n          src=\"every.near/widget/every.post.view\"\n          props={{\n            path,\n            blockHeight: a.blockHeight,\n          }}\n        />\n      );\n    }\n    case \"widget\": {\n      return <Widget src={path} props={props} />;\n    }\n    case \"account\": {\n      return <Widget src=\"efiz.near/widget/Tree\" props={{ rootPath: path }} />;\n    }\n    case \"settings\": {\n      // Standardize path to {accountId}/settings/**\n      parts.splice(2);\n      parts.push(\"**\");\n      path = parts.join(\"/\");\n      return (\n        <Widget\n          src=\"efiz.near/widget/Every.Setting\"\n          props={{ path, blockHeight }}\n        />\n      );\n    }\n    case \"type\": {\n      return (\n        <Widget\n          src=\"every.near/widget/every.type.create\"\n          props={{ typeSrc: path }}\n        />\n      );\n    }\n    case \"hashtag\": {\n      return (\n        <Widget\n          src=\"efiz.near/widget/every.hashtag.view\"\n          props={{ hashtag: parts[0].substring(1) }}\n        />\n      );\n    }\n    case \"schema\": {\n      return (\n        <Widget\n          src=\"every.near/widget/every.type.create\"\n          props={{ typeSrc: path }}\n        />\n      );\n    }\n    // Adjusted case for \"attestation\" to handle and render attestation data correctly\n    case \"attestation\": {\n      // Fetch the attestation data directly using the provided path and blockHeight\n      console.log(`Path:`, path); // Ensure to log the actual object\n\n      useEffect(() => {\n        // Assuming Social.get is synchronous for demonstration; adjust if it's actually asynchronous\n        const fetchData = () => {\n          const attestationData = JSON.stringify(Social.getr(path), null, 2);\n          console.log(\"Attestation data:\", attestationData);\n          // Use setState or similar to update your component state with fetched data\n        };\n\n        fetchData();\n      }, [path, blockHeight]); // Rerun when path or blockHeight changes\n\n      // Assuming attestationData directly contains the data structure you're interested in\n      // No need to extract specificAttestation unless the structure necessitates it\n\n      // Here, directly use attestationData to determine how to render\n      // For example, if attestationData contains an image IPFS CID\n      if (attestationData && attestationData.type === \"every.near/type/image\") {\n        const imageUrl = `https://ipfs.io/ipfs/${attestationData.schema.ipfs_cid}`;\n        return (\n          <div>\n            <p>Recipient ID: {attestationData.recipientId}</p>\n            <p>Expire Date: {attestationData.expireDate}</p>\n            <p>Expire Time: {attestationData.expireTime}</p>\n            <img\n              src={imageUrl}\n              alt=\"Attestation Content\"\n              style={{ maxWidth: \"100%\" }}\n            />\n          </div>\n        );\n      } else {\n        // For other types of attestations or if the attestation data structure is different,\n        // adjust the rendering logic accordingly\n        return <p>Unsupported attestation type or invalid data structure.</p>;\n      }\n    }\n\n    // DEFAULT case to handle unsupported types\n    default:\n      console.log(`Unsupported type: ${type}`);\n      return <p>The type: {type} is not yet supported.</p>;\n  }\n}\n\nreturn (\n  <Container id={path}>\n    <Content>\n      <Thing />\n      <pre>{JSON.stringify(Social.getr(path), null, 2)}</pre>\n    </Content>\n  </Container>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/flowscience.near/widget/NAS.view", "fact_widget_deployments_id": "4538ea2dfef597f9d74095ef52c93f55", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 37}