{"tx_hash": "69yHCSHNLujj8HCnYUoxFrV3hJMZog7vrTc38dVyACes", "action_id_social": "7U7EoFGpMvueau9HkG6LKVsKmcBx5Z8XAhjjdxztKvtD-0-widget", "block_id": 106828051, "block_timestamp": "2023-11-29T21:18:55.886Z", "signer_id": "93068afd39801c0c63a2861d84ee5789d40d5b9d5df54666a50ea0e19718a5fe", "widget_name": "Onboarding.Starter-fork", "source_code": null, "metadata": null, "branch": {"draft": {"": "const accountId = \"indonesiaguild.near\";\n\nif (!accountId) {\n  return \"\";\n}\n\n// Retrieve followers\nlet followers = Social.keys(`*/graph/follow/${accountId}`, \"final\", {\n  return_type: \"BlockHeight\",\n  values_only: true,\n});\n\nif (followers === null) {\n  return \"Loading\";\n}\n\nfollowers = Object.entries(followers || {});\nfollowers.sort(\n  (a, b) => b.graph.follow[accountId][1] - a.graph.follow[accountId][1]\n);\n\n// Total followers count\nconst totalFollowersCount = followers.length;\n\n// Retrieve following\nlet following = Social.keys(`${accountId}/graph/follow/*`, \"final\", {\n  return_type: \"BlockHeight\",\n  values_only: true,\n});\n\nif (following === null) {\n  return \"Loading\";\n}\n\nfollowing = Object.entries(following[accountId].graph.follow || {});\nfollowing.sort((a, b) => b[1] - a[1]);\n\n// Total following count\nconst totalFollowingCount = following.length;\n\nconst [mutualFollowers, setMutualFollowers] = useState([]);\n\nconst updateMutualFollowers = () => {\n  const filteredFollowers = followers.filter(([followerId]) =>\n    following.some(([followingId]) => followerId === followingId)\n  );\n  // Set the state with the filtered followers, avoiding duplicates\n  setMutualFollowers((prevMutualFollowers) => {\n    const uniqueFollowers = new Set([\n      ...prevMutualFollowers.map(([prevFollowerId]) => prevFollowerId),\n      ...filteredFollowers.map(([followerId]) => followerId),\n    ]);\n    return [...uniqueFollowers].map((followerId) =>\n      filteredFollowers.find(([id]) => id === followerId)\n    );\n  });\n};\n\nuseEffect(() => {\n  updateMutualFollowers();\n}, []);\n\n// Total mutual followers count\nconst totalMutualFollowersCount = mutualFollowers.length;\n\nconst [responses, setResponses] = useState([]);\n\nconst [totalTxCount, setTotalTxCount] = useState(0);\nconst [totalBoughtNFT, setTotalBoughtNFT] = useState(0);\nconst [totalBoughtSold, setTotalBoughtSold] = useState(0);\n\nconst processData = (data) => {\n  const accounts = Object.entries(data);\n\n  const allItems = accounts\n    .map((account) => {\n      const accountId = account[0];\n      return Object.entries(account[1].widget).map((kv) => ({\n        accountId,\n        widgetName: kv[0],\n        blockHeight: kv[1],\n      }));\n    })\n    .flat();\n\n  allItems.sort((a, b) => b.blockHeight - a.blockHeight);\n  return allItems;\n};\n\nconst fetchPromisesAccount = [];\n\nfor (const [mutualAccountId] of mutualFollowers) {\n  const fetchPromise = fetch(\n    `https://magenta-syrniki-be7abd.netlify.app/.netlify/functions/api/users/create?accountid=${mutualAccountId}`,\n    {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      responseType: \"json\",\n    }\n  );\n  fetchPromisesAccount.push(fetchPromise);\n}\n\nPromise.all(fetchPromisesAccount)\n  .then((responses) => {})\n  .then((data) => {\n    // Handle the aggregated data if needed\n  })\n  .catch((error) => {\n    // Handle errors\n  });\n\n// Check if mutualFollowers is an array\nif (Array.isArray(mutualFollowers)) {\n  const fetchPromises = mutualFollowers.map(([mutualAccountId]) =>\n    fetch(\n      `https://magenta-syrniki-be7abd.netlify.app/.netlify/functions/api/users/search?accountid=${mutualAccountId}`,\n      {\n        method: \"GET\",\n        mode: \"no-cors\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        responseType: \"json\",\n      }\n    )\n  );\n\n  // Using Promise.all to wait for all requests to complete\n  Promise.all(fetchPromises)\n    .then((responses) => {\n      //  console.log(\"After fetchPromises: test\", mutualFollowers);\n\n      // Extracting only the first element of each response body and update responses state\n      const firstElements = responses.map((response) => {\n        const element = response.body[0];\n\n        //TOTAL DEVELOPMENT\n        let keys = `${element.accountid ?? \"*\"}/widget/*`;\n\n        if (tag) {\n          const taggedWidgets = Social.keys(\n            `${element.accountid ?? \"*\"}/widget/*/metadata/tags/${tag}`,\n            \"final\"\n          );\n\n          if (taggedWidgets === null) {\n            return Promise.resolve({ status: \"load\" });\n          }\n\n          keys = Object.entries(taggedWidgets)\n            .map((kv) =>\n              Object.keys(kv[1].widget).map((w) => `${kv[0]}/widget/${w}`)\n            )\n            .flat();\n\n          if (!keys.length) {\n            return Promise.resolve({ status: \"no widget found\" });\n          }\n        }\n\n        const data = Social.keys(keys, \"final\", {\n          return_type: \"BlockHeight\",\n        });\n\n        if (data === null) {\n          return Promise.resolve(null);\n        }\n\n        // Process data\n        const processedData = processData(data);\n        const totalWidgetCount = processedData.length;\n\n        // Add totalWidgetCount to the element\n        return {\n          ...element,\n          totalWidgetCount: totalWidgetCount,\n        };\n      });\n\n      const totalTxCount = firstElements.reduce((sum, element) => {\n        if (element && typeof element.txCount !== \"undefined\") {\n          return sum + element.txCount;\n        }\n        return sum;\n      }, 0);\n\n      const totalBoughtNFT = firstElements.reduce((sum, element) => {\n        if (element && typeof element.bought_nft !== \"undefined\") {\n          return sum + element.bought_nft;\n        }\n        return sum;\n      }, 0);\n\n      const totalBoughtSold = firstElements.reduce((sum, element) => {\n        if (element && typeof element.sold_nft !== \"undefined\") {\n          return sum + element.sold_nft;\n        }\n        return sum;\n      }, 0);\n\n      // Update totalBoughtNFT state\n      setTotalBoughtNFT(totalBoughtNFT);\n\n      // Update totalBoughtSold state\n      setTotalBoughtSold(totalBoughtSold);\n\n      // Update totalTxCount state\n      setTotalTxCount(totalTxCount);\n\n      // Update responses state\n      setResponses(firstElements);\n    })\n    .catch((error) => {\n      // console.error(\"Error fetching data:\", error);\n    });\n} else {\n  // console.error(\"mutualFollowers is not an array\");\n}\n\nconst [displayCount, setDisplayCount] = useState(5);\n\nconst displayedFollowers = responses.slice(0, displayCount);\n\nconst handleShowMore = () => {\n  setDisplayCount(displayCount + 5);\n};\n\n// useEffect(() => {\n// //   console.log(\"Updated Responses:\", responses); a\n// }, [responses]);\n\n/////////// WIDGET  COUNT\nconst [totalWidgetCount, setTotalWidgetCount] = useState(0);\n\nif (Array.isArray(mutualFollowers)) {\n  const fetchPromises2 = mutualFollowers.map(([mutualAccountIdWidget]) => {\n    let keys = `${mutualAccountIdWidget ?? \"*\"}/widget/*`;\n\n    if (tag) {\n      const taggedWidgets = Social.keys(\n        `${mutualAccountIdWidget ?? \"*\"}/widget/*/metadata/tags/${tag}`,\n        \"final\"\n      );\n\n      if (taggedWidgets === null) {\n        return Promise.resolve({ status: \"load\" });\n      }\n\n      keys = Object.entries(taggedWidgets)\n        .map((kv) =>\n          Object.keys(kv[1].widget).map((w) => `${kv[0]}/widget/${w}`)\n        )\n        .flat();\n\n      if (!keys.length) {\n        return Promise.resolve({ status: \"no widget found\" });\n      }\n    }\n\n    const data = Social.keys(keys, \"final\", {\n      return_type: \"BlockHeight\",\n    });\n\n    if (data === null) {\n      return Promise.resolve(null);\n    }\n\n    // Process data\n    const processedData = processData(data);\n    const totalWidgetCount = processedData.length;\n    // console.log(`Total Widget Count for ${mutualAccountId}:`, totalWidgetCount);\n\n    return Promise.resolve({ status: \"success\", count: totalWidgetCount });\n  });\n\n  // Using Promise.all to wait for all requests to complete\n  Promise.all(fetchPromises2)\n    .then((results) => {\n      const validWidgetCounts = results\n        .filter((result) => result.status === \"success\")\n        .map((result) => result.count);\n\n      const totalWidgetCount = validWidgetCounts.reduce(\n        (acc, count) => acc + count,\n        0\n      );\n      setTotalWidgetCount(totalWidgetCount);\n      // console.log(\"Total Widget Counts:\", totalWidgetCount);\n    })\n    .catch((error) => {\n      // console.error(\"Error fetching data:\", error);\n    });\n} else {\n  // console.error(\"mutualFollowers is not an array\");\n}\n\n//CSSS\n\nreturn (\n  <>\n    <div className=\"mb-3\">Total Followers: {totalFollowersCount}</div>\n    <div className=\"mb-3\">Total Following: {totalFollowingCount}</div>\n    <div className=\"mb-3\">Total Wallet: {totalMutualFollowersCount}</div>\n    <div className=\"mb-3\">Total Transaction: {totalTxCount}</div>\n    <div className=\"mb-3\">Total Development: {totalWidgetCount}</div>\n    <div className=\"mb-3\">Total Bought NFT: {totalBoughtNFT}</div>\n    <div className=\"mb-3\">Total Sold NFT: {totalBoughtSold}</div>\n\n    {displayedFollowers.map((response, i) => (\n      <div key={i} className=\"d-flex justify-content-between mb-3\">\n        <div className=\"me-4\">{response && response.accountid}</div>\n        <div>\n          {/* Display txCount here */}\n          {response && typeof response.txCount !== \"undefined\" && (\n            <div>Transaction: {response.txCount}</div>\n          )}\n          {response && typeof response.transaction_1_days !== \"undefined\" && (\n            <div>Transaction 1 Days: {response.transaction_1_days}</div>\n          )}\n          {response && typeof response.transaction_7_days !== \"undefined\" && (\n            <div>Transaction 7 Days: {response.transaction_7_days}</div>\n          )}\n          {response && typeof response.transaction_30_days !== \"undefined\" && (\n            <div>Transaction 1 Month: {response.transaction_30_days}</div>\n          )}\n          {response && typeof response.bought_nft !== \"undefined\" && (\n            <div>Bought: {response.bought_nft}</div>\n          )}\n          {response && typeof response.sold_nft !== \"undefined\" && (\n            <div>Sold: {response.sold_nft}</div>\n          )}\n          {response && typeof response.holdings_count_nft !== \"undefined\" && (\n            <div>Total NFT: {response.holdings_count_nft}</div>\n          )}\n          {response && typeof response.totalWidgetCount !== \"undefined\" && (\n            <div>Total Development: {response.totalWidgetCount}</div>\n          )}\n        </div>\n      </div>\n    ))}\n\n    {mutualFollowers.length > displayCount && (\n      <button\n        className=\"list-group-item active\"\n        type=\"button\"\n        onClick={handleShowMore}\n      >\n        Show more ({mutualFollowers.length - displayCount} more)\n      </button>\n    )}\n  </>\n);\n"}}, "widget_modules_used": null, "widget_url": "https://near.social/#/93068afd39801c0c63a2861d84ee5789d40d5b9d5df54666a50ea0e19718a5fe/widget/Onboarding.Starter-fork", "fact_widget_deployments_id": "ff0079ca308ba84307d992b1cc084a0b", "inserted_timestamp": "2023-11-29T23:27:31.800Z", "modified_timestamp": "2023-12-20T00:36:59.366Z", "__row_index": 5}