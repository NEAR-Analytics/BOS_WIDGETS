{"tx_hash": "DwSRnudW7dYwcZUcY6GKs75QaPiQ15JNASYZA42mgkpV", "action_id_social": "7kt8kB81ecPZE4SRAUj97Cjf4W8jnfAEodRUp5X7rSCC-0-widget", "block_id": 95317545, "block_timestamp": "2023-06-29T17:08:41.486Z", "signer_id": "c74edb82759f476010ce8363e6be15fcb3cfebf9be6320d6cdc3588f1a5b4c0e", "widget_name": "StakeUnstakeForm", "source_code": "// @ts-check\n\n/** @typedef {Object} SBalancer @property {string} id @property {number} poolCount @property {string} totalLiquidity */\n/** @typedef {Object} SToken @property {string} name @property {string} symbol @property {string} address @property {number} decimals @property {string} totalBalanceUSD @property {string} totalBalanceNotional @property {string} totalVolumeUSD @property {string} totalVolumeNotional @property {string | null} latestUSDPrice @property {SLatestPrice | null} latestPrice */\n/** @typedef {Object} SLatestPrice @property {string} pricingAsset @property {string} price @property {SPoolId} poolId */\n/** @typedef {Object} SPoolId @property {string} totalWeight */\n/** @typedef {Object} SPool @property {string} id @property {string} address @property {string[]} tokensList @property {string} totalWeight @property {string} totalShares @property {string} holdersCount @property {string} poolType @property {number} poolTypeVersion @property {{ token: SToken }[]} tokens */\n/** @typedef {Object} SBalancerGQLResponse @property {SBalancer[]} balancers @property {SPool[]} pools */\n/** @typedef {Object} TokenWeights @property {string} address @property {string} weight */\n/** @typedef {Object} TransformedPool @property {string} totalValueLocked @property {TokenWeights[]} tokenWeights @property {string} id @property {string} address @property {string[]} tokensList @property {string} totalWeight @property {string} totalShares @property {string} holdersCount @property {string} poolType @property {number} poolTypeVersion @property {SToken[]} tokens */\n/** @typedef {Object} TransformedData @property {SBalancer[]} balancers @property {TransformedPool[]} pools */\n/** @typedef {Object} StatePool @property {string} id @property {boolean} approved @property {boolean} depositing @property {boolean} withdrawing @property {boolean} approving @property {boolean} loading */\n/** @typedef {Object} PoolAndBalance @property {string} poolAddress @property {string | undefined} balance */\n/**\n * Form for a single token in the pool.\n * @typedef {Object} OneForm\n * @property {string} inputAmount - User input amount for the token in the pool.\n * @property {string} symbol - Self-explanatory.\n * @property {boolean} isSelected - Indicates whether the token is selected.\n * @property {string} address - Address of the token.\n */\n\n/**\n * Form for the \"all\" token in the pool.\n * @typedef {Object} AllForm\n * @property {string} totalAmount - Total amount for the \"all\" token in the pool.\n */\n\n/**\n * Forms object for the currency selector. There's one per pool address, and inside we'll have a mini form per token in the \"one\", and a form for the \"all\".\n * @typedef {Object} CurrencySelectorGroup\n * @property {\"all\" | \"one\"} allOrOne - Indicates whether the form is for \"all\" or \"one\" tokens in the pool.\n * @property {AllForm} allForm - Form for the \"all\" token in the pool.\n * @property {Object.<string, OneForm>} oneForms - Forms for each token in the pool.\n * @property {boolean} tokenSelectorIsOpen - Indicates whether the token selector dropdown is open.\n * @property {string[]} tokenAddresses - Array containing all the addresses of the tokens it contains.\n * @property {string | undefined} poolBalance - User's balance of pool tokens.\n */\n/**\n * Forms object for the currency selector. There's one per pool address, and inside we'll have a mini form per token in the \"one\", and a form for the \"all\".\n * @typedef {Object.<string, CurrencySelectorGroup>} CurrencySelectorFormGroupsObject\n */\n/**\n * @typedef {Object} StateAsVar\n * @property {CurrencySelectorFormGroupsObject} forms - Forms object for the currency selector.\n * @property {string | undefined} userAddress - User's address.\n * @property {string | undefined} errorGettingBalance - Error message when trying to get the user's balance, if any.\n */\n\n/**\n * @callback StakeUnstakeCallback\n * @param {string} poolAddress The pool address.\n * @param {string} userAddress The user address.\n * @param {SToken} sToken The SToken object.\n * @param {Object} abi The ABI object.\n * @returns {Promise<boolean>} Promise that resolves with true on success, false on failure.\n */\n\n// /**\n//  * @typedef {Object} Props\n//  * @property {\"stake\"|\"unstake\"} operation\n//  * @property {TransformedPool} pool\n//  * @property {string} erc20ABI\n//  * @property {boolean} test\n//  * @property {string} className\n//  */\n\n// /** @type {Props[\"operation\"]} */\n// props.operation = \"stake\";\n// /** @type {Props[\"pool\"]} */\n// props.pool = {\n//   id: \"0x0000000000\",\n//   address: \"0x0000000000\",\n//   tokensList: [\"0x0000000000\", \"0x0000000000\"],\n//   totalWeight: \"0\",\n//   totalShares: \"0\",\n//   holdersCount: \"0\",\n//   poolType: \"0\",\n//   poolTypeVersion: 0,\n//   tokens: [\n//     {\n//       name: \"Token 1\",\n//       symbol: \"TKN1\",\n//       address: \"0x0000000000\",\n//       decimals: 18,\n//       totalBalanceUSD: \"0\",\n//       totalBalanceNotional: \"0\",\n//       totalVolumeUSD: \"0\",\n//       totalVolumeNotional: \"0\",\n//       latestUSDPrice: \"0\",\n//       latestPrice: null,\n//     },\n//   ],\n//   totalValueLocked: \"0\",\n//   tokenWeights: [{ address: \"0x0000000000\", weight: \"0\" }],\n// };\n// /** @type {Props[\"erc20ABI\"]} */\n// props.erc20ABI = \"asdasd\";\n// /** @type {Props[\"test\"]} */\n// props.test = true;\n// /** @type {Props[\"className\"]} */\n// props.className = \"\";\n\nconst missingProps = [];\n// @ts-ignore\nif (!props.operation) missingProps.push('operation (\"stake\"|\"unstake\")');\n// @ts-ignore\nif (!props.pool) missingProps.push(\"pool (TransformedPool)\");\n// @ts-ignore\nif (!props.erc20ABI) missingProps.push(\"erc20ABI (string)\");\n// @ts-ignore\nif (!props.stake) missingProps.push(\"stake (StakeUnstakeCallback)\");\n// @ts-ignore\nif (!props.unstake) missingProps.push(\"unstake (StakeUnstakeCallback)\");\n\nfunction MissingPropsWarning({ missingProps }) {\n  return (\n    <div className=\"alert alert-danger\">\n      <div className=\"fw-bold\">Missing props:</div>\n      <pre>{missingProps.join(\"\\n\")}</pre>\n    </div>\n  );\n}\nif (missingProps.length) {\n  // @ts-ignore\n  return <MissingPropsWarning missingProps={missingProps} />;\n}\n\n/** @type {\"stake\"|\"unstake\"} */\nconst operation =\n  // @ts-ignore\n  props.operation;\n\n/** @type {TransformedPool} */\nconst pool =\n  // @ts-ignore\n  props.pool;\n\n/** @type {string} */\nconst className =\n  // @ts-ignore\n  props.className;\n\n/** @type {string} */\nconst erc20ABI =\n  // @ts-ignore\n  props.erc20ABI;\n\n/** @type {boolean} */\nconst test =\n  // @ts-ignore\n  props.test;\n\n/** @type {StakeUnstakeCallback} */\nconst unstake =\n  // @ts-ignore\n  props.unstake;\n\n/** @type {StakeUnstakeCallback} */\nconst stake =\n  // @ts-ignore\n  props.stake;\n\nconst userAddress = Ethers.send(\"eth_requestAccounts\", [])[0];\nState.update({ userAddress });\n\n/**\n * @param {string} poolAddress\n * @param {string} userAddress\n * @returns {Promise<string>|string|undefined}\n */\n\nfunction getUserBalance(poolAddress, userAddress) {\n  // break if no signer, user disconnected\n  if (!Ethers.provider()?.getSigner?.()) {\n    State.update({\n      userAddress: undefined,\n      errorGettingBalance: \"No signer, user disconnected\",\n    });\n    console.log(\"No signer, user disconnected, exiting getUserBalance()\");\n    return;\n  }\n  try {\n    const erc20 = new ethers.Contract(\n      poolAddress, // address\n      erc20ABI, // erc20 abi\n      Ethers.provider().getSigner()\n    );\n    if (!userAddress) return;\n    const balance = erc20\n      .balanceOf(userAddress)\n      .then((/** @type {{ toString: () => string; }} */ balance) => {\n        // console.log(typeof balance);\n        const formattedBalance = ethers.utils.formatUnits(balance, 18);\n        // console.log(formattedBalance);\n        // undo big number into a string\n        return formattedBalance;\n      });\n    return balance;\n  } catch (e) {\n    // return dummy balance 666s\n    return `Error in getUserBalance(). params:\n- poolAddress: ${poolAddress}\n- userAddress: ${userAddress}\n- error: ${e}`;\n  }\n}\n\n/********************************\n * END BALANCE FETCHING THINGY\n *******************************/\n\n/**\n * @typedef {Object} State\n * @property {string} inputAmount - The input amount (that user attempts to type in).\n * @property {string } lastValidInput - The last valid input amount.\n * @property {string | undefined} selectedToken - The selected token's address.\n * @property {boolean} tokenSelectorIsOpen - Whether the token selector is open or not.\n * @property {CurrencySelectorGroup} form - Forms object for the currency selector.\n * @property {string | undefined} poolBalance - The nominal balance the user has staked in the pool.\n * @property {Object<string, string>} tokenBalances - The nominal balance the user has available in their wallet per token.\n * @property {string | undefined} userAddress - User's address.\n * @property {string | undefined} errorGettingBalance - Error message when trying to get the user's balance, if any.\n */\nState.init({\n  inputAmount: \"\",\n  lastValidInput: 0,\n  selectedToken: undefined,\n  tokenSelectorIsOpen: false,\n  form: {},\n  poolBalance: undefined,\n  tokenBalances: {},\n  // disconnected: true,\n  userAddress: undefined,\n  errorGettingBalance: undefined,\n});\n\n// for each token in the pool, find its balance and update state.tokenBalances[\"tokenAddress\"] = balance\nconst tokenCount = state.form.tokenAddresses.length;\nlet tokenCountDone = 0;\n\nfor (let i = 0; i < tokenCount; i++) {\n  const tokenAddress = state.form.tokenAddresses[i];\n  const userAddress = state.userAddress;\n  if (!userAddress) continue;\n  const balance = getUserBalance(tokenAddress, userAddress);\n  if (!balance || typeof balance === \"string\") {\n    State.update({\n      errorGettingBalance: balance,\n    });\n    continue;\n  }\n  balance.then((/** @type {string} */ balance) => {\n    State.update({\n      tokenBalances: {\n        ...state.tokenBalances,\n        [tokenAddress]: balance,\n      },\n    });\n    tokenCountDone++;\n    if (tokenCountDone === tokenCount) {\n      State.update({\n        errorGettingBalance: undefined,\n      });\n    }\n  });\n}\n// console.log(state.tokenBalances);\n/**\n * @param {string} inputAmount\n */\nfunction validateInputAmount(inputAmount) {\n  if (inputAmount === \"\") return true;\n  const num = parseFloat(inputAmount);\n  if (isNaN(num)) return false;\n  if (num < 0) return false;\n  if (num > parseFloat(state.poolBalance ?? \"0\")) return false;\n  return true;\n}\n\n/**\n * @param {string} inputAmount\n * @returns {string}\n */\nfunction processInputAmount(inputAmount) {\n  // Check for empty string\n  if (inputAmount === \"\") {\n    State.update({\n      lastValidInput: \"\",\n    });\n    return \"\";\n  }\n\n  // Check for invalid characters and multiple dots\n  if (!/^\\d*\\.?\\d*$/.test(inputAmount)) return state.lastValidInput;\n\n  // Parse float value\n  const num = parseFloat(inputAmount);\n\n  // Check for valid float value\n  if (isNaN(num)) return state.lastValidInput;\n\n  // Check for negative or exceeding pool balance value\n  if (num < 0)\n    //|| num > parseFloat(state.poolBalance ?? \"0\"))\n    return state.lastValidInput;\n\n  // If everything is fine, update the last valid input and return it\n  State.update({\n    lastValidInput: inputAmount,\n  });\n  return inputAmount ?? \"\";\n}\n\nlet updated;\nif (!updated) {\n  State.update({\n    form:\n      /**\n       * Form for the currency selector.\n       * @type {CurrencySelectorGroup}\n       */\n      {\n        allOrOne: \"one\",\n        allForm: {\n          totalAmount: \"\",\n        },\n        oneForms: {\n          ...pool.tokens.reduce(\n            (\n              /** @type {Object<string, OneForm>} */\n              acc,\n              token,\n              i\n            ) => {\n              acc[token.address] = {\n                inputAmount: \"\",\n                symbol: token.symbol,\n                isSelected: i === 0,\n                address: token.address,\n              };\n              return acc;\n            },\n            {}\n          ),\n        },\n        tokenSelectorIsOpen: false,\n        tokenAddresses: pool.tokens.map(\n          (\n            /** @type {SToken} */\n            token\n          ) => token.address\n        ),\n        poolBalance: undefined, //getUserBalance(pool.address, userAddress),\n      },\n  });\n}\nupdated = true;\n\nfunction getUserBalanceOnceAndUpdateState() {\n  const balanceProcessor = getUserBalance(pool.address, userAddress);\n  if (typeof balanceProcessor === \"string\") {\n    console.log(\n      \"Error getting balance using getUserBalanceOnceAndUpdateState():\",\n      balanceProcessor\n    );\n    return;\n  }\n  if (balanceProcessor && balanceProcessor.then) {\n    balanceProcessor.then((newBalance) => {\n      State.update({\n        poolBalance: newBalance,\n      });\n    });\n  } else {\n    console.log(\n      \"Got balance using getUserBalanceOnceAndUpdateState(); it was undefined.\"\n    );\n  }\n}\nlet updatedBalance;\nif (!updatedBalance) {\n  getUserBalanceOnceAndUpdateState();\n}\nupdatedBalance = true;\n\n/**\n * @returns {OneForm | null} - The selected OneForm if found, null otherwise.\n */\nfunction getSelectedOneFormInPool() {\n  for (let key in state.form.oneForms) {\n    if (state.form.oneForms[key].isSelected) {\n      return state.form.oneForms[key];\n    }\n  }\n  return null;\n}\n\nfunction updateForm(\n  /** @type {string} */ poolAddress,\n  /** @type {CurrencySelectorGroup} */ newForm\n) {\n  State.update({\n    form: {\n      ...state.form,\n      [poolAddress]: newForm,\n    },\n  });\n}\n\nfunction handleRadioChange(\n  /** @type {string} */ poolAddress,\n  /** @type {\"all\" | \"one\"} */ newAllOrOne\n) {\n  /** @type {CurrencySelectorGroup} */\n  const changedForm = state.form;\n  if (changedForm.allOrOne === newAllOrOne) {\n    return;\n  }\n  const formToChange = state.form;\n  /** @type {CurrencySelectorGroup} */\n  const newForm = {\n    ...formToChange,\n    allOrOne: newAllOrOne,\n  };\n  updateForm(poolAddress, newForm);\n}\n\nfunction handleTokenSelect(\n  /** @type {string} */ poolAddress,\n  /** @type {string} */ tokenAddress\n) {\n  /** @type {CurrencySelectorGroup} */\n  const formToChange = state.form;\n\n  /** @type {CurrencySelectorGroup} */\n  const newForm = {\n    ...formToChange,\n\n    oneForms: {\n      ...Object.keys(formToChange.oneForms).reduce(\n        (\n          /** @type {Object<string, OneForm>} */\n          acc,\n          /** @type {string} */\n          tokenAddress\n        ) => {\n          acc[tokenAddress] = {\n            ...formToChange.oneForms[tokenAddress],\n            isSelected: false,\n          };\n          return acc;\n        },\n        {}\n      ),\n      [tokenAddress]: {\n        ...formToChange.oneForms[tokenAddress],\n        isSelected: true,\n      },\n    },\n  };\n  updateForm(poolAddress, newForm);\n}\nconst myItemStyles = `\n    border-radius: 3px;\n    margin-bottom: 5px;\n    background: #4A4F51;\n    padding: 8px;\n    cursor: pointer;\n    /* deep shadow */\n    \n    &:hover {\n        /*darken*/\n        background: #3A3F41;\n    }\n`;\nconst MyCheckboxItem = styled(\"DropdownMenu.CheckboxItem\")`\n  ${myItemStyles}\n`;\n\nconst indexedTokens = Object.values(pool.tokens).reduce(\n  (\n    /** @type {Object<string, SToken>} */\n    acc,\n    /** @type {SToken} */\n    token\n  ) => {\n    acc[token.address] = token;\n    return acc;\n  },\n  {}\n);\n\n/**\n * @param {{ poolAddress: string, className: string, operation: \"stake\" | \"unstake\" }} currencySelectorProps\n */\nfunction CurrencySelector({ poolAddress, className, operation }) {\n  /** @type {CurrencySelectorGroup} */\n  const currencySelectorGroup = state.form;\n  const { allOrOne, oneForms, tokenAddresses } = currencySelectorGroup;\n  /** @type {number[]} */\n  const arrayOfSameLengthAsTokenAddresses = [...Array(tokenAddresses.length)];\n\n  return (\n    <div className={className}>\n      <div className=\"d-flex flex-column container py-2 pb-3\">\n        {/* title */}\n        <div\n          className=\"d-flex justify-content-between align-items-center\"\n          style={{\n            marginBottom: \"0.25rem\",\n          }}\n        >\n          <div\n            style={{\n              fontSize: \"20px\",\n              fontWeight: \"bold\",\n            }}\n          >\n            {operation === \"stake\" ? \"Stake\" : \"Unstake\"}\n          </div>\n        </div>\n        {!state.userAddress ? (\n          <h6>No user address available, connect wallet.</h6>\n        ) : (\n          <div className=\"d-flex flex-column\">\n            <div className=\"d-flex align-items-center mb-2\">\n              {undefined && operation === \"unstake\" && (\n                <RadioGroup.Root>\n                  <RadioGroup.RadioGroup\n                    value={allOrOne}\n                    style={{\n                      backgroundColor: \"transparent\",\n                      // make height 40px\n                      height: \"40px\",\n                      width: \"100%\",\n                    }}\n                    onValueChange={(\n                      /** @type {\"all\" | \"one\"} */\n                      newAllOrOne\n                    ) => {\n                      console.log(\"newAllOrOne\", newAllOrOne);\n                      return handleRadioChange(poolAddress, newAllOrOne);\n                    }}\n                  >\n                    <RadioGroup.Item\n                      value=\"all\"\n                      style={{\n                        fontWeight: allOrOne === \"all\" ? \"bold\" : \"normal\",\n                        backgroundColor:\n                          allOrOne === \"all\" ? \"#6e4ac5\" : \"#585858\",\n                        borderTopLeftRadius: \"4px\",\n                        borderBottomLeftRadius: \"4px\",\n                        height: \"40px\",\n                        border: \"0px\",\n                        color: \"white\",\n                        letterSpacing:\n                          allOrOne === \"all\" ? \"0.033em\" : \"0.01em\",\n                        padding: \"4px 16px\",\n                      }}\n                    >\n                      <RadioGroup.Indicator />\n                      <label\n                        className=\"form-check-label\"\n                        style={{\n                          cursor: \"pointer\",\n                        }}\n                        // highlight if selected\n                      >\n                        All\n                      </label>\n                    </RadioGroup.Item>\n                    {/* </RadioGroup.Indicator> */}\n                    <RadioGroup.Item\n                      value=\"one\"\n                      style={{\n                        cursor: \"pointer\",\n                        fontWeight: allOrOne === \"one\" ? \"bold\" : \"normal\",\n                        // Background is 6e4ac5 if selected, otherwise it's 585858\n                        backgroundColor:\n                          allOrOne === \"one\" ? \"#6e4ac5\" : \"#585858\",\n                        // round corners to the right by 4 px\n                        borderTopRightRadius: \"4px\",\n                        borderBottomRightRadius: \"4px\",\n                        height: \"40px\",\n                        border: \"0px\",\n                        color: \"white\",\n                        letterSpacing:\n                          allOrOne === \"one\" ? \"0.033em\" : \"0.01em\",\n                        // horizontal padding is 16px and vertical padding is 4px\n                        padding: \"4px 16px\",\n                      }}\n                    >\n                      <RadioGroup.Indicator>\n                        {/* <>One</> */}\n                      </RadioGroup.Indicator>\n                      <label\n                        className=\"form-check-label\"\n                        style={{\n                          cursor: \"pointer\",\n                        }}\n                      >\n                        One\n                      </label>\n                    </RadioGroup.Item>\n                  </RadioGroup.RadioGroup>\n                  {/* </RadioGroup.Content> */}\n                </RadioGroup.Root>\n              )}\n            </div>\n            {/* here goes the title: \"Input Amount\" */}\n            {(operation === \"stake\" ||\n              (operation === \"unstake\" && allOrOne === \"one\")) && (\n              <>\n                <div className=\"d-flex flex-row my-2\">\n                  <div\n                    style={{\n                      fontSize: \"16px\",\n                      fontWeight: \"bold\",\n                    }}\n                  >\n                    Select a token to{\" \"}\n                    {operation === \"stake\" ? \"stake\" : \"unstake\"}.\n                  </div>\n                </div>\n                {/* Token dropdown for the One form*/}\n                {/* make a div same color as input here, rounded right, straight left, and it'll have the selected token inside */}\n\n                <div\n                  style={{\n                    backgroundColor: \"#585858\",\n                    color: \"white\",\n                    // round right corners\n                    borderRadius: \"4px\",\n                    // horizontal padding is 16px and vertical padding is 4px\n                    padding: \"4px 4px\",\n                    height: \"40px\",\n                    // make it a flexbox\n                    display: \"flex\",\n                    // center the text\n                    alignItems: \"center\",\n                    // justify the text to the right\n                    justifyContent: \"center\",\n                    userSelect: \"none\",\n                  }}\n                >\n                  <DropdownMenu.Root\n                    open={state.tokenSelectorIsOpen}\n                    style={{ position: \"relative\" }}\n                    onOpenChange={(\n                      /** @type {boolean} */\n                      isOpen\n                    ) => {\n                      State.update({ tokenSelectorIsOpen: isOpen });\n                    }}\n                  >\n                    <DropdownMenu.Trigger\n                      style={{\n                        backgroundColor: \"transparent\",\n                        border: \"none\",\n                        fontWeight: \"bold\",\n                        color: \"white\",\n                        letterSpacing: \"0.033em\",\n                        display: \"flex\",\n                      }}\n                    >\n                      {tokenAddresses.length === 0 ? (\n                        <></>\n                      ) : allOrOne === \"one\" || operation === \"stake\" ? (\n                        // if one is selected, show the selected token\n                        <span\n                          style={{\n                            // make it a flexbox\n                            display: \"flex\",\n                            // center the text\n                            alignItems: \"center\",\n                            // justify the text to the right\n                            justifyContent: \"flex-end\",\n                            outline: \"none\",\n                          }}\n                        >\n                          {/* find selected token address and use its symbol, if none are there, put \"Select a token\" */}\n                          {\n                            // use this length to iterate through the array of oneForms without actually using Object.keys(oneForm) which is disallowed\n                            arrayOfSameLengthAsTokenAddresses.reduce(\n                              (acc, _, index) => {\n                                const tokenAddress = tokenAddresses[index];\n                                const oneForm = oneForms[tokenAddress];\n                                if (state.selectedToken === tokenAddress) {\n                                  return oneForm.symbol;\n                                }\n                                return acc;\n                              },\n                              \"Select a token\"\n                            )\n                          }\n                        </span>\n                      ) : (\n                        // if all is selected, show \"All\"\n                        \"All\"\n                      )}\n                      <span className=\"ms-1\">\n                        <i className=\"bi bi-caret-down-fill\"></i>\n                      </span>\n                    </DropdownMenu.Trigger>\n                    <DropdownMenu.Content\n                      sideOffset={5}\n                      style={{\n                        position: \"absolute\",\n                        bottom: \"30px\",\n                        backgroundColor: \"#161616\",\n                        padding: \"5px\",\n                        borderRadius: \"4px\",\n                        paddingBottom: \"0px\",\n                        width: \"max-content\",\n                      }}\n                    >\n                      {arrayOfSameLengthAsTokenAddresses.map((_, index) => {\n                        const tokenAddress = tokenAddresses[index];\n                        const oneForm = oneForms[tokenAddress];\n                        return (\n                          <MyCheckboxItem\n                            key={tokenAddress}\n                            checked={state.selectedToken === tokenAddress}\n                            onCheckedChange={(\n                              /** @type {boolean} */\n                              isSelected\n                            ) => {\n                              if (isSelected) {\n                                State.update({ selectedToken: tokenAddress });\n                              }\n                            }}\n                          >\n                            <DropdownMenu.ItemIndicator\n                              style={{ marginRight: \"5px\" }}\n                            >\n                              <i className=\"bi bi-check-circle-fill\"></i>\n                            </DropdownMenu.ItemIndicator>\n                            {oneForm.symbol}\n                          </MyCheckboxItem>\n                        );\n                      })}\n                    </DropdownMenu.Content>\n                  </DropdownMenu.Root>\n                </div>\n              </>\n            )}\n            {/* here goes the title: \"Input Amount\" */}\n            <div className=\"d-flex flex-row my-2\">\n              <div\n                style={{\n                  fontSize: \"16px\",\n                  fontWeight: \"bold\",\n                }}\n              >\n                Input Amount{\" \"}\n                <span\n                  className=\"text-primary\"\n                  style={{\n                    filter: \"hue-rotate(40deg) saturate(80%) brightness(115%)\",\n                    cursor: \"pointer\",\n                  }}\n                  onClick={() => {\n                    const maxAmount = state.poolBalance;\n                    State.update({ inputAmount: maxAmount });\n                  }}\n                >\n                  {operation === \"unstake\"\n                    ? \"(Max: \" + state.poolBalance\n                    : state.selectedToken\n                    ? \"(Max: \" + state.tokenBalances[state.selectedToken] + \")\"\n                    : undefined}\n                </span>\n              </div>\n            </div>\n            <div className=\"d-flex flex-row mb-2\">\n              <input\n                type=\"text\"\n                className=\"form-control\"\n                style={{\n                  backgroundColor: \"#585858\",\n                  color: \"white\",\n                  border: \"0px\",\n                  padding: \"4px 16px\",\n                  height: \"40px\",\n                }}\n                value={state.inputAmount}\n                onChange={(e) => {\n                  const processed = processInputAmount(e.target.value) || \"\";\n                  State.update({ inputAmount: processed });\n                }}\n              />\n            </div>\n            {operation === \"stake\" &&\n              parseFloat(state.inputAmount) >\n                parseFloat(state.poolBalance ?? \"0\") && (\n                <div className=\"d-flex flex-row mb-2\">\n                  <div\n                    className=\"alert alert-warning mt-1\"\n                    style={{\n                      fontSize: \"14px\",\n                    }}\n                  >\n                    Warning: If you unstake more than your balance, the\n                    transaction will consume gas but will be cancelled.\n                  </div>\n                </div>\n              )}\n            {/* submit buttons */}\n            <div\n              className=\"d-flex justify-content-between align-items-center\"\n              style={{ width: \"100%\" }}\n            >\n              <button\n                className=\"btn btn-primary btn-sm\"\n                style={{\n                  filter: \"hue-rotate(40deg) saturate(80%) brightness(115%)\",\n                  width: \"100%\",\n                  height: \"40px\",\n                }}\n                onClick={() => {\n                  // handle stake or unstake\n                  if (operation === \"stake\") {\n                    if (!state.selectedToken) {\n                      console.log(\"no token selected, cannot stake\");\n                      return;\n                    }\n                    stake(\n                      pool.address,\n                      state.selectedToken,\n                      indexedTokens[state.selectedToken],\n                      state.inputAmount\n                    );\n                  }\n                  if (operation === \"unstake\") {\n                    if (!state.selectedToken) {\n                      console.log(\"no token selected, cannot unstake\");\n                      return;\n                    }\n                    unstake(\n                      pool.address,\n                      state.selectedToken,\n                      indexedTokens[state.selectedToken],\n                      state.inputAmount\n                    );\n                  }\n                }}\n              >\n                {operation === \"stake\" ? \"Stake\" : \"Unstake\"}\n              </button>\n            </div>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n\nfunction logAndReturnBalance() {\n  console.log(\"logged balance while rendering\", state.form.poolBalance);\n  return state.form.poolBalance;\n}\n\nfunction TestComponent() {\n  return (\n    <div className=\"container flex\">\n      <div\n        className=\"bg-dark rounded-2\"\n        style={{\n          width: \"250px\",\n        }}\n      >\n        <CurrencySelector\n          className=\"my-2\"\n          operation=\"stake\"\n          poolAddress={pool.address}\n        />\n      </div>\n      <Web3Connect connectLabel=\"Connect wallet with Web3\" className=\"mb-3\" />\n      <h2>User Balance:</h2>\n      <pre>{JSON.stringify(state.poolBalance, null, 2)}</pre>\n      <h2>state.form Information:</h2>\n      <pre>{JSON.stringify(state.form, null, 2)}</pre>\n      <h2>Pool Information:</h2>\n      <pre>{JSON.stringify(pool, null, 2)}</pre>\n    </div>\n  );\n}\n\nfunction MainReturn() {\n  return test ? (\n    <TestComponent />\n  ) : (\n    <CurrencySelector\n      operation={operation}\n      className={className || \"\"}\n      poolAddress={pool.address}\n    />\n  );\n}\n\n// @ts-ignore\nreturn <MainReturn />;\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/c74edb82759f476010ce8363e6be15fcb3cfebf9be6320d6cdc3588f1a5b4c0e/widget/StakeUnstakeForm", "fact_widget_deployments_id": "6f54c25428abfd92aa48f87060ad9e0b", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 0}