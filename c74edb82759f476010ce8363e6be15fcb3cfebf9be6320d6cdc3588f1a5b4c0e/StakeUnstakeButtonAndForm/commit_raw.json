{"tx_hash": "GiZj7iPrGuHNTH29wRG4u7PPBt3gaR3ww9aJLeuju9C8", "action_id_social": "2wm77x1TtjXF9CqhEbk3cytPHb8RL4Jh6G9rcEAbdY74-0-widget", "block_id": 96394831, "block_timestamp": "2023-07-13T18:28:50.693Z", "signer_id": "c74edb82759f476010ce8363e6be15fcb3cfebf9be6320d6cdc3588f1a5b4c0e", "widget_name": "StakeUnstakeButtonAndForm", "source_code": "const missingProps = [];\nif (\n  !props.operation ||\n  (props.operation !== \"stake\" && props.operation !== \"unstake\")\n)\n  missingProps.push('operation (\"stake\"|\"unstake\")');\nif (!props.pool) missingProps.push(\"pool (TransformedPool)\");\nif (!props.vaultAddress) missingProps.push(\"vaultAddress (string)\");\nif (!props.balancerQueriesAddress)\n  missingProps.push(\"balancerQueriesAddress (string)\");\nif (!props.pool.id)\n  missingProps.push(\"pool has no id, check type (TransformedPool)\");\n\nfunction MissingPropsWarning({ missingProps }) {\n  return (\n    <div className=\"alert alert-danger\">\n      <div className=\"fw-bold\">Missing props:</div>\n      <pre>{missingProps.join(\"\\n\")}</pre>\n    </div>\n  );\n}\nif (missingProps.length) {\n  return <MissingPropsWarning missingProps={missingProps} />;\n}\nconst operation = props.operation;\nconst pool = props.pool;\nconst VAULT_ADDRESS = props.vaultAddress;\nconst BALANCER_QUERIES_ADDRESS = props.balancerQueriesAddress;\n\nconst fetchBody = (url) => fetch(url).body;\nconst vaultAbi = fetchBody(\n  \"https://gist.githubusercontent.com/dredshep/728298ed3649bb12cd2c3638e0e1e2fb/raw/21b0c88dd84ac06cc380472b88004ad43f8a688b/balancerVaultABI.json\"\n);\n\nfunction joinPool(joinArgs) {\n  const vault = new ethers.Contract(\n    VAULT_ADDRESS,\n    vaultAbi,\n    Ethers.provider().getSigner()\n  );\n  console.log(\"vault:\", vault);\n  return vault.joinPool(\n    joinArgs.poolId,\n    joinArgs.sender,\n    joinArgs.recipient,\n    [\n      joinArgs.sortedTokenAddresses,\n      joinArgs.maxAmountsIn,\n      joinArgs.userData,\n      joinArgs.fromInternalBalance,\n    ],\n    { gasLimit: 6000000 }\n  );\n}\n\nfunction exitPool(exitArgs) {\n  const vault = new ethers.Contract(\n    VAULT_ADDRESS,\n    vaultAbi,\n    Ethers.provider().getSigner()\n  );\n  return vault.exitPool(\n    exitArgs.poolId,\n    exitArgs.sender,\n    exitArgs.recipient,\n    [\n      exitArgs.sortedTokenAddresses,\n      exitArgs.minAmountsOut,\n      exitArgs.userData,\n      exitArgs.toInternalBalance,\n    ],\n    { gasLimit: 6000000 }\n  );\n}\n/**\n * @param {{ exitArgs?: ExitPoolArgs, joinArgs?: JoinPoolArgs }} joinExitFunctionArgs */\nfunction joinOrExitPool(joinExitFunctionArgs) {\n  const { exitArgs, joinArgs } = joinExitFunctionArgs;\n  let txPromise;\n  if (exitArgs) {\n    console.log(\"exitArgs:\", exitArgs);\n    txPromise = exitPool(exitArgs);\n  } else if (joinArgs) {\n    console.log(\"joinArgs:\", joinArgs);\n    txPromise = joinPool(joinArgs);\n  } else {\n    throw new Error(\"Must provide either exitArgs or joinArgs\");\n  }\n  txPromise\n    ?.then?.((tx) => {\n      console.log(\"joinOrExitPool() transaction emitted TX.then: tx:\", tx);\n      tx?.wait?.()\n        ?.then?.((receipt) => {\n          console.log(\n            \"joinOrExitPool() transaction mined TX.wait.then: receipt:\",\n            receipt\n          );\n\n          fetchAndUpdateBalance(state, getUserBalance, pool, userAddress, true);\n          initializeTokenBalances(state, getUserBalance, true);\n        })\n        ?.catch?.((e) => {\n          console.log(\n            \"joinOrExitPool() transaction mined TX.wait.catch: e:\",\n            e\n          );\n        });\n    })\n    ?.catch?.((e) => {\n      console.log(\"joinOrExitPool() inner error on TX.catch: e:\", e);\n    });\n}\n\nconst ONEe18 = ethers.BigNumber.from(10).pow(18);\nconst ONE = ethers.BigNumber.from(1);\nconst ZERO = ethers.BigNumber.from(0);\nconst MAX = ethers.BigNumber.from(\n  \"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"\n);\nconst encode = (types, values) =>\n  ethers.utils.defaultAbiCoder.encode(types, values);\nconst exitIsSingle = (tokens, amounts) =>\n  tokens.length === 1 && amounts.length === 1;\nconst singleExitIndex = (amounts) =>\n  amounts.findIndex((amount) => amount.gt(0));\nfunction queryExit(poolId, sender, recipient, rawRequest) {\n  const exitArgs = rawRequest;\n  const request = [\n    exitArgs.sortedTokenAddresses,\n    exitArgs.minAmountsOut,\n    exitArgs.userData,\n    exitArgs.toInternalBalance,\n  ];\n\n  const balancerQueriesContract = new ethers.Contract(\n    BALANCER_QUERIES_ADDRESS,\n    fetchBody(\n      \"https://gist.githubusercontent.com/dredshep/728298ed3649bb12cd2c3638e0e1e2fb/raw/df57d6f23060805d02a533b0239d93d0ae807e97/balancerQueriesABI.json\"\n    ),\n    Ethers.provider().getSigner()\n  );\n  const eth_calledPromise = balancerQueriesContract.provider.call({\n    to: balancerQueriesContract.address,\n    data: balancerQueriesContract.interface.encodeFunctionData(\"queryExit\", [\n      poolId,\n      sender,\n      recipient,\n      request,\n    ]),\n  });\n  const queryResultPromise = eth_calledPromise.then((result) => {\n    const decoded = balancerQueriesContract.interface.decodeFunctionResult(\n      \"queryExit\",\n      result\n    );\n    /**@type {{bptIn: object, amountsOut: object[]}} */\n    const queryResult = {\n      bptIn: decoded[0],\n      amountsOut: decoded[1],\n    };\n    return queryResult;\n  });\n  return queryResultPromise;\n}\n\nfunction queryThenExit(poolId, sender, recipient, rawRequest) {\n  queryExit(poolId, sender, recipient, rawRequest).then((res) => {\n    const stringifiedAmountsOut = res.amountsOut.map((x) =>\n      ethers.utils.formatUnits(x, 18)\n    );\n    const stringifiedBptIn = ethers.utils.formatUnits(res.bptIn, 18);\n    console.log(\"queryThenExit res:\", {\n      bptIn: stringifiedBptIn,\n      amountsOut: stringifiedAmountsOut,\n    });\n    const stringifiedInputAmountsOut = rawRequest.minAmountsOut.map((x) =>\n      ethers.utils.formatUnits(x, 18)\n    );\n    const rawInputBptIn = new ethers.utils.AbiCoder().decode(\n      [\"uint256\", \"uint256\"],\n      ethers.utils.arrayify(rawRequest.userData)\n    )[1];\n    console.log(\"rawInputBptIn:\", rawInputBptIn);\n    const stringifiedInputBptIn = ethers.utils.formatUnits(rawInputBptIn, 18);\n    console.log(\"queryThenExit input:\", {\n      bptIn: stringifiedInputBptIn,\n      amountsOut: stringifiedInputAmountsOut,\n    });\n    return joinOrExitPool({\n      exitArgs: {\n        ...rawRequest,\n        minAmountsOut: res.amountsOut.map((x) => x.mul(99).div(100)),\n        userData: encode([\"uint256\", \"uint256\"], [1, res.bptIn]),\n      },\n    });\n  });\n}\n\nconst userAddress = Ethers.send(\"eth_requestAccounts\", [])[0];\nState.update({ userAddress });\n\nfunction checkAllowanceAmount(poolAddress, userAddress, sToken, abi) {\n  if (!Ethers.provider()?.getSigner?.()) {\n    State.update({\n      userAddress: undefined,\n    });\n    console.log(\"No signer, user disconnected, exiting isApproved()\");\n    return;\n  }\n  try {\n    if (!userAddress || !poolAddress || !sToken || !abi) {\n      console.log(\"isApproved() missing args\");\n      return;\n    }\n    let checkedPoolAddress, checkedUserAddress, checkedTokenAddress;\n    try {\n      checkedPoolAddress = ethers.utils.getAddress(VAULT_ADDRESS);\n      checkedUserAddress = ethers.utils.getAddress(userAddress);\n      checkedTokenAddress = ethers.utils.getAddress(sToken.address);\n    } catch (error) {\n      console.log(\"isApproved() error while checking addresses\", error);\n      console.log(\"poolAddress\", poolAddress);\n      console.log(\"userAddress\", userAddress);\n      console.log(\"sToken.address\", sToken.address);\n      console.log(\"checkedPoolAddress\", checkedPoolAddress);\n      console.log(\"checkedUserAddress\", checkedUserAddress);\n      console.log(\"checkedTokenAddress\", checkedTokenAddress);\n      return;\n    }\n    if (!userAddress) return;\n    const tokenContract = new ethers.Contract(\n      checkedTokenAddress,\n      abi,\n      Ethers.provider()?.getSigner?.()\n    );\n    const allowance = tokenContract\n\n      .allowance(userAddress, VAULT_ADDRESS)\n      .then((/** @type {{ gt: (bignum: any) => boolean; }} */ allowance) => {\n        return parseFloat(ethers.utils.formatUnits(allowance, sToken.decimals));\n      });\n    return allowance;\n  } catch (error) {\n    console.log(\"isApproved() error\", error);\n    return;\n  }\n}\n\nconst indexedTokens = Object.values(pool.tokens).reduce((acc, token) => {\n  acc[token.address] = token;\n  return acc;\n}, {});\n\nconst tokenEntries = Object.entries(indexedTokens);\nconst tokenEntriesLength = tokenEntries.length;\nconst checkedTokens = [];\nconst erc20ABI = fetchBody(\n  \"https://raw.githubusercontent.com/dredshep/dev/main/abi.json\"\n);\nif (tokenEntriesLength > 0 && checkedTokens.length < tokenEntriesLength) {\n  tokenEntries.forEach(([tokenAddress, token]) => {\n    const allowanceAmountPromise = checkAllowanceAmount(\n      pool.address,\n      userAddress,\n      token,\n      erc20ABI\n    );\n    const itsAString = typeof allowanceAmountPromise === \"string\";\n    if (itsAString) {\n      console.log(\"Error getting approval status:\", allowanceAmountPromise);\n    } else if (allowanceAmountPromise) {\n      return allowanceAmountPromise.then(\n        (/** @type {number} */ allowanceAmount) => {\n          State.update({\n            indexedApprovalAmountPerToken: {\n              ...state.indexedApprovalAmountPerToken,\n              [tokenAddress]: allowanceAmount,\n            },\n          });\n        }\n      );\n    }\n  });\n}\n\nfunction approve(poolAddress, userAddress, sToken, amount, erc20ABI) {\n  if (!Ethers.provider()?.getSigner?.()) {\n    State.update({\n      userAddress: undefined,\n    });\n    console.log(\"No signer, user disconnected, exiting approve()\");\n    return;\n  }\n  try {\n    const tokenContract = new ethers.Contract(\n      sToken.address,\n      erc20ABI,\n      Ethers.provider().getSigner()\n    );\n    if (!userAddress) return;\n    const preFilledAmount = ethers.utils.parseUnits(amount, sToken.decimals);\n    const allowance = tokenContract\n      .approve(VAULT_ADDRESS, preFilledAmount, {\n        gasLimit: 6000000,\n      })\n      .then((allowance) => {\n        const allowancePromise = checkAllowanceAmount(\n          poolAddress,\n          userAddress,\n          sToken,\n          erc20ABI\n        );\n        if (\n          typeof allowancePromise !== \"string\" &&\n          allowancePromise &&\n          allowancePromise.then\n        ) {\n          allowancePromise.then((/** @type {number} */ allowanceAmount) => {\n            State.update({\n              indexedApprovalAmountPerToken: {\n                ...state.indexedApprovalAmountPerToken,\n                [sToken.address]: allowanceAmount,\n              },\n            });\n          });\n        }\n        return allowance.toString();\n      });\n    return allowance;\n  } catch (error) {\n    console.log(\"approve() error\", error);\n    return;\n  }\n}\n\nfunction getUserBalance(poolAddress, userAddress) {\n  if (!Ethers.provider()?.getSigner?.()) {\n    State.update({\n      userAddress: undefined,\n      errorGettingBalance: \"No signer, user disconnected\",\n    });\n    console.log(\"No signer, user disconnected, exiting getUserBalance()\");\n    return;\n  }\n  try {\n    const erc20 = new ethers.Contract(\n      poolAddress,\n      erc20ABI,\n      Ethers.provider().getSigner()\n    );\n    if (!userAddress) return;\n    const balance = erc20.balanceOf(userAddress).then((balance) => {\n      const formattedBalance = ethers.utils.formatUnits(balance, 18);\n      return formattedBalance;\n    });\n    return balance;\n  } catch (e) {\n    return `Error in getUserBalance(). params:\n- poolAddress: ${poolAddress}\n- userAddress: ${userAddress}\n- error: ${e}`;\n  }\n}\n\nState.init({\n  inputAmount: \"\",\n  lastValidInput: \"\",\n  selectedToken: undefined,\n  tokenSelectorIsOpen: false,\n  form: {},\n  poolBalance: undefined,\n  tokenBalances: {},\n  customWithdrawableAmounts: undefined,\n  maxWithdrawableAmounts: undefined,\n\n  userAddress: undefined,\n  errorGettingBalance: undefined,\n\n  indexedApprovalAmountPerToken: {},\n});\nlet isTokenBalanceInitialized = false;\n\nasync function initializeTokenBalances(state, getUserBalance, force) {\n  console.log(\"INITIALIZING TOKEN BALANCES\");\n  if (isTokenBalanceInitialized && !force) {\n    return;\n  }\n  isTokenBalanceInitialized = true;\n\n  const tokenCount = state.form.tokenAddresses.length;\n  let tokenCountDone = 0;\n  const balances = [];\n\n  for (let i = 0; i < tokenCount; i++) {\n    const tokenAddress = state.form.tokenAddresses[i];\n    const userAddress = state.userAddress;\n    if (!userAddress) continue;\n    const balance = getUserBalance(tokenAddress, userAddress);\n    if (!balance || typeof balance === \"string\") {\n      State.update({\n        errorGettingBalance: balance,\n      });\n      continue;\n    }\n    balance.then((/** @type {string} */ balance) => {\n      balances.push(balance);\n      if (balances.length === tokenCount) {\n        balances.reduce((acc, balance, i) => {\n          acc[state.form.tokenAddresses[i]] = balance;\n          return acc;\n        }, {});\n        State.update({\n          tokenBalances: balances.reduce((acc, balance, i) => {\n            acc[state.form.tokenAddresses[i]] = balance;\n            return acc;\n          }, {}),\n        });\n      }\n      tokenCountDone++;\n      if (tokenCountDone === tokenCount) {\n        State.update({\n          errorGettingBalance: undefined,\n        });\n      }\n    });\n  }\n}\nconst noBalances =\n  !state.tokenBalances ||\n  typeof state.tokenBalances !== \"object\" ||\n  Object.keys(state.tokenBalances).length === 0;\nif (noBalances) {\n  State.update({\n    tokenBalances: {},\n  });\n  initializeTokenBalances(state, getUserBalance, false);\n}\nif (state.errorGettingBalance) {\n  return <div>Error getting balance: {state.errorGettingBalance}</div>;\n}\n\nfunction validateInputAmount(inputAmount) {\n  if (inputAmount === \"\") return true;\n  const num = parseFloat(inputAmount);\n  if (isNaN(num)) return false;\n  if (num < 0) return false;\n  if (num > parseFloat(state.poolBalance ?? \"0\")) return false;\n  return true;\n}\n\n/**\n * @param {string} inputAmount\n * @returns {string}\n */\nfunction processInputAmount(inputAmount) {\n  if (inputAmount === \"\") {\n    State.update({\n      lastValidInput: \"\",\n    });\n    return \"\";\n  }\n  if (!/^\\d*\\.?\\d*$/.test(inputAmount)) return state.lastValidInput;\n  const num = parseFloat(inputAmount);\n  if (isNaN(num)) return state.lastValidInput;\n  if (num < 0)\n    //|| num > parseFloat(state.poolBalance ?? \"0\"))\n    return state.lastValidInput;\n  State.update({\n    lastValidInput: inputAmount,\n  });\n  return inputAmount ?? \"\";\n}\n\nlet updated;\nif (!updated) {\n  State.update({\n    form:\n      /**\n       * Form for the currency selector.\n       * @type {CurrencySelectorGroup}\n       */\n      {\n        allOrOne: \"one\",\n        allForm: {\n          totalAmount: \"\",\n        },\n        oneForms: {\n          ...pool.tokens.reduce(\n            (\n              /** @type {Object<string, OneForm>} */\n              acc,\n              token,\n              i\n            ) => {\n              acc[token.address] = {\n                inputAmount: \"\",\n                symbol: token.symbol,\n                isSelected: i === 0,\n                address: token.address,\n              };\n              return acc;\n            },\n            {}\n          ),\n        },\n        tokenSelectorIsOpen: false,\n        tokenAddresses: pool.tokens.map(\n          (\n            /** @type {SToken} */\n            token\n          ) => token.address\n        ),\n        poolBalance: undefined, //getUserBalance(pool.address, userAddress),\n      },\n  });\n}\nupdated = true;\n\n/**\n * @returns {OneForm | null} - The selected OneForm if found, null otherwise.\n */\nfunction getSelectedOneFormInPool() {\n  for (let key in state.form.oneForms) {\n    if (state.form.oneForms[key].isSelected) {\n      return state.form.oneForms[key];\n    }\n  }\n  return null;\n}\n\nfunction updateForm(\n  /** @type {string} */ poolAddress,\n  /** @type {CurrencySelectorGroup} */ newForm\n) {\n  State.update({\n    form: {\n      ...state.form,\n      [poolAddress]: newForm,\n    },\n  });\n}\n\nfunction handleRadioChange(\n  /** @type {string} */ poolAddress,\n  /** @type {\"all\" | \"one\"} */ newAllOrOne\n) {\n  /** @type {CurrencySelectorGroup} */\n  const changedForm = state.form;\n  if (changedForm.allOrOne === newAllOrOne) {\n    return;\n  }\n  const formToChange = state.form;\n  /** @type {CurrencySelectorGroup} */\n  const newForm = {\n    ...formToChange,\n    allOrOne: newAllOrOne,\n  };\n  updateForm(poolAddress, newForm);\n}\n\nfunction handleTokenSelect(\n  /** @type {string} */ poolAddress,\n  /** @type {string} */ tokenAddress\n) {\n  /** @type {CurrencySelectorGroup} */\n  const formToChange = state.form;\n\n  /** @type {CurrencySelectorGroup} */\n  const newForm = {\n    ...formToChange,\n\n    oneForms: {\n      ...Object.keys(formToChange.oneForms).reduce(\n        (\n          /** @type {Object<string, OneForm>} */\n          acc,\n          /** @type {string} */\n          tokenAddress\n        ) => {\n          acc[tokenAddress] = {\n            ...formToChange.oneForms[tokenAddress],\n            isSelected: false,\n          };\n          return acc;\n        },\n        {}\n      ),\n      [tokenAddress]: {\n        ...formToChange.oneForms[tokenAddress],\n        isSelected: true,\n      },\n    },\n  };\n  updateForm(poolAddress, newForm);\n}\nconst myItemStyles = `\n    border-radius: 3px;\n    margin-bottom: 5px;\n    background: #4A4F51;\n    padding: 8px;\n    cursor: pointer;\n    /* deep shadow */\n    \n    &:hover {\n        /*darken*/\n        background: #3A3F41;\n    }\n`;\nconst MyCheckboxItem = styled(\"DropdownMenu.CheckboxItem\")`\n  ${myItemStyles}\n`;\n\nfunction StakeUnstakeWidget(innerProps) {\n  const poolBalance = innerProps.poolBalance;\n  const operation = innerProps.operation;\n  return (\n    <Dialog.Root>\n      <Dialog.Trigger\n        className={\n          (operation === \"stake\" ? \"btn-primary\" : \"btn-secondary\") +\n          \" btn btn-lg fw-bold border-0\"\n        }\n        style={{\n          letterSpacing: \"0.033em\",\n\n          filter:\n            operation === \"stake\"\n              ? \"hue-rotate(40deg) saturate(80%) brightness(115%)\"\n              : \"saturate(0%) brightness(100%)\",\n        }}\n      >\n        <div>{operation === \"stake\" ? \"Stake\" : \"Unstake\"}</div>\n      </Dialog.Trigger>\n      <Dialog.Content\n        className=\"rounded-4\"\n        style={{\n          position: \"absolute\",\n          width: \"100%\",\n          height: \"100%\",\n          top: 0,\n          left: 0,\n          display: \"flex\",\n          alignItems: \"center\",\n          justifyContent: \"center\",\n          background: \"rgba(0, 0, 0, 0.5)\",\n          zIndex: 1,\n        }}\n      >\n        <div className=\"card bg-dark text-light rounded-4 shadow border-0 p-3\">\n          <div className=\"card-header\">\n            <h5 className=\"card-title  d-flex align-items-center justify-content-between\">\n              <div>{operation === \"stake\" ? \"Stake\" : \"Unstake\"}</div>\n              <Dialog.Close className=\"btn btn-sm bg-secondary border-0 pt-2 ps-2 pe-2\">\n                {/* <button className=\"btn btn-sm btn-secondary border-0 rounded-circle d-flex justify-content-center\"> */}\n                <div className=\"\">\n                  <i className=\"bi bi-x-lg\"></i>\n                </div>\n                {/* </button> */}\n              </Dialog.Close>\n            </h5>\n          </div>\n          <div className=\"card-body\">\n            <innerProps.FormWidget operation={operation} />\n          </div>\n        </div>\n      </Dialog.Content>\n    </Dialog.Root>\n  );\n}\n\nfunction checkSelectedTokenIsApproved() {\n  const selectedToken = state.selectedToken;\n  const inputAmount = state.inputAmount;\n  const indexedApprovalAmountPerToken = state.indexedApprovalAmountPerToken;\n  const parsedInputAmount = inputAmount ? parseFloat(inputAmount) : undefined;\n  const selectedTokenIsApproved =\n    selectedToken && parsedInputAmount\n      ? parsedInputAmount <= indexedApprovalAmountPerToken[selectedToken]\n      : false;\n  return selectedTokenIsApproved;\n}\n\nasync function fetchAndUpdateBalance(\n  state,\n  getUserBalance,\n  pool,\n  userAddress,\n  force\n) {\n  if (typeof state.poolBalance !== \"undefined\" && !force) {\n    return;\n  }\n\n  const promise = getUserBalance(pool.address, userAddress);\n  if (promise !== undefined && typeof promise !== \"string\") {\n    promise.then((_balance) => {\n      const balance = ethers.utils.parseUnits(_balance, 18);\n      State.update({ poolBalance: ethers.utils.formatUnits(balance, 18) });\n    });\n  }\n}\n\nfetchAndUpdateBalance(state, getUserBalance, pool, userAddress, false);\n\nif (typeof state.poolBalance === \"undefined\") {\n  return <div>Loading...</div>;\n}\n\nfunction updateWithdrawableAmounts(init) {\n  try {\n    if (\n      !state.poolBalance ||\n      !state.form ||\n      !state.userAddress ||\n      !pool ||\n      !pool.tokens?.length\n    ) {\n      console.log(\"updateWithdrawableAmounts: missing state\");\n      return;\n    }\n\n    const bptAmount =\n      state.inputAmount &&\n      state.inputAmount !== \"\" &&\n      state.inputAmount !== \"0\" &&\n      (state.inputAmount.split(\".\")[1]?.length ?? 0) <= 18\n        ? ethers.utils.parseUnits(state.inputAmount, 18)\n        : undefined;\n    if (bptAmount === undefined)\n      State.update({ customWithdrawableAmounts: undefined });\n    const maxBptAmount = ethers.utils.parseUnits(state.poolBalance, 18);\n    [bptAmount, maxBptAmount].forEach((amount, i) => {\n      if (amount && pool.id && userAddress) {\n        queryExit(pool.id, userAddress, userAddress, {\n          minAmountsOut: pool.tokens.map(() => ethers.BigNumber.from(0)),\n          poolId: pool.id,\n          recipient: userAddress,\n          sender: userAddress,\n          sortedTokenAddresses: pool.tokens\n            .map((token) => token.address)\n            .sort(),\n          toInternalBalance: false,\n          userData: encode([\"uint256\", \"uint256\"], [1, amount]),\n        })\n          .then((exitAmounts) => {\n            console.log(\"exitAmounts\", exitAmounts);\n            i === 0\n              ? !init &&\n                State.update({\n                  customWithdrawableAmounts: exitAmounts.amountsOut,\n                })\n              : State.update({\n                  maxWithdrawableAmounts: exitAmounts.amountsOut,\n                });\n          })\n          .catch((e) => {\n            console.log(\n              \"Error while running queryExit() in updateWithdrawableAmounts():\",\n              e\n            );\n            i === 0\n              ? State.update({ customWithdrawableAmounts: undefined })\n              : State.update({ maxWithdrawableAmounts: undefined });\n          });\n      }\n    });\n  } catch (e) {\n    console.log(\"Error in updateWithdrawableAmounts()\", e);\n  }\n}\n\nfunction CurrencySelector({ operation }) {\n  const currencySelectorGroup = state.form;\n\n  const { oneForms, tokenAddresses } = currencySelectorGroup;\n  const arrayOfSameLengthAsTokenAddresses = [...Array(tokenAddresses.length)];\n  const displayInput =\n    (operation === \"stake\" && state.selectedToken) || operation === \"unstake\";\n\n  return (\n    <div>\n      <div className=\"d-flex flex-column container py-2 pb-3\">\n        {!state.userAddress ? (\n          <h6>No user address available, connect wallet.</h6>\n        ) : (\n          <div className=\"d-flex flex-column\">\n            {/* here goes the title: \"Input Amount\" */}\n            {operation === \"stake\" && (\n              <>\n                <div className=\"d-flex flex-row my-2\">\n                  <div\n                    style={{\n                      fontSize: \"16px\",\n                      fontWeight: \"bold\",\n                    }}\n                  >\n                    Select a token to{\" \"}\n                    {operation === \"stake\" ? \"stake\" : \"unstake\"}.\n                  </div>\n                </div>\n                {/* Token dropdown for the One form*/}\n                {/* make a div same color as input here, rounded right, straight left, and it'll have the selected token inside */}\n\n                <div\n                  style={{\n                    backgroundColor: \"#585858\",\n                    color: \"white\",\n                    borderRadius: \"4px\",\n                    padding: \"4px 4px\",\n                    height: \"40px\",\n                    display: \"flex\",\n                    alignItems: \"center\",\n                    justifyContent: \"center\",\n                    userSelect: \"none\",\n                  }}\n                >\n                  <DropdownMenu.Root\n                    open={state.tokenSelectorIsOpen}\n                    style={{ position: \"relative\" }}\n                    onOpenChange={(\n                      /** @type {boolean} */\n                      isOpen\n                    ) => {\n                      State.update({ tokenSelectorIsOpen: isOpen });\n                    }}\n                  >\n                    <DropdownMenu.Trigger\n                      style={{\n                        backgroundColor: \"transparent\",\n                        border: \"none\",\n                        fontWeight: \"bold\",\n                        color: \"white\",\n                        letterSpacing: \"0.033em\",\n                        display: \"flex\",\n                      }}\n                    >\n                      {tokenAddresses.length === 0 ? (\n                        <></>\n                      ) : (\n                        <span\n                          style={{\n                            display: \"flex\",\n                            alignItems: \"center\",\n                            justifyContent: \"flex-end\",\n                            outline: \"none\",\n                          }}\n                        >\n                          {/* find selected token address and use its symbol, if none are there, put \"Select a token\" */}\n                          {arrayOfSameLengthAsTokenAddresses.reduce(\n                            (acc, _, index) => {\n                              const tokenAddress = tokenAddresses[index];\n                              const oneForm = oneForms[tokenAddress];\n                              if (state.selectedToken === tokenAddress) {\n                                return oneForm.symbol;\n                              }\n                              return acc;\n                            },\n                            \"Select a token\"\n                          )}\n                        </span>\n                      )}\n                      <span className=\"ms-1\">\n                        <i className=\"bi bi-caret-down-fill\"></i>\n                      </span>\n                    </DropdownMenu.Trigger>\n                    <DropdownMenu.Content\n                      sideOffset={5}\n                      style={{\n                        position: \"absolute\",\n                        bottom: \"30px\",\n                        backgroundColor: \"#161616\",\n                        padding: \"5px\",\n                        borderRadius: \"4px\",\n                        paddingBottom: \"0px\",\n                        width: \"max-content\",\n                        maxWidth: \"170px\",\n                      }}\n                    >\n                      {arrayOfSameLengthAsTokenAddresses.map((_, index) => {\n                        const tokenAddress = tokenAddresses[index];\n                        const oneForm = oneForms[tokenAddress];\n                        return (\n                          <MyCheckboxItem\n                            key={tokenAddress}\n                            checked={state.selectedToken === tokenAddress}\n                            onCheckedChange={(\n                              /** @type {boolean} */\n                              isSelected\n                            ) => {\n                              if (isSelected) {\n                                State.update({ selectedToken: tokenAddress });\n                              }\n                            }}\n                          >\n                            <DropdownMenu.ItemIndicator\n                              style={{ marginRight: \"5px\" }}\n                            >\n                              <i className=\"bi bi-check-circle-fill\"></i>\n                            </DropdownMenu.ItemIndicator>\n                            {oneForm.symbol}\n                          </MyCheckboxItem>\n                        );\n                      })}\n                    </DropdownMenu.Content>\n                  </DropdownMenu.Root>\n                </div>\n              </>\n            )}\n            {operation === \"unstake\" && (\n              <>\n                <div className=\"d-flex flex-row my-2\">\n                  <div\n                    style={{\n                      fontSize: \"16px\",\n                      fontWeight: \"bold\",\n                    }}\n                  >\n                    By unstaking, you will receive:\n                  </div>\n                </div>\n                <div>\n                  <ol\n                    style={{\n                      listStyleType: \"none\",\n                      paddingLeft: \"0px\",\n                    }}\n                  >\n                    {Object.keys(state.tokenBalances).map((tokenAddress) => {\n                      const oneForm = oneForms[tokenAddress];\n                      const tokenBalance = state.tokenBalances[tokenAddress];\n                      return (\n                        <li\n                          key={tokenAddress}\n                          style={{\n                            display: \"flex\",\n                            justifyContent: \"space-between\",\n                            alignItems: \"center\",\n                            padding: \"5px 0px\",\n                          }}\n                        >\n                          <div\n                            style={{\n                              display: \"flex\",\n                              alignItems: \"center\",\n                            }}\n                          >\n                            <span>{oneForm.symbol}:</span>\n\n                            <span\n                              style={{\n                                marginLeft: \"5px\",\n                                color: \"#585858\",\n                              }}\n                            >\n                              {state.customWithdrawableAmounts &&\n                              state.customWithdrawableAmounts.length > 0 &&\n                              state.customWithdrawableAmounts[\n                                tokenAddresses.indexOf(tokenAddress)\n                              ]\n                                ? ethers.utils.formatUnits(\n                                    state.customWithdrawableAmounts[\n                                      tokenAddresses.indexOf(tokenAddress)\n                                    ],\n                                    indexedTokens[tokenAddress].decimals\n                                  )\n                                : \"0\"}\n                            </span>\n                          </div>\n                        </li>\n                      );\n                    })}\n                  </ol>\n                </div>\n              </>\n            )}\n            {displayInput && (\n              <div className=\"d-flex flex-row my-2\">\n                <div\n                  style={{\n                    fontSize: \"16px\",\n                    fontWeight: \"bold\",\n                  }}\n                >\n                  Input Amount{\" \"}\n                  <span\n                    className=\"text-primary\"\n                    style={{\n                      filter:\n                        \"hue-rotate(40deg) saturate(80%) brightness(115%)\",\n                      cursor: \"pointer\",\n                    }}\n                    onClick={() => {\n                      if (!state.selectedToken && operation === \"stake\") {\n                        return;\n                      } else if (state.selectedToken && operation === \"stake\") {\n                        const maxStakeAmount =\n                          state.tokenBalances[state.selectedToken];\n                        State.update({\n                          inputAmount: processInputAmount(maxStakeAmount),\n                        });\n                        return;\n                      }\n\n                      const maxAmount = state.poolBalance;\n                      State.update({\n                        inputAmount: processInputAmount(maxAmount || \"0\"),\n                      });\n                      updateWithdrawableAmounts(false);\n                    }}\n                  >\n                    {operation === \"unstake\"\n                      ? \"(Max: \" + state.poolBalance + \")\"\n                      : state.selectedToken &&\n                        state.tokenBalances[state.selectedToken]\n                      ? \"(Max: \" +\n                        state.tokenBalances[state.selectedToken] +\n                        \")\"\n                      : undefined}\n                  </span>\n                </div>\n              </div>\n            )}\n            {displayInput && (\n              <div className=\"d-flex flex-row mb-2\">\n                <input\n                  type=\"text\"\n                  className=\"form-control\"\n                  style={{\n                    backgroundColor: \"#585858\",\n                    color: \"white\",\n                    border: \"0px\",\n                    padding: \"4px 16px\",\n                    height: \"40px\",\n                  }}\n                  value={state.inputAmount}\n                  onChange={(e) => {\n                    const processed = processInputAmount(e.target.value) || \"\";\n                    State.update({ inputAmount: processed });\n                    updateWithdrawableAmounts(false);\n                  }}\n                />\n              </div>\n            )}\n            {operation === \"stake\" &&\n              state.selectedToken &&\n              parseFloat(state.inputAmount) >\n                parseFloat(state.tokenBalances[state.selectedToken] ?? \"0\") && (\n                <div className=\"d-flex flex-row mb-2\">\n                  <div\n                    className=\"alert alert-warning mt-1\"\n                    style={{\n                      fontSize: \"14px\",\n                      maxWidth: \"220px\",\n                    }}\n                  >\n                    Warning: If you stake/unstake more than your balance, the\n                    transaction will consume gas but will be cancelled.\n                  </div>\n                </div>\n              )}\n            {/* submit buttons */}\n            {(state.selectedToken || operation === \"unstake\") && (\n              <div\n                className=\"d-flex justify-content-between align-items-center\"\n                style={{ width: \"100%\" }}\n              >\n                <button\n                  className={\n                    \"btn btn-sm\" +\n                    ((state.selectedToken || operation === \"unstake\") &&\n                    userAddress\n                      ? \" btn-primary\"\n                      : \" btn-secondary\")\n                  }\n                  disabled={\n                    (operation === \"stake\" &&\n                      (!state.selectedToken || !userAddress)) ||\n                    !state.inputAmount ||\n                    0 === parseFloat(state.inputAmount)\n                  }\n                  style={{\n                    filter:\n                      (state.selectedToken || operation === \"unstake\") &&\n                      userAddress\n                        ? \"hue-rotate(40deg) saturate(80%) brightness(115%)\"\n                        : \"saturate(0%) brightness(100%)\",\n                    width: \"100%\",\n                    height: \"40px\",\n                  }}\n                  onClick={() => {\n                    if (operation === \"stake\") {\n                      if (!state.selectedToken) {\n                        console.log(\"no token selected, cannot stake\");\n                        return;\n                      }\n                      if (checkSelectedTokenIsApproved()) {\n                        const sortedTokenAddresses = [...tokenAddresses].sort();\n                        const amountsIn = sortedTokenAddresses.map(\n                          (tokenAddress) => {\n                            const tokenAmount = state.inputAmount;\n                            const tokenDecimals =\n                              indexedTokens[tokenAddress].decimals;\n                            if (tokenAddress === state.selectedToken) {\n                              return ethers.utils.parseEther(\n                                tokenAmount,\n                                tokenDecimals\n                              );\n                            } else {\n                              return ethers.utils.parseEther(\n                                \"0\",\n                                tokenDecimals\n                              );\n                            }\n                          }\n                        );\n                        const joinArgs = {\n                          fromInternalBalance: false,\n                          maxAmountsIn: amountsIn,\n                          poolId: pool.id,\n                          recipient: userAddress,\n                          sender: userAddress,\n                          sortedTokenAddresses: sortedTokenAddresses,\n                          userData: encode(\n                            [\"uint256\", \"uint256[]\", \"uint256\"],\n                            [1, amountsIn, 0]\n                          ),\n                        };\n                        joinOrExitPool({ joinArgs });\n                      } else {\n                        if (state.userAddress) {\n                          approve(\n                            pool.address,\n                            state.userAddress,\n                            indexedTokens[state.selectedToken],\n                            state.inputAmount,\n                            erc20ABI\n                          );\n                        }\n                      }\n                    }\n                    if (operation === \"unstake\") {\n                      const sortedTokenAddresses = [...tokenAddresses].sort();\n                      const amountsOut = sortedTokenAddresses.map(\n                        (tokenAddress, i) => {\n                          return state.customWithdrawableAmounts?.[i];\n                        }\n                      );\n                      amountsOut.forEach((amount, i) => {\n                        if (amount === undefined) {\n                          throw new Error(\n                            \"amountsOut[\" +\n                              i +\n                              \"] is undefined, this should not happen\"\n                          );\n                        }\n                      });\n                      const bigNumberInputAmount = ethers.utils.parseUnits(\n                        state.inputAmount,\n                        18\n                      );\n                      /** @type {ExitPoolArgs} */\n                      const exitArgs = {\n                        minAmountsOut: [],\n                        toInternalBalance: false,\n                        poolId: pool.id,\n                        recipient: userAddress,\n                        sender: userAddress,\n                        sortedTokenAddresses: sortedTokenAddresses,\n                        userData: encode(\n                          [\"uint256\", \"uint256\"],\n                          [1, bigNumberInputAmount]\n                        ),\n                      };\n                      queryThenExit(\n                        pool.id,\n                        userAddress,\n                        userAddress,\n                        exitArgs\n                      );\n                    }\n                  }}\n                >\n                  {typeof checkSelectedTokenIsApproved() === \"boolean\"\n                    ? checkSelectedTokenIsApproved() || operation === \"unstake\"\n                      ? operation === \"stake\"\n                        ? \"Stake\"\n                        : \"Unstake\"\n                      : !state.inputAmount ||\n                        0 === parseFloat(state.inputAmount)\n                      ? \"Input an amount\"\n                      : \"Approve\"\n                    : \"Select a token\"}\n                </button>\n              </div>\n            )}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\nreturn (\n  <StakeUnstakeWidget\n    poolBalance={poolBalance}\n    errorGettingBalance={errorGettingBalance}\n    operation={operation}\n    FormWidget={CurrencySelector}\n  />\n);\n", "metadata": {"description": "Original version with comments and types:\n\nhttps://github.com/dredshep/balancer-pools-bos/blob/0e92ef910b3ea7888490b0b72b0dbd3aa07ee41f/Widgets/CurrencySelector/CurrencySelector.jsx\n\nPublished version without comments or types:\nhttps://github.com/dredshep/balancer-pools-bos/blob/0e92ef910b3ea7888490b0b72b0dbd3aa07ee41f/Widgets/CurrencySelector/nocomments.jsx\n\nDebugging props:\nhttps://github.com/dredshep/balancer-pools-bos/blob/0e92ef910b3ea7888490b0b72b0dbd3aa07ee41f/Widgets/CurrencySelector/CurrencySelectorProps.json", "linktree": {"website": "https://github.com/dredshep/balancer-pools-bos/tree/0e92ef910b3ea7888490b0b72b0dbd3aa07ee41f/Widgets/CurrencySelector"}}, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/c74edb82759f476010ce8363e6be15fcb3cfebf9be6320d6cdc3588f1a5b4c0e/widget/StakeUnstakeButtonAndForm", "fact_widget_deployments_id": "1ce977540fe7ff0db93fdd90d11d2bf7", "inserted_timestamp": "2000-01-01T00:00:00.000Z", "modified_timestamp": "2000-01-01T00:00:00.000Z", "__row_index": 0}