{"tx_hash": "6F9Qt8EdMBV662kXs9LEpV5rNuxyhDtPa5b9ZEDaXtTq", "action_id_social": "P7WAmtTQzPndsXpZtat6xd6HAJVFc9y2B6p2VyspMwD-0-widget", "block_id": 99685488, "block_timestamp": "2023-08-26T07:25:08.410Z", "signer_id": "ref-admin.near", "widget_name": "NearX.Unstake", "source_code": "/** state init start */\nState.init({\n  unstakeMax: false,\n  inputValue: \"\",\n  inputError: \"\",\n  unstakeType: \"instant\", // instant | delayed\n  showConfirmInstantUnstake: false,\n  showConfirmDelayedUnstake: false,\n  swapEstimate: {},\n  swapAmountIn: \"\",\n  swapAmountOut: \"\",\n});\n/** state init end */\n\n// load config\nconst config = props.config;\nif (!config) {\n  return \"Component not be loaded. Missing `config` props\";\n}\n\n/** common lib start */\nconst accountId = props.accountId || context.accountId;\nconst isSignedIn = !!accountId;\nconst NEAR_DECIMALS = 24;\nconst LiNEAR_DECIMALS = 24;\nconst SLIPPAGE_TOLERANCE = 0.05;\nconst BIG_ROUND_DOWN = 0;\n\nfunction isValid(a) {\n  if (!a) return false;\n  if (isNaN(Number(a))) return false;\n  if (a === \"\") return false;\n  return true;\n}\n\nfunction formatAmount(a) {\n  return isValid(a)\n    ? Number(a).toLocaleString(undefined, {\n        minimumFractionDigits: 5,\n        maximumFractionDigits: 5,\n      })\n    : a;\n}\n\n/** common lib end */\nconst linearBalance = props.linearBalance || \"-\";\nconst formattedLinearBalance =\n  linearBalance === \"-\" ? \"-\" : Big(linearBalance).toFixed(5, BIG_ROUND_DOWN);\n\nconst linearPrice = Big(\n  Near.view(config.contractId, \"ft_price\", `{}`) ?? \"0\"\n).div(Big(10).pow(24));\nconst nearPriceInLiNEAR = linearPrice.eq(0)\n  ? \"1\"\n  : Big(1).div(linearPrice).toFixed(5, BIG_ROUND_DOWN);\n\nfunction getReceivedDelayedUnstakeNear() {\n  const { unstakeMax, inputValue } = state;\n  if (!isValid(linearBalance) || !isValid(inputValue)) {\n    return \"-\";\n  }\n  const delayedUnstakeLiNear = unstakeMax ? linearBalance : inputValue;\n  const _delayedUnstakeNear = Big(delayedUnstakeLiNear)\n    .times(linearPrice)\n    .toFixed(5);\n  return _delayedUnstakeNear;\n}\n\nfunction getReceivedInstantUnstakeNear() {\n  const { inputValue, swapAmountOut } = state;\n  if (\n    !isValid(linearBalance) ||\n    !isValid(inputValue) ||\n    !isValid(swapAmountOut)\n  ) {\n    return \"-\";\n  }\n  return Big(swapAmountOut)\n    .mul(1 - Number(SLIPPAGE_TOLERANCE) / 100)\n    .toFixed(5);\n}\n\nconst receivedDelayedUnstakeNear = getReceivedDelayedUnstakeNear();\nconst receivedInstantUnstakeNear = getReceivedInstantUnstakeNear();\nconst formattedReceivedDelayedUnstakeNear = formatAmount(\n  receivedDelayedUnstakeNear\n);\nconst formattedReceivedInstantUnstakeNear = formatAmount(\n  receivedInstantUnstakeNear\n);\n\nconst UNSTAKE_DIFF_ERROR_RATIO = 0.05;\nconst IMPACT_TOO_HIGH_ERROR = \"Price impact high. Unstake less or try later\";\nconst validReceivedUnstakeAmount =\n  isValid(receivedDelayedUnstakeNear) &&\n  isValid(receivedInstantUnstakeNear) &&\n  receivedDelayedUnstakeNear > 0 &&\n  receivedInstantUnstakeNear > 0 &&\n  state.inputValue === state.swapAmountIn; // compare received NEAR only if the input amounts matches\n\nif (\n  state.unstakeType === \"instant\" &&\n  !state.inputError &&\n  validReceivedUnstakeAmount &&\n  Big(receivedDelayedUnstakeNear)\n    .minus(receivedInstantUnstakeNear)\n    .div(receivedDelayedUnstakeNear)\n    .gt(UNSTAKE_DIFF_ERROR_RATIO)\n) {\n  State.update({\n    inputError: IMPACT_TOO_HIGH_ERROR,\n  });\n} else if (\n  state.inputError === IMPACT_TOO_HIGH_ERROR &&\n  (state.unstakeType !== \"instant\" ||\n    (validReceivedUnstakeAmount &&\n      Big(receivedDelayedUnstakeNear)\n        .minus(receivedInstantUnstakeNear)\n        .div(receivedDelayedUnstakeNear)\n        .lte(UNSTAKE_DIFF_ERROR_RATIO)))\n) {\n  State.update({\n    inputError: \"\",\n  });\n}\n\n/** events start */\nconst onChange = (e) => {\n  // Has user signed in?\n  if (!isSignedIn) {\n    State.update({\n      unstakeMax: false,\n      inputError: \"Sign in please\",\n    });\n    return;\n  }\n  const targetValue = e.target.value;\n  if (targetValue !== \"\" && !targetValue.match(/^\\d*(\\.\\d*)?$/)) {\n    return;\n  }\n  let unstakeAmount = targetValue.replace(/^0+/, \"0\"); // remove prefix 0\n  // limit 24 decimals\n  const most24DecimalsPattern = /^-?\\d+(\\.\\d{0,4})?/;\n  let values = unstakeAmount.match(most24DecimalsPattern);\n  if (values) {\n    unstakeAmount = values[0];\n  }\n  if (\n    linearBalance &&\n    (isNaN(Number(unstakeAmount)) ||\n      unstakeAmount === \"\" ||\n      Big(unstakeAmount).lt(nearPriceInLiNEAR) ||\n      Big(unstakeAmount).gt(Big(linearBalance)))\n  ) {\n    if (\n      isNaN(Number(unstakeAmount)) ||\n      unstakeAmount === \"\" ||\n      Big(unstakeAmount).lt(nearPriceInLiNEAR)\n    ) {\n      State.update({\n        unstakeMax: false,\n        // onClickMax: false,\n        inputValue: unstakeAmount,\n        inputError: \"\",\n      });\n    } else {\n      // TODO\n      State.update({\n        unstakeMax: false,\n        onClickMax: false,\n        inputValue: unstakeAmount,\n        inputError: `Max is ${formattedLinearBalance} NearX`,\n      });\n    }\n    return;\n  }\n  State.update({\n    unstakeMax: false,\n    inputValue: unstakeAmount,\n    inputError: \"\",\n  });\n};\n\nconst onClickMax = () => {\n  if (\n    isNaN(Number(linearBalance)) ||\n    linearBalance === \"\" ||\n    Big(linearBalance).lt(nearPriceInLiNEAR)\n  ) {\n    State.update({\n      unstakeMax: true,\n      inputValue: formattedLinearBalance,\n      inputError: `at least ${nearPriceInLiNEAR} NEAR`,\n    });\n    return;\n  } else {\n    State.update({\n      unstakeMax: true,\n      inputValue: formattedLinearBalance,\n      inputError: \"\",\n    });\n  }\n};\n\nconst onClickUnstake = async () => {\n  const { inputValue, unstakeMax, unstakeType, swapAmountOut } = state;\n  const amount = Big(inputValue)\n    .times(linearPrice)\n    .times(Big(10).pow(LiNEAR_DECIMALS))\n    .toFixed(0);\n\n  if (unstakeType === \"instant\") {\n    callRefSwapTx(\n      TOKEN_LINEAR,\n      TOKEN_NEAR,\n      inputValue,\n      swapAmountOut,\n      SLIPPAGE_TOLERANCE\n    );\n    // hide confirm modal\n    State.update({ showConfirmInstantUnstake: false });\n  } else {\n    if (unstakeMax) {\n      Near.call(config.contractId, \"unstake_all\", {});\n    } else {\n      Near.call(config.contractId, \"unstake\", {\n        amount,\n      });\n    }\n    // hide confirm modal\n    State.update({ showConfirmDelayedUnstake: false });\n  }\n\n  // update account balances\n  if (props.updateAccountInfo) {\n    props.updateAccountInfo();\n  }\n};\n\n// Ref swap constants and functions\n\n// token in and token out of swap\nconst TOKEN_LINEAR = { id: config.contractId, decimals: LiNEAR_DECIMALS };\nconst TOKEN_NEAR = { id: \"NEAR\", decimals: NEAR_DECIMALS };\n\nconst REF_EXCHANGE_CONTRACT_ID = \"v2.ref-finance.near\";\nconst WNEAR_CONTRACT_ID = \"wrap.near\";\n\n// Forked from weige.near/widget/ref-swap\nconst registered = Near.view(WNEAR_CONTRACT_ID, \"storage_balance_of\", {\n  account_id: accountId,\n});\n\nconst expandToken = (value, decimals) => {\n  return new Big(value).mul(new Big(10).pow(decimals));\n};\n\nconst callRefSwapTx = (\n  tokenIn,\n  tokenOut,\n  amountIn,\n  amountOut,\n  slippageTolerance\n) => {\n  const tx = [];\n\n  const nearDeposit = {\n    contractName: WNEAR_CONTRACT_ID,\n    methodName: \"near_deposit\",\n    deposit: expandToken(amountIn, 24).toFixed(),\n    gas: expandToken(50, 12),\n  };\n  const nearWithdraw = {\n    contractName: WNEAR_CONTRACT_ID,\n    methodName: \"near_withdraw\",\n    deposit: new Big(\"1\").toFixed(),\n    args: {\n      amount: expandToken(amountIn, 24).toFixed(),\n    },\n  };\n\n  if (state.swapEstimate.pool === \"wrap\") {\n    if (tokenIn.id === \"NEAR\") {\n      tx.push(nearDeposit);\n    } else {\n      tx.push(nearWithdraw);\n    }\n\n    return Near.call(tx);\n  }\n\n  if (registered === null) {\n    tx.push({\n      contractName: tokenOut.id === \"NEAR\" ? WNEAR_CONTRACT_ID : tokenOut.id,\n      methodName: \"storage_deposit\",\n      deposit: expandToken(0.1, 24).toFixed(),\n      gas: expandToken(50, 12),\n      args: {\n        registration_only: true,\n        account_id: accountId,\n      },\n    });\n  }\n\n  if (tokenIn.id === \"NEAR\") {\n    tx.push(nearDeposit);\n  }\n\n  const minAmountOut = expandToken(\n    new Big(amountOut)\n      .mul(1 - Number(slippageTolerance) / 100)\n      .toFixed(tokenOut.decimals, 0),\n    tokenOut.decimals\n  ).toFixed();\n\n  tx.push({\n    methodName: \"ft_transfer_call\",\n    contractName: tokenIn.id === \"NEAR\" ? WNEAR_CONTRACT_ID : tokenIn.id,\n    gas: expandToken(180, 12),\n    deposit: new Big(\"1\").toFixed(),\n    args: {\n      receiver_id: REF_EXCHANGE_CONTRACT_ID,\n      amount: expandToken(amountIn, tokenIn.decimals).toFixed(0, 0),\n      msg: JSON.stringify({\n        actions: [\n          {\n            pool_id: Number(state.swapEstimate.pool.id),\n            token_in: tokenIn.id === \"NEAR\" ? WNEAR_CONTRACT_ID : tokenIn.id,\n            token_out: tokenOut.id === \"NEAR\" ? WNEAR_CONTRACT_ID : tokenOut.id,\n            amount_in: expandToken(amountIn, tokenIn.decimals).toFixed(0, 0),\n            min_amount_out: minAmountOut,\n          },\n        ],\n      }),\n    },\n  });\n\n  if (tokenOut.id === \"NEAR\") {\n    tx.push({\n      contractName: WNEAR_CONTRACT_ID,\n      methodName: \"near_withdraw\",\n      deposit: new Big(\"1\").toFixed(),\n      args: {\n        amount: minAmountOut,\n      },\n    });\n  }\n\n  Near.call(tx);\n};\n\n/** events end */\nconst disabledStakeButton =\n  !isValid(state.inputValue) || Big(state.inputValue).eq(0) || state.inputError;\nconst StakeFormWrapper = styled.div`\n  width: 100%;\n  max-width: 500px;\n  padding-top: 10px;\n  background: #25283a;\n  border-radius: 16px;\n  margin-top: 20px;\n  padding-bottom: 20px;\n  .contentArea {\n    background: #25283a;\n    border-radius: 16px;\n    padding: 20px 30px 0 30px;\n  }\n  .contentArea p {\n    color: #7c7f96;\n    font-size: 14px;\n  }\n  .contentArea hr {\n    background: #373a53;\n    height: 2px;\n  }\n  .arr .bigIcon {\n    background: #373a53;\n  }\n  .arr .boldText {\n    font-weight: 500;\n  }\n  .arr .apr {\n    color: #7c7f96;\n  }\n  .arr .apr .value {\n    color: #ffffff;\n    font-weight: 500;\n  }\n  .footer p {\n    color: #ffffff;\n  }\n`;\n\nif (state.api === undefined) {\n  const result = fetch(\n    \"https://us-central1-staderdao.cloudfunctions.net/nearApr\"\n  );\n  if (!result.ok) {\n    return \"Loading\";\n  }\n  State.update({ apy: result.body.baseStakingApy });\n}\n\nreturn (\n  <StakeFormWrapper>\n    <div class=\"arr\">\n      <Widget\n        src={`${config.ownerId}/widget/stake-bannerIcon`}\n        props={{\n          firstIconName: \"NearX\",\n          firstIconUrl:\n            \"https://ipfs.near.social/ipfs/bafkreia7nzk2nlapfchtgtdnguzrz425fdkhqdsx5gwutuvttetao63rii\",\n          secondIconName: \"\",\n          secondIconUrl:\n            \"https://ipfs.near.social/ipfs/bafkreid5xjykpqdvinmj432ldrkbjisrp3m4n25n4xefd32eml674ypqly\",\n          componentType: \"NearX\",\n\n          apy_value: state.apy,\n        }}\n      ></Widget>\n    </div>\n    <div style={{ display: \"none\" }}>\n      <Widget\n        src={`${config.ownerId}/widget/Ref.ref-swap-getEstimate`}\n        props={{\n          config,\n          tokenIn: TOKEN_LINEAR,\n          tokenOut: TOKEN_NEAR,\n          amountIn: state.inputValue || 0,\n          loadRes: (value) => {\n            State.update({\n              swapEstimate: value,\n              swapAmountIn: value === null ? \"\" : value.amountIn,\n              swapAmountOut: value === null ? \"\" : value.estimate,\n            });\n          },\n        }}\n      />\n    </div>\n    <div class=\"contentArea\">\n      <Widget\n        src={`${config.ownerId}/widget/LiNEAR.Input`}\n        props={{\n          firstIconName: \"NearX\",\n          placeholder: \"0\",\n          value: state.inputValue,\n          onChange,\n          onClickMax,\n          inputError: state.inputError,\n          balance: `${formattedLinearBalance}`,\n        }}\n      />\n      <Widget\n        src={`${config.ownerId}/widget/LiNEAR.Button`}\n        props={{\n          onClick: onClickUnstake,\n          disabled: disabledStakeButton,\n          text: \"Unstake\",\n          type: \"outline\",\n          firstIconName: \"NearX\",\n        }}\n      />\n      <div class=\"footer\">\n        <Widget\n          src={`${config.ownerId}/widget/LiNEAR.Message.YouWillReceive`}\n          props={{\n            text: `${formattedReceivedInstantUnstakeNear} NEAR`,\n            secondIconName: \"NEAR\",\n            secondIconUrl:\n              \"https://ipfs.near.social/ipfs/bafkreid5xjykpqdvinmj432ldrkbjisrp3m4n25n4xefd32eml674ypqly\",\n          }}\n        />\n      </div>\n    </div>\n  </StakeFormWrapper>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/ref-admin.near/widget/NearX.Unstake", "fact_widget_deployments_id": "5d0123f5d943344c117a0363f84c7baa", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 0}