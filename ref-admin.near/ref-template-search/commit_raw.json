{"tx_hash": "4EnNVw3JNnMaLGv46DounwG5Y4YxLC2fxyttT5aWwcpE", "action_id_social": "5GHYPiDH4DJnuA6WvR1t5v5SXhHFobCrfArsesvbgSz3-0-widget", "block_id": 99453352, "block_timestamp": "2023-08-23T06:28:13.447Z", "signer_id": "ref-admin.near", "widget_name": "ref-template-search", "source_code": "const whitelist = props.whitelist || [];\n\nconst metaList = whitelist\n  .map((item) => {\n    return [\n      item + \"/metadata/name\",\n      item + \"/metadata/description\",\n      item + \"/metadata/tags/*\",\n    ];\n  })\n  .flat();\n\nconst allMetadata = Social.get(metaList, \"final\") || {};\nconsole.log(\"allMetadata: \", allMetadata);\n\nconst keys = Social.keys(whitelist, \"final\", { values_only: true }) || {};\nconsole.log(\"keys: \", keys);\n\nconst requiredTags = props.filterTags;\n\nconst chains = props.chains;\n\nconst boostedTag = props.boostedTag;\nconst inputTerm = props.term;\n\nconst SearchIcon = (\n  <svg width=\"21\" height=\"15\" viewBox=\"0 0 21 15\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    <circle cx=\"7.01829\" cy=\"7.01829\" r=\"6.01829\" stroke=\"#EBF479\" strokeWidth=\"2\" />\n    <rect x=\"14.9141\" y=\"9.64941\" width=\"6.141\" height=\"2.63186\" rx=\"1.31593\" transform=\"rotate(30 14.9141 9.64941)\" fill=\"#EBF479\" />\n  </svg>\n\n);\n\nconst debounce = (func, wait) => {\n  const pause = wait || 350;\n  let timeout;\n\n  return (args) => {\n    const later = () => {\n      clearTimeout(timeout);\n      func(args);\n    };\n\n    clearTimeout(timeout);\n    timeout = setTimeout(later, pause);\n  };\n};\n\nconst _search = (term) => {\n  const terms = (term || \"\")\n    .toLowerCase()\n    .split(/[^\\w._\\/-]/)\n    .filter((s) => !!s.trim());\n\n  const matchedWidgets = [];\n\n  const limit = props.limit ?? 30;\n\n  const MaxSingleScore = 1;\n  const MaxScore = MaxSingleScore * 5;\n\n  const computeScore = (s) => {\n    s = s.toLowerCase();\n    return (\n      terms\n        .map((term) => {\n          const pos = s.indexOf(term);\n          return pos >= 0 ? Math.exp(-pos) : 0;\n        })\n        .reduce((s, v) => s + v, 0) / terms.length\n    );\n  };\n\n  Object.entries(keys).forEach(([accountId, data]) => {\n    Object.keys(data.widget).forEach((componentId) => {\n      const widgetSrc = `${accountId}/widget/${componentId}`;\n      const widgetSrcScore = computeScore(widgetSrc);\n\n      const metadata = allMetadata[accountId].widget[componentId].metadata;\n\n      const componentIdScore = computeScore(componentId);\n\n      const descriptionScore = computeScore(\n        metadata.description || componentId\n      );\n\n      const name = metadata.name || componentId;\n\n      const metaTags = Object.keys(metadata.tags || {});\n\n      if (requiredTags) {\n        if (!metadata.tags) return;\n\n        const noChainTags = requiredTags.filter((t) => !chains.includes(t));\n\n        const chainTags = requiredTags.filter((t) => chains.includes(t));\n\n        const hasRefTag = metaTags.some((t) =>\n          noChainTags.map((f) => f.toLowerCase()).includes(t.toLowerCase())\n        );\n\n        const hasChainTag = chainTags.some((t) =>\n          metaTags.some((f) => f.toLowerCase() === t.toLowerCase())\n        );\n\n        if (chainTags?.length > 0 && !hasChainTag) return;\n\n        if (noChainTags?.length > 0 && !hasRefTag) return;\n      }\n      const boosted =\n        boostedTag && metadata.tags && boostedTag in metadata.tags;\n      const tags = Object.keys(metadata.tags || {}).slice(0, 10);\n      const nameScore = computeScore(name);\n      const tagsScore = Math.min(\n        MaxSingleScore,\n        tags.map(computeScore).reduce((s, v) => s + v, 0)\n      );\n      const score =\n        (widgetSrcScore +\n          componentIdScore +\n          nameScore +\n          tagsScore +\n          descriptionScore) /\n        MaxScore;\n      if (score > 0) {\n        matchedWidgets.push({\n          score,\n          accountId,\n          widgetName: componentId,\n          widgetSrc,\n          name,\n          tags,\n          boosted,\n        });\n      }\n    });\n  });\n\n  matchedWidgets.sort(\n    (a, b) => (b.boosted ? 2 : 0) + b.score - (a.boosted ? 2 : 0) - a.score\n  );\n  const result = matchedWidgets.slice(0, limit);\n  console.log(\"result: \", result);\n\n  State.update({\n    result,\n  });\n\n  if (props.onChange) {\n    props.onChange({ term: term || \"\", result });\n  }\n};\n\nconst _searchDebounced = debounce(_search, 200);\n\nconst computeResults = (term) => {\n  State.update({\n    term: term,\n  });\n\n  _searchDebounced(term);\n};\n\nif (props.term && props.term !== state.oldTerm) {\n  State.update({\n    oldTerm: props.term,\n  });\n  if (props.term !== state.term) {\n    computeResults(props.term);\n  }\n}\n\nif (requiredTags?.length || 0 !== (state.oldFilters || []).length) {\n  State.update({\n    oldFilters: requiredTags,\n  });\n  computeResults(state.term);\n}\n\nconst Wrapper = styled.div`\n  position: fixed;\n  top: 112px;\n  right: 32px;\n  height: 36px;\n  display: flex;\n  align-items: center;\n  border-bottom: 1px #373A53 solid;\n\n\n  background: transparent;\n\n  @media (max-width: 500px) {\n    width: 100%;\n  }\n`;\n\nconst Input = styled.input`\n  padding-left: 4px;\n  appearance: none;\n  outline: none;\n  width: 100%;\n  background: none;\n  border: none;\n  color: #ffffff;\n  ::placeholder {\n    color: #ffffff;\n    opacity: 0.3;\n  }\n`;\n\nreturn (\n  <Wrapper>\n    <Input\n      type=\"text\"\n      className={`ref-component-search`}\n      value={state.term ?? \"\"}\n      onChange={(e) => computeResults(e.target.value)}\n    />\n     {SearchIcon}\n  </Wrapper>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/ref-admin.near/widget/ref-template-search", "fact_widget_deployments_id": "70e60cfb603e70cd4b6de2292a6451b6", "inserted_timestamp": "2023-08-23T08:23:11.280Z", "modified_timestamp": "2023-08-23T08:23:11.280Z", "__row_index": 0}