{"tx_hash": "DcaaLu4rMTb5VWDpeCgTyS1LWyWgtMKUwD9zzGsJsACX", "action_id_social": "DpHPqgCVcf1qXfydi3HZgZxrx9L9hPNKGDojKAnyZpVs-0-widget", "block_id": 115692140, "block_timestamp": "2024-03-29T03:24:50.874Z", "signer_id": "communityvoice.ndctools.near", "widget_name": "lib.Communities", "source_code": "const { camelCaseToUserReadable, isValidUrl } = VM.require(\"communityvoice.ndctools.near/widget/lib.strings\");\nconst { generateMetadata, updateMetadata } = VM.require(\"communityvoice.ndctools.near/widget/lib.metadata\");\n\nconst baseAction = \"cv_communities\";\nconst testAction = `test_${baseAction}`\nconst prodAction = `dev_${baseAction}`\nconst version = \"0.0.1\"\n\nlet isTest = false\n\nfunction getCommunitiesTypes() {\n    return [\n        {\n            id: 0,\n            title: \"Public\",\n            description: \"Anyone can view, post and comment.\"\n        },\n        {\n            id: 1,\n            title: \"Restricted\",\n            description: \"Anyone can view this community, but only approved members can post.\"\n        },\n        {\n            id: 2,\n            title: \"Private access\",\n            description: \"Only approved users can view and post in this community.\"\n        }\n]\n}\n\nfunction getAction() {\n    const envAction = isTest ? testAction : prodAction\n    return `${envAction}_v${version}`\n}\n\nfunction setIsTest(value) {\n    isTest = value\n}\n\nfunction validateCommunityData(communityData) {\n    const expectedStringProperties = [\n        \"name\",\n        \"description\",\n        \"backgroundImage\",\n        \"profileImage\"\n    ]\n    const expectedUrlProperties = [\n        \"backgroundImage\",\n        \"profileImage\"\n    ]\n    const isTypeOk = 0 <= communityData.type && communityData.type < getCommunitiesTypes().length\n    const errArrMessage = []\n    // String properties\n    errArrMessage.push(...expectedStringProperties.map((currentProperty) => {\n        const isValidProperty = communityData[currentProperty]\n        if (!isValidProperty) return `Missing ${camelCaseToUserReadable(currentProperty)}`\n        return undefined\n    }).filter((str) => str !== undefined))\n    // Url properties\n    errArrMessage.push(...expectedUrlProperties.map((currentProperty) => {\n        const isValidProperty = isValidUrl(communityData[currentProperty])\n        if (!isValidProperty) return `Invalid url for ${camelCaseToUserReadable(currentProperty)}`\n        return undefined\n    }).filter((str) => str !== undefined))\n    if (!isTypeOk) {\n        errArrMessage.push(\"Type should be between 0 and 2\")\n    }\n    return errArrMessage\n}\n\nfunction composeData(communityData, metadata) {\n    let data = {\n        index: {\n            [getAction()]: JSON.stringify({\n                key: \"main\",\n                value: {\n                    communityData,\n                    metadata,\n                },\n            }),\n        },\n    };\n\n    return data;\n}\n\nfunction composeDeleteData(communityData) {\n    let data = {\n        index: {\n            [getAction()]: JSON.stringify({\n                key: \"main\",\n                value: {\n                    communityData: {\n                        id: communityData.id\n                    },\n                    isDelete: true\n                },\n            }),\n        },\n    };\n\n    return data;\n}\n\nfunction executeSaveCommunity(communityData, metadata, onCommit, onCancel) {\n    const newData = composeData(communityData, metadata);\n    Social.set(newData, {\n        force: true,\n        onCommit,\n        onCancel,\n    });\n};\n\nfunction executeDeleteCommunity(communityData, onCommit, onCancel) {\n    const newData = composeDeleteData(communityData)\n\n    Social.set(newData, {\n        force: true,\n        onCommit,\n        onCancel,\n    });\n}\n\n/**\n * \n * @param {*} communityData \n * @param {*} ownerId Context doesn't seem to work on imported widgets\n * @param {*} onCommit \n * @param {*} onCancel \n * @returns \n */\nfunction createCommunity(communityData, ownerId, onCommit, onCancel) {\n    const errors = validateCommunityData(communityData);\n    if (!ownerId) {\n        return { error: true, data: [\"Owner id not shared\"] }\n    }\n    if (errors && errors.length) {\n        return { error: true, data: errors }\n    }\n    if (communityData.id) {\n        return { error: true, data: [\"There is already a community with this id\"] }\n    }\n\n    communityData.id = `cd/${ownerId}/${Date.now()}`\n    const metadata = generateMetadata()\n    executeSaveCommunity(communityData, metadata, onCommit, onCancel)\n\n    const result = \"Community created successfully\"\n    return { error: false, data: result };\n}\n\n/**\n * \n * @returns It might return first null and then an empty array and finally an array containing the index structure of communities\n */\nfunction getCommunities() {\n    const action = getAction()\n    const communities = Social.index(action, \"main\", {\n        order: \"desc\",\n        subscribe,\n        // limit: 10,\n    }) || []\n\n    return processCommunities(communities)\n}\n\nfunction processCommunities(communitiesIndexes) {\n    const validCommunities = filterValidCommunities(communitiesIndexes)\n    const latestEdit = getLatestEdit(validCommunities)\n    const nonDeletedLatest = removeDeleted(latestEdit)\n\n    return nonDeletedLatest\n}\n\nfunction filterValidCommunities(communitiesIndexes) {\n    const accountIdMatch = filterAccountIdWithCommunityId(communitiesIndexes)\n\n    return accountIdMatch\n}\n\nfunction filterAccountIdWithCommunityId(communitiesIndexes) {\n    return communitiesIndexes.filter((communityIndex) => {\n        return communityIndex.value.communityData.id.startsWith(communityIndex.accountId)\n    })\n}\n\nfunction getLatestEdit(communitiesIndexes) {\n    return communitiesIndexes.filter((communityIndex, index) => {\n        return communitiesIndexes.findIndex((communityIndex2) => {\n            return communityIndex.value.communityData.id === communityIndex2.value.communityData.id\n        }) === index\n    })\n}\n\nfunction removeDeleted(communitiesIndexes) {\n    return communitiesIndexes.filter((communityIndex) => {\n        return !communityIndex.value.isDelete\n    })\n}\n\nfunction editCommunity(communityIndex, onCommit, onCancel) {\n    const communityData = communityIndex.value.communityData;\n    const errors = validateCommunityData(communityData);\n    if (errors && errors.length) {\n        return { error: true, data: errors }\n    }\n    if (!communityData.id) {\n        return { error: true, data: [\"Community id not provided\"] }\n    }\n\n    const metadata = updateMetadata(communityIndex.value.metadata)\n    executeSaveCommunity(communityData, metadata, onCommit, onCancel)\n    const result = \"Community edited successfully\"\n    return { error: false, data: result };\n}\n\nfunction deleteCommunity(communityData, onCommit, onCancel) {\n    if (!communityData.id) {\n        return { error: true, data: [\"Community id not provided\"] }\n    }\n\n    executeDeleteCommunity(communityData, onCommit, onCancel)\n    const result = \"Community removed successfully\"\n    return { error: false, data: result };\n}\n\nreturn { setIsTest, createCommunity, getCommunities, editCommunity, deleteCommunity }", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/communityvoice.ndctools.near/widget/lib.Communities", "fact_widget_deployments_id": "99385c9fdce257dae21aff1ffae1ab54", "inserted_timestamp": "2024-03-29T04:30:46.452Z", "modified_timestamp": "2024-03-29T05:29:53.007Z", "__row_index": 0}