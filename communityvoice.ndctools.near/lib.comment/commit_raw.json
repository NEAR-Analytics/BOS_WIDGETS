{"tx_hash": "H9Ues2GD5fy9f8zCLux1ZJtMHKgujyKjLdqGPA6FeTou", "action_id_social": "bBAoTCquQxFmfQ6FP1JKu8r7TjSQhygKR2Ypeh7SDR1-0-widget", "block_id": 115692211, "block_timestamp": "2024-03-29T03:26:19.056Z", "signer_id": "communityvoice.ndctools.near", "widget_name": "lib.comment", "source_code": "const { getFromIndex } = VM.require(\"communityvoice.ndctools.near/widget/lib.socialDbIndex\");\nconst { normalize, normalizeId } = VM.require(\n  \"communityvoice.ndctools.near/widget/lib.normalization\"\n);\nconst { generateMetadata, updateMetadata, buildDeleteMetadata } = VM.require(\n  \"communityvoice.ndctools.near/widget/lib.metadata\"\n);\n\nconst { extractMentions, getNotificationData } = VM.require(\n  \"communityvoice.ndctools.near/widget/lib.notifications\"\n);\n\nlet config = {};\n\nconst currentVersion = \"v0.0.4\";\n\nfunction getSplittedCommentIdV0_0_3(commentId) {\n  const commentIdWithoutPrefix = commentId.slice(2);\n  const prefix = \"c-\";\n\n  const oldFormatID = prefix + commentIdWithoutPrefix;\n\n  const newCommentID = normalizeId(oldFormatID, \"comment\");\n\n  const splitCommentId = newCommentID.split(\"/\");\n\n  return splitCommentId;\n  // }\n}\n\nfunction normalizeOldToV_0_0_1(comment) {\n  return comment;\n}\n\nfunction normalizeFromV0_0_1ToV0_0_2(comment) {\n  return comment;\n}\n\nfunction normalizeFromV0_0_2ToV0_0_3(comment) {\n  comment.value.comment.rootId = comment.value.comment.originalCommentId;\n  delete comment.value.comment.originalCommentId;\n  delete comment.value.comment.id;\n\n  return comment;\n}\n\nfunction normalizeFromV0_0_3ToV0_0_4(comment) {\n  const now = Date.now();\n\n  // const splitCommentId = getSplittedCommentIdV0_0_3(comment.value.metadata.id);\n  const splitCommentId = getSplittedCommentIdV0_0_3(\n    comment.value.comment.commentId\n  );\n  \n  comment.value.commentData = {text: comment.value.comment.text};\n  const author = splitCommentId[1];\n  comment.value.metadata = {\n    id: splitCommentId.join(\"/\"),\n    author,\n    createdTimestamp: now,\n    lastEditTimestamp: now,\n    rootId: comment.value.comment.rootId,\n    versionKey: \"v0.0.4\",\n  };\n\n  delete comment.value.comment.commentId;\n  delete comment.value.comment.rootId;\n  delete comment.value.comment.timestamp;\n  delete comment.value.comment.text;\n  delete comment.value.comment;\n  delete comment.isEdition;\n\n  return comment;\n}\n\nfunction normalizeFromV0_0_4ToV0_0_5(comment) {\n  return comment;\n}\n\nconst versions = {\n  old: {\n    normalizationFunction: normalizeOldToV_0_0_1,\n    suffixAction: \"\",\n  },\n  \"v1.0.1\": {\n    normalizationFunction: normalizeFromV0_0_1ToV0_0_2,\n    suffixAction: `-v1.0.1`,\n  },\n  \"v0.0.2\": {\n    normalizationFunction: normalizeFromV0_0_2ToV0_0_3,\n    suffixAction: `_v0.0.2`,\n  },\n  \"v0.0.3\": {\n    normalizationFunction: normalizeFromV0_0_3ToV0_0_4,\n    suffixAction: `_v0.0.3`,\n  },\n  \"v0.0.4\": {\n    normalizationFunction: normalizeFromV0_0_4ToV0_0_5,\n    suffixAction: `_v0.0.4`,\n  },\n};\n\nfunction setConfig(newConfig) {\n  config = newConfig;\n}\n\nfunction getConfig() {\n  return config;\n}\n\nfunction fillAction(version, config) {\n  const baseAction = config.baseActions.comment;\n  const filledAction = baseAction + version.suffixAction;\n  return config.isTest ? `test_${filledAction}` : filledAction;\n}\n\nfunction getCommentBlackListByBlockHeight() {\n  return [98588599, 115199907, 115238101];\n}\n\nfunction filterInvalidComments(comments) {\n  return comments\n    .filter(\n      (comment) =>\n        comment.blockHeight &&\n        !getCommentBlackListByBlockHeight().includes(comment.blockHeight) // Comment is not in blacklist\n    )\n    .filter((comment) => {\n      return (\n        comment.accountId ===\n        getUserNameFromCommentId(\n          comment.value.metadata.id ?? comment.value.comment.commentId\n        )\n      );\n    });\n}\n\nfunction getUserNameFromCommentId(commentId) {\n  let userName;\n  if (commentId.startsWith(\"c/\") || commentId.startsWith(\"comment/\")) {\n    const splittedCommentId = commentId.split(\"/\");\n    userName = splittedCommentId[1];\n  } else if (commentId.startsWith(\"c_\")) {\n    const userNamePlusTimestamp = commentId.split(\"c_\")[1];\n\n    const splittedUserNamePlusTimestamp = userNamePlusTimestamp.split(\"-\");\n\n    splittedUserNamePlusTimestamp.pop();\n\n    userName = splittedUserNamePlusTimestamp.join(\"-\");\n  }\n\n  return userName;\n}\n\nfunction processComments(comments) {\n  const lastEditionComments = comments.filter((comment) => {\n    const firstCommentWithThisCommentId = comments.find((compComment) => {\n      return compComment.value.metadata.id === comment.value.metadata.id;\n    });\n\n    return (\n      JSON.stringify(firstCommentWithThisCommentId) === JSON.stringify(comment)\n    );\n  });\n\n  const lastEditionCommentsWithoutDeletedOnes = lastEditionComments.filter(\n    (comment) => !comment.value.metadata.isDelete\n  );\n\n  const lastEditionCommentsWithEditionMark =\n    lastEditionCommentsWithoutDeletedOnes.map((comment) => {\n      const commentsWithThisCommentId = comments.filter((compComment) => {\n        return (\n          comment.value.metadata.id === compComment.value.metadata.commentId\n        );\n      });\n\n      if (commentsWithThisCommentId.length > 1) {\n        comment.value.metadata.isEdition = true;\n      }\n\n      return comment;\n    });\n\n  return lastEditionCommentsWithEditionMark;\n}\n\nfunction getComments(articleId, config) {\n  setConfig(config);\n  const commentsByVersionPromise = Object.keys(versions).map(\n    (version, index, arr) => {\n      const action = fillAction(versions[version], config);\n\n      return getFromIndex(action, articleId, \"asc\").then((comments) => {\n        const validComments = filterInvalidComments(comments);\n\n        const normalizedComments = validComments.map((comment) => {\n          return normalize(comment, versions, index);\n        });\n\n        return normalizedComments;\n      });\n    }\n  );\n\n  return Promise.all(commentsByVersionPromise).then((commentsByVersion) => {\n    return processComments(commentsByVersion.flat());\n  });\n}\n\nfunction getAction(parameterVersion, parameterConfig) {\n  //parameterVersion and parameterCconfig are optative for testing\n  const baseAction =\n    parameterConfig.baseActions.comment ?? getConfig().baseActions.comment;\n\n  const versionData = parameterVersion\n    ? versions[parameterVersion]\n    : versions[currentVersion];\n\n  const action = baseAction + versionData.suffixAction;\n\n  return parameterConfig.isTest || getConfig().isTest\n    ? `test_${action}`\n    : action;\n}\n\nfunction composeCommentData(comment, version, config) {\n  // if (comment.metadata.replyingTo) {\n  //   //We add the following so the user been replied get's a notification\n  //   comment.commentData.text = `@${comment.metadata.replyingTo} ${comment.commentData.text}`;\n  // }\n\n  let data = {\n    index: {\n      [getAction(version, config)]: JSON.stringify({\n        key: comment.metadata.articleId,\n        value: {\n          type: \"md\",\n          ...comment,\n        },\n      }),\n    },\n  };\n\n  if(comment.metadata.isDelete) return data\n  \n  const mentions = comment.commentData.isDelete ? [] : extractMentions(comment.commentData.text);\n\n  const articleIdSplitted = comment.metadata.articleId.split(\"/\");\n  const articleAuthor = articleIdSplitted[1];\n\n  const dataToAdd = getNotificationData(\n    getConfig(),\n    mentions.length > 0 ? \"mentionOnComment\" : \"comment\",\n    mentions,\n    comment.metadata,\n    {author: articleAuthor}\n  );\n\n  data.post = dataToAdd.post;\n  data.index.notify = dataToAdd.index.notify;\n  \n\n  return data;\n}\n\nfunction executeSaveComment(\n  comment,\n  onCommit,\n  onCancel,\n  parameterVersion,\n  parameterConfig\n) {\n  //parameterVersion and parameterConfig are optative for testing\n  const newData = composeCommentData(\n    comment,\n    parameterVersion ?? currentVersion,\n    parameterConfig ?? config\n  );\n\n  Social.set(newData, {\n    force: true,\n    onCommit,\n    onCancel,\n  });\n\n  return comment.metadata.id;\n}\n\nfunction createComment(props) {\n  const {\n    config,\n    author,\n    commentText,\n    replyingTo,\n    articleId,\n    onCommit,\n    onCancel,\n  } = props;\n\n  setConfig(config);\n\n  const metadataHelper = {\n    author,\n    idPrefix: \"comment\",\n    versionKey: currentVersion,\n  };\n\n  let metadata = generateMetadata(metadataHelper);\n  metadata.articleId = articleId;\n  metadata.rootId = replyingTo;\n\n  const comment = {\n    commentData: { text: commentText },\n    metadata,\n  };\n\n  const result = executeSaveComment(comment, onCommit, onCancel);\n\n  return { error: !result, data: result };\n}\n\nfunction editComment(props) {\n  const { config, comment, onCommit, onCancel } = props;\n\n  setConfig(config);\n\n  //TODO ask Dani abaut the second parameter in this case\n  // let metadata = updateMetadata(comment.metadata, currentVersion);\n  let metadata = updateMetadata(comment.value.metadata, currentVersion);\n  metadata.isEdition = true;\n\n  //===========================================================================================================================================================================\n  // interface comment {\n  //   commentData: {text: string},\n  //   metadata\n  // }\n  //===========================================================================================================================================================================\n\n  const newComment = {\n    commentData: { text: comment.value.commentData.text },\n    metadata,\n  };\n\n  const result = executeSaveComment(newComment, onCommit, onCancel);\n\n  return { error: !result, data: result };\n}\n\nfunction deleteComment(props) {\n  const { config, commentId, articleId, rootId, onCommit, onCancel } = props;\n\n  setConfig(config);\n\n  let metadata = buildDeleteMetadata(commentId);\n  metadata.articleId = articleId;\n  metadata.rootId = rootId;\n\n  const comment = {\n    metadata,\n  };\n\n  const result = executeSaveComment(comment, onCommit, onCancel);\n\n  return { error: !result, data: result };\n}\n\nreturn {\n  getComments,\n  createComment,\n  editComment,\n  deleteComment,\n  functionsToTest: {\n    normalizeOldToV_0_0_1,\n    normalizeFromV0_0_1ToV0_0_2,\n    normalizeFromV0_0_2ToV0_0_3,\n    normalizeFromV0_0_3ToV0_0_4,\n    setConfig,\n    getConfig,\n    fillAction,\n    getCommentBlackListByBlockHeight,\n    filterInvalidComments,\n    getUserNameFromCommentId,\n    processComments,\n    getComments,\n    getSplittedCommentIdV0_0_3,\n    composeCommentData,\n    createComment,\n    editComment,\n    deleteComment,\n  },\n};\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/communityvoice.ndctools.near/widget/lib.comment", "fact_widget_deployments_id": "28493c8a0407513c1dd8fd098acc4337", "inserted_timestamp": "2024-03-29T04:30:46.452Z", "modified_timestamp": "2024-03-29T05:29:53.007Z", "__row_index": 16}