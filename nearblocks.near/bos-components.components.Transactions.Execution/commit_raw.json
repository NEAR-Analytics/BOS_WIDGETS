{"tx_hash": "3REMAWo1sGqiiJn4aRgVbkDifSD9k8BUsn13pYE11j8B", "action_id_social": "C2W4iZxfyFBXKwBo6HTrVPWq7m1sT6vrnMu2xUtsez1v-0-widget", "block_id": 112949036, "block_timestamp": "2024-02-16T12:05:50.900Z", "signer_id": "nearblocks.near", "widget_name": "bos-components.components.Transactions.Execution", "source_code": "/**\n * Component: TransactionsExecution\n * Author: Nearblocks Pte Ltd\n * License: Business Source License 1.1\n * Description: Alternative Style of Transaction Execution on Near Protocol.\n * @interface Props\n * @param {string} [network] - The network data to show, either mainnet or testnet\n * @param {Function} [t] - A function for internationalization (i18n) provided by the next-translate package.\n * @param {TransactionInfo} [txn] - Information related to a transaction.\n * @param {RPCTransactionInfo} [rpcTxn] - RPC data of the transaction.\n */\n\n\n\n\n\n\n\n\n/* INCLUDE: \"includes/libs.jsx\" */\nfunction getConfig(network) {\n  switch (network) {\n    case 'mainnet':\n      return {\n        ownerId: 'nearblocks.near',\n        nodeUrl: 'https://rpc.mainnet.near.org',\n        backendUrl: 'https://api3.nearblocks.io/v1/',\n        rpcUrl: 'https://archival-rpc.testnet.near.org',\n        appUrl: 'https://nearblocks.io/',\n      };\n    case 'testnet':\n      return {\n        ownerId: 'nearblocks.testnet',\n        nodeUrl: 'https://rpc.testnet.near.org',\n        backendUrl: 'https://api3-testnet.nearblocks.io/v1/',\n        rpcUrl: 'https://archival-rpc.testnet.near.org',\n        appUrl: 'https://testnet.nearblocks.io/',\n      };\n    default:\n      return {};\n  }\n}\n\nfunction debounce(\n  delay,\n  func,\n) {\n  let timer;\n  let active = true;\n  const debounced = (arg) => {\n    if (active) {\n      clearTimeout(timer);\n      timer = setTimeout(() => {\n        active && func(arg);\n        timer = undefined;\n      }, delay);\n    } else {\n      func(arg);\n    }\n  };\n\n  debounced.isPending = () => {\n    return timer !== undefined;\n  };\n\n  debounced.cancel = () => {\n    active = false;\n  };\n\n  debounced.flush = (arg) => func(arg);\n\n  return debounced;\n}\n\nfunction timeAgo(unixTimestamp) {\n  const currentTimestamp = Math.floor(Date.now() / 1000);\n  const secondsAgo = currentTimestamp - unixTimestamp;\n\n  if (secondsAgo < 5) {\n    return 'Just now';\n  } else if (secondsAgo < 60) {\n    return `${secondsAgo} seconds ago`;\n  } else if (secondsAgo < 3600) {\n    const minutesAgo = Math.floor(secondsAgo / 60);\n    return `${minutesAgo} minute${minutesAgo > 1 ? 's' : ''} ago`;\n  } else if (secondsAgo < 86400) {\n    const hoursAgo = Math.floor(secondsAgo / 3600);\n    return `${hoursAgo} hour${hoursAgo > 1 ? 's' : ''} ago`;\n  } else {\n    const daysAgo = Math.floor(secondsAgo / 86400);\n    return `${daysAgo} day${daysAgo > 1 ? 's' : ''} ago`;\n  }\n}\n\nfunction shortenAddress(address) {\n  const string = String(address);\n\n  if (string.length <= 20) return string;\n\n  return `${string.substr(0, 10)}...${string.substr(-7)}`;\n}\n\nfunction urlHostName(url) {\n  try {\n    const domain = new URL(url);\n    return domain?.hostname ?? null;\n  } catch (e) {\n    return null;\n  }\n}\n\nfunction holderPercentage(supply, quantity) {\n  return Math.min(Big(quantity).div(Big(supply)).mul(Big(100)).toFixed(2), 100);\n}\n\nfunction isAction(type) {\n  const actions = [\n    'DEPLOY_CONTRACT',\n    'TRANSFER',\n    'STAKE',\n    'ADD_KEY',\n    'DELETE_KEY',\n    'DELETE_ACCOUNT',\n  ];\n\n  return actions.includes(type.toUpperCase());\n}\nfunction localFormat(number) {\n  const bigNumber = Big(number);\n  const formattedNumber = bigNumber\n    .toFixed(5)\n    .replace(/(\\d)(?=(\\d{3})+\\.)/g, '$1,'); // Add commas before the decimal point\n  return formattedNumber.replace(/\\.?0*$/, ''); // Remove trailing zeros and the dot\n}\nfunction formatWithCommas(number) {\n  return number.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',');\n}\n/* END_INCLUDE: \"includes/libs.jsx\" */\n/* INCLUDE: \"includes/near.jsx\" */\nfunction collectNestedReceiptWithOutcomeOld(\n  idOrHash,\n  parsedMap,\n) {\n  const parsedElement = parsedMap.get(idOrHash);\n  if (!parsedElement) {\n    return { id: idOrHash };\n  }\n  const { receiptIds, ...restOutcome } = parsedElement.outcome;\n  return {\n    ...parsedElement,\n    outcome: {\n      ...restOutcome,\n      nestedReceipts: receiptIds.map((id) =>\n        collectNestedReceiptWithOutcomeOld(id, parsedMap),\n      ),\n    },\n  };\n}\n\nfunction parseReceipt(\n  receipt,\n  outcome,\n  transaction,\n) {\n  if (!receipt) {\n    return {\n      id: outcome.id,\n      predecessorId: transaction.signer_id,\n      receiverId: transaction.receiver_id,\n      actions: transaction.actions.map(mapRpcActionToAction1),\n    };\n  }\n  return {\n    id: receipt.receipt_id,\n    predecessorId: receipt.predecessor_id,\n    receiverId: receipt.receiver_id,\n    actions:\n      'Action' in receipt.receipt\n        ? receipt.receipt.Action.actions.map(mapRpcActionToAction1)\n        : [],\n  };\n}\n\nfunction mapNonDelegateRpcActionToAction(\n  rpcAction,\n) {\n  if (rpcAction === 'CreateAccount') {\n    return {\n      kind: 'createAccount',\n      args: {},\n    };\n  }\n  if ('DeployContract' in rpcAction) {\n    return {\n      kind: 'deployContract',\n      args: rpcAction.DeployContract,\n    };\n  }\n  if ('FunctionCall' in rpcAction) {\n    return {\n      kind: 'functionCall',\n      args: {\n        methodName: rpcAction.FunctionCall.method_name,\n        args: rpcAction.FunctionCall.args,\n        deposit: rpcAction.FunctionCall.deposit,\n        gas: rpcAction.FunctionCall.gas,\n      },\n    };\n  }\n  if ('Transfer' in rpcAction) {\n    return {\n      kind: 'transfer',\n      args: rpcAction.Transfer,\n    };\n  }\n  if ('Stake' in rpcAction) {\n    return {\n      kind: 'stake',\n      args: {\n        publicKey: rpcAction.Stake.public_key,\n        stake: rpcAction.Stake.stake,\n      },\n    };\n  }\n  if ('AddKey' in rpcAction) {\n    return {\n      kind: 'addKey',\n      args: {\n        publicKey: rpcAction.AddKey.public_key,\n        accessKey: {\n          nonce: rpcAction.AddKey.access_key.nonce,\n          permission:\n            rpcAction.AddKey.access_key.permission === 'FullAccess'\n              ? {\n                  type: 'fullAccess',\n                }\n              : {\n                  type: 'functionCall',\n                  contractId:\n                    rpcAction.AddKey.access_key.permission.FunctionCall\n                      .receiver_id,\n                  methodNames:\n                    rpcAction.AddKey.access_key.permission.FunctionCall\n                      .method_names,\n                },\n        },\n      },\n    };\n  }\n  if ('DeleteKey' in rpcAction) {\n    return {\n      kind: 'deleteKey',\n      args: {\n        publicKey: rpcAction.DeleteKey.public_key,\n      },\n    };\n  }\n  return {\n    kind: 'deleteAccount',\n    args: {\n      beneficiaryId: rpcAction.DeleteAccount.beneficiary_id,\n    },\n  };\n}\nfunction mapRpcInvalidAccessKeyError(error) {\n  const UNKNOWN_ERROR = { type: 'unknown' };\n\n  if (error === 'DepositWithFunctionCall') {\n    return {\n      type: 'depositWithFunctionCall',\n    };\n  }\n  if (error === 'RequiresFullAccess') {\n    return {\n      type: 'requiresFullAccess',\n    };\n  }\n  if ('AccessKeyNotFound' in error) {\n    const { account_id, public_key } = error.AccessKeyNotFound;\n    return {\n      type: 'accessKeyNotFound',\n      accountId: account_id,\n      publicKey: public_key,\n    };\n  }\n  if ('ReceiverMismatch' in error) {\n    const { ak_receiver, tx_receiver } = error.ReceiverMismatch;\n    return {\n      type: 'receiverMismatch',\n      akReceiver: ak_receiver,\n      transactionReceiver: tx_receiver,\n    };\n  }\n  if ('MethodNameMismatch' in error) {\n    const { method_name } = error.MethodNameMismatch;\n    return {\n      type: 'methodNameMismatch',\n      methodName: method_name,\n    };\n  }\n  if ('NotEnoughAllowance' in error) {\n    const { account_id, allowance, cost, public_key } =\n      error.NotEnoughAllowance;\n    return {\n      type: 'notEnoughAllowance',\n      accountId: account_id,\n      allowance: allowance,\n      cost: cost,\n      publicKey: public_key,\n    };\n  }\n\n  return UNKNOWN_ERROR;\n}\n\nfunction mapRpcCompilationError(error) {\n  const UNKNOWN_ERROR = { type: 'unknown' };\n  if ('CodeDoesNotExist' in error) {\n    return {\n      type: 'codeDoesNotExist',\n      accountId: error.CodeDoesNotExist.account_id,\n    };\n  }\n  if ('PrepareError' in error) {\n    return {\n      type: 'prepareError',\n    };\n  }\n  if ('WasmerCompileError' in error) {\n    return {\n      type: 'wasmerCompileError',\n      msg: error.WasmerCompileError.msg,\n    };\n  }\n  if ('UnsupportedCompiler' in error) {\n    return {\n      type: 'unsupportedCompiler',\n      msg: error.UnsupportedCompiler.msg,\n    };\n  }\n  return UNKNOWN_ERROR;\n}\n\nfunction mapRpcFunctionCallError(error) {\n  const UNKNOWN_ERROR = { type: 'unknown' };\n  if ('CompilationError' in error) {\n    return {\n      type: 'compilationError',\n      error: mapRpcCompilationError(error.CompilationError),\n    };\n  }\n  if ('LinkError' in error) {\n    return {\n      type: 'linkError',\n      msg: error.LinkError.msg,\n    };\n  }\n  if ('MethodResolveError' in error) {\n    return {\n      type: 'methodResolveError',\n    };\n  }\n  if ('WasmTrap' in error) {\n    return {\n      type: 'wasmTrap',\n    };\n  }\n  if ('WasmUnknownError' in error) {\n    return {\n      type: 'wasmUnknownError',\n    };\n  }\n  if ('HostError' in error) {\n    return {\n      type: 'hostError',\n    };\n  }\n  if ('_EVMError' in error) {\n    return {\n      type: 'evmError',\n    };\n  }\n  if ('ExecutionError' in error) {\n    return {\n      type: 'executionError',\n      error: error.ExecutionError,\n    };\n  }\n  return UNKNOWN_ERROR;\n}\nfunction mapRpcNewReceiptValidationError(error) {\n  const UNKNOWN_ERROR = { type: 'unknown' };\n  if ('InvalidPredecessorId' in error) {\n    return {\n      type: 'invalidPredecessorId',\n      accountId: error.InvalidPredecessorId.account_id,\n    };\n  }\n  if ('InvalidReceiverId' in error) {\n    return {\n      type: 'invalidReceiverId',\n      accountId: error.InvalidReceiverId.account_id,\n    };\n  }\n  if ('InvalidSignerId' in error) {\n    return {\n      type: 'invalidSignerId',\n      accountId: error.InvalidSignerId.account_id,\n    };\n  }\n  if ('InvalidDataReceiverId' in error) {\n    return {\n      type: 'invalidDataReceiverId',\n      accountId: error.InvalidDataReceiverId.account_id,\n    };\n  }\n  if ('ReturnedValueLengthExceeded' in error) {\n    return {\n      type: 'returnedValueLengthExceeded',\n      length: error.ReturnedValueLengthExceeded.length,\n      limit: error.ReturnedValueLengthExceeded.limit,\n    };\n  }\n  if ('NumberInputDataDependenciesExceeded' in error) {\n    return {\n      type: 'numberInputDataDependenciesExceeded',\n      numberOfInputDataDependencies:\n        error.NumberInputDataDependenciesExceeded\n          .number_of_input_data_dependencies,\n      limit: error.NumberInputDataDependenciesExceeded.limit,\n    };\n  }\n  if ('ActionsValidation' in error) {\n    return {\n      type: 'actionsValidation',\n    };\n  }\n  return UNKNOWN_ERROR;\n}\n\nfunction mapRpcReceiptActionError(error) {\n  const UNKNOWN_ERROR = { type: 'unknown' };\n  const { kind } = error;\n  if (kind === 'DelegateActionExpired') {\n    return {\n      type: 'delegateActionExpired',\n    };\n  }\n  if (kind === 'DelegateActionInvalidSignature') {\n    return {\n      type: 'delegateActionInvalidSignature',\n    };\n  }\n  if ('DelegateActionSenderDoesNotMatchTxReceiver' in kind) {\n    return {\n      type: 'delegateActionSenderDoesNotMatchTxReceiver',\n      receiverId: kind.DelegateActionSenderDoesNotMatchTxReceiver.receiver_id,\n      senderId: kind.DelegateActionSenderDoesNotMatchTxReceiver.sender_id,\n    };\n  }\n  if ('DelegateActionAccessKeyError' in kind) {\n    return {\n      type: 'delegateActionAccessKeyError',\n      error: mapRpcInvalidAccessKeyError(kind.DelegateActionAccessKeyError),\n    };\n  }\n  if ('DelegateActionInvalidNonce' in kind) {\n    return {\n      type: 'delegateActionInvalidNonce',\n      akNonce: kind.DelegateActionInvalidNonce.ak_nonce,\n      delegateNonce: kind.DelegateActionInvalidNonce.delegate_nonce,\n    };\n  }\n  if ('DelegateActionNonceTooLarge' in kind) {\n    return {\n      type: 'delegateActionNonceTooLarge',\n      delegateNonce: kind.DelegateActionNonceTooLarge.delegate_nonce,\n      upperBound: kind.DelegateActionNonceTooLarge.upper_bound,\n    };\n  }\n  if ('AccountAlreadyExists' in kind) {\n    return {\n      type: 'accountAlreadyExists',\n      accountId: kind.AccountAlreadyExists.account_id,\n    };\n  }\n  if ('AccountDoesNotExist' in kind) {\n    return {\n      type: 'accountDoesNotExist',\n      accountId: kind.AccountDoesNotExist.account_id,\n    };\n  }\n  if ('CreateAccountOnlyByRegistrar' in kind) {\n    return {\n      type: 'createAccountOnlyByRegistrar',\n      accountId: kind.CreateAccountOnlyByRegistrar.account_id,\n      registrarAccountId:\n        kind.CreateAccountOnlyByRegistrar.registrar_account_id,\n      predecessorId: kind.CreateAccountOnlyByRegistrar.predecessor_id,\n    };\n  }\n  if ('CreateAccountNotAllowed' in kind) {\n    return {\n      type: 'createAccountNotAllowed',\n      accountId: kind.CreateAccountNotAllowed.account_id,\n      predecessorId: kind.CreateAccountNotAllowed.predecessor_id,\n    };\n  }\n  if ('ActorNoPermission' in kind) {\n    return {\n      type: 'actorNoPermission',\n      accountId: kind.ActorNoPermission.account_id,\n      actorId: kind.ActorNoPermission.actor_id,\n    };\n  }\n  if ('DeleteKeyDoesNotExist' in kind) {\n    return {\n      type: 'deleteKeyDoesNotExist',\n      accountId: kind.DeleteKeyDoesNotExist.account_id,\n      publicKey: kind.DeleteKeyDoesNotExist.public_key,\n    };\n  }\n  if ('AddKeyAlreadyExists' in kind) {\n    return {\n      type: 'addKeyAlreadyExists',\n      accountId: kind.AddKeyAlreadyExists.account_id,\n      publicKey: kind.AddKeyAlreadyExists.public_key,\n    };\n  }\n  if ('DeleteAccountStaking' in kind) {\n    return {\n      type: 'deleteAccountStaking',\n      accountId: kind.DeleteAccountStaking.account_id,\n    };\n  }\n  if ('LackBalanceForState' in kind) {\n    return {\n      type: 'lackBalanceForState',\n      accountId: kind.LackBalanceForState.account_id,\n      amount: kind.LackBalanceForState.amount,\n    };\n  }\n  if ('TriesToUnstake' in kind) {\n    return {\n      type: 'triesToUnstake',\n      accountId: kind.TriesToUnstake.account_id,\n    };\n  }\n  if ('TriesToStake' in kind) {\n    return {\n      type: 'triesToStake',\n      accountId: kind.TriesToStake.account_id,\n      stake: kind.TriesToStake.stake,\n      locked: kind.TriesToStake.locked,\n      balance: kind.TriesToStake.balance,\n    };\n  }\n  if ('InsufficientStake' in kind) {\n    return {\n      type: 'insufficientStake',\n      accountId: kind.InsufficientStake.account_id,\n      stake: kind.InsufficientStake.stake,\n      minimumStake: kind.InsufficientStake.minimum_stake,\n    };\n  }\n  if ('FunctionCallError' in kind) {\n    return {\n      type: 'functionCallError',\n      error: mapRpcFunctionCallError(kind.FunctionCallError),\n    };\n  }\n  if ('NewReceiptValidationError' in kind) {\n    return {\n      type: 'newReceiptValidationError',\n      error: mapRpcNewReceiptValidationError(kind.NewReceiptValidationError),\n    };\n  }\n  if ('OnlyImplicitAccountCreationAllowed' in kind) {\n    return {\n      type: 'onlyImplicitAccountCreationAllowed',\n      accountId: kind.OnlyImplicitAccountCreationAllowed.account_id,\n    };\n  }\n  if ('DeleteAccountWithLargeState' in kind) {\n    return {\n      type: 'deleteAccountWithLargeState',\n      accountId: kind.DeleteAccountWithLargeState.account_id,\n    };\n  }\n  return UNKNOWN_ERROR;\n}\n\nfunction mapRpcReceiptInvalidTxError(error) {\n  const UNKNOWN_ERROR = { type: 'unknown' };\n  if ('InvalidAccessKeyError' in error) {\n    return {\n      type: 'invalidAccessKeyError',\n      error: mapRpcInvalidAccessKeyError(error.InvalidAccessKeyError),\n    };\n  }\n  if ('InvalidSignerId' in error) {\n    return {\n      type: 'invalidSignerId',\n      signerId: error.InvalidSignerId.signer_id,\n    };\n  }\n  if ('SignerDoesNotExist' in error) {\n    return {\n      type: 'signerDoesNotExist',\n      signerId: error.SignerDoesNotExist.signer_id,\n    };\n  }\n  if ('InvalidNonce' in error) {\n    return {\n      type: 'invalidNonce',\n      transactionNonce: error.InvalidNonce.tx_nonce,\n      akNonce: error.InvalidNonce.ak_nonce,\n    };\n  }\n  if ('NonceTooLarge' in error) {\n    return {\n      type: 'nonceTooLarge',\n      transactionNonce: error.NonceTooLarge.tx_nonce,\n      upperBound: error.NonceTooLarge.upper_bound,\n    };\n  }\n  if ('InvalidReceiverId' in error) {\n    return {\n      type: 'invalidReceiverId',\n      receiverId: error.InvalidReceiverId.receiver_id,\n    };\n  }\n  if ('InvalidSignature' in error) {\n    return {\n      type: 'invalidSignature',\n    };\n  }\n  if ('NotEnoughBalance' in error) {\n    return {\n      type: 'notEnoughBalance',\n      signerId: error.NotEnoughBalance.signer_id,\n      balance: error.NotEnoughBalance.balance,\n      cost: error.NotEnoughBalance.cost,\n    };\n  }\n  if ('LackBalanceForState' in error) {\n    return {\n      type: 'lackBalanceForState',\n      signerId: error.LackBalanceForState.signer_id,\n      amount: error.LackBalanceForState.amount,\n    };\n  }\n  if ('CostOverflow' in error) {\n    return {\n      type: 'costOverflow',\n    };\n  }\n  if ('InvalidChain' in error) {\n    return {\n      type: 'invalidChain',\n    };\n  }\n  if ('Expired' in error) {\n    return {\n      type: 'expired',\n    };\n  }\n  if ('ActionsValidation' in error) {\n    return {\n      type: 'actionsValidation',\n    };\n  }\n  if ('TransactionSizeExceeded' in error) {\n    return {\n      type: 'transactionSizeExceeded',\n      size: error.TransactionSizeExceeded.size,\n      limit: error.TransactionSizeExceeded.limit,\n    };\n  }\n  return UNKNOWN_ERROR;\n}\n\nfunction mapRpcReceiptError(error) {\n  let UNKNOWN_ERROR = { type: 'unknown' };\n  if ('ActionError' in error) {\n    return {\n      type: 'action',\n      error: mapRpcReceiptActionError(error.ActionError),\n    };\n  }\n  if ('InvalidTxError' in error) {\n    return {\n      type: 'transaction',\n      error: mapRpcReceiptInvalidTxError(error.InvalidTxError),\n    };\n  }\n  return UNKNOWN_ERROR;\n}\n\nfunction mapRpcReceiptStatus(status) {\n  if ('SuccessValue' in status) {\n    return { type: 'successValue', value: status.SuccessValue };\n  }\n  if ('SuccessReceiptId' in status) {\n    return { type: 'successReceiptId', receiptId: status.SuccessReceiptId };\n  }\n  if ('Failure' in status) {\n    return { type: 'failure', error: mapRpcReceiptError(status.Failure) };\n  }\n  return { type: 'unknown' };\n}\n\nfunction mapRpcActionToAction1(rpcAction) {\n  if (typeof rpcAction === 'object' && 'Delegate' in rpcAction) {\n    return {\n      kind: 'delegateAction',\n      args: {\n        actions: rpcAction.Delegate.delegate_action.actions.map(\n          (subaction, index) => ({\n            ...mapNonDelegateRpcActionToAction(subaction),\n            delegateIndex: index,\n          }),\n        ),\n        receiverId: rpcAction.Delegate.delegate_action.receiver_id,\n        senderId: rpcAction.Delegate.delegate_action.sender_id,\n      },\n    };\n  }\n  return mapNonDelegateRpcActionToAction(rpcAction);\n}\n\nfunction parseOutcomeOld(outcome) {\n  return {\n    blockHash: outcome.block_hash,\n    tokensBurnt: outcome.outcome.tokens_burnt,\n    gasBurnt: outcome.outcome.gas_burnt,\n    status: mapRpcReceiptStatus(outcome.outcome.status),\n    logs: outcome.outcome.logs,\n    receiptIds: outcome.outcome.receipt_ids,\n  };\n}\nfunction parseOutcomeOld(outcome) {\n  return {\n    blockHash: outcome.block_hash,\n    tokensBurnt: outcome.outcome.tokens_burnt,\n    gasBurnt: outcome.outcome.gas_burnt,\n    status: mapRpcReceiptStatus(outcome.outcome.status),\n    logs: outcome.outcome.logs,\n    receiptIds: outcome.outcome.receipt_ids,\n  };\n}\nfunction parseReceipt(\n  receipt,\n  outcome,\n  transaction,\n) {\n  if (!receipt) {\n    return {\n      id: outcome.id,\n      predecessorId: transaction.signer_id,\n      receiverId: transaction.receiver_id,\n      actions: transaction.actions.map(mapRpcActionToAction1),\n    };\n  }\n  return {\n    id: receipt.receipt_id,\n    predecessorId: receipt.predecessor_id,\n    receiverId: receipt.receiver_id,\n    actions:\n      'Action' in receipt.receipt\n        ? receipt.receipt.Action.actions.map(mapRpcActionToAction1)\n        : [],\n  };\n}\n\nfunction mapNonDelegateRpcActionToAction(\n  rpcAction,\n) {\n  if (rpcAction === 'CreateAccount') {\n    return {\n      kind: 'createAccount',\n      args: {},\n    };\n  }\n  if ('DeployContract' in rpcAction) {\n    return {\n      kind: 'deployContract',\n      args: rpcAction.DeployContract,\n    };\n  }\n  if ('FunctionCall' in rpcAction) {\n    return {\n      kind: 'functionCall',\n      args: {\n        methodName: rpcAction.FunctionCall.method_name,\n        args: rpcAction.FunctionCall.args,\n        deposit: rpcAction.FunctionCall.deposit,\n        gas: rpcAction.FunctionCall.gas,\n      },\n    };\n  }\n  if ('Transfer' in rpcAction) {\n    return {\n      kind: 'transfer',\n      args: rpcAction.Transfer,\n    };\n  }\n  if ('Stake' in rpcAction) {\n    return {\n      kind: 'stake',\n      args: {\n        publicKey: rpcAction.Stake.public_key,\n        stake: rpcAction.Stake.stake,\n      },\n    };\n  }\n  if ('AddKey' in rpcAction) {\n    return {\n      kind: 'addKey',\n      args: {\n        publicKey: rpcAction.AddKey.public_key,\n        accessKey: {\n          nonce: rpcAction.AddKey.access_key.nonce,\n          permission:\n            rpcAction.AddKey.access_key.permission === 'FullAccess'\n              ? {\n                  type: 'fullAccess',\n                }\n              : {\n                  type: 'functionCall',\n                  contractId:\n                    rpcAction.AddKey.access_key.permission.FunctionCall\n                      .receiver_id,\n                  methodNames:\n                    rpcAction.AddKey.access_key.permission.FunctionCall\n                      .method_names,\n                },\n        },\n      },\n    };\n  }\n  if ('DeleteKey' in rpcAction) {\n    return {\n      kind: 'deleteKey',\n      args: {\n        publicKey: rpcAction.DeleteKey.public_key,\n      },\n    };\n  }\n  return {\n    kind: 'deleteAccount',\n    args: {\n      beneficiaryId: rpcAction.DeleteAccount.beneficiary_id,\n    },\n  };\n}\nfunction mapRpcInvalidAccessKeyError(error) {\n  const UNKNOWN_ERROR = { type: 'unknown' };\n\n  if (error === 'DepositWithFunctionCall') {\n    return {\n      type: 'depositWithFunctionCall',\n    };\n  }\n  if (error === 'RequiresFullAccess') {\n    return {\n      type: 'requiresFullAccess',\n    };\n  }\n  if ('AccessKeyNotFound' in error) {\n    const { account_id, public_key } = error.AccessKeyNotFound;\n    return {\n      type: 'accessKeyNotFound',\n      accountId: account_id,\n      publicKey: public_key,\n    };\n  }\n  if ('ReceiverMismatch' in error) {\n    const { ak_receiver, tx_receiver } = error.ReceiverMismatch;\n    return {\n      type: 'receiverMismatch',\n      akReceiver: ak_receiver,\n      transactionReceiver: tx_receiver,\n    };\n  }\n  if ('MethodNameMismatch' in error) {\n    const { method_name } = error.MethodNameMismatch;\n    return {\n      type: 'methodNameMismatch',\n      methodName: method_name,\n    };\n  }\n  if ('NotEnoughAllowance' in error) {\n    const { account_id, allowance, cost, public_key } =\n      error.NotEnoughAllowance;\n    return {\n      type: 'notEnoughAllowance',\n      accountId: account_id,\n      allowance: allowance,\n      cost: cost,\n      publicKey: public_key,\n    };\n  }\n\n  return UNKNOWN_ERROR;\n}\n\nfunction mapRpcCompilationError(error) {\n  const UNKNOWN_ERROR = { type: 'unknown' };\n  if ('CodeDoesNotExist' in error) {\n    return {\n      type: 'codeDoesNotExist',\n      accountId: error.CodeDoesNotExist.account_id,\n    };\n  }\n  if ('PrepareError' in error) {\n    return {\n      type: 'prepareError',\n    };\n  }\n  if ('WasmerCompileError' in error) {\n    return {\n      type: 'wasmerCompileError',\n      msg: error.WasmerCompileError.msg,\n    };\n  }\n  if ('UnsupportedCompiler' in error) {\n    return {\n      type: 'unsupportedCompiler',\n      msg: error.UnsupportedCompiler.msg,\n    };\n  }\n  return UNKNOWN_ERROR;\n}\n\nfunction mapRpcFunctionCallError(error) {\n  const UNKNOWN_ERROR = { type: 'unknown' };\n  if ('CompilationError' in error) {\n    return {\n      type: 'compilationError',\n      error: mapRpcCompilationError(error.CompilationError),\n    };\n  }\n  if ('LinkError' in error) {\n    return {\n      type: 'linkError',\n      msg: error.LinkError.msg,\n    };\n  }\n  if ('MethodResolveError' in error) {\n    return {\n      type: 'methodResolveError',\n    };\n  }\n  if ('WasmTrap' in error) {\n    return {\n      type: 'wasmTrap',\n    };\n  }\n  if ('WasmUnknownError' in error) {\n    return {\n      type: 'wasmUnknownError',\n    };\n  }\n  if ('HostError' in error) {\n    return {\n      type: 'hostError',\n    };\n  }\n  if ('_EVMError' in error) {\n    return {\n      type: 'evmError',\n    };\n  }\n  if ('ExecutionError' in error) {\n    return {\n      type: 'executionError',\n      error: error.ExecutionError,\n    };\n  }\n  return UNKNOWN_ERROR;\n}\nfunction mapRpcNewReceiptValidationError(error) {\n  const UNKNOWN_ERROR = { type: 'unknown' };\n  if ('InvalidPredecessorId' in error) {\n    return {\n      type: 'invalidPredecessorId',\n      accountId: error.InvalidPredecessorId.account_id,\n    };\n  }\n  if ('InvalidReceiverId' in error) {\n    return {\n      type: 'invalidReceiverId',\n      accountId: error.InvalidReceiverId.account_id,\n    };\n  }\n  if ('InvalidSignerId' in error) {\n    return {\n      type: 'invalidSignerId',\n      accountId: error.InvalidSignerId.account_id,\n    };\n  }\n  if ('InvalidDataReceiverId' in error) {\n    return {\n      type: 'invalidDataReceiverId',\n      accountId: error.InvalidDataReceiverId.account_id,\n    };\n  }\n  if ('ReturnedValueLengthExceeded' in error) {\n    return {\n      type: 'returnedValueLengthExceeded',\n      length: error.ReturnedValueLengthExceeded.length,\n      limit: error.ReturnedValueLengthExceeded.limit,\n    };\n  }\n  if ('NumberInputDataDependenciesExceeded' in error) {\n    return {\n      type: 'numberInputDataDependenciesExceeded',\n      numberOfInputDataDependencies:\n        error.NumberInputDataDependenciesExceeded\n          .number_of_input_data_dependencies,\n      limit: error.NumberInputDataDependenciesExceeded.limit,\n    };\n  }\n  if ('ActionsValidation' in error) {\n    return {\n      type: 'actionsValidation',\n    };\n  }\n  return UNKNOWN_ERROR;\n}\n\nfunction mapRpcReceiptActionError(error) {\n  const UNKNOWN_ERROR = { type: 'unknown' };\n  const { kind } = error;\n  if (kind === 'DelegateActionExpired') {\n    return {\n      type: 'delegateActionExpired',\n    };\n  }\n  if (kind === 'DelegateActionInvalidSignature') {\n    return {\n      type: 'delegateActionInvalidSignature',\n    };\n  }\n  if ('DelegateActionSenderDoesNotMatchTxReceiver' in kind) {\n    return {\n      type: 'delegateActionSenderDoesNotMatchTxReceiver',\n      receiverId: kind.DelegateActionSenderDoesNotMatchTxReceiver.receiver_id,\n      senderId: kind.DelegateActionSenderDoesNotMatchTxReceiver.sender_id,\n    };\n  }\n  if ('DelegateActionAccessKeyError' in kind) {\n    return {\n      type: 'delegateActionAccessKeyError',\n      error: mapRpcInvalidAccessKeyError(kind.DelegateActionAccessKeyError),\n    };\n  }\n  if ('DelegateActionInvalidNonce' in kind) {\n    return {\n      type: 'delegateActionInvalidNonce',\n      akNonce: kind.DelegateActionInvalidNonce.ak_nonce,\n      delegateNonce: kind.DelegateActionInvalidNonce.delegate_nonce,\n    };\n  }\n  if ('DelegateActionNonceTooLarge' in kind) {\n    return {\n      type: 'delegateActionNonceTooLarge',\n      delegateNonce: kind.DelegateActionNonceTooLarge.delegate_nonce,\n      upperBound: kind.DelegateActionNonceTooLarge.upper_bound,\n    };\n  }\n  if ('AccountAlreadyExists' in kind) {\n    return {\n      type: 'accountAlreadyExists',\n      accountId: kind.AccountAlreadyExists.account_id,\n    };\n  }\n  if ('AccountDoesNotExist' in kind) {\n    return {\n      type: 'accountDoesNotExist',\n      accountId: kind.AccountDoesNotExist.account_id,\n    };\n  }\n  if ('CreateAccountOnlyByRegistrar' in kind) {\n    return {\n      type: 'createAccountOnlyByRegistrar',\n      accountId: kind.CreateAccountOnlyByRegistrar.account_id,\n      registrarAccountId:\n        kind.CreateAccountOnlyByRegistrar.registrar_account_id,\n      predecessorId: kind.CreateAccountOnlyByRegistrar.predecessor_id,\n    };\n  }\n  if ('CreateAccountNotAllowed' in kind) {\n    return {\n      type: 'createAccountNotAllowed',\n      accountId: kind.CreateAccountNotAllowed.account_id,\n      predecessorId: kind.CreateAccountNotAllowed.predecessor_id,\n    };\n  }\n  if ('ActorNoPermission' in kind) {\n    return {\n      type: 'actorNoPermission',\n      accountId: kind.ActorNoPermission.account_id,\n      actorId: kind.ActorNoPermission.actor_id,\n    };\n  }\n  if ('DeleteKeyDoesNotExist' in kind) {\n    return {\n      type: 'deleteKeyDoesNotExist',\n      accountId: kind.DeleteKeyDoesNotExist.account_id,\n      publicKey: kind.DeleteKeyDoesNotExist.public_key,\n    };\n  }\n  if ('AddKeyAlreadyExists' in kind) {\n    return {\n      type: 'addKeyAlreadyExists',\n      accountId: kind.AddKeyAlreadyExists.account_id,\n      publicKey: kind.AddKeyAlreadyExists.public_key,\n    };\n  }\n  if ('DeleteAccountStaking' in kind) {\n    return {\n      type: 'deleteAccountStaking',\n      accountId: kind.DeleteAccountStaking.account_id,\n    };\n  }\n  if ('LackBalanceForState' in kind) {\n    return {\n      type: 'lackBalanceForState',\n      accountId: kind.LackBalanceForState.account_id,\n      amount: kind.LackBalanceForState.amount,\n    };\n  }\n  if ('TriesToUnstake' in kind) {\n    return {\n      type: 'triesToUnstake',\n      accountId: kind.TriesToUnstake.account_id,\n    };\n  }\n  if ('TriesToStake' in kind) {\n    return {\n      type: 'triesToStake',\n      accountId: kind.TriesToStake.account_id,\n      stake: kind.TriesToStake.stake,\n      locked: kind.TriesToStake.locked,\n      balance: kind.TriesToStake.balance,\n    };\n  }\n  if ('InsufficientStake' in kind) {\n    return {\n      type: 'insufficientStake',\n      accountId: kind.InsufficientStake.account_id,\n      stake: kind.InsufficientStake.stake,\n      minimumStake: kind.InsufficientStake.minimum_stake,\n    };\n  }\n  if ('FunctionCallError' in kind) {\n    return {\n      type: 'functionCallError',\n      error: mapRpcFunctionCallError(kind.FunctionCallError),\n    };\n  }\n  if ('NewReceiptValidationError' in kind) {\n    return {\n      type: 'newReceiptValidationError',\n      error: mapRpcNewReceiptValidationError(kind.NewReceiptValidationError),\n    };\n  }\n  if ('OnlyImplicitAccountCreationAllowed' in kind) {\n    return {\n      type: 'onlyImplicitAccountCreationAllowed',\n      accountId: kind.OnlyImplicitAccountCreationAllowed.account_id,\n    };\n  }\n  if ('DeleteAccountWithLargeState' in kind) {\n    return {\n      type: 'deleteAccountWithLargeState',\n      accountId: kind.DeleteAccountWithLargeState.account_id,\n    };\n  }\n  return UNKNOWN_ERROR;\n}\n\nfunction mapRpcReceiptInvalidTxError(error) {\n  const UNKNOWN_ERROR = { type: 'unknown' };\n  if ('InvalidAccessKeyError' in error) {\n    return {\n      type: 'invalidAccessKeyError',\n      error: mapRpcInvalidAccessKeyError(error.InvalidAccessKeyError),\n    };\n  }\n  if ('InvalidSignerId' in error) {\n    return {\n      type: 'invalidSignerId',\n      signerId: error.InvalidSignerId.signer_id,\n    };\n  }\n  if ('SignerDoesNotExist' in error) {\n    return {\n      type: 'signerDoesNotExist',\n      signerId: error.SignerDoesNotExist.signer_id,\n    };\n  }\n  if ('InvalidNonce' in error) {\n    return {\n      type: 'invalidNonce',\n      transactionNonce: error.InvalidNonce.tx_nonce,\n      akNonce: error.InvalidNonce.ak_nonce,\n    };\n  }\n  if ('NonceTooLarge' in error) {\n    return {\n      type: 'nonceTooLarge',\n      transactionNonce: error.NonceTooLarge.tx_nonce,\n      upperBound: error.NonceTooLarge.upper_bound,\n    };\n  }\n  if ('InvalidReceiverId' in error) {\n    return {\n      type: 'invalidReceiverId',\n      receiverId: error.InvalidReceiverId.receiver_id,\n    };\n  }\n  if ('InvalidSignature' in error) {\n    return {\n      type: 'invalidSignature',\n    };\n  }\n  if ('NotEnoughBalance' in error) {\n    return {\n      type: 'notEnoughBalance',\n      signerId: error.NotEnoughBalance.signer_id,\n      balance: error.NotEnoughBalance.balance,\n      cost: error.NotEnoughBalance.cost,\n    };\n  }\n  if ('LackBalanceForState' in error) {\n    return {\n      type: 'lackBalanceForState',\n      signerId: error.LackBalanceForState.signer_id,\n      amount: error.LackBalanceForState.amount,\n    };\n  }\n  if ('CostOverflow' in error) {\n    return {\n      type: 'costOverflow',\n    };\n  }\n  if ('InvalidChain' in error) {\n    return {\n      type: 'invalidChain',\n    };\n  }\n  if ('Expired' in error) {\n    return {\n      type: 'expired',\n    };\n  }\n  if ('ActionsValidation' in error) {\n    return {\n      type: 'actionsValidation',\n    };\n  }\n  if ('TransactionSizeExceeded' in error) {\n    return {\n      type: 'transactionSizeExceeded',\n      size: error.TransactionSizeExceeded.size,\n      limit: error.TransactionSizeExceeded.limit,\n    };\n  }\n  return UNKNOWN_ERROR;\n}\n\nfunction mapRpcReceiptError(error) {\n  let UNKNOWN_ERROR = { type: 'unknown' };\n  if ('ActionError' in error) {\n    return {\n      type: 'action',\n      error: mapRpcReceiptActionError(error.ActionError),\n    };\n  }\n  if ('InvalidTxError' in error) {\n    return {\n      type: 'transaction',\n      error: mapRpcReceiptInvalidTxError(error.InvalidTxError),\n    };\n  }\n  return UNKNOWN_ERROR;\n}\n\nfunction mapRpcReceiptStatus(status) {\n  if ('SuccessValue' in status) {\n    return { type: 'successValue', value: status.SuccessValue };\n  }\n  if ('SuccessReceiptId' in status) {\n    return { type: 'successReceiptId', receiptId: status.SuccessReceiptId };\n  }\n  if ('Failure' in status) {\n    return { type: 'failure', error: mapRpcReceiptError(status.Failure) };\n  }\n  return { type: 'unknown' };\n}\n\nfunction mapRpcActionToAction1(rpcAction) {\n  if (typeof rpcAction === 'object' && 'Delegate' in rpcAction) {\n    return {\n      kind: 'delegateAction',\n      args: {\n        actions: rpcAction.Delegate.delegate_action.actions.map(\n          (subaction, index) => ({\n            ...mapNonDelegateRpcActionToAction(subaction),\n            delegateIndex: index,\n          }),\n        ),\n        receiverId: rpcAction.Delegate.delegate_action.receiver_id,\n        senderId: rpcAction.Delegate.delegate_action.sender_id,\n      },\n    };\n  }\n  return mapNonDelegateRpcActionToAction(rpcAction);\n}\n\nfunction parseOutcomeOld(outcome) {\n  return {\n    blockHash: outcome.block_hash,\n    tokensBurnt: outcome.outcome.tokens_burnt,\n    gasBurnt: outcome.outcome.gas_burnt,\n    status: mapRpcReceiptStatus(outcome.outcome.status),\n    logs: outcome.outcome.logs,\n    receiptIds: outcome.outcome.receipt_ids,\n  };\n}\n/* END_INCLUDE: \"includes/near.jsx\" */\n\n\n\n\n\n\n\nfunction MainComponent(props) {\n  const { network, rpcTxn, t } = props;\n  const [receipt, setReceipt] = useState\n\n(null);\n  const config = getConfig(network);\n  const [expandAll, setExpandAll] = useState(false);\n  const expandAllReceipts = useCallback(\n    () => setExpandAll((x) => !x),\n    [setExpandAll],\n  );\n\n  function transactionReceipts(txn) {\n    const receiptsMap = txn.receipts_outcome.reduce(\n      (mapping, receiptOutcome) => {\n        const receipt = parseReceipt(\n          txn.receipts.find(\n            (rpcReceipt) => rpcReceipt.receipt_id === receiptOutcome.id,\n          ),\n          receiptOutcome,\n          txn.transaction,\n        );\n        return mapping.set(receiptOutcome.id, {\n          ...receipt,\n          outcome: parseOutcomeOld(receiptOutcome),\n        });\n      },\n      new Map(),\n    );\n\n    const receipts = collectNestedReceiptWithOutcomeOld(\n      txn.transaction_outcome.outcome.receipt_ids[0],\n      receiptsMap,\n    );\n\n    return receipts;\n  }\n\n  useEffect(() => {\n    if (rpcTxn) {\n      const receipt = transactionReceipts(rpcTxn);\n      setReceipt(receipt);\n    }\n  }, [rpcTxn, receipt?.block_hash, config.backendUrl]);\n\n  const Loader = (props) => {\n    return (\n      <div\n        className={`bg-gray-200 h-5 rounded shadow-sm animate-pulse ${props.className}`}\n      ></div>\n    );\n  };\n\n  return (\n    <div className=\"text-sm text-nearblue-600 divide-solid divide-gray-200 divide-y\">\n      <div className=\"flex flex-col w-full mx-auto divide-y\">\n        <div className=\"flex justify-end w-full p-4 items-center\">\n          <div\n            className=\"cursor-pointer mx-1 flex items-center text-nearblue-600 font-medium py-1 border border-neargray-700 px-2 rounded-md bg-whit select-none\"\n            onClick={expandAllReceipts}\n          >\n            Expand all <span>+</span>\n          </div>\n        </div>\n        <div className=\"p-8\">\n          {!receipt ? (\n            <div className=\"w-full md:w-3/4\">\n              <Loader wrapperClassName=\"flex w-full my-1 max-w-xs\" />\n              <Loader wrapperClassName=\"flex w-full\" />\n              <Loader wrapperClassName=\"flex w-full\" />\n              <Loader wrapperClassName=\"flex w-full\" />\n            </div>\n          ) : (\n            <Widget\n              src={`${config.ownerId}/widget/bos-components.components.Transactions.TransactionReceipt`}\n              props={{\n                network: network,\n                t: t,\n                receipt: receipt,\n                expandAll: expandAll,\n                fellowOutgoingReceipts: [],\n                convertionReceipt: true,\n                className: '',\n              }}\n            />\n          )}\n        </div>\n      </div>\n    </div>\n  );\n}\n\nreturn MainComponent(props, context);", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/nearblocks.near/widget/bos-components.components.Transactions.Execution", "fact_widget_deployments_id": "f80e6853fb93e829c01dee0059139395", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 3}