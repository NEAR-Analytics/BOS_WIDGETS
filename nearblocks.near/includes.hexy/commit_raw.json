{"tx_hash": "8xS2NXE1ohg9KhsUj2uMDn212jMnrBXkjQAQuES2wd8v", "action_id_social": "8cpL3sg48joUz5dZ7PGm35bvj8Jeh6iTQtnX81Lu3k8V-0-widget", "block_id": 114693059, "block_timestamp": "2024-03-14T12:45:23.868Z", "signer_id": "nearblocks.near", "widget_name": "includes.hexy", "source_code": "export function hexy(buffer, config) {\n  const MAX_ADDRESS_LENGTH = 8;\n  const defaults = {\n    width: 16,\n    numbering: 'hex_bytes',\n    format: 'fours',\n    littleEndian: false,\n    radix: 16,\n    caps: 'lower',\n    annotate: 'ascii',\n    prefix: '',\n    indent: 0,\n    html: false,\n    offset: 0,\n    length: -1,\n    extendedChs: false,\n    display_offset: 0,\n  };\n  const options = { ...defaults, ...config };\n\n  let bufferData;\n  if (Buffer.isBuffer(buffer)) {\n    bufferData = buffer;\n  } else if (Array.isArray(buffer)) {\n    bufferData = Buffer.from(buffer);\n  } else {\n    throw new Error('Input must be a Buffer or an array of numbers.');\n  }\n\n  const {\n    width,\n    numbering,\n    format,\n    littleEndian,\n    radix,\n    annotate,\n    indent,\n    html,\n    offset,\n    length,\n    extendedChs,\n    display_offset,\n  } = options;\n\n  const prefixSpaces = ' '.repeat(indent);\n  const htmlOpenTag = html ? \"<div class='hexy'>\\n\" : '';\n  const htmlCloseTag = html ? '</div>\\n' : '';\n\n  const bufferSlice = bufferData.slice(\n    offset,\n    length === -1 ? undefined : offset + length,\n  );\n  let str = htmlOpenTag;\n  let addr = offset + display_offset;\n\n  const numGroups = Math.ceil(bufferSlice.length / width);\n\n  for (let group = 0; group < numGroups; group++) {\n    const startIndex = group * width;\n    const endIndex = Math.min(startIndex + width, bufferSlice.length);\n    const slice = bufferSlice.slice(startIndex, endIndex);\n\n    if (html) {\n      str += `<div class='${num2str(addr, MAX_ADDRESS_LENGTH, 16)}'>`;\n    }\n\n    str += `${prefixSpaces}${\n      numbering === 'hex_bytes'\n        ? num2str(addr, MAX_ADDRESS_LENGTH, 16) + ': '\n        : ''\n    }`;\n    str += hex(slice, width, format, radix, littleEndian);\n\n    if (annotate === 'ascii') {\n      str += ` ${\n        html\n          ? html_escape(getTextRepresentation(slice, extendedChs))\n          : ascii_escape(getTextRepresentation(slice, extendedChs))\n      }`;\n    }\n\n    str += html ? '</div>\\n' : '\\n';\n    addr += width;\n  }\n\n  str += htmlCloseTag;\n\n  return str;\n}\n\nfunction hex(\n  buffer,\n  width,\n  format,\n  radix,\n  littleEndian,\n) {\n  let str = '';\n  const delimiter = format === 'none' ? '' : ' ';\n  const group_len = maxnumberlen(format === 'none' ? 1 : 2, radix);\n  const padlen =\n    (width - buffer.length) *\n    (format === 'none' ? group_len : (group_len + 1) / 2);\n\n  const numGroups = Math.ceil(buffer.length / 2);\n\n  for (let group = 0; group < numGroups; ++group) {\n    const startIndex = group * 2;\n    const endIndex = Math.min(startIndex + 2, buffer.length);\n    const bytes = buffer.slice(startIndex, endIndex);\n\n    if (bytes.length === 0) break;\n\n    if (bytes.length === 2) {\n      let val = littleEndian ? bytes.readUInt16LE(0) : bytes.readUInt16BE(0);\n      const text = val.toString(radix);\n      str += '0'.repeat(group_len - text.length) + text;\n      str += delimiter;\n    } else {\n      str += '0'.repeat(group_len);\n      str += delimiter;\n    }\n  }\n\n  if (buffer.length < width) {\n    str += ' '.repeat(padlen);\n  }\n\n  return str;\n}\n\nfunction num2str(b, len, radix) {\n  const s = b.toString(radix);\n  return '0'.repeat(len - s.length) + s;\n}\n\nfunction maxnumberlen(bytes, radix) {\n  let result = 2;\n  if (bytes === 0) {\n    bytes = 1;\n  }\n  switch (radix) {\n    case 2:\n      result = bytes * 8;\n      break;\n    case 8:\n      switch (bytes) {\n        case 1:\n          result = 3;\n          break;\n        case 2:\n          result = 6;\n          break;\n        case 4:\n          result = 11;\n          break;\n        case 8:\n          result = 22;\n          break;\n      }\n      break;\n    case 10:\n      switch (bytes) {\n        case 1:\n          result = 3;\n          break;\n        case 2:\n          result = 6;\n          break;\n        case 4:\n          result = 10;\n          break;\n        case 8:\n          result = 20;\n          break;\n      }\n      break;\n    case 16:\n      result = 2 * bytes;\n      break;\n  }\n  return result;\n}\n\nfunction getTextRepresentation(buffer, extendedChs) {\n  let text = '';\n  for (const byte of buffer) {\n    if (extendedChs) {\n      text += byte >= 32 && byte <= 126 ? String.fromCharCode(byte) : '.';\n    } else {\n      text += byte >= 32 && byte <= 126 ? String.fromCharCode(byte) : '.';\n    }\n  }\n  return text;\n}\n\nfunction ascii_escape(str) {\n  return str.replace(/[^\\x20-\\x7E]/g, '.');\n}\n\nfunction html_escape(str) {\n  return str\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\\'/g, '&apos;')\n    .replace(/\\\"/g, '&quot;')\n    .replace(/[^\\x20-\\x7E]/g, function (ch) {\n      return '&#x' + ch.codePointAt(0)?.toString(16) + ';';\n    });\n}\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/nearblocks.near/widget/includes.hexy", "fact_widget_deployments_id": "6d015484fb6740c55ac12a59042ce303", "inserted_timestamp": "2024-03-14T14:27:27.073Z", "modified_timestamp": "2024-03-14T14:27:27.073Z", "__row_index": 0}