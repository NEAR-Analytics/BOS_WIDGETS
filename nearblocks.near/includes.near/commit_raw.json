{"tx_hash": "Cizf9kN45VdYgGArsJuCU9dGdEUW1Gxh3THuqCXAqZbX", "action_id_social": "DAb29isUSfiqPPWMPNGASHA6vcQR7cwMYPmEtHP9Zgt5-0-widget", "block_id": 109569508, "block_timestamp": "2024-01-04T12:15:08.096Z", "signer_id": "nearblocks.near", "widget_name": "includes.near", "source_code": "import { localFormat } from '@/includes/formats';\nimport { yoctoToNear } from '@/includes/libs';\n\n\n\n\n\n\n\nexport function encodeArgs(args) {\n  if (!args || typeof args === 'undefined') return '';\n\n  return Buffer.from(JSON.stringify(args)).toString('base64');\n}\n\nexport function decodeArgs(args) {\n  if (!args || typeof args === 'undefined') return {};\n\n  const encodedString = Buffer.from(args).toString('base64');\n  return JSON.parse(Buffer.from(encodedString, 'base64').toString());\n}\n\nexport function txnMethod(\n  actions,\n  t,\n) {\n  const count = actions?.length || 0;\n\n  if (!count) return t ? t('txns:unknownType') : 'Unknown';\n  if (count > 1) return t ? t('txns:batchTxns') : 'Batch Transaction';\n\n  const action = actions[0];\n\n  if (action.action === 'FUNCTION_CALL') {\n    return action.method;\n  }\n\n  return action.action;\n}\n\nexport function gasPrice(yacto) {\n  const near = Big(yoctoToNear(yacto, false)).mul(Big(10).pow(12)).toString();\n\n  return `${localFormat(near)} \u24c3 / Tgas`;\n}\n\nexport function tokenAmount(amount, decimal, format) {\n  if (amount === undefined || amount === null) return 'N/A';\n\n  const near = Big(amount).div(Big(10).pow(+decimal));\n\n  return format\n    ? near.toString().toLocaleString(undefined, {\n        minimumFractionDigits: 0,\n        maximumFractionDigits: 8,\n      })\n    : near;\n}\n\nexport function mapRpcActionToAction(action) {\n  if (action === 'CreateAccount') {\n    return {\n      action_kind: 'CreateAccount',\n      args: {},\n    };\n  }\n\n  if (typeof action === 'object') {\n    const kind = Object.keys(action)[0];\n\n    return {\n      action_kind: kind,\n      args: action[kind],\n    };\n  }\n\n  return null;\n}\n\nconst valueFromObj = (obj) => {\n  const keys = Object.keys(obj);\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const value = obj[key];\n\n    if (typeof value === 'string') {\n      return value;\n    }\n\n    if (typeof value === 'object') {\n      const nestedValue = valueFromObj(value );\n      if (nestedValue) {\n        return nestedValue;\n      }\n    }\n  }\n\n  return undefined;\n};\n\nexport function txnLogs(txn) {\n  let txLogs = [];\n\n  const outcomes = txn?.receipts_outcome || [];\n\n  for (let i = 0; i < outcomes.length; i++) {\n    const outcome = outcomes[i];\n    let logs = outcome?.outcome?.logs || [];\n\n    if (logs.length > 0) {\n      const mappedLogs = logs.map((log) => ({\n        contract: outcome?.outcome?.executor_id || '',\n        logs: log,\n      }));\n      txLogs = [...txLogs, ...mappedLogs];\n    }\n  }\n\n  return txLogs;\n}\n\nexport function txnActions(txn) {\n  const txActions = [];\n  const receipts = txn?.receipts || [];\n\n  for (let i = 0; i < receipts.length; i++) {\n    const receipt = receipts[i];\n    const from = receipt?.predecessor_id;\n    const to = receipt?.receiver_id;\n\n    if (Array.isArray(receipt?.receipt)) {\n      const actions = receipt.receipt;\n\n      for (let j = 0; j < actions.length; j++) {\n        const action = actions[j];\n\n        txActions.push({ from, to, ...action });\n      }\n    } else {\n      const actions = receipt?.receipt?.Action?.actions || [];\n\n      for (let j = 0; j < actions.length; j++) {\n        const action = mapRpcActionToAction(actions[j]);\n\n        txActions.push({ from, to, ...action });\n      }\n    }\n  }\n\n  return txActions.filter(\n    (action) =>\n      action.action_kind !== 'FunctionCall' && action.from !== 'system',\n  );\n}\n\nexport function txnErrorMessage(txn) {\n  const kind = txn?.status?.Failure?.ActionError?.kind;\n\n  if (typeof kind === 'string') return kind;\n  if (typeof kind === 'object') {\n    return valueFromObj(kind);\n  }\n\n  return null;\n}\n\nexport function formatLine(line, offset, format) {\n  let result = `${offset.toString(16).padStart(8, '0')}  `;\n\n  const bytes = line.split(' ').filter(Boolean);\n  bytes.forEach((byte, index) => {\n    if (index > 0 && index % 4 === 0) {\n      result += ' ';\n    }\n    result += byte.toUpperCase().padEnd(2, ' ') + ' ';\n  });\n\n  if (format === 'default') {\n    result += ` ${String.fromCharCode(\n      ...bytes.map((b) => parseInt(b, 16)),\n    )}`;\n  }\n\n  return result.trimEnd();\n}\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/nearblocks.near/widget/includes.near", "fact_widget_deployments_id": "a5611c5830fade9f6908f12b18736c7d", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 14}