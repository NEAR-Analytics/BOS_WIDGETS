{"tx_hash": "A8pmw2m6ks6hVEQeuSmW1PCcJ7BL53d5ckSLsL7FPH1A", "action_id_social": "7NHCwhZK8YuZMV75nk2HWLhfeYHVRfC5hwVJm3b8qeFm-0-widget", "block_id": 114592680, "block_timestamp": "2024-03-12T23:12:50.954Z", "signer_id": "microchipgnu.near", "widget_name": "Agent", "source_code": "const tools = props.tools || [];\nconst role = props.role || \"Helpful Assistant\";\nconst backstory =\n  props.backstory ||\n  \"You are an experienced assistant. You have many years of experience helping people.\";\nconst goal =\n  props.goal ||\n  \"Your goal is to assist the best way possible user requests. You have the capability of making decisions\";\n\nconst ACTION_PREFIX = \"Action:\";\nconst ACTION_INPUT_PREFIX = \"Action Input:\";\nconst OBSERVATION_PREFIX = \"Observation:\";\nconst FINAL_ANSWER_PREFIX = \"Final Answer:\";\nconst THOUGHT_PREFIX = \"Thought:\";\nconst MAX_ITERATIONS_DEFAULT = 100;\n\nconst [task, setTask] = useState(\"\");\nconst [scratchPad, setScratchPad] = useState(\"\");\nconst [messages, setMessages] = useState([]);\nconst [loading, setLoading] = useState(false);\n\nconst Wrapper = styled.div`\n  display: flex;\n  flex-direction: column;\n  gap: 48px;\n  padding: 48px;\n`;\n\nconst buildPrompt = (tools, role, goal, backstory) => `\n  You are ${role}.\n  ${backstory}\n  \n  Your personal goal is: ${goal}\n  \n  ${\n    tools.length > 0 &&\n    tools.map((tool) => {\n      return `\n    TOOLS:\n    ------\n    You have access to the following tools:\n    ${tool.name} - ${tool.description} - for this tool input MUST be ${\n        tool.inputDescription ?? \"null\"\n      }\\n`;\n    })\n  }\n  \n  Use the following format in your response:\n  \n  ${THOUGHT_PREFIX} Do I need to use a tool? Yes\n  ${ACTION_PREFIX} the action to take, should be one of [${tools\n  .map((tool) => tool.name)\n  .join(\",\")}]\n  ${ACTION_INPUT_PREFIX} the input to the action\n  ${OBSERVATION_PREFIX} the result of the action\n  \n  ... (this Thought/Action/Action Input/Observation can repeat N times)\n  \n  When you have a response for your task, or if you DO NOT need to use a tool, you MUST use the format:\n  \n  ${THOUGHT_PREFIX} Do I need to use a tool? No\n  ${FINAL_ANSWER_PREFIX} the final answer to the original input question\n  \n  Begin! Solve the following tasks as best you can. This is VERY important to you, your job depends on it!\n  `;\n\nconst parseMessageToStructuredFormatWithRegex = (message) => {\n  const result = { actions: [], observations: [], finalAnswer: \"\" };\n  const lines = message.split(\"\\n\");\n\n  // Updated regex to capture tool name and action separately\n  const actionRegex = /^Action: (.+)/;\n  const actionInputRegex = /^Action Input: (.+)/;\n  const observationRegex = /^Observation: (.+)/;\n  const finalAnswerRegex = /^Final Answer: (.+)/;\n\n  lines.forEach((line) => {\n    let match;\n    if ((match = line.match(actionRegex))) {\n      // Directly add action details to the actions array\n      const tool = match[1];\n      const content = match[2];\n      result.actions.push({ tool, content }); // Assuming the next line is always the action input\n    } else if ((match = line.match(actionInputRegex))) {\n      // Attach input to the last action\n      const lastAction = result.actions[result.actions.length - 1];\n      if (lastAction) {\n        lastAction.input = match[1];\n      }\n    } else if ((match = line.match(observationRegex))) {\n      // Add observation\n      result.observations.push({ content: match[1] });\n    } else if ((match = line.match(finalAnswerRegex))) {\n      // Set final answer\n      result.finalAnswer = match[1];\n    }\n  });\n\n  // Convert the result object to the expected array format\n  const formattedResult = [];\n  if (result.actions.length > 0) {\n    formattedResult.push({ type: \"actions\", actions: result.actions });\n  }\n  result.observations.forEach((observation) => {\n    formattedResult.push({ type: \"observation\", content: observation.content });\n  });\n  if (result.finalAnswer) {\n    formattedResult.push({ type: \"finalAnswer\", content: result.finalAnswer });\n  }\n\n  return formattedResult;\n};\nconst nearLlama = async (messages) => {\n  return asyncFetch(`https://ai.near.social/api`, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    responseType: \"json\",\n    body: JSON.stringify(messages),\n  }).then((response) => {\n    return response.body.response;\n  });\n};\n\nconst toolToUse = (tool) => {\n  return tools.find((tool) => tool.name === action.tool);\n};\n\nconst run = () => {\n  let iteration = Math.ceil(messages.length / 2);\n  let _scratchPad = scratchPad || \"\";\n\n  if (iteration >= MAX_ITERATIONS_DEFAULT) {\n    setLoading(false);\n    console.log(\"Max iterations reached or stopping condition met\");\n    return; // Stop the iteration loop\n  }\n\n  setLoading(true);\n\n  const systemPrompt = `\n    ${buildPrompt(tools, role, goal, backstory)}\n    Current task: ${task}\\n\n  `;\n\n  const userPrompt = `The SCRATCHPAD contains the context you're working with! I only see what you return as \"${FINAL_ANSWER_PREFIX}\"\\nYou have ${\n    MAX_ITERATIONS_DEFAULT - iteration\n  } iterations left to provide a final answer.\\n Here is the SCRATCHPAD:\\n----\n    \"\"\"\n    ${_scratchPad}\n    \"\"\"\n  `;\n\n  const _messages = [\n    { role: \"system\", content: systemPrompt },\n    { role: \"user\", content: userPrompt },\n  ];\n\n  nearLlama(_messages)\n    .then((response) => {\n      let _scratchPad = \"\";\n      const parsedResponse = parseMessageToStructuredFormatWithRegex(response);\n\n      for (const activity of parsedResponse) {\n        console.log(activity);\n        if (activity.type === \"observation\") {\n          _scratchPad += `${OBSERVATION_PREFIX} ${activity.content}\\n`;\n        }\n\n        if (activity.type === \"finalAnswer\") {\n          _scratchPad += `${OBSERVATION_PREFIX} ${activity.content}\\n`;\n        }\n\n        if (activity.type === \"actions\") {\n          for (const action of activity.actions) {\n            console.log(action);\n            const tool = toolToUse(action.tool);\n\n            if (tool) {\n              /** TODO: Implement tool execution */\n            } else {\n              _scratchPad += `${OBSERVATION_PREFIX} ${action.tool} does not exist\\n`;\n            }\n          }\n        }\n      }\n\n      setScratchPad(_scratchPad);\n\n      const newMessages = [\n        ...messages,\n        { role: \"assistant\", content: _scratchPad, activity: parsedResponse },\n      ];\n\n      setMessages(newMessages);\n\n      setLoading(false);\n    })\n    .catch((error) => {\n      console.error(\"Error:\", error);\n      setLoading(false); // Ensure loading is stopped in case of error\n    });\n};\n\nuseEffect(() => {\n  setMessages([]);\n}, [task]);\n\nreturn (\n  <Wrapper>\n    <div className=\"input-group mb-3\">\n      <input\n        type=\"text\"\n        className=\"form-control\"\n        value={task}\n        onChange={(e) => setTask(e.target.value)}\n        onKeyPress={(e) => {\n          if (e.key === \"Enter\") {\n            run();\n          }\n        }}\n        placeholder=\"What's your goal?\"\n        autoFocus\n      />\n      <Widget\n        src=\"near/widget/DIG.Button\"\n        className=\"btn btn-dark w-100\"\n        props={{\n          onClick: () => run(),\n          variant: \"affirmative\",\n          fill: \"solid\",\n          size: \"large\",\n          label: \"Submit\",\n          style: {\n            borderTopLeftRadius: \"0rem\",\n            borderBottomLeftRadius: \"0rem\",\n          },\n        }}\n      />\n    </div>\n\n    <div className=\"flex-fill overflow-auto px-4 py-2 space-y-2\">\n      {messages.map((message, index) => (\n        <div\n          key={index}\n          className=\"p-2 bg-light rounded shadow-sm d-flex flex-column mb-2\"\n        >\n          <div className=\"fw-bold text-large\">\n            {message.role === \"assistant\" ? \"AutoAgent\" : \"\"}\n          </div>\n          <div>\n            {message.role === \"assistant\" &&\n              message.activity.map((result, index) => {\n                if (result.type === \"actions\") {\n                  return result.actions.map((action, index) => (\n                    <div\n                      key={index}\n                      className=\"text-sm d-flex flex-column mb-4\"\n                    >\n                      <div key={index} className=\"text-sm\">\n                        {action.tool} - {action.input}\n                      </div>\n                      {toolToUse(action.tool) && <button>Execute</button>}\n                    </div>\n                  ));\n                }\n                if (result.type === \"observation\") {\n                  return (\n                    <div\n                      key={index}\n                      className=\"text-sm mb-4 d-flex flex-column\"\n                    >\n                      <div className=\"fw-bold\">Observation </div>\n                      {result.content}\n                    </div>\n                  );\n                }\n                if (result.type === \"finalAnswer\") {\n                  return (\n                    <div\n                      key={index}\n                      className=\"text-sm mb-4 d-flex flex-column\"\n                    >\n                      <div className=\"fw-bold\">Final Answer </div>\n                      {result.content}\n                    </div>\n                  );\n                }\n              })}\n          </div>\n        </div>\n      ))}\n\n      {loading && (\n        <div key=\"loading\" className={`d-flex align-items-center`}>\n          <div>\n            <span\n              className=\"spinner-grow spinner-grow-sm me-1\"\n              role=\"status\"\n              aria-hidden=\"true\"\n            />\n          </div>\n        </div>\n      )}\n\n      {messages.length > 0 && !loading && (\n        <button onClick={() => run()} className=\"btn btn-dark w-100 mt-2\">\n          Continue\n        </button>\n      )}\n    </div>\n  </Wrapper>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/microchipgnu.near/widget/Agent", "fact_widget_deployments_id": "3a5ba3d2d8dc788eff17451e394327d7", "inserted_timestamp": "2024-03-13T00:39:48.506Z", "modified_timestamp": "2024-03-13T00:39:48.506Z", "__row_index": 0}