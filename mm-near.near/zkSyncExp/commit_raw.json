{"tx_hash": "GEeptv9ADUjuYh9sGj7Rv5Qd3x8zpzZzJwtYWtt38i6Z", "action_id_social": "Ew5dX1aTPo2dxzcU4PZkpMLRjfWLTDALrBvtECSjWZzM-0-widget", "block_id": 101871156, "block_timestamp": "2023-09-24T19:53:28.144Z", "signer_id": "mm-near.near", "widget_name": "zkSyncExp", "source_code": "const allQuestions = [\"first\", \"second\", \"third\"];\n\nState.init({\n  accountBalance: 0,\n  hasNFT: 0,\n  nftId: -1,\n  getVotes: Array.from({ length: allQuestions.length }, () => [\"?\", \"?\"]),\n  questionsLoaded: false,\n  addQuestion: \"\",\n});\n\nlet account = Ethers.send(\"eth_requestAccounts\", [])[0];\nif (!account) return \"Please connect wallet first\";\n\nconst res = Ethers.send(\"wallet_switchEthereumChain\", [{ chainId: \"0x118\" }]);\n\nEthers.provider()\n  .getBalance(account)\n  .then((data) => {\n    State.update({\n      accountBalance: parseInt(data.toString()) / 1000000000000000000,\n    });\n  });\n\nconst nftABI = [\n  {\n    constant: true,\n    inputs: [{ name: \"owner\", type: \"address\" }],\n    name: \"balanceOf\",\n    outputs: [{ name: \"\", type: \"uint256\" }],\n    payable: false,\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        name: \"tokenId\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"ownerOf\",\n    outputs: [\n      {\n        name: \"\",\n        type: \"address\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\nconst iface = new ethers.utils.Interface(nftABI);\n\nconst nftAddress = \"0x5657a1278924839fbc32ebaa29fcd475e23105f7\";\n\nconst encodedData = iface.encodeFunctionData(\"balanceOf\", [account]);\n\nEthers.provider()\n  .call({\n    to: nftAddress,\n    data: encodedData,\n  })\n  .then((data) => {\n    State.update({\n      hasNFT: parseInt(data.toString()),\n    });\n  });\n\nconst checkOwner = (nftId) => {\n  const nftContract = new ethers.Contract(\n    nftAddress,\n    nftABI,\n    Ethers.provider()\n  );\n  nftContract\n    .ownerOf(nftId)\n    .then((data) => {\n      if (data.toLowerCase() == account.toString()) {\n        console.log(\"Found it\");\n        State.update({\n          nftId: nftId,\n        });\n      }\n    })\n    .catch((error) => {});\n};\n\n// My NFT doesn't provide the method to get the id for the user - so we simply loop over for now.\nconst guessNFTId = () => {\n  if (state.nftId == -1) {\n    state.nftId = -2;\n\n    for (let i = 0; i < 40; i++) {\n      console.log(\"Querying owner of \", i);\n      checkOwner(i);\n    }\n  }\n};\n\nguessNFTId();\n\nconst votingABI = [\n  {\n    inputs: [\n      {\n        name: \"question\",\n        type: \"string\",\n      },\n    ],\n    name: \"addQuestion\",\n    outputs: [\n      {\n        name: \"hashed_question\",\n        type: \"bytes32\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        name: \"question\",\n        type: \"string\",\n      },\n    ],\n    name: \"getVotes\",\n    outputs: [\n      {\n        name: \"\",\n        type: \"uint256\",\n      },\n      {\n        name: \"\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        name: \"\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"questions\",\n    outputs: [\n      {\n        name: \"\",\n        type: \"bool\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        name: \"question\",\n        type: \"string\",\n      },\n      {\n        name: \"token_id\",\n        type: \"uint256\",\n      },\n      {\n        name: \"vote_for\",\n        type: \"bool\",\n      },\n    ],\n    name: \"vote\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        name: \"\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"votesAgainst\",\n    outputs: [\n      {\n        name: \"\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        name: \"\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"votesFor\",\n    outputs: [\n      {\n        name: \"\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\n\nconst votingAddress = \"0x8711a970c431E51Ff1e68B2F7693E259f894c1a0\";\n\nEthers.provider()\n  .call({\n    to: nftAddress,\n    data: encodedData,\n  })\n  .then((data) => {\n    State.update({\n      hasNFT: parseInt(data.toString()),\n    });\n  });\n\nconst addQuestion = () => {\n  const votingContract = new ethers.Contract(\n    votingAddress,\n    votingABI,\n    Ethers.provider().getSigner()\n  );\n  votingContract.addQuestion(state.addQuestion).then((transactionHash) => {\n    console.log(\"transaction hash is \" + transactionHash);\n  });\n};\n\nconst votingContract = new ethers.Contract(\n  votingAddress,\n  votingABI,\n  Ethers.provider()\n);\n\nconst getVotesForQuestion = (question_id) => {\n  votingContract\n    .getVotes(allQuestions[question_id])\n    .then((result) => {\n      console.log(\"Got votes: \" + result);\n\n      state.getVotes[question_id][0] = result[0].toString();\n      state.getVotes[question_id][1] = result[1].toString();\n\n      console.log(\"Updated display\");\n      State.update({ getVotes: state.getVotes });\n    })\n    .catch((error) => {\n      console.log(\n        \"Failed to fetch question: \" + allQuestions[question_id] + \" \" + error\n      );\n    });\n};\n\nconst refreshAllVotes = () => {\n  allQuestions.map((name, index) => {\n    getVotesForQuestion(index);\n  });\n};\n\nconst loadAllQuestions = () => {\n  if (state.questionsLoaded == false) {\n    state.questionsLoaded = true;\n    refreshAllVotes();\n  }\n};\n\nloadAllQuestions();\n\nconst vote = (decision, question_id) => {\n  const votingContract = new ethers.Contract(\n    votingAddress,\n    votingABI,\n    Ethers.provider().getSigner()\n  );\n  votingContract\n    .vote(allQuestions[question_id], state.nftId, decision)\n    .then((transactionHash) => {\n      console.log(\"transaction hash is \" + transactionHash);\n    });\n};\n\nfunction getSignInput(transaction) {\n  const maxFeePerGas = transaction.maxFeePerGas ?? transaction.gasPrice ?? 0;\n  const maxPriorityFeePerGas = transaction.maxPriorityFeePerGas ?? maxFeePerGas;\n  const gasPerPubdataByteLimit = transaction.customData?.gasPerPubdata ?? 50000;\n  const signInput = {\n    txType: transaction.type,\n    from: transaction.from,\n    to: transaction.to,\n    gasLimit: transaction.gasLimit,\n    gasPerPubdataByteLimit: gasPerPubdataByteLimit,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    paymaster:\n      transaction.customData?.paymasterParams?.paymaster ||\n      ethers.constants.AddressZero,\n    nonce: transaction.nonce,\n    value: transaction.value,\n    data: transaction.data,\n    factoryDeps:\n      transaction.customData?.factoryDeps?.map((dep) => hashBytecode(dep)) ||\n      [],\n    paymasterInput:\n      transaction.customData?.paymasterParams?.paymasterInput || \"0x\",\n  };\n  return signInput;\n}\n\nfunction serialize(transaction) {\n  if (!transaction.chainId) {\n    console.log(\"Transaction chainId isn't set\");\n    return;\n  }\n\n  function formatNumber(value, name) {\n    const result = ethers.utils.stripZeros(\n      ethers.BigNumber.from(value).toHexString()\n    );\n    if (result.length > 32) {\n      throw new Error(\"invalid length for \" + name);\n    }\n    return result;\n  }\n\n  if (!transaction.from) {\n    console.log(\n      \"Explicitly providing `from` field is reqiured for EIP712 transactions\"\n    );\n    return;\n  }\n  const from = transaction.from;\n\n  const meta = transaction.customData;\n\n  let maxFeePerGas = transaction.maxFeePerGas || transaction.gasPrice || 0;\n  let maxPriorityFeePerGas = transaction.maxPriorityFeePerGas || maxFeePerGas;\n\n  const fields = [\n    formatNumber(transaction.nonce || 0, \"nonce\"),\n    formatNumber(maxPriorityFeePerGas, \"maxPriorityFeePerGas\"),\n    formatNumber(maxFeePerGas, \"maxFeePerGas\"),\n    formatNumber(transaction.gasLimit || 0, \"gasLimit\"),\n    transaction.to != null ? ethers.utils.getAddress(transaction.to) : \"0x\",\n    formatNumber(transaction.value || 0, \"value\"),\n    transaction.data || \"0x\",\n  ];\n\n  // signature\n  {\n    fields.push(formatNumber(transaction.chainId, \"chainId\"));\n    fields.push(\"0x\");\n    fields.push(\"0x\");\n  }\n  fields.push(formatNumber(transaction.chainId, \"chainId\"));\n  fields.push(ethers.utils.getAddress(from));\n\n  // Add meta\n  fields.push(formatNumber(meta.gasPerPubdata, \"gasPerPubdata\"));\n  fields.push((meta.factoryDeps ?? []).map((dep) => ethers.utils.hexlify(dep)));\n\n  if (\n    meta.customSignature &&\n    ethers.utils.arrayify(meta.customSignature).length == 0\n  ) {\n    console.log(\"Empty signatures are not supported\");\n    return;\n  }\n  fields.push(meta.customSignature || \"0x\");\n\n  if (meta.paymasterParams) {\n    fields.push([\n      meta.paymasterParams.paymaster,\n      ethers.utils.hexlify(meta.paymasterParams.paymasterInput),\n    ]);\n  } else {\n    fields.push([]);\n  }\n\n  return ethers.utils.hexConcat([[0x71], ethers.utils.RLP.encode(fields)]);\n}\n\nconst paymasterABI = [\n  {\n    inputs: [\n      {\n        name: \"input\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"general\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n];\n\nconst paymasterIface = new ethers.utils.Interface(paymasterABI);\n\nconst encodedPaymaster = paymasterIface.encodeFunctionData(\"general\", [\"0x\"]);\n\nconst eip712Types = {\n  Transaction: [\n    { name: \"txType\", type: \"uint256\" },\n    { name: \"from\", type: \"uint256\" },\n    { name: \"to\", type: \"uint256\" },\n    { name: \"gasLimit\", type: \"uint256\" },\n    { name: \"gasPerPubdataByteLimit\", type: \"uint256\" },\n    { name: \"maxFeePerGas\", type: \"uint256\" },\n    { name: \"maxPriorityFeePerGas\", type: \"uint256\" },\n    { name: \"paymaster\", type: \"uint256\" },\n    { name: \"nonce\", type: \"uint256\" },\n    { name: \"value\", type: \"uint256\" },\n    { name: \"data\", type: \"bytes\" },\n    { name: \"factoryDeps\", type: \"bytes32[]\" },\n    { name: \"paymasterInput\", type: \"bytes\" },\n  ],\n};\n\nfunction signCustom(transaction) {\n  const domain = {\n    name: \"zkSync\",\n    version: \"2\",\n    chainId: transaction.chainId,\n  };\n\n  console.log(\"About to get sign input\");\n  console.log(getSignInput(transaction));\n\n  return Ethers.provider()\n    .getSigner()\n    ._signTypedData(domain, eip712Types, getSignInput(transaction));\n}\n\nfunction getSignedDigest(transaction) {\n  if (!transaction.chainId) {\n    throw Error(\"Transaction chainId isn't set\");\n  }\n  const domain = {\n    name: \"zkSync\",\n    version: \"2\",\n    chainId: transaction.chainId,\n  };\n  console.log(\"in get signed\");\n\n  console.log(getSignInput(transaction));\n  return ethers.utils._TypedDataEncoder.hash(\n    domain,\n    eip712Types,\n    getSignInput(transaction)\n  );\n}\n\nfunction getSignature(transaction, ethSignature) {\n  if (\n    transaction?.customData?.customSignature &&\n    transaction.customData.customSignature.length\n  ) {\n    return ethers.utils.arrayify(transaction.customData.customSignature);\n  }\n\n  if (!ethSignature) {\n    throw new Error(\"No signature provided\");\n  }\n\n  const r = ethers.utils.zeroPad(ethers.utils.arrayify(ethSignature.r), 32);\n  const s = ethers.utils.zeroPad(ethers.utils.arrayify(ethSignature.s), 32);\n  const v = ethSignature.v;\n\n  return [...r, ...s, v];\n}\n\nfunction eip712TxHash(transaction, ethSignature) {\n  const signedDigest = getSignedDigest(transaction);\n  const hashedSignature = ethers.utils.keccak256(\n    getSignature(transaction, ethSignature)\n  );\n\n  return ethers.utils.keccak256(\n    ethers.utils.hexConcat([signedDigest, hashedSignature])\n  );\n}\n\nconst EIP712_TX_TYPE = 0x71;\n\nfunction parseTransaction(payload) {\n  function handleAddress(value) {\n    if (value === \"0x\") {\n      return null;\n    }\n    return ethers.utils.getAddress(value);\n  }\n\n  function handleNumber(value) {\n    if (value === \"0x\") {\n      return ethers.BigNumber.from(0);\n    }\n    return ethers.BigNumber.from(value);\n  }\n\n  function arrayToPaymasterParams(arr) {\n    if (arr.length == 0) {\n      return undefined;\n    }\n    if (arr.length != 2) {\n      console.log(\n        `Invalid paymaster parameters, expected to have length of 2, found ${arr.length}`\n      );\n      return undefined;\n    }\n\n    return {\n      paymaster: ethers.utils.getAddress(arr[0]),\n      paymasterInput: ethers.utils.arrayify(arr[1]),\n    };\n  }\n\n  const bytes = ethers.utils.arrayify(payload);\n  if (bytes[0] != EIP712_TX_TYPE) {\n    return ethers.utils.parseTransaction(bytes);\n  }\n\n  const raw = ethers.utils.RLP.decode(bytes.slice(1));\n  const transaction = {\n    type: EIP712_TX_TYPE,\n    nonce: handleNumber(raw[0]).toNumber(),\n    maxPriorityFeePerGas: handleNumber(raw[1]),\n    maxFeePerGas: handleNumber(raw[2]),\n    gasLimit: handleNumber(raw[3]),\n    to: handleAddress(raw[4]),\n    value: handleNumber(raw[5]),\n    data: raw[6],\n    chainId: handleNumber(raw[10]),\n    from: handleAddress(raw[11]),\n    customData: {\n      gasPerPubdata: handleNumber(raw[12]),\n      factoryDeps: raw[13],\n      customSignature: raw[14],\n      paymasterParams: arrayToPaymasterParams(raw[15]),\n    },\n  };\n\n  const ethSignature = {\n    v: handleNumber(raw[7]).toNumber(),\n    r: raw[8],\n    s: raw[9],\n  };\n\n  if (\n    (ethers.utils.hexlify(ethSignature.r) == \"0x\" ||\n      ethers.utils.hexlify(ethSignature.s) == \"0x\") &&\n    !transaction.customData.customSignature\n  ) {\n    return transaction;\n  }\n\n  if (\n    ethSignature.v !== 0 &&\n    ethSignature.v !== 1 &&\n    !transaction.customData.customSignature\n  ) {\n    throw new Error(\"Failed to parse signature\");\n  }\n\n  if (!transaction.customData.customSignature) {\n    transaction.v = ethSignature.v;\n    transaction.s = ethSignature.s;\n    transaction.r = ethSignature.r;\n  }\n\n  transaction.hash = eip712TxHash(transaction, ethSignature);\n\n  return transaction;\n}\n\nconst voteForFree = (decision, question_id) => {\n  const votingContract = new ethers.Contract(\n    votingAddress,\n    votingABI,\n    Ethers.provider().getSigner()\n  );\n  votingContract.populateTransaction\n    .vote(allQuestions[question_id], state.nftId, decision)\n    .then((populatedTransaction) => {\n      populatedTransaction;\n      Ethers.provider()\n        .getTransactionCount(account, \"latest\")\n        .then((nonce) => {\n          Ethers.provider()\n            .getNetwork()\n            .then((network) => {\n              populatedTransaction.type = 0x71;\n              populatedTransaction.nonce = nonce;\n              populatedTransaction.chainId = network.chainId;\n              populatedTransaction.gasPrice = 250000000;\n              // 10M\n              populatedTransaction.gasLimit = 10000000;\n              populatedTransaction.value = 0;\n\n              populatedTransaction.customData = {\n                gasPerPubdata: 800,\n                factoryDeps: [],\n                paymasterParams: {\n                  paymaster: \"0x52681C7B08F1EAce7f1aF6411DaCA9e28150edDE\",\n                  paymasterInput: encodedPaymaster,\n                },\n              };\n              signCustom(populatedTransaction).then((signature) => {\n                populatedTransaction.customData.customSignature = signature;\n\n                console.log(\"populated Transaction\");\n                console.log(populatedTransaction);\n\n                const bytes = serialize(populatedTransaction);\n\n                console.log(bytes);\n                const provider = Ethers.provider();\n                provider.formatter.transaction = parseTransaction;\n\n                provider.sendTransaction(bytes).then((result) => {\n                  console.log(\"Transaction sent\");\n                  console.log(result);\n                });\n              });\n            });\n        });\n    });\n  return;\n};\n\nreturn (\n  <>\n    <div class=\"container border border-info p-3 text-center\">\n      <h1>Hello {props.name}</h1>\n\n      <p>\n        {\"Your zkSync account is:\"}\n        {account}\n      </p>\n      <p>\n        {\" Balance is: \"} {state.accountBalance}\n      </p>\n      <p>\n        {\" Has NFT is: \"} {state.hasNFT} {\" id\"} {state.nftId}\n      </p>\n\n      <p>\n        {allQuestions.map((name, index) => (\n          <p>\n            {\" \"}\n            {\"Question \"} {index} {\" is: \"}\n            <b> {name}</b> <br /> {\"Current votes: +\"}{\" \"}\n            {state.getVotes[index][0]} {\" - \"}\n            {state.getVotes[index][1]}\n            <br />\n            <button onClick={() => vote(true, index)}>Vote YES</button>\n            <button onClick={() => vote(false, index)}>Vote NO</button>\n            <button onClick={() => voteForFree(true, index)}>\n              Vote YES (free with paymaster)\n            </button>\n            <button onClick={() => voteForFree(false, index)}>\n              Vote NO (free with paymaster)\n            </button>\n          </p>\n        ))}\n      </p>\n\n      <input\n        value={state.addQuestion}\n        onChange={(e) => State.update({ addQuestion: e.target.value })}\n        placeholder=\"Your question\"\n      />\n      <button onClick={() => addQuestion()}>Add question</button>\n    </div>\n  </>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/mm-near.near/widget/zkSyncExp", "fact_widget_deployments_id": "c7eab7cfddba0a142924751f13d119ea", "inserted_timestamp": "2023-09-24T21:43:13.109Z", "modified_timestamp": "2023-09-24T21:43:13.109Z", "__row_index": 1}