{"tx_hash": "6BFuWfwRYZHg5E3THL7o4c9Sb3CHpqJEMDhPQTr7PLqm", "action_id_social": "43Nyb6tEbhQqNR3bngRuDJxSQAgtSpKGxu5FCYuVescw-0-widget", "block_id": 101909816, "block_timestamp": "2023-09-25T08:16:25.311Z", "signer_id": "mm-near.near", "widget_name": "zkSyncExp", "source_code": "const allQuestions = [\n  \"Did you use zksyncEra before this experiment?\",\n  \"Is 1$ a day enough for stipend?\",\n  \"Are you using zkSyncEra daily?\",\n  \"Did you ever use paymaster?\",\n  \"Can you answer this question without paymaster?\",\n  \"Did you eat breakfast today?\",\n  \"Can you answer NO this to question?\",\n  \"Do you like this form?\",\n];\n\nState.init({\n  accountBalance: 0,\n  paymasterAccountBalance: 0,\n  hasNFT: 0,\n  nftId: -1,\n  getVotes: Array.from({ length: allQuestions.length }, () => [\"?\", \"?\"]),\n  questionsLoaded: false,\n  addQuestion: \"\",\n});\n\nlet account = Ethers.send(\"eth_requestAccounts\", [])[0];\nif (!account) return \"Please connect wallet first\";\n\nconst res = Ethers.send(\"wallet_switchEthereumChain\", [{ chainId: \"0x118\" }]);\n\nEthers.provider()\n  .getBalance(account)\n  .then((data) => {\n    State.update({\n      accountBalance: parseInt(data.toString()) / 1000000000000000000,\n    });\n  });\n\nconst paymasterAccount = \"0x52681C7B08F1EAce7f1aF6411DaCA9e28150edDE\";\nEthers.provider()\n  .getBalance(paymasterAccount)\n  .then((data) => {\n    State.update({\n      paymasterAccountBalance: parseInt(data.toString()) / 1000000000000000000,\n    });\n  });\n\nconst nftABI = [\n  {\n    constant: true,\n    inputs: [{ name: \"owner\", type: \"address\" }],\n    name: \"balanceOf\",\n    outputs: [{ name: \"\", type: \"uint256\" }],\n    payable: false,\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        name: \"tokenId\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"ownerOf\",\n    outputs: [\n      {\n        name: \"\",\n        type: \"address\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\nconst iface = new ethers.utils.Interface(nftABI);\n\nconst nftAddress = \"0x5657a1278924839fbc32ebaa29fcd475e23105f7\";\n\nconst encodedData = iface.encodeFunctionData(\"balanceOf\", [account]);\n\nconst checkOwner = (nftId) => {\n  const nftContract = new ethers.Contract(\n    nftAddress,\n    nftABI,\n    Ethers.provider()\n  );\n  return nftContract\n    .ownerOf(nftId)\n    .then((data) => {\n      if (data.toLowerCase() == account.toString()) {\n        console.log(\"Found it\");\n        State.update({\n          nftId: nftId,\n        });\n      }\n    })\n    .catch((error) => {});\n};\n\n// My NFT doesn't provide the method to get the id for the user - so we simply loop over for now.\nconst guessNFTId = () => {\n  if (state.nftId == -1) {\n    state.nftId = -2;\n    let promises = [];\n\n    for (let i = 0; i < 40; i++) {\n      console.log(\"Querying owner ofs \", i);\n      promises.push(checkOwner(i));\n    }\n  }\n};\n\nEthers.provider()\n  .call({\n    to: nftAddress,\n    data: encodedData,\n  })\n  .then((data) => {\n    const hasNFT = parseInt(data.toString());\n    if (hasNFT) {\n      guessNFTId();\n    }\n    State.update({\n      hasNFT: hasNFT,\n    });\n  });\n\nconst votingABI = [\n  {\n    inputs: [\n      {\n        name: \"question\",\n        type: \"string\",\n      },\n    ],\n    name: \"addQuestion\",\n    outputs: [\n      {\n        name: \"hashed_question\",\n        type: \"bytes32\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        name: \"question\",\n        type: \"string\",\n      },\n    ],\n    name: \"getVotes\",\n    outputs: [\n      {\n        name: \"\",\n        type: \"uint256\",\n      },\n      {\n        name: \"\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        name: \"\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"questions\",\n    outputs: [\n      {\n        name: \"\",\n        type: \"bool\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        name: \"question\",\n        type: \"string\",\n      },\n      {\n        name: \"token_id\",\n        type: \"uint256\",\n      },\n      {\n        name: \"vote_for\",\n        type: \"bool\",\n      },\n    ],\n    name: \"vote\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        name: \"\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"votesAgainst\",\n    outputs: [\n      {\n        name: \"\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        name: \"\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"votesFor\",\n    outputs: [\n      {\n        name: \"\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\n\nconst votingAddress = \"0x8711a970c431E51Ff1e68B2F7693E259f894c1a0\";\n\nEthers.provider()\n  .call({\n    to: nftAddress,\n    data: encodedData,\n  })\n  .then((data) => {\n    State.update({\n      hasNFT: parseInt(data.toString()),\n    });\n  });\n\nconst addQuestion = () => {\n  const votingContract = new ethers.Contract(\n    votingAddress,\n    votingABI,\n    Ethers.provider().getSigner()\n  );\n  votingContract.addQuestion(state.addQuestion).then((transactionHash) => {\n    console.log(\"transaction hash is \" + transactionHash);\n  });\n};\n\nconst votingContract = new ethers.Contract(\n  votingAddress,\n  votingABI,\n  Ethers.provider()\n);\n\nconst getVotesForQuestion = (question_id) => {\n  votingContract\n    .getVotes(allQuestions[question_id])\n    .then((result) => {\n      console.log(\"Got votes: \" + result);\n\n      state.getVotes[question_id][0] = result[0];\n      state.getVotes[question_id][1] = result[1];\n\n      console.log(\"Updated display\");\n      State.update({ getVotes: state.getVotes });\n    })\n    .catch((error) => {\n      console.log(\n        \"Failed to fetch question: \" + allQuestions[question_id] + \" \" + error\n      );\n    });\n};\n\nconst refreshAllVotes = () => {\n  allQuestions.map((name, index) => {\n    getVotesForQuestion(index);\n  });\n};\n\nconst loadAllQuestions = () => {\n  if (state.questionsLoaded == false) {\n    state.questionsLoaded = true;\n    refreshAllVotes();\n  }\n};\n\nloadAllQuestions();\n\nconst vote = (decision, question_id) => {\n  const votingContract = new ethers.Contract(\n    votingAddress,\n    votingABI,\n    Ethers.provider().getSigner()\n  );\n  votingContract\n    .vote(allQuestions[question_id], state.nftId, decision)\n    .then((transaction) => {\n      console.log(\"transaction sent \");\n      console.log(transaction);\n      transaction.wait().then((receipt) => {\n        console.log(\"got receipt\");\n        console.log(receipt);\n        getVotesForQuestion(question_id);\n      });\n    });\n};\n\nfunction getSignInput(transaction) {\n  const maxFeePerGas = transaction.maxFeePerGas ?? transaction.gasPrice ?? 0;\n  const maxPriorityFeePerGas = transaction.maxPriorityFeePerGas ?? maxFeePerGas;\n  const gasPerPubdataByteLimit = transaction.customData?.gasPerPubdata ?? 50000;\n  const signInput = {\n    txType: transaction.type,\n    from: transaction.from,\n    to: transaction.to,\n    gasLimit: transaction.gasLimit,\n    gasPerPubdataByteLimit: gasPerPubdataByteLimit,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    paymaster:\n      transaction.customData?.paymasterParams?.paymaster ||\n      ethers.constants.AddressZero,\n    nonce: transaction.nonce,\n    value: transaction.value,\n    data: transaction.data,\n    factoryDeps:\n      transaction.customData?.factoryDeps?.map((dep) => hashBytecode(dep)) ||\n      [],\n    paymasterInput:\n      transaction.customData?.paymasterParams?.paymasterInput || \"0x\",\n  };\n  return signInput;\n}\n\nfunction serialize(transaction) {\n  if (!transaction.chainId) {\n    console.log(\"Transaction chainId isn't set\");\n    return;\n  }\n\n  function formatNumber(value, name) {\n    const result = ethers.utils.stripZeros(\n      ethers.BigNumber.from(value).toHexString()\n    );\n    if (result.length > 32) {\n      throw new Error(\"invalid length for \" + name);\n    }\n    return result;\n  }\n\n  if (!transaction.from) {\n    console.log(\n      \"Explicitly providing `from` field is reqiured for EIP712 transactions\"\n    );\n    return;\n  }\n  const from = transaction.from;\n\n  const meta = transaction.customData;\n\n  let maxFeePerGas = transaction.maxFeePerGas || transaction.gasPrice || 0;\n  let maxPriorityFeePerGas = transaction.maxPriorityFeePerGas || maxFeePerGas;\n\n  const fields = [\n    formatNumber(transaction.nonce || 0, \"nonce\"),\n    formatNumber(maxPriorityFeePerGas, \"maxPriorityFeePerGas\"),\n    formatNumber(maxFeePerGas, \"maxFeePerGas\"),\n    formatNumber(transaction.gasLimit || 0, \"gasLimit\"),\n    transaction.to != null ? ethers.utils.getAddress(transaction.to) : \"0x\",\n    formatNumber(transaction.value || 0, \"value\"),\n    transaction.data || \"0x\",\n  ];\n\n  // signature\n  {\n    fields.push(formatNumber(transaction.chainId, \"chainId\"));\n    fields.push(\"0x\");\n    fields.push(\"0x\");\n  }\n  fields.push(formatNumber(transaction.chainId, \"chainId\"));\n  fields.push(ethers.utils.getAddress(from));\n\n  // Add meta\n  fields.push(formatNumber(meta.gasPerPubdata, \"gasPerPubdata\"));\n  fields.push((meta.factoryDeps ?? []).map((dep) => ethers.utils.hexlify(dep)));\n\n  if (\n    meta.customSignature &&\n    ethers.utils.arrayify(meta.customSignature).length == 0\n  ) {\n    console.log(\"Empty signatures are not supported\");\n    return;\n  }\n  fields.push(meta.customSignature || \"0x\");\n\n  if (meta.paymasterParams) {\n    fields.push([\n      meta.paymasterParams.paymaster,\n      ethers.utils.hexlify(meta.paymasterParams.paymasterInput),\n    ]);\n  } else {\n    fields.push([]);\n  }\n\n  return ethers.utils.hexConcat([[0x71], ethers.utils.RLP.encode(fields)]);\n}\n\nconst paymasterABI = [\n  {\n    inputs: [\n      {\n        name: \"input\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"general\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n];\n\nconst paymasterIface = new ethers.utils.Interface(paymasterABI);\n\nconst encodedPaymaster = paymasterIface.encodeFunctionData(\"general\", [\"0x\"]);\n\nconst eip712Types = {\n  Transaction: [\n    { name: \"txType\", type: \"uint256\" },\n    { name: \"from\", type: \"uint256\" },\n    { name: \"to\", type: \"uint256\" },\n    { name: \"gasLimit\", type: \"uint256\" },\n    { name: \"gasPerPubdataByteLimit\", type: \"uint256\" },\n    { name: \"maxFeePerGas\", type: \"uint256\" },\n    { name: \"maxPriorityFeePerGas\", type: \"uint256\" },\n    { name: \"paymaster\", type: \"uint256\" },\n    { name: \"nonce\", type: \"uint256\" },\n    { name: \"value\", type: \"uint256\" },\n    { name: \"data\", type: \"bytes\" },\n    { name: \"factoryDeps\", type: \"bytes32[]\" },\n    { name: \"paymasterInput\", type: \"bytes\" },\n  ],\n};\n\nfunction signCustom(transaction) {\n  const domain = {\n    name: \"zkSync\",\n    version: \"2\",\n    chainId: transaction.chainId,\n  };\n\n  console.log(\"About to get sign input\");\n  console.log(getSignInput(transaction));\n\n  return Ethers.provider()\n    .getSigner()\n    ._signTypedData(domain, eip712Types, getSignInput(transaction));\n}\n\nfunction getSignedDigest(transaction) {\n  if (!transaction.chainId) {\n    throw Error(\"Transaction chainId isn't set\");\n  }\n  const domain = {\n    name: \"zkSync\",\n    version: \"2\",\n    chainId: transaction.chainId,\n  };\n  console.log(\"in get signed\");\n\n  console.log(getSignInput(transaction));\n  return ethers.utils._TypedDataEncoder.hash(\n    domain,\n    eip712Types,\n    getSignInput(transaction)\n  );\n}\n\nfunction getSignature(transaction, ethSignature) {\n  if (\n    transaction?.customData?.customSignature &&\n    transaction.customData.customSignature.length\n  ) {\n    return ethers.utils.arrayify(transaction.customData.customSignature);\n  }\n\n  if (!ethSignature) {\n    throw new Error(\"No signature provided\");\n  }\n\n  const r = ethers.utils.zeroPad(ethers.utils.arrayify(ethSignature.r), 32);\n  const s = ethers.utils.zeroPad(ethers.utils.arrayify(ethSignature.s), 32);\n  const v = ethSignature.v;\n\n  return [...r, ...s, v];\n}\n\nfunction eip712TxHash(transaction, ethSignature) {\n  const signedDigest = getSignedDigest(transaction);\n  const hashedSignature = ethers.utils.keccak256(\n    getSignature(transaction, ethSignature)\n  );\n\n  return ethers.utils.keccak256(\n    ethers.utils.hexConcat([signedDigest, hashedSignature])\n  );\n}\n\nconst EIP712_TX_TYPE = 0x71;\n\nfunction parseTransaction(payload) {\n  function handleAddress(value) {\n    if (value === \"0x\") {\n      return null;\n    }\n    return ethers.utils.getAddress(value);\n  }\n\n  function handleNumber(value) {\n    if (value === \"0x\") {\n      return ethers.BigNumber.from(0);\n    }\n    return ethers.BigNumber.from(value);\n  }\n\n  function arrayToPaymasterParams(arr) {\n    if (arr.length == 0) {\n      return undefined;\n    }\n    if (arr.length != 2) {\n      console.log(\n        `Invalid paymaster parameters, expected to have length of 2, found ${arr.length}`\n      );\n      return undefined;\n    }\n\n    return {\n      paymaster: ethers.utils.getAddress(arr[0]),\n      paymasterInput: ethers.utils.arrayify(arr[1]),\n    };\n  }\n\n  const bytes = ethers.utils.arrayify(payload);\n  if (bytes[0] != EIP712_TX_TYPE) {\n    return ethers.utils.parseTransaction(bytes);\n  }\n\n  const raw = ethers.utils.RLP.decode(bytes.slice(1));\n  const transaction = {\n    type: EIP712_TX_TYPE,\n    nonce: handleNumber(raw[0]).toNumber(),\n    maxPriorityFeePerGas: handleNumber(raw[1]),\n    maxFeePerGas: handleNumber(raw[2]),\n    gasLimit: handleNumber(raw[3]),\n    to: handleAddress(raw[4]),\n    value: handleNumber(raw[5]),\n    data: raw[6],\n    chainId: handleNumber(raw[10]),\n    from: handleAddress(raw[11]),\n    customData: {\n      gasPerPubdata: handleNumber(raw[12]),\n      factoryDeps: raw[13],\n      customSignature: raw[14],\n      paymasterParams: arrayToPaymasterParams(raw[15]),\n    },\n  };\n\n  const ethSignature = {\n    v: handleNumber(raw[7]).toNumber(),\n    r: raw[8],\n    s: raw[9],\n  };\n\n  if (\n    (ethers.utils.hexlify(ethSignature.r) == \"0x\" ||\n      ethers.utils.hexlify(ethSignature.s) == \"0x\") &&\n    !transaction.customData.customSignature\n  ) {\n    return transaction;\n  }\n\n  if (\n    ethSignature.v !== 0 &&\n    ethSignature.v !== 1 &&\n    !transaction.customData.customSignature\n  ) {\n    throw new Error(\"Failed to parse signature\");\n  }\n\n  if (!transaction.customData.customSignature) {\n    transaction.v = ethSignature.v;\n    transaction.s = ethSignature.s;\n    transaction.r = ethSignature.r;\n  }\n\n  transaction.hash = eip712TxHash(transaction, ethSignature);\n\n  return transaction;\n}\n\nconst voteForFree = (decision, question_id) => {\n  const votingContract = new ethers.Contract(\n    votingAddress,\n    votingABI,\n    Ethers.provider().getSigner()\n  );\n  votingContract.populateTransaction\n    .vote(allQuestions[question_id], state.nftId, decision)\n    .then((populatedTransaction) => {\n      populatedTransaction;\n      Ethers.provider()\n        .getTransactionCount(account, \"latest\")\n        .then((nonce) => {\n          Ethers.provider()\n            .getNetwork()\n            .then((network) => {\n              populatedTransaction.type = 0x71;\n              populatedTransaction.nonce = nonce;\n              populatedTransaction.chainId = network.chainId;\n              populatedTransaction.gasPrice = 250000000;\n              // 10M\n              populatedTransaction.gasLimit = 10000000;\n              populatedTransaction.value = 0;\n\n              populatedTransaction.customData = {\n                gasPerPubdata: 800,\n                factoryDeps: [],\n                paymasterParams: {\n                  paymaster: \"0x52681C7B08F1EAce7f1aF6411DaCA9e28150edDE\",\n                  paymasterInput: encodedPaymaster,\n                },\n              };\n              signCustom(populatedTransaction).then((signature) => {\n                populatedTransaction.customData.customSignature = signature;\n\n                console.log(\"populated Transaction\");\n                console.log(populatedTransaction);\n\n                const bytes = serialize(populatedTransaction);\n\n                console.log(bytes);\n                const provider = Ethers.provider();\n                provider.formatter.transaction = parseTransaction;\n\n                provider.sendTransaction(bytes).then((result) => {\n                  console.log(\"Transaction sent\");\n                  console.log(result);\n                  result.wait().then((receipt) => {\n                    console.log(\"got receipt\");\n                    console.log(receipt);\n                    getVotesForQuestion(question_id);\n                  });\n                });\n              });\n            });\n        });\n    });\n  return;\n};\n\nfunction checkIfVoted(bn) {\n  if (state.nftId >= 0 && state.nftId < 255) {\n    return bn.shr(state.nftId).and(1).eq(1);\n  }\n  return true;\n}\n\nconst renderButtons = (index) => {\n  if (state.hasNFT) {\n    if (state.getVotes[index][0] == \"?\") {\n      return <span>Question not found</span>;\n    }\n    if (checkIfVoted(state.getVotes[index][0].or(state.getVotes[index][1]))) {\n      return <span>Already voted</span>;\n    }\n\n    return (\n      <span>\n        <button onClick={() => vote(true, index)}>Vote YES</button>\n        <button onClick={() => vote(false, index)}>Vote NO</button>\n        <button onClick={() => voteForFree(true, index)}>\n          Vote YES (free with paymaster)\n        </button>\n        <button onClick={() => voteForFree(false, index)}>\n          Vote NO (free with paymaster)\n        </button>\n      </span>\n    );\n  } else {\n    return <span>NFT needed to vote</span>;\n  }\n};\n\nfunction countVotes(bn) {\n  if (bn == \"?\") {\n    return \"?\";\n  }\n\n  let count = 0;\n\n  while (!bn.isZero()) {\n    if (bn.and(1).eq(1)) {\n      count++;\n    }\n    bn = bn.shr(1);\n  }\n\n  return count;\n}\n\nreturn (\n  <>\n    <div class=\"container border border-info p-3 text-center\">\n      <h1>Welcome to voting page</h1>\n      <br />\n      You can vote only if you are the owner of the NFT.\n      <br />\n      Clicking Vote yes / no - will create a regular transaction.\n      <br />\n      Clicking Vote using paymaster - will create a transaction, but you will\n      not have to pay for gas (assuming paymaster have funds remaining).\n      <br />\n      <br />\n      <p>\n        {\"Your zkSync account is:\"}\n        {account}\n      </p>\n      <p>\n        {\" Balance is: \"} {state.accountBalance}\n      </p>\n      <p>\n        {\" \"}\n        {\" Paymaster balance: \"} {state.paymasterAccountBalance}\n      </p>\n      <p>\n        {\" Has NFT is: \"} {state.hasNFT} {\" id\"} {state.nftId}\n      </p>\n      <p>\n        {state.hasNFT ? (\n          <h1 style={{ color: \"green\" }}>\n            {\" \"}\n            You have NFT {state.nftId >= 0\n              ? \"( \" + state.nftId + \" )\"\n              : \"\"}{\" \"}\n          </h1>\n        ) : (\n          <h1 style={{ color: \"red\" }}> NO NFT </h1>\n        )}\n      </p>\n      <p>\n        {allQuestions.map((name, index) => (\n          <p>\n            {\" \"}\n            {\"Question \"} {index} {\" is: \"}\n            <b> {name}</b> <br /> {\"Current votes:\"}{\" \"}\n            <img\n              height=\"20\"\n              src=\"https://user-images.githubusercontent.com/128217157/270274380-89e98ae0-f7f0-4daa-a7b2-3cc414fa6306.png\"\n            />\n            <b style={{ color: \"green\" }}>\n              {countVotes(state.getVotes[index][0])}\n            </b>\n            <img\n              height=\"20\"\n              src=\"https://user-images.githubusercontent.com/128217157/270274279-208a1236-2ad0-487f-a830-08b8fee9fdc3.png\"\n            />\n            <b style={{ color: \"red\" }}>\n              {countVotes(state.getVotes[index][1])}\n            </b>\n            <br />\n            {renderButtons(index)}\n          </p>\n        ))}\n      </p>\n      <input\n        value={state.addQuestion}\n        onChange={(e) => State.update({ addQuestion: e.target.value })}\n        placeholder=\"Your question\"\n      />\n      <button onClick={() => addQuestion()}>Add question</button>\n    </div>\n  </>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/mm-near.near/widget/zkSyncExp", "fact_widget_deployments_id": "4ac1c6286cdf10605398fb494480d905", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 0}