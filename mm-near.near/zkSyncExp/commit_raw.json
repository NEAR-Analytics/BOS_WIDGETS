{"tx_hash": "5ADzF6XaxQPKuQ6acd63SzPTGJNTd6wBLLZRvK4nS5HJ", "action_id_social": "CbPgBBgNhFLW4dopQiMWh72TE4ynLkw4Y9C2bkf23THY-0-widget", "block_id": 101843321, "block_timestamp": "2023-09-24T10:57:32.267Z", "signer_id": "mm-near.near", "widget_name": "zkSyncExp", "source_code": "const allQuestions = [\"first\", \"second\", \"third\"];\n\nState.init({\n  accountBalance: 0,\n  hasNFT: 0,\n  nftId: -1,\n  getVotes: Array.from({ length: allQuestions.length }, () => [\"?\", \"?\"]),\n  questionsLoaded: false,\n  addQuestion: \"\",\n});\n\nlet account = Ethers.send(\"eth_requestAccounts\", [])[0];\nif (!account) return \"Please connect wallet first\";\n\nconst res = Ethers.send(\"wallet_switchEthereumChain\", [{ chainId: \"0x118\" }]);\n\nEthers.provider()\n  .getBalance(account)\n  .then((data) => {\n    State.update({\n      accountBalance: parseInt(data.toString()) / 1000000000000000000,\n    });\n  });\n\nconst nftABI = [\n  {\n    constant: true,\n    inputs: [{ name: \"owner\", type: \"address\" }],\n    name: \"balanceOf\",\n    outputs: [{ name: \"\", type: \"uint256\" }],\n    payable: false,\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        name: \"tokenId\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"ownerOf\",\n    outputs: [\n      {\n        name: \"\",\n        type: \"address\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\nconst iface = new ethers.utils.Interface(nftABI);\n\nconst nftAddress = \"0x5657a1278924839fbc32ebaa29fcd475e23105f7\";\n\nconst encodedData = iface.encodeFunctionData(\"balanceOf\", [account]);\n\nEthers.provider()\n  .call({\n    to: nftAddress,\n    data: encodedData,\n  })\n  .then((data) => {\n    State.update({\n      hasNFT: parseInt(data.toString()),\n    });\n  });\n\nconst checkOwner = (nftId) => {\n  const nftContract = new ethers.Contract(\n    nftAddress,\n    nftABI,\n    Ethers.provider()\n  );\n  nftContract\n    .ownerOf(nftId)\n    .then((data) => {\n      if (data.toLowerCase() == account.toString()) {\n        console.log(\"Found it\");\n        State.update({\n          nftId: nftId,\n        });\n      }\n    })\n    .catch((error) => {});\n};\n\n// My NFT doesn't provide the method to get the id for the user - so we simply loop over for now.\nconst guessNFTId = () => {\n  if (state.nftId == -1) {\n    state.nftId = -2;\n\n    for (let i = 0; i < 10; i++) {\n      console.log(\"Querying owner of \", i);\n      checkOwner(i);\n    }\n  }\n};\n\nguessNFTId();\n\nconst votingABI = [\n  {\n    inputs: [\n      {\n        name: \"question\",\n        type: \"string\",\n      },\n    ],\n    name: \"addQuestion\",\n    outputs: [\n      {\n        name: \"hashed_question\",\n        type: \"bytes32\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        name: \"question\",\n        type: \"string\",\n      },\n    ],\n    name: \"getVotes\",\n    outputs: [\n      {\n        name: \"\",\n        type: \"uint256\",\n      },\n      {\n        name: \"\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        name: \"\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"questions\",\n    outputs: [\n      {\n        name: \"\",\n        type: \"bool\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        name: \"question\",\n        type: \"string\",\n      },\n      {\n        name: \"token_id\",\n        type: \"uint256\",\n      },\n      {\n        name: \"vote_for\",\n        type: \"bool\",\n      },\n    ],\n    name: \"vote\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        name: \"\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"votesAgainst\",\n    outputs: [\n      {\n        name: \"\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        name: \"\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"votesFor\",\n    outputs: [\n      {\n        name: \"\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\n\nconst votingAddress = \"0x8711a970c431E51Ff1e68B2F7693E259f894c1a0\";\n\nEthers.provider()\n  .call({\n    to: nftAddress,\n    data: encodedData,\n  })\n  .then((data) => {\n    State.update({\n      hasNFT: parseInt(data.toString()),\n    });\n  });\n\nconst addQuestion = () => {\n  const votingContract = new ethers.Contract(\n    votingAddress,\n    votingABI,\n    Ethers.provider().getSigner()\n  );\n  votingContract.addQuestion(state.addQuestion).then((transactionHash) => {\n    console.log(\"transaction hash is \" + transactionHash);\n  });\n};\n\nconst votingContract = new ethers.Contract(\n  votingAddress,\n  votingABI,\n  Ethers.provider()\n);\n\nconst getVotesForQuestion = (question_id) => {\n  votingContract\n    .getVotes(allQuestions[question_id])\n    .then((result) => {\n      console.log(\"Got votes: \" + result);\n\n      state.getVotes[question_id][0] = result[0].toString();\n      state.getVotes[question_id][1] = result[1].toString();\n\n      console.log(\"Updated display\");\n      State.update({ getVotes: state.getVotes });\n    })\n    .catch((error) => {\n      console.log(\n        \"Failed to fetch question: \" + allQuestions[question_id] + \" \" + error\n      );\n    });\n};\n\nconst refreshAllVotes = () => {\n  allQuestions.map((name, index) => {\n    getVotesForQuestion(index);\n  });\n};\n\nconst loadAllQuestions = () => {\n  if (state.questionsLoaded == false) {\n    state.questionsLoaded = true;\n    refreshAllVotes();\n  }\n};\n\nloadAllQuestions();\n\nconst vote = (decision, question_id) => {\n  const votingContract = new ethers.Contract(\n    votingAddress,\n    votingABI,\n    Ethers.provider().getSigner()\n  );\n  votingContract\n    .vote(allQuestions[question_id], state.nftId, decision)\n    .then((transactionHash) => {\n      console.log(\"transaction hash is \" + transactionHash);\n    });\n};\n\nreturn (\n  <>\n    <div class=\"container border border-info p-3 text-center\">\n      <h1>Hello {props.name}</h1>\n\n      <p>\n        {\"Your zkSync account is:\"}\n        {account}\n      </p>\n      <p>\n        {\" Balance is: \"} {state.accountBalance}\n      </p>\n      <p>\n        {\" Has NFT is: \"} {state.hasNFT} {\" id\"} {state.nftId}\n      </p>\n\n      <p>\n        {allQuestions.map((name, index) => (\n          <p>\n            {\" \"}\n            {\"Question \"} {index} {\" is: \"}\n            <b> {name}</b> <br /> {\"Current votes: +\"}{\" \"}\n            {state.getVotes[index][0]} {\" - \"}\n            {state.getVotes[index][1]}\n            <br />\n            <button onClick={() => vote(true, index)}>Vote YES</button>\n            <button onClick={() => vote(false, index)}>Vote NO</button>\n          </p>\n        ))}\n      </p>\n\n      <input\n        value={state.addQuestion}\n        onChange={(e) => State.update({ addQuestion: e.target.value })}\n        placeholder=\"Your question\"\n      />\n      <button onClick={() => addQuestion()}>Add question</button>\n    </div>\n  </>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/mm-near.near/widget/zkSyncExp", "fact_widget_deployments_id": "63616b7e963ef50a4857aec3d8ee1b6d", "inserted_timestamp": "2023-09-24T12:46:19.858Z", "modified_timestamp": "2023-09-24T12:46:19.858Z", "__row_index": 0}