{"tx_hash": "7AnNCuQydJg5Y3t9VZhuSHkUQBvLjMEo498HrJ1vZsBA", "action_id_social": "Gm1LHfCRg9U5qYrWoVHWxkt5MpznrQ6JtZX1an6p45Y-0-widget", "block_id": 107462851, "block_timestamp": "2023-12-08T20:30:37.608Z", "signer_id": "fastvault.near", "widget_name": "EncryptedImage", "source_code": "/* Image component that allows to show encrypted images, given a password. */\n\nconst image = props.image;\nconst className = props.className;\nconst style = props.style;\nconst alt = props.alt ?? \"Not set\";\nconst fallbackUrl = props.fallbackUrl;\nconst unableToDecryptUrl =\n  props.unableToDecryptUrl ??\n  \"https://ipfs.near.social/ipfs/bafkreidkq63i7r6cyowrmqksj7mz2zr4iawkc5p232oxs7souopsknkcju\";\nconst determineFileType = props.determineFileType;\nconst fileType = props.fileType;\nconst ipfsUrl =\n  props.ipfsUrl ?? ((cid) => `https://ipfs.near.social/ipfs/${cid}`);\n\n// Optional: will load from local storage or recover from account id and password.\nconst decryptSk = props.decryptSk;\n\n/// Required to pass in.\nconst password = props.password;\n\nif (!password) {\n  return <> \"props.password is required for EncryptedImage\" </>;\n}\n\nconst { decrypt, newSecretKey } = VM.require(\n  \"fastvault.near/widget/module.crypto\"\n);\n\nState.init({\n  image,\n});\n\nconst thumb = (imageUrl) =>\n  thumbnail && imageUrl && !imageUrl.startsWith(\"data:image/\")\n    ? `https://i.near.social/${thumbnail}/${imageUrl}`\n    : imageUrl;\n\nconst [storageSk, _] = useState(() => {\n  if (decryptSk) {\n    // decryptSk is available. use it instead of recovering\n    if (password) {\n      console.log(\"Utilizing decryptSk over password\");\n    }\n    return decryptSk;\n  }\n  const localSk = Storage.privateGet(\"storage_secret\");\n  if (localSk && !password) {\n    return localSk;\n  }\n  const sk = newSecretKey(context.accountId, password);\n  console.log(\"recovered decryption key for local storage\");\n  Storage.privateSet(\"storage_secret\", sk);\n  return sk;\n});\n\nconst check = (headers) => {\n  return (buffers) =>\n    headers.every((header, index) => header === buffers[index]);\n};\n\n// Only define common image types. User can supply their own determine filetype check if they want.\nconst isPng = check([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a]);\nconst isJpg = check([0xff, 0xd8, 0xff]);\nconst isGif = check([0x47, 0x49, 0x46, 0x38]);\nconst isBmp = check([0x42, 0x4d]);\n\nconst getFileType =\n  determineFileType ??\n  ((u8buf) => {\n    if (isPng(u8buf)) {\n      return \"png\";\n    }\n    if (isJpg(u8buf)) {\n      return \"jpg\";\n    }\n    if (isGif(u8buf)) {\n      return \"gif\";\n    }\n    if (isBmp(u8buf)) {\n      return \"bmp\";\n    }\n  });\n\nconst fetchImage = (cid) => {\n  asyncFetch(ipfsUrl(cid)).then((file) => {\n    if (!file.ok) {\n      console.log(\"IPFS fetch not ok\", file);\n      return;\n    }\n\n    // Expect ciphertext and nonce to be Array type. Convert to Uint8Array.\n    const ciphertext = new Uint8Array(file.body.ciphertext);\n    const nonce = new Uint8Array(file.body.nonce);\n    const bytes = decrypt(nonce, ciphertext, storageSk);\n\n    if (bytes) {\n      const fileType = fileType ?? `image/${getFileType(bytes)}`;\n      State.update({\n        imageUrl: URL.createObjectURL(new Blob([bytes], { type: fileType })),\n      });\n    } else {\n      console.log(`could not decrypt '${file.body.name}'`);\n      State.update({\n        imageUrl: unableToDecryptUrl,\n      });\n    }\n  });\n};\n\nuseEffect(() => {\n  if (image.ipfs_cid) {\n    fetchImage(image.ipfs_cid);\n  }\n}, [image]);\n\nreturn (\n  <img\n    className={className}\n    style={style}\n    src={state.imageUrl ?? thumb(fallbackUrl)}\n    alt={alt}\n    onError={() => {\n      if (state.imageUrl !== fallbackUrl) {\n        State.update({\n          imageUrl: fallbackUrl,\n        });\n      }\n    }}\n  />\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/fastvault.near/widget/EncryptedImage", "fact_widget_deployments_id": "27227351fe17c2460ac2c8eb5309eb89", "inserted_timestamp": "2023-12-08T22:30:11.712Z", "modified_timestamp": "2023-12-20T03:22:11.422Z", "__row_index": 2}