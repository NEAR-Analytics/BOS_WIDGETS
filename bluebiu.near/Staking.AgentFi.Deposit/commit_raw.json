{"tx_hash": "65TdRFgXvZxVgp2fmpUUvKPiecBz4ACkEWJCZYV6JEPX", "action_id_social": "DykSkt6s3WrJeyTUSZdS41T5Lv9Mduzz4JsvfCm8Gvyk-0-widget", "block_id": 121063375, "block_timestamp": "2024-06-13T07:48:52.601Z", "signer_id": "bluebiu.near", "widget_name": "Staking.AgentFi.Deposit", "source_code": "const StyledContainer = styled.div`\n  display: flex;\n  flex-direction: column;\n  align-items: stretch;\n  height: 100%;\n`;\nconst StyledFormItem = styled.div`\n  border-bottom: 1px solid #373A53;\n  padding-bottom: 18px;\n  padding-top: 18px;\n\n  &.inline {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n  }\n\n  &:first-child {\n    padding-top: 0;\n  }\n`;\nconst StyledFormItemTitle = styled.div`\n  font-size: 14px;\n  font-weight: 400;\n  line-height: 17px;\n  color: #979ABE;\n`;\nconst StyledFormItemBody = styled.div`\n  margin-top: 8px;\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  gap: 20px;\n`;\nconst StyledFormItemFoot = styled.div`\n  margin-top: 8px;\n  display: flex;\n  justify-content: space-between;\n  font-size: 12px;\n  font-weight: 400;\n  line-height: 14.4px;\n  color: rgba(151, 154, 190, 1);\n`;\nconst StyledInput = styled.input`\n  flex: 1;\n  width: 0;\n  color: #fff;\n  font-size: 20px;\n  font-weight: 500;\n  border: none;\n  height: 24px;\n  outline: none;\n  background-color: transparent;\n  padding: 0;\n\n  &:focus {\n    color: #fff;\n    background-color: transparent;\n    border-color: transparent;\n    outline: none;\n    box-shadow: none;\n  }\n`;\nconst StyledList = styled.div`\n  display: flex;\n  flex-direction: column;\n  justify-content: flex-start;\n  align-items: stretch;\n  gap: 8px;\n  margin-top: 8px;\n`;\nconst StyledListItem = styled.div`\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  font-size: 14px;\n\n  .label {\n    color: #979ABE;\n  }\n\n  .value {\n    color: #fff;\n  }\n`;\nconst StyledContent = styled.div`\n  flex: 1;\n`;\nconst StyledButton = styled.button`\n  background: var(--switch-color);\n  color: var(--button-text-color);\n\n  display: block;\n  width: 100%;\n  font-size: 16px;\n  font-weight: 600;\n  height: 56px;\n  line-height: 56px;\n  border-radius: 6px;\n  cursor: pointer;\n  transition: 0.5s;\n  margin-top: auto;\n  text-align: center;\n\n  &:hover {\n    opacity: 0.8;\n  }\n\n  &:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n  }\n`;\nconst StyledFullSelect = styled.div`\n  width: 100%;\n\n  > div {\n    width: 100%;\n\n    > div[type=\"button\"] {\n      width: 100%;\n    }\n  }\n`;\nconst StyledTips = styled.div`\n  color: rgb(151, 154, 190);\n  font-size: 14px;\n  font-style: normal;\n  font-weight: 400;\n  line-height: normal;\n  margin-bottom: 16px;\n\n  &.full {\n    height: 100%;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n  }\n`;\nconst StyledWithdrawTips = styled.div`\n  width: 240px;\n  text-align: center;\n  margin: 0 auto;\n\n  .value {\n    color: var(--switch-color);\n    font-size: 18px;\n  }\n\n  .title {\n    border-bottom: 1px solid #373A53;\n    font-size: 18px;\n    color: rgb(151, 154, 190);\n    padding: 8px 0;\n  }\n\n  .assets {\n    margin-top: 8px;\n  }\n\n  .head-wd {\n    border-bottom: 1px solid #373A53;\n\n    .col-wd {\n      color: rgb(151, 154, 190);\n    }\n  }\n\n  .row-wd {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    gap: 8px;\n    flex-wrap: nowrap;\n  }\n\n  .col-wd {\n    flex-shrink: 0;\n    flex-basis: 33.33%;\n    color: #fff;\n    font-size: 14px;\n    text-align: left;\n    padding: 8px 0;\n  }\n\n  .body-wd {\n  }\n`;\n\nconst DEPOSIT_POOL_ABI_MULTI = [\n  {\n    inputs: [\n      {\n        \"components\": [\n          {\n            \"internalType\": \"address\",\n            \"name\": \"to\",\n            \"type\": \"address\",\n          },\n          {\n            \"internalType\": \"uint256\",\n            \"name\": \"value\",\n            \"type\": \"uint256\",\n          },\n          {\n            \"internalType\": \"bytes\",\n            \"name\": \"data\",\n            \"type\": \"bytes\",\n          },\n          {\n            \"internalType\": \"uint8\",\n            \"name\": \"operation\",\n            \"type\": \"uint8\",\n          },\n        ],\n        \"internalType\": \"struct BatchExecutor.Operation[]\",\n        \"name\": \"operations\",\n        \"type\": \"tuple[]\",\n      },\n    ],\n    name: \"executeBatch\",\n    outputs: [\n      {\n        \"internalType\": \"bytes[]\",\n        \"name\": \"\",\n        \"type\": \"bytes[]\",\n      },\n    ],\n    stateMutability: \"payable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        name: \"receiver\",\n        type: \"address\",\n        internalType: \"address\",\n      },\n      {\n        name: \"sqrtPriceX96\",\n        type: \"uint160\",\n        internalType: \"uint160\",\n      },\n      {\n        name: \"slippageLiquidity\",\n        type: \"uint24\",\n        internalType: \"uint24\",\n      },\n    ],\n    name: \"moduleC_increaseLiquidityWithBalanceAndRefundTo\",\n    outputs: [\n      {\n        name: \"liquidity\",\n        type: \"uint128\",\n        internalType: \"uint128\",\n      },\n      {\n        name: \"amount0\",\n        type: \"uint256\",\n        internalType: \"uint256\",\n      },\n      {\n        name: \"amount1\",\n        type: \"uint256\",\n        internalType: \"uint256\",\n      },\n    ],\n    stateMutability: \"payable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"bytes[]\", name: \"data\", type: \"bytes[]\" }\n    ],\n    name: \"multicall\",\n    outputs: [\n      { internalType: \"bytes[]\", name: \"\", type: \"bytes[]\" }\n    ],\n    stateMutability: \"payable\",\n    type: \"function\",\n  },\n];\nconst TRANSFORM_TOKEN_ABI = [\n  {\n    inputs: [\n      {\n        name: \"from\",\n        type: \"address\",\n        internalType: \"address\",\n      },\n      {\n        name: \"to\",\n        type: \"address\",\n        internalType: \"address\",\n      },\n      {\n        name: \"amount\",\n        type: \"uint256\",\n        internalType: \"uint256\",\n      },\n    ],\n    name: \"transferFrom\",\n    outputs: [\n      { internalType: \"bytes\", name: \"returnData\", type: \"bytes\" },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\n\nconst { parseUnits, formatUnits } = ethers.utils;\n\nconst {\n  record,\n  prices,\n  dexConfig,\n  getTokenBalance,\n  currentStrategy,\n  account,\n  rootAgent,\n  onSuccess,\n  addAction,\n  toast,\n  chainId,\n  handleApprove,\n  balanceList,\n  queryPoolInfo,\n  strategies,\n} = props;\n\nconst { StakeTokens } = dexConfig;\n\nconst actionText = \"Stake\";\n\nState.init({\n  pending: false,\n\n  //#region dex/clm\n  currentEthToken: {},\n  ethAmount: \"\",\n  ethTokens: [],\n  currentEthTokenBalance: 0,\n  usdAmount: \"\",\n  usdTokens: [],\n  currentUsdToken: {},\n  currentUsdTokenBalance: 0,\n  //#endregion\n\n  //#region Multipliooor\n  stakeAmount: \"\",\n  stakeTokens: [],\n  stakeToken: {},\n  stakeTokenBalance: 0,\n  //#endregion\n\n  //#region clm\n  currentEthPer: 50,\n  currentUsdPer: 50,\n  //#endregion\n});\n\nconst formatAddAction = (actionText, _amount, status, transactionHash, tokenSymbol) => {\n  addAction?.({\n    type: \"Staking\",\n    action: actionText,\n    token: {\n      symbol: tokenSymbol,\n    },\n    amount: _amount,\n    template: props.name,\n    add: false,\n    status,\n    transactionHash,\n  });\n};\n\nconst queryUSDBTransform = () => {\n  // query usdb fransform\n  const iface = new ethers.utils.Interface(TRANSFORM_TOKEN_ABI);\n  const params = [\n    // from\n    account,\n    // to\n    record.agentAddress,\n    // amount\n    ethers.BigNumber.from(Big(state.usdAmount).times(Big(10).pow(state.currentUsdToken.decimals)).toString()),\n  ];\n  return iface.encodeFunctionData(\"transferFrom\", params);\n};\n\nconst handleSubmit = () => {\n  if (record.name.toLowerCase() === strategies[2].name) {\n    if (!state.ethAmount || !state.usdAmount) return;\n    State.update({\n      pending: true,\n    });\n\n    const data = queryUSDBTransform();\n\n    // const params = [\n    //   {\n    //     to: record.agentAddress,\n    //     value: parseUnits(state.ethAmount, state.currentEthToken.decimals),\n    //     data: '0x',\n    //     operation: 0,\n    //   },\n    //   {\n    //     to: state.currentUsdToken.address,\n    //     value: 0,\n    //     data: data,\n    //     operation: 0,\n    //   },\n    //   {\n    //     to: record.agentAddress,\n    //     value: 0,\n    //     data: '0x7bb485dc',\n    //     operation: 0,\n    //   },\n    // ];\n    const params = [\n      [\n        record.agentAddress,\n        // Big(state.ethAmount).times(Big(10).pow(state.currentEthToken.decimals)).toNumber(),\n        parseUnits(state.ethAmount, state.currentEthToken.decimals),\n        \"0x\",\n        0,\n      ],\n      [\n        state.currentUsdToken.address,\n        0,\n        data,\n        0,\n      ],\n      [\n        record.agentAddress,\n        0,\n        \"0x7bb485dc\",\n        0,\n      ],\n    ];\n\n    const approveList = [\n      handleApprove(rootAgent.agentAddress, state.currentEthToken.address, state.ethAmount, state.currentEthToken.decimals),\n      handleApprove(rootAgent.agentAddress, state.currentUsdToken.address, state.usdAmount, state.currentUsdToken.decimals),\n    ];\n    Promise.all(approveList).then((approveRes) => {\n      if (approveRes.some((approved) => !approved)) {\n        State.update({\n          pending: false,\n        });\n        return;\n      }\n\n      const contract = new ethers.Contract(\n        rootAgent.agentAddress,\n        DEPOSIT_POOL_ABI_MULTI,\n        Ethers.provider().getSigner(),\n      );\n\n      const getTx = (gas) => {\n        const contractOption = {\n          gasLimit: gas || 4000000,\n        };\n        if (['ETH'].includes(state.currentEthToken.value)) {\n          contractOption.value = parseUnits(state.ethAmount, state.currentEthToken.decimals || 18);\n        }\n        contract.executeBatch(params, contractOption)\n          .then((tx) => {\n            tx.wait()\n              .then((res) => {\n                const { status, transactionHash } = res;\n                State.update({\n                  pending: false,\n                });\n                if (status !== 1) throw new Error(\"\");\n                onSuccess();\n                formatAddAction(actionText, state.ethAmount, status, transactionHash, state.currentEthToken.value);\n                toast?.success({\n                  title: `${actionText} Successfully!`,\n                  text: `${actionText} ${state.ethAmount} ${state.currentEthToken.value}`,\n                  tx: transactionHash,\n                  chainId,\n                });\n              })\n              .catch((err) => {\n                console.log(\"tx error: \", err);\n                State.update({\n                  pending: false,\n                });\n                toast?.fail({\n                  title: `${actionText} Failed!`,\n                  text: err?.message?.includes(\"user rejected transaction\")\n                    ? \"User rejected transaction\"\n                    : ``,\n                });\n              });\n          })\n          .catch((err) => {\n            console.log(\"contract fn error: \", err);\n            State.update({\n              pending: false,\n            });\n            toast?.fail({\n              title: `${actionText} Failed!`,\n              text: err?.message?.includes(\"user rejected transaction\")\n                ? \"User rejected transaction\"\n                : ``,\n            });\n          });\n      };\n\n      const estimateGas = () => {\n        contract.estimateGas.executeBatch(\n          params,\n          { value: parseUnits(state.ethAmount, state.currentEthToken.decimals || 18) },\n        ).then((gas) => {\n          getTx(gas);\n        }).catch((err) => {\n          console.log(\"get gas failed: \", err);\n          getTx();\n        });\n      };\n\n      estimateGas();\n    });\n    return;\n  }\n  if (record.name.toLowerCase() === strategies[3].name) {\n    if (!state.stakeAmount || !rootAgent.agentAddress) return;\n    State.update({\n      pending: true,\n    });\n\n    // const params = [\n    //   {\n    //     to: rootAgent.agentAddress,\n    //     value: parseUnits(state.stakeAmount, state.stakeToken.decimals),\n    //     data: '0x',\n    //     operation: 0,\n    //   },\n    //   {\n    //     to: rootAgent.agentAddress,\n    //     value: 0,\n    //     data: '0x7bb485dc',\n    //     operation: 0,\n    //   },\n    // ];\n    const params = [\n      [\n        record.agentAddress,\n        parseUnits(state.stakeAmount, state.stakeToken.decimals),\n        \"0x\",\n        0,\n      ],\n      [\n        record.agentAddress,\n        0,\n        \"0x7bb485dc\",\n        0,\n      ],\n    ];\n\n    const contract = new ethers.Contract(\n      rootAgent.agentAddress,\n      DEPOSIT_POOL_ABI_MULTI,\n      Ethers.provider().getSigner(),\n    );\n\n    const getTx = (gas) => {\n      const contractOption = {\n        gasLimit: gas || 4000000,\n        value: parseUnits(state.stakeAmount, state.stakeToken.decimals || 18),\n      };\n      contract.executeBatch(params, contractOption)\n        .then((tx) => {\n          tx.wait()\n            .then((res) => {\n              const { status, transactionHash } = res;\n              State.update({\n                pending: false,\n              });\n              if (status !== 1) throw new Error(\"\");\n              onSuccess();\n              formatAddAction(actionText, state.stakeAmount, status, transactionHash, state.stakeToken.value);\n              toast?.success({\n                title: `${actionText} Successfully!`,\n                text: `${actionText} ${state.stakeAmount} ${state.stakeToken.value}`,\n                tx: transactionHash,\n                chainId,\n              });\n            })\n            .catch((err) => {\n              console.log(\"tx error: \", err);\n              State.update({\n                pending: false,\n              });\n              toast?.fail({\n                title: `${actionText} Failed!`,\n                text: err?.message?.includes(\"user rejected transaction\")\n                  ? \"User rejected transaction\"\n                  : ``,\n              });\n            });\n        })\n        .catch((err) => {\n          console.log(\"contract fn error: \", err);\n          State.update({\n            pending: false,\n          });\n          toast?.fail({\n            title: `${actionText} Failed!`,\n            text: err?.message?.includes(\"user rejected transaction\")\n              ? \"User rejected transaction\"\n              : ``,\n          });\n        });\n    };\n\n    const estimateGas = () => {\n      contract.estimateGas.executeBatch(\n        params,\n        { value: parseUnits(state.stakeAmount, state.stakeToken.decimals || 18) },\n      ).then((gas) => {\n        getTx(gas);\n      }).catch((err) => {\n        console.log(\"get gas failed: \", err);\n        getTx();\n      });\n    };\n\n    estimateGas();\n    return;\n  }\n  if (record.name.toLowerCase() === strategies[1].name) {\n    if (!state.ethAmount || !state.usdAmount) return;\n    State.update({\n      pending: true,\n    });\n\n    const data = queryUSDBTransform();\n    // fixed 0.30 % fee tier\n    queryPoolInfo({ fee: currentStrategy.meta.feeTierList[2] }).then((poolRes) => {\n      if (!poolRes) {\n        State.update({\n          pending: false,\n        });\n        toast?.fail({\n          title: `${actionText} Failed!`,\n          text: 'Query pool information failed!',\n        });\n        return;\n      }\n      const { sqrtPriceX96 } = poolRes;\n\n      // queryPoolInfo({ fee: currentStrategy.meta.feeTierList[1] }).then((pool1) => {\n      //   queryPoolInfo({ fee: currentStrategy.meta.feeTierList[0] }).then((pool0) => {\n      //     console.log('pool0.sqrtPriceX96: ', pool0.sqrtPriceX96);\n      //     console.log('pool1.sqrtPriceX96: ', pool1.sqrtPriceX96);\n      //     console.log('pool2.sqrtPriceX96: ', sqrtPriceX96);\n      //   });\n      // });\n\n      const approveList = [\n        handleApprove(record.agentAddress, state.currentEthToken.address, state.ethAmount, state.currentEthToken.decimals),\n        handleApprove(\n          record.agentAddress,\n          state.currentUsdToken.address,\n          '115792089237316195423570985008687907853269984665640564039457.584007913129639935',\n          state.currentUsdToken.decimals\n        ),\n      ];\n      if (state.currentEthToken.value !== 'ETH') {\n        approveList[0] = handleApprove(\n          record.agentAddress,\n          state.currentEthToken.address,\n          '115792089237316195423570985008687907853269984665640564039457.584007913129639935',\n          state.currentEthToken.decimals\n        );\n      }\n      Promise.all(approveList).then((approveRes) => {\n        if (approveRes.some((approved) => !approved)) {\n          State.update({\n            pending: false,\n          });\n          return;\n        }\n\n        const executeBatchParams = [\n          [\n            {\n              to: state.currentUsdToken.address,\n              value: '0',\n              data,\n              operation: 0\n            }\n          ]\n        ];\n        const moduleCParams = [\n          account,\n          sqrtPriceX96,\n          1000000,\n        ];\n\n        const iface = new ethers.utils.Interface(DEPOSIT_POOL_ABI_MULTI);\n        const multicallParams = [\n          iface.encodeFunctionData(\"executeBatch\", executeBatchParams),\n          iface.encodeFunctionData(\"moduleC_increaseLiquidityWithBalanceAndRefundTo\", moduleCParams)\n        ];\n\n        const multicallContract = new ethers.Contract(\n          record.agentAddress,\n          DEPOSIT_POOL_ABI_MULTI,\n          Ethers.provider().getSigner()\n        );\n\n        const multicallOptions = {};\n\n        if (['ETH'].includes(state.currentEthToken.value)) {\n          multicallOptions.value = parseUnits(state.ethAmount, state.currentEthToken.decimals || 18);\n        }\n\n        const getTx = (_gas) => {\n          multicallContract\n            // .populateTransaction\n            .multicall(multicallParams, {\n              ...multicallOptions,\n              gasLimit: _gas || 5000000,\n            })\n            .then((tx) => {\n              tx.wait().then((res) => {\n                const { status, transactionHash } = res;\n                State.update({\n                  pending: false,\n                });\n                if (status !== 1) throw new Error(\"\");\n                onSuccess();\n                formatAddAction(actionText, state.ethAmount, status, transactionHash, state.currentEthToken.value);\n                toast?.success({\n                  title: `${actionText} Successfully!`,\n                  text: `${actionText} ${state.ethAmount} ${state.currentEthToken.value}`,\n                  tx: transactionHash,\n                  chainId,\n                });\n              }).catch((err) => {\n                console.log('Concentrated Liquidity Manager deposit faild when wait, ', err);\n                State.update({\n                  pending: false,\n                });\n                toast?.fail({\n                  title: `${actionText} Failed!`,\n                  text: err?.message?.includes(\"user rejected transaction\")\n                    ? \"User rejected transaction\"\n                    : ``,\n                });\n              });\n            })\n            .catch((err) => {\n              console.log('Concentrated Liquidity Manager deposit faild when multicall, ', err);\n              State.update({\n                pending: false,\n              });\n              toast?.fail({\n                title: `${actionText} Failed!`,\n                text: err?.message?.includes(\"user rejected transaction\")\n                  ? \"User rejected transaction\"\n                  : ``,\n              });\n            });\n        };\n\n        const estimateGas = () => {\n          multicallContract.estimateGas\n            .multicall(multicallParams, multicallOptions)\n            .then((_gas) => {\n              getTx(_gas);\n            })\n            .catch((err) => {\n              getTx();\n            });\n        };\n\n        estimateGas();\n      });\n    });\n  }\n};\n\n//#region dex/clm\nconst handleUsdAmount = (ev) => {\n  if (isNaN(Number(ev.target.value))) return;\n  let amount = ev.target.value.replace(/\\s+/g, \"\");\n\n  if (!amount) {\n    State.update({\n      ethAmount: \"\",\n      usdAmount: \"\",\n    });\n    return;\n  }\n\n  if (Big(amount || 0).gt(Big(state.currentUsdTokenBalance || 0))) {\n    amount = Big(state.currentUsdTokenBalance || 0).toFixed(4, 0);\n  }\n  let calcEthAmount = Big(amount).times(prices[state.currentUsdToken.value]).div(prices[state.currentEthToken.value]).toFixed(state.currentEthToken.decimals, 0);\n  if (record.name.toLowerCase() === strategies[1].name) {\n    if (Big(state.currentUsdPer).lte(0)) {\n      calcEthAmount = Big(amount).times(prices[state.currentUsdToken.value]).times(Big(state.currentEthPer).div(100)).div(prices[state.currentEthToken.value]).toFixed(state.currentEthToken.decimals);\n    } else {\n      calcEthAmount = Big(amount).times(prices[state.currentUsdToken.value]).div(Big(state.currentUsdPer).div(100)).times(Big(state.currentEthPer).div(100)).div(prices[state.currentEthToken.value]).toFixed(state.currentEthToken.decimals);\n    }\n  }\n  State.update({\n    usdAmount: amount,\n    ethAmount: calcEthAmount,\n  });\n};\n\nconst handleUsdToken = (option) => {\n  if (option.value === state.currentUsdToken.value) return;\n  State.update({\n    currentUsdToken: option,\n    usdAmount: \"\",\n    ethAmount: \"\",\n  });\n  getTokenBalance(option).then((value) => {\n    State.update({\n      currentUsdTokenBalance: value,\n    });\n  });\n};\n\nconst handleUsdBalance = (value) => {\n  // auto enter eth amount\n  const updates = {\n    usdAmount: Big(value).toFixed(4, 0),\n  };\n  updates.ethAmount = Big(updates.usdAmount).times(prices[state.currentUsdToken.value]).div(prices[state.currentEthToken.value]).toFixed(state.currentEthToken.decimals, 0);\n  if (record.name.toLowerCase() === strategies[1].name) {\n    updates.ethAmount = Big(updates.usdAmount).times(prices[state.currentUsdToken.value]).div(Big(state.currentUsdPer).div(100)).times(Big(state.currentEthPer).div(100)).div(prices[state.currentEthToken.value]).toFixed(state.currentEthToken.decimals);\n  }\n  State.update(updates);\n};\n\nconst handleEthAmount = (ev) => {\n  if (isNaN(Number(ev.target.value))) return;\n  let amount = ev.target.value.replace(/\\s+/g, \"\");\n\n  if (!amount) {\n    State.update({\n      ethAmount: \"\",\n      usdAmount: \"\",\n    });\n    return;\n  }\n\n  if (Big(amount || 0).gt(Big(state.currentEthTokenBalance || 0))) {\n    amount = Big(state.currentEthTokenBalance || 0).toFixed(4, 0);\n  }\n  let calcUsdAmount = Big(amount).times(prices[state.currentEthToken.value]).div(prices[state.currentUsdToken.value]).toFixed(state.currentUsdToken.decimals, 0);\n  if (record.name.toLowerCase() === strategies[1].name) {\n    if (Big(state.currentEthPer).lte(0)) {\n      calcUsdAmount = Big(amount).times(prices[state.currentEthToken.value]).times(Big(state.currentUsdPer).div(100)).div(prices[state.currentUsdToken.value]).toFixed(state.currentUsdToken.decimals);\n    } else {\n      calcUsdAmount = Big(amount).times(prices[state.currentEthToken.value]).div(Big(state.currentEthPer).div(100)).times(Big(state.currentUsdPer).div(100)).div(prices[state.currentUsdToken.value]).toFixed(state.currentUsdToken.decimals);\n    }\n  }\n  State.update({\n    ethAmount: amount,\n    usdAmount: calcUsdAmount,\n  });\n};\n\nconst handleEthToken = (option) => {\n  if (option.value === state.currentEthToken.value) return;\n  State.update({\n    currentEthToken: option,\n    ethAmount: \"\",\n  });\n  getTokenBalance(option).then((value) => {\n    State.update({\n      currentEthTokenBalance: value,\n    });\n  });\n};\n\nconst handleEthBalance = (value) => {\n  // auto enter usd amount\n  const updates = {\n    ethAmount: Big(value).toFixed(4, 0),\n  };\n  updates.usdAmount = Big(updates.ethAmount).times(prices[state.currentEthToken.value]).div(prices[state.currentUsdToken.value]).toFixed(state.currentUsdToken.decimals, 0);\n  if (record.name.toLowerCase() === strategies[1].name) {\n    updates.usdAmount = Big(updates.ethAmount).times(prices[state.currentEthToken.value]).div(Big(state.currentEthPer).div(100)).times(Big(state.currentUsdPer).div(100)).div(prices[state.currentUsdToken.value]).toFixed(state.currentUsdToken.decimals);\n  }\n  State.update(updates);\n};\n//#endregion\n\n//#region Multipliooor\nconst handleAmount = (ev) => {\n  if (isNaN(Number(ev.target.value))) return;\n  let amount = ev.target.value.replace(/\\s+/g, \"\");\n\n  if (Big(amount || 0).gt(Big(state.stakeTokenBalance || 0))) {\n    amount = Big(state.stakeTokenBalance || 0).toFixed(4, 0);\n  }\n  State.update({\n    stakeAmount: amount,\n  });\n};\n\nconst handleToken = (option) => {\n  if (option.value === state.stakeToken.value) return;\n  State.update({\n    stakeToken: option,\n    stakeAmount: \"\",\n  });\n  const currToken = StakeTokens.find((it) => it.symbol === option.value);\n  currToken && getTokenBalance(currToken).then((value) => {\n    State.update({\n      stakeTokenBalance: value,\n    });\n  });\n};\n\nconst handleBalance = (value) => {\n  State.update({\n    stakeAmount: Big(value).toFixed(4, 0),\n  });\n};\n//#endregion\n\nuseEffect(() => {\n  //#region dex/clm\n  if ([strategies[2].name, strategies[1].name].includes(record.name.toLowerCase())) {\n    const _ethTokens = [];\n    const _usdTokens = [];\n    const EthStakeTokens = StakeTokens.filter((it) => [\"ETH\", \"WETH\"].includes(it.symbol));\n    const UsdStakeTokens = StakeTokens.filter((it) => [\"USDB\"].includes(it.symbol));\n    EthStakeTokens.forEach((it) => {\n      _ethTokens.push({\n        ...it,\n        text: it.symbol,\n        value: it.symbol,\n        icons: [it.icon],\n        address: it.address === \"native\" ? \"0x0000000000000000000000000000000000000000\" : it.address,\n      });\n    });\n    UsdStakeTokens.forEach((it) => {\n      _usdTokens.push({\n        ...it,\n        text: it.symbol,\n        value: it.symbol,\n        icons: [it.icon],\n      });\n    });\n    State.update({\n      ethTokens: _ethTokens,\n      currentEthToken: _ethTokens[0],\n      usdTokens: _usdTokens,\n      currentUsdToken: _usdTokens[0],\n    });\n    getTokenBalance(EthStakeTokens[0]).then((value) => {\n      State.update({\n        currentEthTokenBalance: value,\n      });\n    });\n    getTokenBalance(UsdStakeTokens[0]).then((value) => {\n      State.update({\n        currentUsdTokenBalance: value,\n      });\n    });\n  }\n  //#endregion\n\n  //#region Multipliooor\n  if (record.name.toLowerCase() === strategies[3].name) {\n    const _stakeTokens = [];\n    const eth = StakeTokens.find((it) => it.symbol === \"ETH\");\n    eth && _stakeTokens.push({\n      ...eth,\n      text: eth.symbol,\n      value: eth.symbol,\n      icons: [eth.icon],\n      address: \"0x0000000000000000000000000000000000000000\",\n    });\n    State.update({\n      stakeMode: currentStrategy.meta.modeList[0],\n      stakeTokens: _stakeTokens,\n      stakeToken: _stakeTokens[0] || {},\n    });\n    getTokenBalance(StakeTokens[0]).then((value) => {\n      State.update({\n        stakeTokenBalance: value,\n      });\n    });\n  }\n  //#endregion\n}, []);\n\nuseEffect(() => {\n  //#region 'Concentrated Liquidity Manager'\n  if (record.name.toLowerCase() === strategies[1].name) {\n    try {\n      const weth = balanceList.find((it) => [\"WETH\", \"ETH\"].includes(it.symbol));\n      const usdb = balanceList.find((it) => it.symbol === \"USDB\");\n      const wethVal = Big(weth.balance).times(prices[weth.symbol]);\n      const usdbVal = Big(usdb.balance).times(prices[usdb.symbol]);\n      const total = wethVal.plus(usdbVal);\n      if (total.lte(0)) {\n        State.update({\n          currentEthPer: 50,\n          currentUsdPer: 50,\n        });\n        return;\n      }\n      const wethPer = wethVal.div(total).times(100).toString();\n      const usdbPer = usdbVal.div(total).times(100).toString();\n      State.update({\n        currentEthPer: wethPer,\n        currentUsdPer: usdbPer,\n      });\n    } catch (err) {\n      console.log(err);\n    }\n  }\n  //#endregion\n}, [balanceList, prices]);\n\nconst {\n  pending,\n\n  //#region dex/clm\n  ethAmount,\n  currentEthToken,\n  ethTokens,\n  currentEthTokenBalance,\n  usdAmount,\n  usdTokens,\n  currentUsdToken,\n  currentUsdTokenBalance,\n  //#endregion\n\n  //#region Multipliooor\n  stakeAmount,\n  stakeTokens,\n  stakeToken,\n  stakeTokenBalance,\n  //#endregion\n} = state;\n\nconst renderButton = (disabled) => {\n  return (\n    <StyledButton\n      disabled={pending || disabled}\n      onClick={handleSubmit}\n    >\n      {pending ? (\n        <Widget\n          src=\"bluebiu.near/widget/0vix.LendingLoadingIcon\"\n          props={{\n            size: 16,\n          }}\n        />\n      ) : \"DEPOSIT MORE ETH\"}\n    </StyledButton>\n  );\n};\n\nconst renderDeposit = () => {\n  if (record.name.toLowerCase() === strategies[3].name) {\n    return (\n      <>\n        <StyledContent>\n          <StyledTips>\n            If the remaining funds are low, deposit more funds to ensure the Blast Multiplier tasks are completed.\n          </StyledTips>\n          <StyledFormItem>\n            <StyledFormItemTitle>\n              Watch for our Discord announcements!\n            </StyledFormItemTitle>\n            <StyledFormItemBody>\n              <StyledInput\n                type=\"text\"\n                placeholder=\"0\"\n                value={stakeAmount}\n                onChange={handleAmount}\n              />\n              <Widget\n                src=\"bluebiu.near/widget/UI.Select.Index\"\n                props={{\n                  options: stakeTokens,\n                  value: stakeToken,\n                  onChange: handleToken,\n                }}\n              />\n            </StyledFormItemBody>\n            <StyledFormItemFoot>\n              <div className=\"prices\">\n                ${Big(stakeAmount || 0).times(Big(prices[stakeToken.value] || 1)).toFixed(2, 0)}\n              </div>\n              <div className=\"balance\">\n                Balance:\n                <Widget\n                  src=\"bluebiu.near/widget/Staking.Kelp.Balance\"\n                  props={{\n                    value: stakeTokenBalance,\n                    digit: 4,\n                    onClick: handleBalance,\n                    symbol: stakeToken.value,\n                  }}\n                />\n              </div>\n            </StyledFormItemFoot>\n          </StyledFormItem>\n        </StyledContent>\n        {renderButton(!stakeAmount)}\n      </>\n    );\n  }\n  if (record.name.toLowerCase() === strategies[2].name || record.name.toLowerCase() === strategies[1].name) {\n    return (\n      <>\n        <StyledContent>\n          {\n            record.name.toLowerCase() === strategies[1].name ? (\n              <>\n                <StyledTips>\n                  Due to price movement, your LP position is {Big(state.currentEthPer).toFixed(0)}% : {Big(state.currentUsdPer).toFixed(0)}%, WETH :\n                  USDB.\n                </StyledTips>\n                <StyledTips>\n                  Deposit more below at the same ratio.\n                </StyledTips>\n              </>\n            ) : (\n              <StyledTips>\n                Add to your position\n              </StyledTips>\n            )\n          }\n          <StyledFormItem>\n            <StyledFormItemBody>\n              <StyledInput\n                type=\"text\"\n                placeholder=\"0\"\n                value={ethAmount}\n                onChange={handleEthAmount}\n              />\n              <Widget\n                src=\"bluebiu.near/widget/UI.Select.Index\"\n                props={{\n                  options: ethTokens,\n                  value: currentEthToken,\n                  onChange: handleEthToken,\n                }}\n              />\n            </StyledFormItemBody>\n            <StyledFormItemFoot>\n              <div className=\"prices\">\n                ${Big(ethAmount || 0).times(Big(prices[currentEthToken.value] || 1)).toFixed(2, 0)}\n              </div>\n              <div className=\"balance\">\n                Balance:\n                <Widget\n                  src=\"bluebiu.near/widget/Staking.Kelp.Balance\"\n                  props={{\n                    value: currentEthTokenBalance,\n                    digit: 5,\n                    onClick: handleEthBalance,\n                    symbol: currentEthToken.value,\n                  }}\n                />\n              </div>\n            </StyledFormItemFoot>\n            <StyledFormItemBody>\n              <StyledInput\n                type=\"text\"\n                placeholder=\"0\"\n                value={usdAmount}\n                onChange={handleUsdAmount}\n              />\n              <Widget\n                src=\"bluebiu.near/widget/UI.Select.Index\"\n                props={{\n                  options: usdTokens,\n                  value: currentUsdToken,\n                  onChange: handleUsdToken,\n                }}\n              />\n            </StyledFormItemBody>\n            <StyledFormItemFoot>\n              <div className=\"prices\">\n                ${Big(usdAmount || 0).times(Big(prices[currentUsdToken.value] || 1)).toFixed(2, 0)}\n              </div>\n              <div className=\"balance\">\n                Balance:\n                <Widget\n                  src=\"bluebiu.near/widget/Staking.Kelp.Balance\"\n                  props={{\n                    value: currentUsdTokenBalance,\n                    digit: 5,\n                    onClick: handleUsdBalance,\n                    symbol: currentUsdToken.value,\n                  }}\n                />\n              </div>\n            </StyledFormItemFoot>\n          </StyledFormItem>\n        </StyledContent>\n        {renderButton(!ethAmount && !usdAmount)}\n      </>\n    );\n  }\n  return null;\n};\n\nreturn (\n  <StyledContainer>\n    {renderDeposit()}\n  </StyledContainer>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/bluebiu.near/widget/Staking.AgentFi.Deposit", "fact_widget_deployments_id": "31b3b3240104e57fc7bb210f0d614108", "inserted_timestamp": "2024-06-13T09:04:53.640Z", "modified_timestamp": "2024-06-13T09:04:53.640Z", "__row_index": 2}