{"tx_hash": "2mxqHtYn2ggXzMB2XYpoyyyhpKCKuPaRRKCFXcJ8dbiV", "action_id_social": "vNtzzmshsAxHy8ZYXrkxX2FDdRWEg5H8ndemMStkp6Y-0-widget", "block_id": 101689628, "block_timestamp": "2023-09-22T09:17:47.470Z", "signer_id": "bluebiu.near", "widget_name": "MetaPool.StakeEthButton", "source_code": "const StakeButton = styled.button`\n  background-color: #c7ff18;\n  width: 100%;\n  height: 60px;\n  border-radius: 8px;\n  color: #000;\n  font-size: 18px;\n  font-weight: 500;\n  border: none;\n  transition: 0.5s;\n\n  &:disabled {\n    opacity: 0.5;\n  }\n  @media (max-width: 768px) {\n    height: 40px;\n    font-size: 16px;\n  }\n`;\n\nconst {\n  disabled,\n  amount,\n  ethAccount,\n  lpToken,\n  stakeType,\n  liquidAddress,\n  minAmountOut,\n  onSuccess,\n} = props;\n\nState.init({\n  isApproved: false,\n  approving: false,\n  loading: false,\n});\n\nconst getAllowance = () => {\n  const TokenContract = new ethers.Contract(\n    lpToken.address,\n    [\n      {\n        constant: true,\n        inputs: [\n          {\n            name: \"_owner\",\n            type: \"address\",\n          },\n          {\n            name: \"_spender\",\n            type: \"address\",\n          },\n        ],\n        name: \"allowance\",\n        outputs: [\n          {\n            name: \"\",\n            type: \"uint256\",\n          },\n        ],\n        payable: false,\n        stateMutability: \"view\",\n        type: \"function\",\n      },\n    ],\n    Ethers.provider().getSigner()\n  );\n  TokenContract.allowance(ethAccount, liquidAddress).then((allowanceRaw) => {\n    State.update({\n      isApproved: !Big(Number(allowanceRaw._hex)).eq(0),\n    });\n  });\n};\n\nif (stakeType) {\n  getAllowance();\n} else {\n  State.update({ isApproved: true });\n}\n\nconst handleApprove = () => {\n  State.update({\n    approving: true,\n  });\n  const TokenContract = new ethers.Contract(\n    lpToken.address,\n    [\n      {\n        constant: false,\n        inputs: [\n          {\n            name: \"_spender\",\n            type: \"address\",\n          },\n          {\n            name: \"_value\",\n            type: \"uint256\",\n          },\n        ],\n        name: \"approve\",\n        outputs: [\n          {\n            name: \"\",\n            type: \"bool\",\n          },\n        ],\n        payable: false,\n        stateMutability: \"nonpayable\",\n        type: \"function\",\n      },\n    ],\n    Ethers.provider().getSigner()\n  );\n  TokenContract.approve(liquidAddress, ethers.utils.parseUnits(amount, 18))\n    .then((tx) => {\n      tx.wait().then((res) => {\n        const { status, transactionHash } = res;\n        State.update({\n          isApproved: status === 1,\n          approving: false,\n        });\n      });\n    })\n    .catch(() => {\n      State.update({\n        approving: false,\n      });\n    });\n};\n\nif (!state.isApproved) {\n  return (\n    <StakeButton onClick={handleApprove} disabled={state.approving}>\n      {state.approving ? \" Wait...\" : \" Approve\"}\n    </StakeButton>\n  );\n}\n\nconst stakeEth = () => {\n  State.update({\n    loading: true,\n  });\n  const Erc20Contract = new ethers.Contract(\n    lpToken.address,\n    [\n      {\n        inputs: [\n          { internalType: \"address\", name: \"_receiver\", type: \"address\" },\n        ],\n        name: \"depositETH\",\n        outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n        stateMutability: \"payable\",\n        type: \"function\",\n      },\n    ],\n    Ethers.provider().getSigner()\n  );\n  Erc20Contract.depositETH(ethAccount, {\n    value: ethers.utils.parseEther(amount),\n  })\n    .then((tx) => {\n      tx.wait().then((res) => {\n        State.update({\n          loading: false,\n        });\n        if (res.status === 1) onSuccess?.();\n      });\n    })\n    .catch((err) => {\n      console.log(err);\n      State.update({\n        loading: false,\n      });\n    });\n};\nconst unstakeEthFastly = () => {\n  State.update({\n    loading: true,\n  });\n  const StakingContract = new ethers.Contract(\n    liquidAddress,\n    [\n      {\n        inputs: [\n          { internalType: \"uint256\", name: \"_amount\", type: \"uint256\" },\n          { internalType: \"uint256\", name: \"_minOut\", type: \"uint256\" },\n        ],\n        name: \"swapmpETHforETH\",\n        outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n        stateMutability: \"nonpayable\",\n        type: \"function\",\n      },\n    ],\n    Ethers.provider().getSigner()\n  );\n  StakingContract.swapmpETHforETH(\n    ethers.utils.parseEther(amount),\n    ethers.utils.parseEther(Big(minAmountOut).mul(0.995).toString()),\n    {\n      gasLimit: 5000000,\n    }\n  )\n    .then((tx) => {\n      tx.wait()\n        .then((res) => {\n          onSuccess?.(res);\n          State.update({\n            loading: false,\n          });\n        })\n        .catch((err) => {\n          State.update({\n            loading: false,\n          });\n        });\n    })\n    .catch((err) => {\n      console.log(err);\n      State.update({\n        loading: false,\n      });\n    });\n};\nconst unstakeEthDelay = () => {\n  State.update({\n    loading: true,\n  });\n  const Erc20Contract = new ethers.Contract(\n    lpToken.address,\n    [\n      {\n        inputs: [\n          { internalType: \"uint256\", name: \"shares\", type: \"uint256\" },\n          { internalType: \"address\", name: \"receiver\", type: \"address\" },\n          { internalType: \"address\", name: \"owner\", type: \"address\" },\n        ],\n        name: \"redeem\",\n        outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n        stateMutability: \"nonpayable\",\n        type: \"function\",\n      },\n    ],\n    Ethers.provider().getSigner()\n  );\n  Erc20Contract.redeem(ethers.utils.parseEther(amount), ethAccount, ethAccount)\n    .then((tx) => {\n      tx.wait()\n        .then((res) => {\n          onSuccess?.(res);\n          State.update({\n            loading: false,\n          });\n        })\n        .catch((err) => {\n          State.update({\n            loading: false,\n          });\n        });\n    })\n    .catch((err) => {\n      console.log(err);\n      State.update({\n        loading: false,\n      });\n    });\n};\n\nconst handleClick = () => {\n  if (stakeType === 0) {\n    stakeEth();\n    return;\n  }\n  if (stakeType === 1) {\n    unstakeEthFastly();\n    return;\n  }\n  if (stakeType === 2) {\n    unstakeEthDelay();\n    return;\n  }\n};\n\nreturn (\n  <StakeButton disabled={disabled || state.loading} onClick={handleClick}>\n    {state.loading ? \"Wait...\" : stakeType ? \"Unstake\" : \"Stake Now\"}\n  </StakeButton>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/bluebiu.near/widget/MetaPool.StakeEthButton", "fact_widget_deployments_id": "c27ba26b1a3ef9720b7f318cd001931a", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 0}