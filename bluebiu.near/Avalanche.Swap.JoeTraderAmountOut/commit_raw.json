{"tx_hash": "AJzVXXEr7tAvLDdQJzFPzCvJZer4b7ZqoE5vmKprifS9", "action_id_social": "BmddhkK4D4hYCxxGJjYEy5KiUo3Kqwz42wkFrE3NRSxu-0-widget", "block_id": 109558422, "block_timestamp": "2024-01-04T09:01:49.803Z", "signer_id": "bluebiu.near", "widget_name": "Avalanche.Swap.JoeTraderAmountOut", "source_code": "const QUOTER_ABI = [\n  {\n    inputs: [\n      {\n        internalType: \"address[]\",\n        name: \"route\",\n        type: \"address[]\",\n      },\n      {\n        internalType: \"uint128\",\n        name: \"amountIn\",\n        type: \"uint128\",\n      },\n    ],\n    name: \"findBestPathFromAmountIn\",\n    outputs: [\n      {\n        components: [\n          {\n            internalType: \"address[]\",\n            name: \"route\",\n            type: \"address[]\",\n          },\n          {\n            internalType: \"address[]\",\n            name: \"pairs\",\n            type: \"address[]\",\n          },\n          {\n            internalType: \"uint256[]\",\n            name: \"binSteps\",\n            type: \"uint256[]\",\n          },\n          {\n            internalType: \"enum ILBRouter.Version[]\",\n            name: \"versions\",\n            type: \"uint8[]\",\n          },\n          {\n            internalType: \"uint128[]\",\n            name: \"amounts\",\n            type: \"uint128[]\",\n          },\n          {\n            internalType: \"uint128[]\",\n            name: \"virtualAmountsWithoutSlippage\",\n            type: \"uint128[]\",\n          },\n          {\n            internalType: \"uint128[]\",\n            name: \"fees\",\n            type: \"uint128[]\",\n          },\n        ],\n        internalType: \"struct LBQuoter.Quote\",\n        name: \"quote\",\n        type: \"tuple\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\nconst ROUTER_ABI = [\n  {\n    inputs: [\n      {\n        internalType: \"uint256\",\n        name: \"amountOutMin\",\n        type: \"uint256\",\n      },\n      {\n        components: [\n          {\n            internalType: \"uint256[]\",\n            name: \"pairBinSteps\",\n            type: \"uint256[]\",\n          },\n          {\n            internalType: \"enum ILBRouter.Version[]\",\n            name: \"versions\",\n            type: \"uint8[]\",\n          },\n          {\n            internalType: \"contract IERC20[]\",\n            name: \"tokenPath\",\n            type: \"address[]\",\n          },\n        ],\n        internalType: \"struct ILBRouter.Path\",\n        name: \"path\",\n        type: \"tuple\",\n      },\n      {\n        internalType: \"address\",\n        name: \"to\",\n        type: \"address\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"deadline\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"swapExactNATIVEForTokens\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"amountOut\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"payable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"uint256\",\n        name: \"amountIn\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"amountOutMinNATIVE\",\n        type: \"uint256\",\n      },\n      {\n        components: [\n          {\n            internalType: \"uint256[]\",\n            name: \"pairBinSteps\",\n            type: \"uint256[]\",\n          },\n          {\n            internalType: \"enum ILBRouter.Version[]\",\n            name: \"versions\",\n            type: \"uint8[]\",\n          },\n          {\n            internalType: \"contract IERC20[]\",\n            name: \"tokenPath\",\n            type: \"address[]\",\n          },\n        ],\n        internalType: \"struct ILBRouter.Path\",\n        name: \"path\",\n        type: \"tuple\",\n      },\n      {\n        internalType: \"address payable\",\n        name: \"to\",\n        type: \"address\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"deadline\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"swapExactTokensForNATIVE\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"amountOut\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"uint256\",\n        name: \"amountIn\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"amountOutMin\",\n        type: \"uint256\",\n      },\n      {\n        components: [\n          {\n            internalType: \"uint256[]\",\n            name: \"pairBinSteps\",\n            type: \"uint256[]\",\n          },\n          {\n            internalType: \"enum ILBRouter.Version[]\",\n            name: \"versions\",\n            type: \"uint8[]\",\n          },\n          {\n            internalType: \"contract IERC20[]\",\n            name: \"tokenPath\",\n            type: \"address[]\",\n          },\n        ],\n        internalType: \"struct ILBRouter.Path\",\n        name: \"path\",\n        type: \"tuple\",\n      },\n      {\n        internalType: \"address\",\n        name: \"to\",\n        type: \"address\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"deadline\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"swapExactTokensForTokens\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"amountOut\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n];\n\nconst {\n  updater,\n  quoterAddress,\n  routerAddress,\n  wethAddress,\n  inputCurrency,\n  outputCurrency,\n  inputCurrencyAmount,\n  onLoad,\n  slippage,\n  account,\n} = props;\n\nuseEffect(() => {\n  if (\n    !inputCurrency.address ||\n    !outputCurrency.address ||\n    !inputCurrencyAmount\n  ) {\n    onLoad({});\n    return;\n  }\n\n  const wrapType =\n    inputCurrency.address === \"native\" && outputCurrency.address === wethAddress\n      ? 1\n      : inputCurrency.address === wethAddress &&\n        outputCurrency.address === \"native\"\n      ? 2\n      : 0;\n\n  if (wrapType) {\n    onLoad({\n      outputCurrencyAmount: inputCurrencyAmount,\n      noPair: false,\n    });\n    return;\n  }\n  const amount = ethers.utils.parseUnits(\n    Big(inputCurrencyAmount || 0).toFixed(inputCurrency.decimals),\n    inputCurrency.decimals\n  );\n\n  const path = [\n    inputCurrency.address === \"native\" ? wethAddress : inputCurrency.address,\n    outputCurrency.address === \"native\" ? wethAddress : outputCurrency.address,\n  ];\n\n  const getTraderJoeAmount = () => {\n    const QuoterContract = new ethers.Contract(\n      quoterAddress,\n      QUOTER_ABI,\n      Ethers.provider().getSigner()\n    );\n\n    QuoterContract.findBestPathFromAmountIn(path, amount)\n      .then((res) => {\n        const amount = Big(\n          ethers.utils.formatUnits(res[4][1], outputCurrency.decimals)\n        );\n\n        if (amount.gt(0)) {\n          const virtualAmount = Big(\n            ethers.utils.formatUnits(res[5][1], outputCurrency.decimals)\n          );\n          const priceImpact = Big(virtualAmount)\n            .minus(amount)\n            .div(virtualAmount)\n            .mul(100)\n            .toString();\n          getTraderJoeTransaction({\n            binSteps: res[2],\n            versions: res[3],\n            amountout: res[4][1],\n            priceImpact,\n            amountoutDesimals: amount.toString(),\n          });\n        } else {\n          onLoad({\n            noPair: true,\n          });\n        }\n      })\n      .catch((err) => {\n        onLoad({\n          noPair: true,\n        });\n      });\n  };\n\n  const getTraderJoeTransaction = ({\n    binSteps,\n    versions,\n    amountout,\n    priceImpact,\n    amountoutDesimals,\n  }) => {\n    const RouterContract = new ethers.Contract(\n      routerAddress,\n      ROUTER_ABI,\n      Ethers.provider().getSigner()\n    );\n    let method = \"\";\n    const deadline = Math.ceil(Date.now() / 1000) + 60;\n    const _amountOut = Big(amountout)\n      .mul(1 - (slippage || 0.05))\n      .toFixed(0);\n\n    const options = {};\n    const params = [_amountOut, [binSteps, versions, path], account, deadline];\n\n    if (inputCurrency.address === \"native\") {\n      method = \"swapExactNATIVEForTokens\";\n      options.value = amount;\n    } else if (outputCurrency.address === \"native\") {\n      method = \"swapExactTokensForNATIVE\";\n      params.unshift(amount);\n    } else {\n      method = \"swapExactTokensForTokens\";\n      params.unshift(amount);\n    }\n\n    const returnData = {\n      outputCurrencyAmount: Big(amountoutDesimals).gt(0.01)\n        ? Big(amountoutDesimals).toPrecision(10)\n        : Big(amountoutDesimals).toFixed(10),\n      priceImpact,\n    };\n\n    RouterContract.estimateGas[method](...params, options)\n      .then((_gas) => {\n        RouterContract.populateTransaction[method](...params, options)\n          .then((res) => {\n            onLoad({\n              ...returnData,\n              noPair: false,\n              gas: _gas,\n              unsignedTx: res,\n            });\n          })\n          .catch((err) => {\n            onLoad({\n              ...returnData,\n              noPair: false,\n              gas: _gas,\n            });\n          });\n      })\n      .catch((err) => {\n        onLoad({\n          ...returnData,\n          noPair: false,\n        });\n      });\n  };\n\n  getTraderJoeAmount();\n}, [updater]);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/bluebiu.near/widget/Avalanche.Swap.JoeTraderAmountOut", "fact_widget_deployments_id": "c8d93ee4c303ca081873af435499d195", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 4}