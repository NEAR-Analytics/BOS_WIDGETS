{"tx_hash": "4iMf8X8x4NHas5P2Ri5Jt5Sp8gJG3AeY3hDnijZqXeHX", "action_id_social": "7TWC8As3Bn1xmJUL2HYShcynoZvCSFDNgwqYCo4sba2w-0-widget", "block_id": 122374903, "block_timestamp": "2024-07-01T07:01:54.863Z", "signer_id": "bluebiu.near", "widget_name": "Liquidity.Bridge.Detail", "source_code": "\nconst {\n  // defaultPair,\n  // pair,\n  data,\n  toast,\n  prices,\n  addresses,\n  defaultDex,\n  proxyAddress,\n  addAction,\n  userPositions,\n  ICON_VAULT_MAP\n} = props;\n\nconst {\n  Row,\n  Column,\n  DetailWrapper,\n  FilterButtonList,\n  FilterButton,\n  InputWrapList,\n  InputWrap,\n  Input,\n  InputSuffix,\n  StyledImageList,\n  PriceWrap,\n  TotalPrice,\n  BalancePrice,\n  StyledButtonList,\n  StyledButton,\n} = VM.require('bluebiu.near/widget/Liquidity.Handler.Styles')\n\nconst defaultDeposit = props.tab === \"deposit\" || !props.tab;\n\nconst curPositionUSD = userPositions[data.vaultAddress]?.balanceUSD;\n\nState.init({\n  isDeposit: defaultDeposit,\n  lpBalance: \"\",\n  balances: [],\n  amount0: \"\",\n  amount1: \"\",\n  lpAmount: \"\",\n  isError: false,\n  isLoading: false,\n  isToken0Approved: true,\n  isToken1Approved: true,\n  isToken0Approving: false,\n  isToken1Approving: false,\n  loadingMsg: \"\",\n  isPostTx: false,\n  showPairs: false,\n});\nconst sourceBalances = {\n}\nconst {\n  isDeposit,\n  balances,\n  amount0,\n  amount1,\n  isLoading,\n  isError,\n  isToken0Approved,\n  isToken1Approved,\n  isToken0Approving,\n  isToken1Approving,\n  loadingMsg,\n  lpBalance,\n  lpAmount,\n  isPostTx,\n} = state;\n\nconst detailLoading = Object.keys(balances).length < 2 || lpBalance === \"\"\n\nconst getFromDepositAmount = (depositAmount, tokenDecimal) => {\n  let a = new Big(depositAmount[0].toString());\n  let b = new Big(depositAmount[1].toString());\n\n  if (a.eq(0) && b.eq(0)) return \"0\";\n\n  let diff;\n  let midpoint;\n  if (a.gt(b)) {\n    diff = a.minus(b);\n    midpoint = diff.div(new Big(2)).plus(b);\n  } else {\n    diff = b.minus(a);\n    midpoint = diff.div(new Big(2)).plus(a);\n  }\n\n  for (let i = tokenDecimal; i > 0; i--) {\n    const midpointFixed = midpoint\n      .div(new Big(10).pow(tokenDecimal))\n      .toFixed(i);\n    if (\n      a.div(Big(10).pow(tokenDecimal)).lte(midpointFixed) &&\n      b.div(Big(10).pow(tokenDecimal)).gte(midpointFixed)\n    ) {\n      return midpointFixed;\n    }\n  }\n\n  return \"0\";\n};\n\nconst sender = Ethers.send(\"eth_requestAccounts\", [])[0];\n// if (!sender) return <Web3Connect connectLabel=\"Connect with Web3\" />;\nconst { token0, token1, decimals0, decimals1, id } = data || defaultPair;\n\nconst vaultAddress = addresses[id];\n\n\n\nconst updateLPBalance = () => {\n  const abi = [\"function balanceOf(address) view returns (uint256)\"];\n  const vaultContract = new ethers.Contract(\n    vaultAddress,\n    abi,\n    Ethers.provider()\n  );\n  vaultContract.balanceOf(sender).then((balanceBig) => {\n    const adjustedBalance = ethers.utils.formatUnits(balanceBig, 18);\n    State.update({\n      lpBalance: adjustedBalance,\n    });\n  });\n};\nconst updateBalance = (token) => {\n  const { address, decimals, symbol } = token;\n  if (symbol === \"ETH\") {\n    Ethers.provider()\n      .getBalance(sender)\n      .then((balanceBig) => {\n        const adjustedBalance = ethers.utils.formatEther(balanceBig);\n        sourceBalances[symbol] = adjustedBalance\n        State.update({\n          balances: sourceBalances,\n        });\n      });\n  } else {\n    const erc20Abi = [\"function balanceOf(address) view returns (uint256)\"];\n    const tokenContract = new ethers.Contract(\n      address,\n      erc20Abi,\n      Ethers.provider()\n    );\n    tokenContract.balanceOf(sender)\n      .then((balanceBig) => {\n        const adjustedBalance = Big(\n          ethers.utils.formatUnits(balanceBig, decimals)\n        ).toFixed();\n        sourceBalances[symbol] = adjustedBalance\n        State.update({\n          balances: sourceBalances,\n        });\n      })\n      .catch(error => {\n        console.log('error: ', error);\n        setTimeout(() => {\n          updateBalance(token)\n        }, 1500)\n      });\n  }\n};\n\nuseEffect(() => {\n  if (!sender || !token0 || !token1) return;\n  [\n    { symbol: token0, address: addresses[token0], decimals: decimals0 },\n    { symbol: token1, address: addresses[token1], decimals: decimals1 },\n  ].map(updateBalance);\n\n  updateLPBalance();\n}, [sender, token0, token1]);\n\n\n\nconst handleCheckApproval = (symbol, amount, decimals) => {\n  const wei = ethers.utils.parseUnits(\n    Big(amount).toFixed(decimals),\n    decimals\n  );\n  const abi = [\n    \"function allowance(address, address) external view returns (uint256)\",\n  ];\n\n  const contract = new ethers.Contract(\n    addresses[symbol],\n    abi,\n    Ethers.provider()\n  );\n  return new Promise((resolve) => {\n    contract\n      .allowance(sender, vaultAddress)\n      .then((allowance) => {\n        const approved = !new Big(allowance.toString()).lt(wei)\n        State.update({\n          [symbol === token0 ? 'isToken0Approved' : 'isToken1Approved']: approved,\n        });\n        resolve(approved)\n      })\n      .catch((e) => console.log(e));\n  })\n}\nconst checkApproval = (amount, otherAmount, symbol, callback) => {\n  const otherSymbol = symbol === token0 ? token1 : token0\n  const decimals = symbol === token0 ? decimals0 : decimals1\n  const otherDecimals = symbol === token0 ? decimals1 : decimals0\n  const promiseArray = [\n    handleCheckApproval(symbol, amount, decimals),\n    handleCheckApproval(otherSymbol, otherAmount, otherDecimals)\n  ]\n  Promise.all(promiseArray).then(result => {\n    const [firstApproved, secondApproved] = result\n    if (callback) {\n      if (firstApproved && secondApproved) {\n        symbol === token0 ? callback(amount, otherAmount) : callback(otherAmount, amount)\n      } else {\n        toast?.dismiss(state.toastId);\n        State.update({\n          isLoading: false\n        })\n      }\n    }\n  })\n};\nconst changeMode = (isDeposit) => {\n  State.update({ isDeposit });\n};\n\nconst handleMax = (isToken0) => {\n  if (isToken0) handleTokenChange(balances[token0], token0);\n  else handleTokenChange(balances[token1], token1);\n};\n\nconst handleTokenChange = (amount, symbol, callback) => {\n  State.update({ [symbol === token0 ? 'amount0' : 'amount1']: amount });\n  if (Number(amount) === 0) {\n    State.update({\n      [symbol === token0 ? 'amount1' : 'amount0']: \"\",\n      isToken0Approved: true,\n      isToken1Approved: true,\n    });\n    return;\n  }\n\n  State.update({\n    isLoading: true,\n    isError: false,\n    loadingMsg: \"Computing deposit amount...\",\n  });\n  const decimals = (symbol === token0 ? decimals0 : decimals1)\n  const otherDecimals = symbol === token0 ? decimals1 : decimals0\n\n  const tokenWei = ethers.utils.parseUnits(\n    Big(amount).toFixed(decimals),\n    decimals\n  );\n\n  const proxyAbi = [\n    \"function getDepositAmount(address, address, uint256) public view returns (uint256, uint256)\",\n  ];\n  const proxyContract = new ethers.Contract(\n    proxyAddress,\n    proxyAbi,\n    Ethers.provider()\n  );\n\n  proxyContract\n    .getDepositAmount(vaultAddress, addresses[symbol], tokenWei)\n    .then((depositAmount) => {\n      const otherAmount = getFromDepositAmount(depositAmount, otherDecimals);\n      State.update({\n        [symbol === token0 ? 'amount1' : 'amount0']: otherAmount,\n        focusedSymbol: symbol,\n        isLoading: callback ? true : false\n      });\n      checkApproval(amount, otherAmount, symbol, callback);\n    })\n    .catch((e) => {\n      State.update({\n        isLoading: true,\n        isError: true,\n        loadingMsg: \"Something went wrong. Please try again.\",\n      });\n    });\n};\n\n\nconst handleLPChange = (amount) => {\n  State.update({\n    lpAmount: amount,\n  });\n};\n\nconst handleApprove = (isToken0) => {\n  const _token = isToken0 ? token0 : token1;\n  const payload = isToken0\n    ? { isToken0Approving: true }\n    : { isToken1Approving: true };\n\n  const amount = isToken0\n    ? Big(amount0).toFixed(decimals0)\n    : Big(amount1).toFixed(decimals1);\n\n  const toastId = toast?.loading({\n    title: `Approve ${amount} ${_token}`,\n  });\n\n  State.update({\n    ...payload,\n    isLoading: true,\n    loadingMsg: `Approving ${_token}...`,\n  });\n\n  const tokenWei = ethers.utils.parseUnits(\n    amount,\n    isToken0 ? decimals0 : decimals1\n  );\n\n  const abi = [\"function approve(address, uint) public\"];\n\n  const tokenContract = new ethers.Contract(\n    addresses[_token],\n    abi,\n    Ethers.provider().getSigner()\n  );\n\n  tokenContract\n    .approve(vaultAddress, tokenWei)\n    .then((tx) => tx.wait())\n    .then((receipt) => {\n      const payload = isToken0\n        ? { isToken0Approved: true, isToken0Approving: false }\n        : { isToken1Approved: true, isToken1Approving: false };\n\n      State.update({ ...payload, isLoading: false, loadingMsg: \"\" });\n      toast?.dismiss(toastId);\n      toast?.success({\n        title: \"Approve Successfully!\",\n        text: `Approve ${amount} ${_token}`,\n        tx: receipt.transactionHash,\n        chainId: props.chainId,\n      });\n    })\n    .catch((error) => {\n      console.log('error: ', error)\n      State.update({\n        isError: true,\n        isLoading: false,\n        loadingMsg: error,\n        isToken0Approving: false,\n        isToken1Approving: false,\n      });\n      toast?.dismiss(toastId);\n      toast?.fail({\n        title: \"Approve Failed!\",\n        text: error?.message?.includes(\"user rejected transaction\")\n          ? \"User rejected transaction\"\n          : `Approve ${amount} ${_token}`,\n      });\n    });\n};\nconst handleDeposit = () => {\n  const toastId = toast?.loading({\n    title: `Depositing...`,\n  });\n  State.update({\n    toastId,\n    isLoading: true,\n    isError: false,\n    loadingMsg: \"Depositing...\",\n  });\n  handleTokenChange(\n    state.focusedSymbol === token0 ? amount0 : amount1,\n    state.focusedSymbol === token0 ? token0 : token1,\n    (amount, otherAmount) => {\n      const tokenWei = ethers.utils.parseUnits(\n        Big(amount).toFixed(decimals0),\n        decimals0\n      );\n      const otherTokenWei = ethers.utils.parseUnits(\n        Big(otherAmount).toFixed(decimals1),\n        decimals1\n      );\n      const proxyAbi = [\n        \"function deposit(uint256, uint256,address,address,uint256[4] memory)  external returns (uint256)\",\n      ];\n      const proxyContract = new ethers.Contract(\n        proxyAddress,\n        proxyAbi,\n        Ethers.provider().getSigner()\n      );\n      proxyContract\n        .deposit(tokenWei, otherTokenWei, sender, ethers.utils.getAddress(vaultAddress), [0, 0, 0, 0])\n        .then((tx) => {\n          return tx.wait();\n        })\n        .then((receipt) => {\n          const { status, transactionHash } = receipt;\n\n          addAction?.({\n            type: \"Liquidity\",\n            action: \"Deposit\",\n            token0,\n            token1,\n            amount: amount0,\n            template: defaultDex,\n            status: status,\n            add: 1,\n            transactionHash,\n            chain_id: props.chainId,\n            extra_data: JSON.stringify({\n              action: \"Deposit\",\n              amount0,\n              amount1,\n            })\n          });\n\n          State.update({\n            isLoading: false,\n            isPostTx: true,\n          });\n\n          setTimeout(() => State.update({ isPostTx: false }), 10_000);\n\n          const { refetch } = props;\n          if (refetch) {\n            refetch()\n          }\n\n          toast?.dismiss(toastId);\n          toast?.success({\n            title: \"Deposit Successfully!\",\n          });\n        })\n        .catch((error) => {\n          console.log('error: ', error)\n          State.update({\n            isError: true,\n            isLoading: false,\n            loadingMsg: error,\n          });\n          toast?.dismiss(toastId);\n          toast?.fail({\n            title: \"Deposit Failed!\",\n            text: error?.message?.includes(\"user rejected transaction\")\n              ? \"User rejected transaction\"\n              : error?.message ?? \"\",\n          });\n        });\n    })\n};\nconst handleGetAmount = (contract, params, callback) => {\n  contract\n    .callStatic\n    .withdraw(...params)\n    .then(callback)\n}\nconst handleWithdraw = () => {\n  const toastId = toast?.loading({\n    title: `Withdrawing...`,\n  });\n  State.update({\n    isLoading: true,\n    isError: false,\n    loadingMsg: \"Withdrawing...\",\n  });\n\n  const lpWeiAmount = ethers.utils.parseUnits(Big(lpAmount).toFixed(18), 18);\n  const abi = [\n    \"function withdraw(uint256, address, address,uint256[4] memory) external returns (uint256, uint256)\",\n  ];\n\n  const contract = new ethers.Contract(\n    vaultAddress,\n    abi,\n    Ethers.provider().getSigner()\n  );\n  const params = [lpWeiAmount, sender, sender, [0, 0, 0, 0]]\n  contract\n    .callStatic\n    .withdraw(...params)\n    .then(result => {\n      contract\n        .withdraw(...params)\n        .then((tx) => tx.wait())\n        .then((receipt) => {\n          State.update({\n            isLoading: false,\n            isPostTx: true,\n          });\n          const { status, transactionHash } = receipt;\n          console.log('=receipt', receipt)\n\n          addAction?.({\n            type: \"Liquidity\",\n            action: \"Withdraw\",\n            token0,\n            token1,\n            amount: lpAmount,\n            template: defaultDex,\n            status: status,\n            add: 0,\n            transactionHash,\n            chain_id: state.chainId,\n            extra_data: JSON.stringify({\n              action: \"Withdraw\",\n              amount0: ethers.utils.formatUnits(result[0], decimals0),\n              amount1: ethers.utils.formatUnits(result[1], decimals1),\n            })\n          });\n          setTimeout(() => State.update({ isPostTx: false }), 10_000);\n          const { refetch } = props;\n          if (refetch) {\n            setTimeout(() => {\n              refetch();\n            }, 3000)\n          }\n\n          toast?.dismiss(toastId);\n          toast?.success({\n            title: \"Withdraw Successfully!\",\n          });\n        })\n        .catch((error) => {\n          State.update({\n            isError: true,\n            isLoading: false,\n            loadingMsg: error,\n          });\n          toast?.dismiss(toastId);\n          toast?.fail({\n            title: \"Withdraw Failed!\",\n            text: error?.message?.includes(\"user rejected transaction\")\n              ? \"User rejected transaction\"\n              : error?.message ?? \"\",\n          });\n        });\n    })\n\n\n};\n\nconst tokensPrice = prices;\n\nconst isInSufficient =\n  Number(amount0) > Number(balances[token0]) ||\n  Number(amount1) > Number(balances[token1]);\n\nconst isWithdrawInsufficient = Number(lpAmount) > Number(lpBalance);\n\nconst balance0 =\n  !amount0 || !tokensPrice?.[token0]\n    ? \"-\"\n    : parseFloat(Big(amount0).times(tokensPrice[token0]).toFixed(4));\n\nconst balance1 =\n  !amount1 || !tokensPrice?.[token1]\n    ? \"-\"\n    : parseFloat(Big(amount1).times(tokensPrice[token1]).toFixed(4));\n\nconst balanceLp =\n  !lpAmount || !lpBalance || !curPositionUSD\n    ? \"-\"\n    : parseFloat(\n      Big(lpAmount)\n        .div(Big(lpBalance).gt(0) ? lpBalance : 1)\n        .times(curPositionUSD)\n        .toFixed(4)\n    );\n\nconst onUpdateLpPercent = (percent) => {\n  State.update({\n    lpPercent: percent,\n  });\n};\n\nconst onChangeSlider = (percent) => {\n  console.log(\"percent: \", percent);\n  const newLpValue = Big(percent)\n    .div(100)\n    .times(lpBalance || 0)\n    .toFixed(6);\n\n  handleLPChange(newLpValue);\n};\n\nuseEffect(() => {\n  if (amount0) {\n    handleTokenChange(amount0, token0);\n  }\n}, [data]);\nreturn (\n  <DetailWrapper>\n    <FilterButtonList>\n      <FilterButton className={isDeposit ? 'isActive' : ''} onClick={() => changeMode(true)}>Deposit</FilterButton>\n      <FilterButton className={!isDeposit ? 'isActive' : ''} onClick={() => changeMode(false)}>Withdraw</FilterButton>\n    </FilterButtonList>\n    {\n      detailLoading ? (\n        <div style={{ padding: \"30px 0 45px\" }}>\n          <Widget\n            props={{\n              color: \"#999\"\n            }}\n            src=\"bluebiu.near/widget/Liquidity.Bridge.Loading\"\n          />\n        </div>\n      ) : (\n        <>\n          {\n            isDeposit ? <>\n              <Row className=\"price-input\">\n                <Column>\n                  <InputWrap className={Number(amount0) > Number(balances[token0]) ? \"inSufficient\" : \"\"}>\n                    <Input value={amount0} type=\"number\" onChange={(e) => handleTokenChange(e.target.value, token0)} />\n                    <InputSuffix>\n                      <img src={ICON_VAULT_MAP[token0]} alt={token0} />\n                      <span>{token0}</span>\n                    </InputSuffix>\n                  </InputWrap>\n                  <PriceWrap>\n                    <TotalPrice>${balance0}</TotalPrice>\n                    <BalancePrice>Balance:<span onClick={() => handleMax(true)}>{Big(balances[token0] ?? 0).toFixed(6)}</span> {token0}</BalancePrice>\n                  </PriceWrap>\n                </Column>\n                <Column>\n                  <InputWrap className={Number(amount1) > Number(balances[token1]) ? \"inSufficient\" : \"\"}>\n                    <Input value={amount1} type=\"number\" onChange={(e) => handleTokenChange(e.target.value, token1)} />\n                    <InputSuffix>\n                      <img src={ICON_VAULT_MAP[token1]} alt={token1} />\n                      <span>{token1}</span>\n                    </InputSuffix>\n                  </InputWrap>\n                  <PriceWrap>\n                    <TotalPrice>${balance1}</TotalPrice>\n                    <BalancePrice>Balance:<span onClick={() => handleMax(false)}>{Big(balances[token1] ?? 0).toFixed(6)}</span> {token1}</BalancePrice>\n                  </PriceWrap>\n                </Column>\n              </Row>\n              <StyledButtonList>\n                {isInSufficient && <StyledButton disabled>InSufficient Balance</StyledButton>}\n                {\n                  !isInSufficient &&\n                  (isToken0Approved &&\n                    isToken1Approved &&\n                    !isToken0Approving &&\n                    !isToken1Approving ? (\n\n                    <StyledButton disabled={isLoading || !amount0 || !amount1} onClick={handleDeposit}>\n                      {\n                        isLoading ? (\n                          <Widget src=\"bluebiu.near/widget/Liquidity.Bridge.Loading\" />\n                        ) : (\n                          \"Deposit\"\n                        )\n                      }\n                    </StyledButton>\n                  ) : (\n                    <>\n                      <StyledButton disabled={isToken0Approved || isToken0Approving} onClick={() => handleApprove(true)}>{\n                        isToken0Approving ? (\n                          <Widget src=\"bluebiu.near/widget/Liquidity.Bridge.Loading\" />\n                        ) : (\n                          <>\n                            {isToken0Approved ? \"Approved\" : \"Approve\"} {token0}\n                          </>\n                        )}\n                      </StyledButton>\n                      <StyledButton disabled={isToken1Approved || isToken1Approving} onClick={() => handleApprove(false)}>{\n                        isToken1Approving ? (\n                          <Widget src=\"bluebiu.near/widget/Liquidity.Bridge.Loading\" />\n                        ) : (\n                          <>\n                            {isToken1Approved ? \"Approved\" : \"Approve\"} {token1}\n                          </>\n                        )}\n                      </StyledButton>\n                    </>\n                  ))\n                }\n              </StyledButtonList>\n            </> : <>\n              <Row className=\"price-input\">\n                <Column>\n                  <InputWrap>\n                    <Input value={lpAmount} type=\"number\" onChange={(e) => {\n                      handleLPChange(e.target.value);\n\n                      const value = e.target.value;\n\n                      if (!value) {\n                        onUpdateLpPercent(0);\n                      }\n\n                      if (value && Big(value).gt(0)) {\n                        const newSliderPercent = Big(value || 0)\n                          .div(Big(lpBalance).gt(0) ? lpBalance : 1)\n                          .times(100)\n                          .toFixed(0);\n                        onUpdateLpPercent(newSliderPercent);\n                      }\n                    }} />\n\n                    <InputSuffix>\n                      <StyledImageList>\n                        <img src={ICON_VAULT_MAP[token0]} alt={token0} />\n                        <img src={ICON_VAULT_MAP[token1]} alt={token1} style={{ marginLeft: -6 }} />\n                      </StyledImageList>\n                      <span>{token0}/{token1}</span>\n                    </InputSuffix>\n                  </InputWrap>\n                  <PriceWrap>\n                    <TotalPrice>${balanceLp}</TotalPrice>\n                    <BalancePrice>Balance: <span\n                      onClick={() => {\n                        const newSliderPercent = Big(lpBalance || 0)\n                          .div(Big(lpBalance).gt(0) ? lpBalance : 1)\n                          .times(100)\n                          .toFixed(0);\n\n                        onUpdateLpPercent(newSliderPercent);\n\n                        handleLPChange(lpBalance);\n                      }}\n                    >\n                      {lpBalance}\n                    </span></BalancePrice>\n                  </PriceWrap>\n                </Column>\n              </Row>\n              <StyledButtonList>\n                <StyledButton\n                  disabled={isWithdrawInsufficient || isLoading || Number(lpAmount) <= 0}\n                  onClick={handleWithdraw}\n                >\n                  {isLoading ? (\n                    <Widget src=\"bluebiu.near/widget/Liquidity.Bridge.Loading\" />\n                  ) : (\n                    <>\n                      {isWithdrawInsufficient ? \"InSufficient Balance\" : \"Withdraw\"}\n                    </>\n                  )}\n                </StyledButton>\n              </StyledButtonList>\n            </>\n          }\n        </>\n      )\n    }\n  </DetailWrapper>\n)", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/bluebiu.near/widget/Liquidity.Bridge.Detail", "fact_widget_deployments_id": "5229e77564c17c8d513be42bb810aa07", "inserted_timestamp": "2024-07-01T07:54:38.137Z", "modified_timestamp": "2024-07-01T07:54:38.137Z", "__row_index": 2}