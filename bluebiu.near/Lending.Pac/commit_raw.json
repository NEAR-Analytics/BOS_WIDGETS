{"tx_hash": "77fYzMmYbR6baU6tKQ6wb96nEHpBJKioWwt9ghKQqU3M", "action_id_social": "FqEjxtpkBDKSWH5WHAH9XD685dKu98cUwBcq4UhkqYVV-0-widget", "block_id": 117906344, "block_timestamp": "2024-04-29T20:52:39.548Z", "signer_id": "bluebiu.near", "widget_name": "Lending.Pac", "source_code": "const Wrap = styled.div`\n  padding: 24px 15px;\n  /* background: #0e0e26; */\n  min-height: 100vh;\n  color: white;\n  font-family: Gantari;\n`;\n\nconst FlexContainer = styled.div``;\n\nconst ChainsWrap = styled.div`\n  display: flex;\n  justify-content: flex-end;\n`;\nconst Yours = styled.div`\n  display: flex;\n  gap: 20px;\n  margin-top: 16px;\n`;\nconst YoursTableWrapper = styled.div`\n  background-color: rgba(53, 55, 73, 0.2);\n  border-radius: 6px;\n  width: 50%;\n`;\nconst Title = styled.div`\n  padding: 10px 20px 0;\n  /* border-bottom: 1px solid #292c42; */\n`;\nconst SubTitle = styled.div`\n  display: flex;\n  align-items: center;\n`;\nconst Label = styled.div`\n  color: #979abe;\n  font-size: 16px;\n  font-weight: 400;\n  margin-right: 5px;\n`;\nconst Value = styled.div`\n  color: #fff;\n  font-size: 16px;\n  font-weight: 500;\n  margin-right: 15px;\n`;\n\nconst ROUND_DOWN = 0;\nconst NATIVE_SYMBOL_ADDRESS_MAP_KEY = \"0x0\";\nconst ACTUAL_BORROW_AMOUNT_RATE = 0.99;\n\nconst { formatUnits, parseUnits } = ethers.utils;\n\nconst {\n  account,\n  CHAIN_LIST,\n  curChain,\n  onSwitchChain,\n  GAS_LIMIT_RECOMMENDATIONS,\n  chainId,\n  prices: rawPrices,\n  multicallAddress,\n  multicall,\n  isChainSupported,\n  switchingChain,\n  dexConfig,\n  theme,\n  toast,\n  addAction,\n  refresh,\n} = props;\nconst { CONTRACT_ABI } = dexConfig;\nconsole.log(\"PROPS: \", props);\n\n// App config\nfunction getConfig() {\n  const abis = {\n    wrappedTokenGatewayV3ABI: fetch(CONTRACT_ABI.wrappedTokenGatewayV3ABI),\n    erc20Abi: fetch(CONTRACT_ABI.erc20Abi),\n    aavePoolV3ABI: fetch(CONTRACT_ABI.aavePoolV3ABI),\n    variableDebtTokenABI: fetch(CONTRACT_ABI.variableDebtTokenABI),\n    // walletBalanceProviderABI: fetch(CONTRACT_ABI.walletBalanceProviderABI),\n  };\n\n  const constants = {\n    FIXED_LIQUIDATION_VALUE: \"1.0\",\n    MAX_UINT_256:\n      \"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\",\n    AAVE_API_BASE_URL: \"https://aave-data-service-7a85eea3aebe.herokuapp.com\",\n  };\n\n  return {\n    ...dexConfig.config,\n    ...abis,\n    ...constants,\n  };\n}\n\nconst config = getConfig();\n// console.log(\"CONFIG: \", config);\n\nconst markets = dexConfig?.rawMarkets;\n\nconst underlyingTokens = dexConfig?.rawMarkets?.map(\n  (market) => market.underlyingAsset\n);\n\n// App states\nState.init({\n  imports: {},\n\n  showWithdrawModal: false,\n  showSupplyModal: false,\n  showRepayModal: false,\n  showBorrowModal: false,\n\n  threshold: 1,\n  assetsToSupply: markets,\n  yourSupplies: undefined,\n  yourBorrows: undefined,\n  netWorthUSD: \"\",\n  netAPY: \"\",\n  healthFactor: \"\",\n  availableBorrowsUSD: \"\",\n\n  selectTab: \"MARKET\", // MARKET | YOURS\n  fresh: 0, // fresh rewards\n  yourSupplyApy: 0,\n  yourBorrowApy: 0,\n  yourTotalCollateral: 0,\n\n  BlastPoints: 0,\n  BlastGold: 0,\n\n  emissionPerSeconds: [],\n  aTokenTotal: [],\n  debtTotal: [],\n\n  updater: 0,\n  isShowReloadModal: false,\n\n  prices: rawPrices,\n});\n\nconst { prices } = state;\n\nfunction isValid(a) {\n  if (!a) return false;\n  if (isNaN(Number(a))) return false;\n  if (a === \"\") return false;\n  return true;\n}\n\nfunction getGasPrice() {\n  return Ethers.provider().getGasPrice();\n}\n\nfunction gasEstimation(action) {\n  const assetsToSupply = state.assetsToSupply;\n  if (!assetsToSupply) {\n    return \"-\";\n  }\n  const baseAsset = assetsToSupply.find(\n    (asset) => asset.symbol === config.nativeCurrency.symbol\n  );\n  if (!baseAsset) {\n    return \"-\";\n  }\n\n  const { symbol, decimals } = baseAsset;\n  return getGasPrice()\n    .then((gasPrice) => {\n      const gasLimit = GAS_LIMIT_RECOMMENDATIONS[action].limit;\n      // console.log(\"gasPrice--\", gasPrice);\n      return Big(gasPrice.toString())\n        .mul(gasLimit)\n        .div(Big(10).pow(decimals))\n        .mul(prices[symbol])\n        .toFixed(2);\n    })\n    .catch((err) => {\n      console.log(\"gasEstimation error\");\n    });\n}\n\nfunction depositETHGas() {\n  return gasEstimation(\"deposit\");\n}\n\nfunction depositERC20Gas() {\n  return gasEstimation(\"supplyWithPermit\");\n}\n\nfunction withdrawETHGas() {\n  return gasEstimation(\"withdrawETH\");\n}\n\nfunction withdrawERC20Gas() {\n  return gasEstimation(\"withdraw\");\n}\n\nfunction borrowETHGas() {\n  return gasEstimation(\"borrowETH\");\n}\n\nfunction borrowERC20Gas() {\n  return gasEstimation(\"borrow\");\n}\n\nfunction repayETHGas() {\n  return gasEstimation(\"repay\");\n}\n\nfunction repayERC20Gas() {\n  return gasEstimation(\"repayWithPermit\");\n}\nfunction formatNumber(value, digits) {\n  if (Big(value).eq(0)) return `$ 0`;\n  return Big(value || 0).lt(0.01)\n    ? \"< $0.01\"\n    : `$ ${Number(value).toFixed(digits || 2)}`;\n}\n\nfunction showReload() {\n  State.update({\n    isShowReloadModal: true,\n  });\n}\nfunction calcAvailableBorrows(availableBorrowsUSD, tokenPrice) {\n  let r =\n    isValid(availableBorrowsUSD) && isValid(tokenPrice)\n      ? Big(availableBorrowsUSD || 0)\n          .div(tokenPrice)\n          .toFixed()\n      : Number(0).toFixed();\n\n  return r;\n}\n\nfunction bigMin(_a, _b) {\n  const a = Big(_a || 0);\n  const b = Big(_b || 0);\n  return a.gt(b) ? b : a;\n}\n\nfunction formatHealthFactor(hf) {\n  try {\n    if (hf === \"\u221e\") return hf;\n\n    if (!hf || !isValid(hf)) return \"-\";\n\n    if (Big(hf).gt(10000)) return \"\u221e\";\n    if (Number(hf) === -1) return \"\u221e\";\n    return Big(hf).toFixed(2, ROUND_DOWN);\n  } catch (error) {\n    console.log(\"CATCH_formatHealthFactor:\", error);\n  }\n}\n\nfunction calcHealthFactor(type, symbol, amount) {\n  // console.log(\n  //   \"calcHealthFactor\",\n  //   type,\n  //   symbol,\n  //   amount,\n  //   isValid(state.yourTotalCollateral),\n  //   isValid(state.yourTotalBorrow),\n  //   isValid(amount)\n  // );\n  try {\n    if (\n      // !isValid(state.yourTotalCollateral) ||\n      // !isValid(state.yourTotalBorrow) ||\n      isNaN(Number(state.yourTotalCollateral)) ||\n      isNaN(Number(state.yourTotalBorrow)) ||\n      !isValid(amount)\n    )\n      return \"-\";\n    let newHealthFactor;\n    let totalCollateral = Big(state.yourTotalCollateral);\n    let totalBorrows = Big(state.yourTotalBorrow);\n\n    const assetsUSD = Big(prices[symbol] || 1).times(Big(amount));\n    if (type === \"SUPPLY\") {\n      totalCollateral = Big(state.yourTotalCollateral).plus(assetsUSD);\n    }\n    if (type === \"INC_COLLATERAL\") {\n      totalCollateral = Big(state.yourTotalCollateral).plus(assetsUSD);\n    }\n    if (type === \"WITHDRAW\") {\n      totalCollateral = Big(state.yourTotalCollateral).minus(assetsUSD);\n    }\n    if (type === \"DEC_COLLATERAL\") {\n      totalCollateral = Big(state.yourTotalCollateral).minus(assetsUSD);\n    }\n    if (type === \"BORROW\") {\n      totalBorrows = Big(state.yourTotalBorrow).plus(assetsUSD);\n    }\n    if (type === \"REPAY\") {\n      totalBorrows = Big(state.yourTotalBorrow).minus(assetsUSD);\n    }\n    if (totalBorrows.eq(0)) return \"\u221e\";\n\n    newHealthFactor = totalCollateral\n      .times(Big(state.threshold))\n      .div(totalBorrows);\n\n    console.log(\"calcHealthFactor--\", newHealthFactor);\n    return newHealthFactor.toFixed(2);\n  } catch (error) {\n    console.log(\"CATCH_calcHealthFactor\", error);\n  }\n}\n\nfunction batchBalanceOf(userAddress, tokenAddresses) {\n  const balanceProvider = new ethers.Contract(\n    config.balanceProviderAddress,\n    [\n      {\n        inputs: [\n          { internalType: \"address[]\", name: \"users\", type: \"address[]\" },\n          { internalType: \"address[]\", name: \"tokens\", type: \"address[]\" },\n        ],\n        name: \"batchBalanceOf\",\n        outputs: [{ internalType: \"uint256[]\", name: \"\", type: \"uint256[]\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n      },\n    ],\n    Ethers.provider().getSigner()\n  );\n\n  return balanceProvider.batchBalanceOf([userAddress], tokenAddresses);\n}\n\nfunction getLiquidity() {\n  const aTokenAddresss = markets?.map((item) => item.aTokenAddress);\n  const variableDebtTokenAddresss = markets?.map(\n    (item) => item.variableDebtTokenAddress\n  );\n\n  const calls = aTokenAddresss\n    .map((addr) => ({\n      address: addr,\n      name: \"totalSupply\",\n    }))\n    .concat(\n      variableDebtTokenAddresss?.map((addr) => ({\n        address: addr,\n        name: \"totalSupply\",\n      }))\n    );\n\n  multicall({\n    abi: [\n      {\n        inputs: [],\n        name: \"totalSupply\",\n        outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n      },\n    ],\n    calls,\n    options: {},\n    multicallAddress,\n    provider: Ethers.provider(),\n  })\n    .then((res) => {\n      try {\n        console.log(\"getLiquidity_res\", res);\n        const l = res.length;\n        const aTokenTotal = res.slice(0, l / 2);\n        const debtTotal = res.slice(l / 2);\n\n        const _assetsToSupply = [...state.assetsToSupply];\n        for (let i = 0; i < _assetsToSupply.length; i++) {\n          const liquidityAmount = Big(aTokenTotal[i] || 0)\n            .minus(Big(debtTotal[i] || 0))\n            .toFixed();\n          // console.log(\n          //   liquidityAmount,\n          //   prices[_assetsToSupply[i].symbol],\n          //   _assetsToSupply[i]\n          // );\n          _assetsToSupply[i].availableLiquidity = liquidityAmount;\n          const _availableLiquidityUSD = Big(\n            ethers.utils.formatUnits(\n              liquidityAmount,\n              _assetsToSupply[i].decimals\n            )\n          )\n            .mul(Big(prices[_assetsToSupply[i].symbol] || 0))\n            .toFixed();\n          // console.log(_availableLiquidityUSD);\n          _assetsToSupply[i].availableLiquidityUSD = _availableLiquidityUSD;\n\n          const _availableBorrowsUSD = bigMin(\n            state.availableBorrowsUSD,\n            ethers.utils.formatUnits(\n              liquidityAmount,\n              _assetsToSupply[i].decimals\n            )\n          )\n            .times(ACTUAL_BORROW_AMOUNT_RATE)\n            .toFixed();\n          // console.log(_availableBorrowsUSD);\n          const availableBorrows = calcAvailableBorrows(\n            _availableBorrowsUSD,\n            prices[_assetsToSupply[i].symbol]\n          );\n          // console.log(availableBorrows);\n          _assetsToSupply[i].availableBorrowsUSD = _availableBorrowsUSD;\n          _assetsToSupply[i].availableBorrows = availableBorrows;\n        }\n        State.update({\n          assetsToSupply: _assetsToSupply,\n          aTokenTotal,\n          debtTotal,\n        });\n      } catch (error) {\n        console.log(\"catch getLiquidity\", error);\n      }\n    })\n    .catch((err) => {\n      console.log(\"getLiquidity_err\", err);\n    });\n}\n\nfunction getUserPoints() {\n  const params = JSON.stringify({ address: account });\n  asyncFetch(`/pac?path=blastpoint&params=${params}`)\n    .then((res) => {\n      if (res.status === 200) {\n        const { blastGold, blastPoint, details } = res.body.data;\n\n        const _assetsToSupply = [...state.assetsToSupply];\n        for (let i = 0; i < details.length; i++) {\n          let asset = _assetsToSupply.find(\n            (item) =>\n              item.symbol.toLowerCase() === details[i].token.toLowerCase()\n          );\n\n          asset.blastPoint = details[i].points;\n          asset.blastGold = details[i].gold;\n        }\n\n        State.update({\n          assetsToSupply: _assetsToSupply,\n          BlastPoints: blastPoint,\n          BlastGold: blastGold,\n        });\n      }\n    })\n    .catch((error) => {\n      console.log(\"getUserPoints_error:\", error);\n    });\n}\n\nfunction getPrices() {\n  const contract = new ethers.Contract(\n    config.AaveOracle,\n    [\n      {\n        inputs: [\n          { internalType: \"address[]\", name: \"assets\", type: \"address[]\" },\n        ],\n        name: \"getAssetsPrices\",\n        outputs: [{ internalType: \"uint256[]\", name: \"\", type: \"uint256[]\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n      },\n    ],\n    Ethers.provider().getSigner()\n  );\n  const tokenAddrs = markets.map((item) => item.underlyingAsset);\n  const tokenSymbols = markets.map((item) => item.symbol);\n\n  contract\n    .getAssetsPrices(tokenAddrs)\n    .then((res) => {\n      console.log(\"getPrices--\", res);\n\n      for (let index = 0; index < tokenSymbols.length; index++) {\n        const _tokenPrice = formatUnits(res[index], 8);\n        rawPrices[tokenSymbols[index]] = _tokenPrice;\n      }\n\n      State.update({\n        prices: rawPrices,\n      });\n    })\n    .catch((err) => {\n      console.log(\"getPrices_error:\", err);\n    })\n    .then(() => {\n      getUserBalance();\n    });\n}\n\nfunction getUserBalance() {\n  const provider = Ethers.provider();\n  provider\n    .getSigner()\n    ?.getBalance()\n    .then((balance) => {\n      return balance;\n    })\n    .then((baseAssetBalance) => {\n      // get user balances\n      batchBalanceOf(\n        account,\n        markets?.map((market) => market.underlyingAsset)\n      )\n        .then((balances) => {\n          return balances?.map((balance) => balance.toString());\n        })\n        .then((userBalances) => {\n          console.log(\"getUserBalance--\", userBalances);\n\n          const _assetsToSupply = [...state.assetsToSupply];\n          for (let index = 0; index < _assetsToSupply.length; index++) {\n            const item = _assetsToSupply[index];\n            const _bal =\n              item.symbol === config.nativeCurrency.symbol\n                ? baseAssetBalance\n                : userBalances[index];\n            const balanceRaw = Big(_bal || 0).div(Big(10).pow(item.decimals));\n            const _balance = balanceRaw.toFixed(item.decimals, ROUND_DOWN);\n\n            const _balanceInUSD = balanceRaw\n              .times(Big(prices[item.symbol] || 0))\n              .toFixed();\n\n            item.balance = _balance;\n            item.balanceInUSD = _balanceInUSD;\n          }\n\n          State.update({\n            assetsToSupply: _assetsToSupply,\n          });\n        })\n\n        .catch((err) => {\n          showReload();\n          console.log(\"batchBalanceOfERROR:\", err);\n        });\n    });\n}\n\nfunction onActionSuccess({ msg, callback }) {\n  console.log(\"onActionSuccess--\");\n\n  handleRefresh();\n  // update UI after data has almost loaded\n  setTimeout(() => {\n    if (callback) {\n      callback();\n    }\n    if (msg) {\n      State.update({ alertModalText: msg });\n    }\n  }, 5000);\n}\n\nfunction getPoolDataProvider() {\n  const underlyingTokens = dexConfig?.rawMarkets?.map(\n    (market) => market.underlyingAsset\n  );\n  // console.log(\"getPoolDataProvider--\", underlyingTokens);\n  const calls = underlyingTokens?.map((addr) => ({\n    address: config.PoolDataProvider,\n    name: \"getReserveData\",\n    params: [addr],\n  }));\n\n  multicall({\n    abi: [\n      {\n        inputs: [{ internalType: \"address\", name: \"asset\", type: \"address\" }],\n        name: \"getReserveData\",\n        outputs: [\n          { internalType: \"uint256\", name: \"unbacked\", type: \"uint256\" },\n          {\n            internalType: \"uint256\",\n            name: \"accruedToTreasuryScaled\",\n            type: \"uint256\",\n          },\n          { internalType: \"uint256\", name: \"totalAToken\", type: \"uint256\" },\n          {\n            internalType: \"uint256\",\n            name: \"totalStableDebt\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"totalVariableDebt\",\n            type: \"uint256\",\n          },\n          { internalType: \"uint256\", name: \"liquidityRate\", type: \"uint256\" },\n          {\n            internalType: \"uint256\",\n            name: \"variableBorrowRate\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"stableBorrowRate\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"averageStableBorrowRate\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"liquidityIndex\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"variableBorrowIndex\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint40\",\n            name: \"lastUpdateTimestamp\",\n            type: \"uint40\",\n          },\n        ],\n        stateMutability: \"view\",\n        type: \"function\",\n      },\n    ],\n    calls,\n    options: {},\n    multicallAddress,\n    provider: Ethers.provider(),\n  })\n    .then((res) => {\n      console.log(\"getPoolDataProvider_res\", res);\n      return res;\n    })\n    .then((poolData) => {\n      console.log(\"CALC APY\");\n      if (!Array.isArray(poolData) || !poolData.length) return;\n\n      const _assetsToSupply = [...state.assetsToSupply];\n\n      for (let i = 0; i < poolData.length; i++) {\n        if (poolData[i]) {\n          const [\n            unbacked,\n            accruedToTreasuryScaled,\n            totalAToken,\n            totalStableDebt,\n            totalVariableDebt,\n            liquidityRate,\n            variableBorrowRate,\n            stableBorrowRate,\n            averageStableBorrowRate,\n            liquidityIndex,\n            variableBorrowIndex,\n            lastUpdateTimestamp,\n          ] = poolData[i];\n          const RAY = Big(10).pow(27);\n          const SECONDS_PER_YEAR = 31_536_000;\n          const depositAPR = Big(liquidityRate).div(RAY || 1);\n          const depositAPY0 = Big(1)\n            .plus(depositAPR.div(Big(SECONDS_PER_YEAR)))\n            .toNumber();\n\n          const _supplyAPY = Big(\n            Math.pow(depositAPY0, SECONDS_PER_YEAR) - 1\n          ).toFixed();\n\n          if (!_assetsToSupply[i]) return;\n          const variableBorrowAPR = Big(variableBorrowRate).div(RAY || 1);\n\n          const variableBorrowAPY0 = Big(1)\n            .plus(Big(variableBorrowAPR).div(Big(SECONDS_PER_YEAR)))\n            .toNumber();\n\n          const _borrowAPY = Big(\n            Math.pow(variableBorrowAPY0, SECONDS_PER_YEAR) - 1\n          ).toFixed();\n          console.log(\"APY--\", _supplyAPY, _borrowAPY);\n\n          let _utilized = Big(totalVariableDebt || 0)\n            .div(Big(totalAToken || 1))\n            .toFixed();\n\n          _assetsToSupply[i].supplyAPY = _supplyAPY;\n          _assetsToSupply[i].borrowAPY = _borrowAPY;\n          _assetsToSupply[i].utilized = _utilized;\n        }\n      }\n      State.update({\n        assetsToSupply: _assetsToSupply,\n      });\n    })\n    .then(() => {\n      getYourSupplies();\n      getUserDebts();\n    })\n    .catch((err) => {\n      showReload();\n      console.log(\"getPoolDataProvider_err\", err);\n    });\n}\n\n// Pool Liquidity\nfunction getPoolDataProviderTotalSupply() {\n  const prevAssetsToSupply = [...state.assetsToSupply];\n\n  const underlyingTokens = dexConfig?.rawMarkets?.map(\n    (market) => market.underlyingAsset\n  );\n\n  const calls = underlyingTokens?.map((addr) => ({\n    address: config.PoolDataProvider,\n    name: \"getATokenTotalSupply\",\n    params: [addr],\n  }));\n\n  multicall({\n    abi: [\n      {\n        inputs: [{ internalType: \"address\", name: \"asset\", type: \"address\" }],\n        name: \"getATokenTotalSupply\",\n        outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n      },\n    ],\n    calls,\n    options: {},\n    multicallAddress,\n    provider: Ethers.provider(),\n  })\n    .then((res) => {\n      console.log(\"getPoolDataProviderTotal_res\", res);\n\n      for (let i = 0; i < res.length; i++) {\n        const _totalSupply = ethers.utils.formatUnits(\n          res[i][0],\n          prevAssetsToSupply[i].decimals\n        );\n        prevAssetsToSupply[i].totalSupply = _totalSupply;\n      }\n      State.update({\n        assetsToSupply: prevAssetsToSupply,\n      });\n    })\n    .catch((err) => {\n      showReload();\n      console.log(\"getPoolDataProviderTotal_err\", err);\n    });\n}\n// seamless use\nfunction getPoolDataProviderTotalDebt() {\n  const prevAssetsToSupply = [...state.assetsToSupply];\n\n  const underlyingTokens = dexConfig?.rawMarkets?.map(\n    (market) => market.underlyingAsset\n  );\n  // console.log(\"getPoolDataProviderTotalDebt--\", underlyingTokens);\n  const calls = underlyingTokens?.map((addr) => ({\n    address: config.PoolDataProvider,\n    name: \"getTotalDebt\",\n    params: [addr],\n  }));\n\n  multicall({\n    abi: [\n      {\n        inputs: [{ internalType: \"address\", name: \"asset\", type: \"address\" }],\n        name: \"getTotalDebt\",\n        outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n      },\n    ],\n    calls,\n    options: {},\n    multicallAddress,\n    provider: Ethers.provider(),\n  })\n    .then((res) => {\n      console.log(\"getPoolDataProviderTotal_res\", res);\n\n      for (let i = 0; i < res.length; i++) {\n        const _totalDebts = ethers.utils.formatUnits(\n          res[i][0],\n          prevAssetsToSupply[i].decimals\n        );\n        prevAssetsToSupply[i].totalDebts = _totalDebts;\n        prevAssetsToSupply[i].totalDebtsUSD = Big(_totalDebts)\n          .times(prices[prevAssetsToSupply[i].symbol])\n          .toFixed();\n      }\n      State.update({\n        assetsToSupply: prevAssetsToSupply,\n      });\n    })\n    .catch((err) => {\n      showReload();\n      console.log(\"getPoolDataProviderTotal_err\", err);\n    });\n}\nfunction getPoolDataProviderCaps() {\n  const prevAssetsToSupply = [...state.assetsToSupply];\n\n  const underlyingTokens = dexConfig?.rawMarkets?.map(\n    (market) => market.underlyingAsset\n  );\n  // console.log(\"getPoolDataProviderCaps--\", underlyingTokens);\n  const calls = underlyingTokens?.map((addr) => ({\n    address: config.PoolDataProvider,\n    name: \"getReserveCaps\",\n    params: [addr],\n  }));\n\n  multicall({\n    abi: [\n      {\n        inputs: [{ internalType: \"address\", name: \"asset\", type: \"address\" }],\n        name: \"getReserveCaps\",\n        outputs: [\n          { internalType: \"uint256\", name: \"borrowCap\", type: \"uint256\" },\n          { internalType: \"uint256\", name: \"supplyCap\", type: \"uint256\" },\n        ],\n        stateMutability: \"view\",\n        type: \"function\",\n      },\n    ],\n    calls,\n    options: {},\n    multicallAddress,\n    provider: Ethers.provider(),\n  })\n    .then((res) => {\n      console.log(\"getPoolDataProviderCaps_res\", res);\n\n      for (let i = 0; i < res.length; i++) {\n        const [borrowCap, supplyCap] = res[i];\n\n        prevAssetsToSupply[i].borrowCap = borrowCap ? borrowCap.toNumber() : 0;\n        prevAssetsToSupply[i].borrowCapUSD = Big(borrowCap)\n          .times(prices[prevAssetsToSupply[i].symbol])\n          .toFixed();\n        prevAssetsToSupply[i].supplyCap = supplyCap ? supplyCap.toNumber() : 0;\n        prevAssetsToSupply[i].supplyCapUSD = Big(supplyCap)\n          .times(prices[prevAssetsToSupply[i].symbol])\n          .toFixed();\n      }\n      State.update({\n        assetsToSupply: prevAssetsToSupply,\n      });\n    })\n    .catch((err) => {\n      showReload();\n      console.log(\"getPoolDataProviderCaps_err\", err);\n    });\n}\n\nfunction getUserAccountData() {\n  const contract = new ethers.Contract(\n    config.aavePoolV3Address,\n    [\n      {\n        inputs: [\n          {\n            internalType: \"address\",\n            name: \"user\",\n            type: \"address\",\n          },\n        ],\n        name: \"getUserAccountData\",\n        outputs: [\n          {\n            internalType: \"uint256\",\n            name: \"totalCollateralBase\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"totalDebtBase\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"availableBorrowsBase\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"currentLiquidationThreshold\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"ltv\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"healthFactor\",\n            type: \"uint256\",\n          },\n        ],\n        stateMutability: \"view\",\n        type: \"function\",\n      },\n    ],\n    Ethers.provider()\n  );\n  contract\n    .getUserAccountData(account)\n    .then((res) => {\n      console.log(\"getUserAccountData_res:\", res);\n      const [\n        totalCollateralBase,\n        totalDebtBase,\n        availableBorrowsBase,\n        currentLiquidationThreshold,\n        ltv,\n        healthFactor,\n      ] = res;\n\n      const totalDebtBaseUSD = ethers.utils.formatUnits(\n        totalDebtBase.toString(),\n        8\n      );\n\n      const totalCollateralBaseUSD = ethers.utils.formatUnits(\n        totalCollateralBase.toString(),\n        8\n      );\n      const threshold = ethers.utils.formatUnits(\n        currentLiquidationThreshold.toString(),\n        4\n      );\n\n      const _totalCollateralBaseUSD = Big(totalCollateralBaseUSD).times(\n        Big(threshold)\n      );\n      const BorrowPowerUsed = Big(totalDebtBaseUSD || 0)\n        .div(_totalCollateralBaseUSD.eq(0) ? 1 : _totalCollateralBaseUSD)\n        .times(100)\n        .toFixed();\n      // console.log(\n      //   \"HF--\",\n      //   ethers.utils.formatUnits(healthFactor),\n      //   formatHealthFactor(ethers.utils.formatUnits(healthFactor))\n      // );\n      State.update({\n        threshold,\n        currentLiquidationThreshold,\n        BorrowPowerUsed,\n        healthFactor: !totalDebtBase.toNumber()\n          ? formatHealthFactor(\"\u221e\")\n          : formatHealthFactor(ethers.utils.formatUnits(healthFactor)),\n\n        availableBorrowsUSD: ethers.utils.formatUnits(availableBorrowsBase, 8),\n      });\n    })\n    .then(() => {\n      getLiquidity();\n    })\n    .catch((err) => {\n      showReload();\n      console.log(\"getUserAccountData_error\", err);\n    });\n}\nfunction valueToBigNumber(amount) {\n  if (amount instanceof BigNumber) {\n    return amount;\n  }\n\n  return new BigNumber(amount);\n}\nconst LTV_PRECISION = 4;\n// return  HealthFactorFromBalanceRequest): BigNumber\nfunction calculateHealthFactorFromBalances({\n  borrowBalanceMarketReferenceCurrency,\n  collateralBalanceMarketReferenceCurrency,\n  currentLiquidationThreshold,\n}) {\n  if (valueToBigNumber(borrowBalanceMarketReferenceCurrency).eq(0)) {\n    return valueToBigNumber(\"-1\"); // Invalid number\n  }\n\n  return valueToBigNumber(collateralBalanceMarketReferenceCurrency)\n    .multipliedBy(currentLiquidationThreshold)\n    .shiftedBy(LTV_PRECISION * -1)\n    .div(borrowBalanceMarketReferenceCurrency || 1);\n}\n\nfunction getYourSupplies() {\n  const aTokenAddresss = markets\n    ?.map((item) => item.aTokenAddress)\n    .filter((item) => item.symbol !== \"ETH\");\n\n  const calls = aTokenAddresss?.map((addr) => ({\n    address: addr,\n    name: \"balanceOf\",\n    params: [account],\n  }));\n  multicall({\n    abi: [\n      {\n        inputs: [\n          {\n            internalType: \"address\",\n            name: \"user\",\n            type: \"address\",\n          },\n        ],\n        name: \"balanceOf\",\n        outputs: [\n          {\n            internalType: \"uint256\",\n            name: \"\",\n            type: \"uint256\",\n          },\n        ],\n        stateMutability: \"view\",\n        type: \"function\",\n      },\n    ],\n    calls,\n    options: {},\n    multicallAddress,\n    provider: Ethers.provider(),\n  })\n    .then((res) => {\n      console.log(\"getUsetDeposits_res\", res);\n      let userDeposits = [];\n      for (let index = 0; index < res.length; index++) {\n        if (res[index]) {\n          // let underlyingBalance=\n          let market = state.assetsToSupply.find(\n            (item) =>\n              item.aTokenAddress === aTokenAddresss[index] &&\n              item.symbol !== \"ETH\"\n          );\n          if (market) {\n            let _bal = res[index]\n              ? ethers.utils.formatUnits(res[index][0], market.decimals)\n              : 0;\n\n            market.underlyingBalance = _bal;\n            const _balUSD = Big(_bal)\n              .mul(prices[market.symbol] || 0)\n              .toFixed();\n            market.underlyingBalanceUSD = _balUSD;\n\n            userDeposits.push(market);\n          }\n        }\n      }\n      const mm = state.assetsToSupply.reduce((prev, cur) => {\n        prev[cur.underlyingAsset] = cur;\n        return prev;\n      }, {});\n      const _yourSupplies = userDeposits?.map((userDeposit) => {\n        const market = mm[userDeposit.underlyingAsset];\n\n        return {\n          ...market,\n          ...userDeposit,\n          ...(market.symbol === config.nativeCurrency.symbol\n            ? {\n                ...config.nativeCurrency,\n                supportPermit: true,\n              }\n            : {}),\n        };\n      });\n      let obj = {};\n      const yourSupplies = _yourSupplies.reduce((prev, cur) => {\n        obj[cur.aTokenAddress]\n          ? \"\"\n          : (obj[cur.aTokenAddress] = true && prev.push(cur));\n        return prev;\n      }, []);\n      console.log(\"yourSupplies:\", yourSupplies);\n      // State.update({\n      //   yourSupplies,\n      // });\n      return yourSupplies;\n    })\n    .then((_yourSupplies) => {\n      if (!_yourSupplies || !_yourSupplies.length) return;\n      const calls = [\n        {\n          address: config.aavePoolV3Address,\n          name: \"getUserConfiguration\",\n          params: [account],\n        },\n        {\n          address: config.aavePoolV3Address,\n          name: \"getReservesList\",\n        },\n      ];\n\n      multicall({\n        abi: [\n          {\n            inputs: [\n              {\n                internalType: \"address\",\n                name: \"user\",\n                type: \"address\",\n              },\n            ],\n            name: \"getUserConfiguration\",\n            outputs: [\n              {\n                components: [\n                  {\n                    internalType: \"uint256\",\n                    name: \"data\",\n                    type: \"uint256\",\n                  },\n                ],\n                internalType: \"struct DataTypes.UserConfigurationMap\",\n                name: \"\",\n                type: \"tuple\",\n              },\n            ],\n            stateMutability: \"view\",\n            type: \"function\",\n          },\n          {\n            inputs: [],\n            name: \"getReservesList\",\n            outputs: [\n              {\n                internalType: \"address[]\",\n                name: \"\",\n                type: \"address[]\",\n              },\n            ],\n            stateMutability: \"view\",\n            type: \"function\",\n          },\n        ],\n        calls,\n        options: {},\n        multicallAddress,\n        provider: Ethers.provider(),\n      })\n        .then((res) => {\n          console.log(\"getCollateralStatus-res:\", res);\n          const [[rawStatus], [addrs]] = res;\n          if (rawStatus) {\n            const _status = parseInt(rawStatus.toString())\n              .toString(2)\n              .split(\"\");\n            // console.log(\"_status--\", _status);\n            const _statusArray = chunk(_status, 2);\n            // console.log(\"_status--\", _statusArray, addrs, _yourSupplies);\n\n            for (let i = 0; i < _yourSupplies.length; i++) {\n              const item = _yourSupplies[i];\n\n              const index = addrs.findIndex(\n                (addr) =>\n                  addr.toLowerCase() === item.underlyingAsset.toLowerCase()\n              );\n\n              _yourSupplies[i].isCollateraled = Number(_statusArray[index][0]);\n            }\n\n            let yourTotalCollateral = _yourSupplies\n              .filter((item) => item.isCollateraled === 1)\n              .reduce(\n                (prev, curr) =>\n                  Big(prev)\n                    .plus(Big(curr.underlyingBalanceUSD || 0))\n                    .toFixed(),\n                0\n              );\n\n            State.update((prev) => ({\n              ...prev,\n              yourSupplies: _yourSupplies,\n              yourTotalCollateral,\n            }));\n          } else {\n            State.update((prev) => ({\n              ...prev,\n              yourSupplies: _yourSupplies,\n            }));\n          }\n        })\n        .catch((err) => {\n          console.log(\"getCollateralStatus-error:\", err);\n        });\n    })\n    .catch((err) => {\n      showReload();\n      console.log(\"getUsetDeposits_err\", err);\n    });\n}\n\nfunction getUserDebts() {\n  const variableDebtTokenAddresss = markets?.map(\n    (item) => item.variableDebtTokenAddress\n  );\n\n  const calls = variableDebtTokenAddresss?.map((addr) => ({\n    address: addr,\n    name: \"balanceOf\",\n    params: [account],\n  }));\n\n  multicall({\n    abi: [\n      {\n        inputs: [\n          {\n            internalType: \"address\",\n            name: \"user\",\n            type: \"address\",\n          },\n        ],\n        name: \"balanceOf\",\n        outputs: [\n          {\n            internalType: \"uint256\",\n            name: \"\",\n            type: \"uint256\",\n          },\n        ],\n        stateMutability: \"view\",\n        type: \"function\",\n      },\n    ],\n    calls,\n    options: {},\n    multicallAddress,\n    provider: Ethers.provider(),\n  })\n    .then((res) => {\n      console.log(\"getUserDebts_res\", res);\n      let userDebs = [];\n      const _assetsToSupply = [...state.assetsToSupply];\n      for (let index = 0; index < res.length; index++) {\n        if (res[index]) {\n          let market = _assetsToSupply.find(\n            (item) =>\n              item.variableDebtTokenAddress ===\n                variableDebtTokenAddresss[index] && item.symbol !== \"ETH\"\n          );\n          if (market) {\n            let _debt = ethers.utils.formatUnits(\n              res[index][0],\n              market.decimals\n            );\n\n            market.debt = _debt;\n\n            market.debtInUSD = Big(_debt || 0)\n              .mul(prices[market.symbol] || 1)\n              .toFixed();\n            userDebs.push(market);\n          }\n        }\n      }\n      let hash = {};\n      let _yourBorrows = userDebs.reduce((accum, item) => {\n        hash[item[\"aTokenAddress\"]]\n          ? \"\"\n          : (hash[item[\"aTokenAddress\"]] = true && accum.push(item));\n        return accum;\n      }, []);\n\n      console.log(\"yourBorrows--\", _yourBorrows);\n      State.update({\n        yourBorrows: _yourBorrows,\n      });\n    })\n    .catch((err) => {\n      showReload();\n      console.log(\"getUserDebts_err\", err);\n    });\n}\n\nfunction chunk(arr, size) {\n  let result = [];\n\n  let temp = [];\n  for (let i = arr.length - 1; i > -1; i--) {\n    temp.unshift(arr[i]);\n    if (temp.length === size) {\n      result.push(temp);\n\n      temp = [];\n    }\n  }\n  if (temp.length !== 0) result.push(temp);\n  return result;\n}\n\nfunction handleRefresh() {\n  State.update({\n    updater: state.updater + 1,\n  });\n}\n\nuseEffect(() => {\n  if (!account || !isChainSupported) return;\n  getUserPoints();\n  getPrices();\n\n  getUserAccountData();\n  getPoolDataProvider();\n\n  getPoolDataProviderTotalSupply();\n  // if (dexConfig.name === \"Seamless Protocol\") {\n  //   getPoolDataProviderTotalDebt();\n  //   getPoolDataProviderCaps();\n  // }\n}, [account, isChainSupported, state.updater]);\n\nuseEffect(() => {\n  if (!account || !isChainSupported) return;\n  if (dexConfig.name !== \"Seamless Protocol\") return;\n  if (!Array.isArray(state.assetsToSupply)) return;\n  console.log(\"calc totalMarketSize\");\n  const totalMarketSize = state.assetsToSupply.reduce((prev, curr) => {\n    return Big(prev).plus(Big(curr.totalSupplyUSD)).toFixed();\n  }, 0);\n  const totalBorrows = state.assetsToSupply.reduce((prev, curr) => {\n    return Big(prev).plus(Big(curr.totalDebtsUSD)).toFixed();\n  }, 0);\n  const totalAvailable = Big(totalMarketSize)\n    .minus(Big(totalBorrows))\n    .toFixed();\n  State.update({\n    totalMarketSize,\n    totalAvailable,\n    totalBorrows,\n  });\n}, [account, isChainSupported, state.assetsToSupply]);\n\nuseEffect(() => {\n  if (!account || !isChainSupported) return;\n\n  if (!state.yourSupplies || !state.yourBorrows) return;\n  console.log(\"calc net apy\", state.yourSupplies, state.yourBorrows);\n  //calc net worth\n  const supplyBal = state.yourSupplies.reduce(\n    (total, cur) =>\n      Big(total || 0)\n        .plus(cur.underlyingBalanceUSD)\n        .toFixed(),\n    0\n  );\n  console.log(\"supplyBal--\", supplyBal);\n  const debtsBal = state.yourBorrows.reduce(\n    (total, cur) =>\n      Big(total || 0)\n        .plus(cur.debtInUSD)\n        .toFixed(),\n    0\n  );\n  console.log(\"debtsBal--\", debtsBal, supplyBal);\n  const netWorth = Big(supplyBal || 0)\n    .minus(debtsBal)\n    .toFixed(2, ROUND_DOWN);\n  console.log(\"netWorth--\", netWorth, state.yourSupplies);\n  if (!Number(netWorth)) return;\n\n  //calc net apy\n\n  const weightedAverageSupplyAPY = state.yourSupplies.reduce(\n    (total, cur) =>\n      Big(total || 0)\n        .plus(\n          Big(cur.underlyingBalanceUSD || 0)\n            .times(Big(cur.supplyAPY || 0))\n            .div(Number(supplyBal) || 1)\n        )\n        .toFixed(),\n    0\n  );\n  const yourSupplyRewardAPY = state.yourSupplies.reduce((total, cur) => {\n    return Big(total || 0)\n      .plus(Big(cur.supplyRewardApy || 0))\n      .toFixed();\n  }, 0);\n\n  console.log(\"weightedAverageSupplyAPY--\", weightedAverageSupplyAPY);\n  const weightedAverageBorrowsAPY = state.yourBorrows.reduce((total, cur) => {\n    return Big(total || 0)\n      .plus(\n        Big(cur.debtInUSD)\n          .times(Big(cur.borrowAPY || 1))\n          .div(debtsBal || 1)\n      )\n      .toFixed();\n  }, 0);\n  console.log(\"weightedAverageBorrowsAPY--\", weightedAverageBorrowsAPY);\n\n  const a = Big(weightedAverageSupplyAPY || 0)\n    .times(supplyBal)\n    .div(netWorth || 1)\n    .toFixed();\n  console.log(\"a--\", a);\n  const b = Big(weightedAverageBorrowsAPY || 0)\n    .times(debtsBal)\n    .div(netWorth || 1)\n    .toFixed();\n  console.log(\"b--\", b);\n  const netAPY = Big(a).minus(Big(b)).toFixed();\n  console.log(\"netAPY--\", netAPY);\n  const yourTotalSupply = state.yourSupplies.reduce(\n    (prev, curr) =>\n      Big(prev)\n        .plus(Big(curr.underlyingBalanceUSD || 0))\n        .toFixed(),\n    0\n  );\n  console.log(\"yourTotalSupply--\", yourTotalSupply);\n\n  const yourTotalBorrow = state.yourBorrows.reduce(\n    (prev, curr) =>\n      Big(prev)\n        .plus(Big(curr.debtInUSD || 0))\n        .toFixed(),\n    0\n  );\n  console.log(\"yourTotalBorrow--\", yourTotalBorrow);\n\n  State.update((prev) => ({\n    ...prev,\n    netAPY,\n    netWorthUSD: netWorth,\n    yourTotalSupply,\n    yourTotalBorrow,\n    yourSupplyApy: Big(weightedAverageSupplyAPY)\n      .plus(yourSupplyRewardAPY)\n      .toFixed(),\n    yourBorrowApy: weightedAverageBorrowsAPY,\n  }));\n}, [state.yourSupplies, state.yourBorrows]);\n\nfunction onSuccess() {\n  State.update({\n    ...state,\n    fresh: state.fresh + 1,\n  });\n}\n\nconsole.log(\"STATE: \", state);\n\nconst body = isChainSupported ? (\n  <Wrap>\n    <FlexContainer>\n      <ChainsWrap>\n        <Widget\n          src=\"bluebiu.near/widget/Lending.Chains\"\n          props={{\n            chains: CHAIN_LIST,\n            curChain,\n            onSwitchChain,\n            // onChange: (tab) => {\n            //   State.update({\n            //     tab: tab.key,\n            //   });\n            // },\n          }}\n        />\n      </ChainsWrap>\n      <Widget\n        src={`${config.ownerId}/widget/AAVE.HeroData`}\n        props={{\n          config,\n          netWorth: `$ ${\n            state.netWorthUSD ? Big(state.netWorthUSD || 0).toFixed(2) : \"-\"\n          }`,\n          netAPY: `${\n            state.netAPY\n              ? Number(\n                  Big(state.netAPY || 0)\n                    .times(100)\n                    .toFixed(2)\n                )\n              : \"-\"\n          }%`,\n          healthFactor: formatHealthFactor(state.healthFactor),\n          totalMarketSize: state.totalMarketSize,\n          totalAvailable: state.totalAvailable,\n          totalBorrows: state.totalBorrows,\n          theme: dexConfig?.theme,\n          yourBorrows: state.yourBorrows,\n          BlastPoints: state.BlastPoints,\n          BlastGold: state.BlastGold,\n        }}\n      />\n    </FlexContainer>\n    <Widget\n      src={`${config.ownerId}/widget/AAVE.TabSwitcher`}\n      props={{\n        config,\n        theme: dexConfig?.theme,\n        select: state.selectTab,\n        setSelect: (tabName) => State.update({ selectTab: tabName }),\n      }}\n    />\n    {state.selectTab === \"MARKET\" && (\n      <>\n        <Widget\n          src={`${config.ownerId}/widget/AAVE.Card.Markets`}\n          props={{\n            formatUSD,\n            config,\n            dexConfig,\n            chainId: chainId,\n            assetsToSupply: state.assetsToSupply,\n            showSupplyModal: state.showSupplyModal,\n            setShowSupplyModal: (isShow) =>\n              State.update({ showSupplyModal: isShow }),\n            onActionSuccess,\n            healthFactor: formatHealthFactor(state.healthFactor),\n            formatHealthFactor,\n            calcHealthFactor,\n            depositETHGas,\n            depositERC20Gas,\n            borrowETHGas,\n            borrowERC20Gas,\n            yourSupplies: state.yourSupplies,\n            yourTotalSupply: state.yourTotalSupply,\n            theme: dexConfig?.theme,\n            addAction,\n            dexConfig,\n            prices,\n          }}\n        />\n      </>\n    )}\n    {state.selectTab === \"YOURS\" && (\n      <>\n        <Yours>\n          <YoursTableWrapper>\n            <Title>\n              You Supplies\n              {state.yourSupplies && state.yourSupplies.length ? (\n                <SubTitle>\n                  <Label>Balance:</Label>\n                  <Value>$ {Number(state.yourTotalSupply).toFixed(2)}</Value>\n\n                  <Label>APY:</Label>\n                  <Value>\n                    {Big(state.yourSupplyApy).times(100).toFixed(2)} %\n                  </Value>\n\n                  <Label>Collateral:</Label>\n                  <Value>\n                    $ {Number(state.yourTotalCollateral).toFixed(2)}\n                  </Value>\n                </SubTitle>\n              ) : null}\n            </Title>\n            <Widget\n              src={`${config.ownerId}/widget/AAVE.Card.YourSupplies`}\n              props={{\n                formatNumber,\n                config,\n                chainId: chainId,\n                yourSupplies: state.yourSupplies,\n                showWithdrawModal: state.showWithdrawModal,\n                setShowWithdrawModal: (isShow) =>\n                  State.update({ showWithdrawModal: isShow }),\n                onActionSuccess,\n                healthFactor: formatHealthFactor(state.healthFactor),\n                formatHealthFactor,\n                calcHealthFactor,\n                withdrawETHGas,\n                withdrawERC20Gas,\n                account,\n                prices,\n                threshold: state.threshold,\n                addAction,\n                dexConfig,\n                yourTotalCollateral: state.yourTotalCollateral,\n                yourTotalBorrow: state.yourTotalBorrow,\n                theme: dexConfig?.theme,\n                onRefresh: handleRefresh,\n              }}\n            />\n          </YoursTableWrapper>\n          <YoursTableWrapper>\n            <Title>\n              You Borrows\n              {state.yourBorrows && state.yourBorrows.length ? (\n                <SubTitle>\n                  <Label>Balance:</Label>\n                  <Value>$ {Number(state.yourTotalBorrow).toFixed(2)}</Value>\n\n                  <Label>APY:</Label>\n                  <Value>\n                    {Big(state.yourBorrowApy).times(100).toFixed(2)} %\n                  </Value>\n\n                  <Label>Borrow power used:</Label>\n                  <Value>{Number(state.BorrowPowerUsed).toFixed(2)}%</Value>\n                </SubTitle>\n              ) : null}\n            </Title>\n            <Widget\n              src={`${config.ownerId}/widget/AAVE.Card.YourBorrows`}\n              props={{\n                config,\n                chainId: chainId,\n                prices,\n                assetsToSupply: state.assetsToSupply,\n                yourBorrows: state.yourBorrows,\n                showRepayModal: state.showRepayModal,\n                setShowRepayModal: (isShow) =>\n                  State.update({ showRepayModal: isShow }),\n                showBorrowModal: state.showBorrowModal,\n                setShowBorrowModal: (isShow) =>\n                  State.update({ showBorrowModal: isShow }),\n                formatHealthFactor,\n                calcHealthFactor,\n                onActionSuccess,\n                repayETHGas,\n                repayERC20Gas,\n                borrowETHGas,\n                borrowERC20Gas,\n                addAction,\n                dexConfig,\n                healthFactor: formatHealthFactor(state.healthFactor),\n                theme: dexConfig?.theme,\n              }}\n            />\n          </YoursTableWrapper>\n        </Yours>\n\n        <Widget\n          src={`${config.ownerId}/widget/AAVE.Card.PointsTable`}\n          props={{\n            account,\n            config,\n            data: state.assetsToSupply,\n            dapps: dexConfig,\n            onSuccess,\n            markets,\n            prices,\n            toast,\n            theme: dexConfig?.theme,\n          }}\n        />\n      </>\n    )}\n    {state.alertModalText && (\n      <Widget\n        src={`${config.ownerId}/widget/AAVE.Modal.AlertModal`}\n        props={{\n          config,\n          theme: dexConfig?.theme,\n          title: \"All done!\",\n          description: state.alertModalText,\n          onRequestClose: () => State.update({ alertModalText: false }),\n        }}\n      />\n    )}\n    {state.isShowReloadModal ? (\n      <Widget\n        src={`${config.ownerId}/widget/AAVE.Modal.ReloadModal`}\n        props={{\n          title:\n            \"You are temporarily unable to access the data, please try to reload.\",\n          theme: dexConfig.theme,\n          config,\n          children: (\n            <div>\n              <Widget\n                src={`${config.ownerId}/widget/AAVE.PrimaryButton`}\n                props={{\n                  config,\n                  theme: dexConfig.theme,\n                  children: \"Reload\",\n                  onClick: () => {\n                    refresh && refresh();\n                  },\n                }}\n              />\n              <Widget\n                src={`${config.ownerId}/widget/AAVE.PrimaryButton`}\n                props={{\n                  config,\n                  // theme: dexConfig.theme,\n                  style: {\n                    color: \"#979ABE\",\n                    marginTop: 5,\n                    fontWeight: \"normal\",\n                  },\n                  children: \"Close\",\n                  onClick: () => {\n                    State.update({ isShowReloadModal: false });\n                  },\n                }}\n              />\n            </div>\n          ),\n        }}\n      />\n    ) : null}\n  </Wrap>\n) : (\n  <>\n    <Widget\n      src=\"bluebiu.near/widget/Swap.ChainWarnigBox\"\n      props={{\n        chain: curChain,\n        onSwitchChain: onSwitchChain,\n        switchingChain: switchingChain,\n        theme: dexConfig.theme,\n      }}\n    />\n  </>\n);\n// );\n\nreturn <div>{body}</div>;\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/bluebiu.near/widget/Lending.Pac", "fact_widget_deployments_id": "aea7090d2a7f78e38ead1d5f57fc948d", "inserted_timestamp": "2024-04-29T23:43:30.865Z", "modified_timestamp": "2024-04-29T23:43:30.865Z", "__row_index": 13}