{"tx_hash": "3CFkT4T1F2JrRbNAq2jVWzS6DLR3JVpfkmmWDRwhBDJe", "action_id_social": "Ahkd9aXYjDAdrX8E85VvRWTeqcMYqLjcW3QqdvQhiSYb-0-widget", "block_id": 121066648, "block_timestamp": "2024-06-13T08:52:46.126Z", "signer_id": "bluebiu.near", "widget_name": "Staking.AgentFi.Index", "source_code": "const StyledContainer = styled.div`\n  padding-top: 34px;\n  width: var(--container-width);\n  margin: 0 auto;\n`;\nconst StyledTabs = styled.div`\n  position: relative;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n\n  &::after {\n    content: \"\";\n    position: absolute;\n    z-index: 1;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    height: 1px;\n    background: linear-gradient(90deg, rgba(22, 24, 29, 0.00) 0%, #373A53 50%, rgba(22, 24, 29, 0.00) 100%);\n  }\n\n  .tab-item {\n    position: relative;\n    display: flex;\n    -webkit-box-align: center;\n    align-items: center;\n    -webkit-box-pack: center;\n    justify-content: center;\n    width: 200px;\n    height: 46px;\n    cursor: pointer;\n    color: #979ABE;\n    font-size: 20px;\n    font-style: normal;\n    font-weight: 700;\n    line-height: normal;\n    \n    &.active {\n      color: #ffffff;\n    }\n  }\n`;\nconst StyledTabsPointer = styled.div`\n  content: \"\";\n  display: block;\n  width: 200px;\n  height: 1px;\n  background: #ffffff;\n  position: absolute;\n  z-index: 2;\n  left: 0;\n  bottom: 0;\n  transition: transform .3s ease-in-out;\n`;\nconst StyledContentTopTVL = styled.div`\n  position: absolute;\n  z-index: 1;\n  right: 0;\n  top: 0;\n  color: #979ABE;\n  height: 46px;\n  display: flex;\n  justify-content: flex-start;\n  align-items: center;\n  gap: 8px;\n  font-size: 16px;\n  \n  .tvl-value {\n    color: var(--button-color);\n    font-weight: 600;\n  }\n`;\nconst StyledContent = styled.div``;\n\nconst ERC20_ABI = [\n  {\n    constant: true,\n    inputs: [\n      {\n        name: \"owner\",\n        type: \"address\",\n      },\n      {\n        name: \"spender\",\n        type: \"address\",\n      },\n    ],\n    name: \"allowance\",\n    outputs: [\n      {\n        name: \"\",\n        type: \"uint256\",\n      },\n    ],\n    payable: false,\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    constant: false,\n    inputs: [\n      {\n        name: \"spender\",\n        type: \"address\",\n      },\n      {\n        name: \"amount\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"approve\",\n    outputs: [\n      {\n        name: \"\",\n        type: \"bool\",\n      },\n    ],\n    payable: false,\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n];\nconst QUERY_POOL_ABI = [\n  {\n    \"inputs\": [],\n    \"name\": \"slot0\",\n    \"outputs\": [\n      { \"internalType\": \"uint160\", \"name\": \"sqrtPriceX96\", \"type\": \"uint160\" },\n      { \"internalType\": \"int24\", \"name\": \"tick\", \"type\": \"int24\" },\n      { \"internalType\": \"uint16\", \"name\": \"observationIndex\", \"type\": \"uint16\" },\n      { \"internalType\": \"uint16\", \"name\": \"observationCardinality\", \"type\": \"uint16\" },\n      { \"internalType\": \"uint16\", \"name\": \"observationCardinalityNext\", \"type\": \"uint16\" },\n      { \"internalType\": \"uint8\", \"name\": \"feeProtocol\", \"type\": \"uint8\" },\n      { \"internalType\": \"bool\", \"name\": \"unlocked\", \"type\": \"bool\" },\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\",\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"liquidity\",\n    \"outputs\": [\n      { \"internalType\": \"uint128\", \"name\": \"\", \"type\": \"uint128\" },\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\",\n  },\n];\n\n//#region tickMath\nconst MAX_TICK = 887272;\nconst MIN_TICK = -887272;\nconst CLM_FEES = {\n  100: {\n    value: 100,\n    space: 1,\n    desc: \"Best for stable pairs\",\n  },\n  500: {\n    value: 500,\n    space: 10,\n    desc: \"Best for most pairs\",\n  },\n  3000: {\n    value: 3000,\n    space: 60,\n    desc: \"Best for exotic pairs\",\n  },\n};\n\nfunction wrapNativeToken(token) {\n  if (token.isNative) return { ...token, address: \"0x4300000000000000000000000000000000000004\" };\n  return token;\n}\n\nfunction sortTokens(token0, token1) {\n  if (!token0 || !token1) return [];\n  const _token0 = wrapNativeToken(token0);\n  const _token1 = wrapNativeToken(token1);\n  if (_token0.address.toLowerCase() > _token1.address.toLowerCase()) return [token1, token0];\n\n  return [token0, token1];\n}\n\nfunction tickToPrice({ tick, token0, token1 }) {\n  const [_token0, _token1] = sortTokens(token0, token1);\n  const decimals = _token1.decimals - _token0.decimals;\n  const isReverse = _token1.address === token0.address;\n  const price = new Big(Math.pow(1.0001, tick)).div(Math.pow(10, decimals)).toNumber();\n  return isReverse ? 1 / price : price;\n}\n\nfunction priceToTick({ price, token0, token1 }) {\n  const [_token0, _token1] = sortTokens(token0, token1);\n  const decimals = _token1.decimals - _token0.decimals;\n  const isReverse = _token1.address === token0.address;\n  return Math.floor(Math.log(new Big(isReverse ? 1 / price : price).mul(Big(10).pow(decimals)).toNumber()) / Math.log(1.0001));\n}\n\nfunction nearestUsableTick(tick, fee) {\n  if (!fee) return tick;\n  const tickSpacing = CLM_FEES[fee].space;\n  const rounded = Math.round(tick / tickSpacing) * tickSpacing;\n  if (rounded < MIN_TICK) return rounded + tickSpacing;\n  else if (rounded > MAX_TICK) return rounded - tickSpacing;\n  else return rounded;\n}\n\nfunction priceToUsableTick({ price, token0, token1, fee }) {\n  const tick = priceToTick({ price, token0, token1 });\n  return nearestUsableTick(tick, fee);\n}\n//#endregion\n\nconst { parseUnits, formatUnits } = ethers.utils;\n\nconst {\n  CHAIN_LIST,\n  curChain,\n  dexConfig,\n  wethAddress,\n  multicallAddress,\n  multicall,\n  prices,\n  onSwitchChain,\n  switchingChain,\n  addAction,\n  toast,\n  chainId,\n  nativeCurrency,\n  account,\n  chainIdNotSupport,\n  isChainSupported,\n} = props;\n\nconst { StakeTokens } = dexConfig;\n\nconst tabs = [\n  {\n    key: 1,\n    title: 'Strategy Factory',\n  },\n  {\n    key: 2,\n    title: 'My Strategies',\n  },\n];\n\nState.init({\n  currentTabIdx: 0,\n  // strategy factory selected\n  currentStrategy: {},\n  // mystrategies selected\n  record: {},\n  loading: true,\n  tvl: 0,\n  multiplier: 0,\n  numKnownMissions: 0,\n  totalMissions: 12,\n  // dex apr\n  dexAPR: '',\n  strategies: [],\n\n  //#region user\n  listData: [],\n  listDataLoaded: false,\n  rootAgent: {},\n  listLoading: false,\n  totalDeposited: '0.00',\n  //#endregion\n});\n\nconst handleTab = (index) => {\n  if (state.currentTabIdx === index) return;\n  State.update({\n    currentTabIdx: index,\n  });\n};\n\nconst handleStrategy = (strategy) => {\n  State.update({\n    currentStrategy: strategy,\n  });\n};\n\nconst handleRecord = (_record) => {\n  State.update({\n    record: _record,\n  });\n};\n\nconst handleStrategyClose = () => {\n  State.update({\n    currentStrategy: {},\n  });\n};\n\nconst handleRecordClose = () => {\n  State.update({\n    record: {},\n  });\n};\n\nconst getTokenBalance = (token) => {\n  return new Promise((resolve) => {\n    if (token.address === 'native') {\n      Ethers.provider()\n        .getBalance(account)\n        .then((rawBalance) => {\n          resolve(formatUnits(rawBalance, token.decimals || 18));\n        }).catch((err) => {\n        console.log('get native balance error', err);\n        resolve(0);\n      });\n      return;\n    }\n    const contract = new ethers.Contract(\n      token.address,\n      [\n        {\n          inputs: [{ internalType: \"address\", name: \"account\", type: \"address\" }],\n          name: \"balanceOf\",\n          outputs: [{ internalType: \"uint256\", name: \"value\", type: \"uint256\" }],\n          stateMutability: \"view\",\n          type: \"function\",\n        },\n      ],\n      Ethers.provider().getSigner(),\n    );\n    contract\n      .balanceOf(account)\n      .then((_balance) => {\n        resolve(formatUnits(_balance, token.decimals || 18));\n      })\n      .catch((err) => {\n        console.log(\"getTokenBalance failed\", err);\n        resolve(0);\n      });\n  });\n}\n\nconst handleUpdateData = () => {\n  State.update({\n    loading: true,\n  });\n};\n\nconst getTVLData = () => {\n  const url = `https://stats-cdn.agentfi.io/protocolSummary.json`;\n  asyncFetch(url).then((res) => {\n    if (!res.ok || !res.body) {\n      return;\n    }\n    State.update({\n      // not this one, see getAppInformation fn\n      // tvl: res.body.tvl,\n      multiplier: res.body.multiplier,\n      numKnownMissions: res.body.numKnownMissions,\n    });\n  }).catch((err) => {\n    console.log(err);\n  });\n};\n\nconst getDexBalancerData = () => {\n  const url = `https://api.agentfi.io/strategy/dex-balancer`;\n  asyncFetch(url).then((res) => {\n    if (!res.ok || !res.body || !res.body.data || !res.body.data.apr) {\n      return;\n    }\n    const { net } = res.body.data.apr;\n    State.update({\n      dexAPR: Big(net || 0).toFixed(1),\n    });\n  }).catch((err) => {\n    console.log(err);\n  });\n};\n\nconst formatTVL = (record, options) => {\n  let { strategies } = options || {};\n  if (!strategies) {\n    strategies = state.strategies;\n  }\n  if (!record.balances || !record.balances.length) {\n    return { value: '$0.00', list: [], usd: Big(0) };\n  }\n  const calcList = record.balances.filter((b) => ![\"All Gas\", \"Max Gas Reclaim\"].includes(b.name));\n  if (!calcList.length) {\n    return { value: '$0.00', list: [], usd: Big(0) };\n  }\n  const calcValue = (balance) => {\n    if (!balance) return Big(0);\n    return Big(balance.balance).times(prices[balance.symbol]);\n  };\n\n  if ([strategies[1].name, strategies[2].name].includes(record.name.toLowerCase())) {\n    let totalValue = Big(0);\n    const balanceList = [];\n    calcList.forEach((it) => {\n      if (!it.underlying) return;\n      it.underlying.forEach((_it) => {\n        _it.balanceValue = calcValue(_it);\n        totalValue = totalValue.plus(_it.balanceValue);\n\n        const blei = balanceList.findIndex((bl) => bl.address === _it.address);\n        if (blei > -1) {\n          balanceList[blei].balance = Big(balanceList[blei].balance).plus(_it.balance).toString();\n          balanceList[blei].amount = Big(balanceList[blei].amount).plus(_it.amount).toString();\n        } else {\n          const currTk = StakeTokens.find((st) => st.symbol === _it.symbol);\n          _it.icon = currTk?.icon;\n          balanceList.push(_it);\n        }\n      });\n    });\n    return {\n      value: `$${totalValue.toFixed(2)}`,\n      list: balanceList,\n      usd: totalValue,\n    };\n  }\n\n  let totalValue = Big(0);\n  const balanceList = [];\n  calcList.forEach((it) => {\n    it.balanceValue = calcValue(it);\n    const currTk = StakeTokens.find((st) => st.symbol === it.symbol);\n    it.icon = currTk?.icon;\n    totalValue = totalValue.plus(it.balanceValue);\n    balanceList.push({ ...it });\n  });\n  return {\n    value: `$${totalValue.toFixed(2)}`,\n    list: balanceList,\n    usd: totalValue,\n  };\n};\n\nconst getListData = (options) => {\n  return new Promise(resolve => {\n    let { strategies } = options || {};\n    if (!strategies) {\n      strategies = state.strategies;\n    }\n    if (!account || !curChain) {\n      resolve([]);\n      return;\n    }\n    State.update({\n      listLoading: true,\n    });\n    const url = `https://api.agentfi.io/agents/${account}?chainID=${curChain.chain_id}`;\n    asyncFetch(url).then((res) => {\n      if (!res.ok || !res.body || !res.body.data) {\n        resolve([]);\n        return;\n      }\n      const ls = res.body.data || [];\n      const _listData = [];\n      let totalDeposited = Big(0);\n      let _rootAgent = [];\n      for (const it of ls) {\n        if (it.agentType === 'ROOT') {\n          _rootAgent = it;\n          const { usd } = formatTVL(it, { strategies, from: 'list data' });\n          totalDeposited = totalDeposited.plus(usd);\n          continue;\n        }\n        _listData.push(it);\n      }\n      _listData.forEach((record) => {\n        const { usd } = formatTVL(record, { strategies, from: 'list data' });\n        totalDeposited = totalDeposited.plus(usd);\n      });\n      State.update({\n        listLoading: false,\n        listData: _listData,\n        totalDeposited: totalDeposited.toFixed(2),\n        rootAgent: _rootAgent || {},\n      });\n      resolve(_listData);\n    }).catch((err) => {\n      console.log('getListData failed, ', err);\n      resolve([]);\n      State.update({\n        listLoading: false,\n      });\n    });\n  });\n};\n\nconst handleApprove = (spender, tokenAddress, tokenAmount, tokenDecimals) => {\n  return new Promise((resolve) => {\n    // eth will not approve\n    if (['0x0000000000000000000000000000000000000000', 'native'].includes(tokenAddress)) {\n      resolve(true);\n      return;\n    }\n    const TokenContract = new ethers.Contract(\n      tokenAddress,\n      ERC20_ABI,\n      Ethers.provider().getSigner()\n    );\n    const allowanceParams = [\n      // owner\n      account,\n      // spender\n      spender,\n    ];\n    const approveParams = [\n      // spender\n      spender,\n      // amount\n      parseUnits(Big(tokenAmount).toFixed(tokenDecimals || 18).toString(), tokenDecimals),\n    ];\n    const approveFailed = (msg) => {\n      toast?.fail({\n        title: \"Approve Failed!\",\n        text: msg || `Approve ${Big(state.usdAmount).toFixed(2)} ${state.currentUsdToken.value}`,\n      });\n    };\n    TokenContract.allowance(...allowanceParams).then((res) => {\n      const allowanceValue = Big(formatUnits(res, tokenDecimals));\n      if (allowanceValue.gte(tokenAmount || 0)) {\n        resolve(true);\n        return;\n      }\n      // re-approve\n      TokenContract.approve(...approveParams).then((tx) => {\n        tx.wait()\n          .then((res) => {\n            const { status, transactionHash } = res;\n            if (status !== 1) {\n              resolve(false);\n              approveFailed();\n              return;\n            }\n            resolve(true);\n            toast?.success({\n              title: \"Approve Successfully!\",\n              tx: transactionHash,\n              chainId,\n            });\n          })\n          .catch((err) => {\n            resolve(false);\n            console.log(err);\n            approveFailed();\n          });\n      })\n        .catch((err) => {\n          resolve(false);\n          approveFailed(err?.message?.includes(\"user rejected transaction\") ? 'User rejected transaction' : '');\n        });\n    }).catch((err) => {\n      console.log(err);\n      resolve(false);\n    });\n  });\n};\n\nconst getAppInformation = () => {\n  const url = `https://api.llama.fi/protocol/agentfi`;\n  const url2 = `/api/app/agentfi/strategies`;\n  asyncFetch(url).then((res) => {\n    if (!res.ok || !res.body || !res.body.tvl || !res.body.tvl.length) {\n      return;\n    }\n    const tvlList = res.body.tvl.sort((a, b) => b.date - a.date);\n    State.update({\n      tvl: tvlList[0]?.totalLiquidityUSD,\n    });\n  }).catch((err) => {\n    console.log(err);\n  });\n  return new Promise((resolve) => {\n    State.update({\n      listLoading: true,\n    });\n    const formatStrategies = (remoteStrategies) => {\n      const strategiesResult = [];\n      dexConfig.strategies.forEach((it) => {\n        const curr = remoteStrategies.find((_it) => _it.ID === it.ID);\n        const obj = {\n          ...it,\n          NAME: curr?.NAME || it.NAME,\n        };\n        obj.name = obj.NAME.toLowerCase();\n        strategiesResult.push(obj);\n      });\n      State.update({\n        strategies: strategiesResult,\n      });\n      resolve(strategiesResult);\n      State.update({\n        listLoading: false,\n      });\n    };\n    asyncFetch(url2).then((res) => {\n      if (!res.ok || !res.body || !res.body.length) {\n        formatStrategies([]);\n        return;\n      }\n      formatStrategies(res.body);\n    }).catch((err) => {\n      console.log(err);\n      formatStrategies([]);\n    });\n  });\n};\n\nconst {\n  currentTabIdx,\n  currentStrategy,\n  loading,\n  listLoading,\n  record,\n  tvl,\n  multiplier,\n  numKnownMissions,\n  totalMissions,\n  listData,\n  rootAgent,\n  totalDeposited,\n  dexAPR,\n  strategies,\n} = state;\n\nuseEffect(() => {\n  State.update({\n    loading: !chainIdNotSupport,\n  });\n}, [chainIdNotSupport]);\n\nuseEffect(() => {\n  if (!prices || !Object.keys(prices).length || state.listDataLoaded) return;\n  getAppInformation().then((strategies) => {\n    getTVLData();\n    getDexBalancerData();\n    getListData({ strategies });\n  });\n  State.update({\n    listDataLoaded: true,\n  });\n}, [prices, state.listDataLoaded]);\n\nreturn (\n  <StyledContainer style={dexConfig.theme}>\n    {\n      loading || listLoading ? (\n        <Widget src=\"bluebiu.near/widget/Lending.Spinner\" />\n      ) : (\n        <>\n          <StyledTabs>\n            {\n              tabs.map((tab, index) => (\n                <div\n                  className={`tab-item ${currentTabIdx === index ? 'active' : ''}`}\n                  key={tab.key}\n                  onClick={() => handleTab(index)}\n                >\n                  {tab.title}\n                </div>\n              ))\n            }\n            <StyledTabsPointer\n              style={{\n                left: `calc((100% - 200px * ${tabs.length}) / 2)`,\n                transform: `translateX(${currentTabIdx * 200}px)`,\n              }}\n            />\n            {\n              currentTabIdx === 0 && (\n                <StyledContentTopTVL>\n                  <span className=\"tvl-label\">Protocol TVL</span>\n                  <span className=\"tvl-value\">\n                    $\n                    <Widget\n                      src=\"bluebiu.near/widget/Utils.FormatNumber\"\n                      props={{\n                        number: tvl,\n                      }}\n                    />\n                  </span>\n                </StyledContentTopTVL>\n              )\n            }\n          </StyledTabs>\n          <StyledContent>\n            {\n              currentTabIdx === 0 && (\n                <Widget\n                  src={\"bluebiu.near/widget/Staking.AgentFi.StrategyFactory\"}\n                  props={{\n                    ...props,\n                    currentStrategy,\n                    handleStrategy,\n                    onStrategyClose: handleStrategyClose,\n                    getTokenBalance,\n                    handleUpdateData,\n                    totalMissions,\n                    multiplier,\n                    numKnownMissions,\n                    rootAgent,\n                    handleApprove,\n                    tickToPrice,\n                    priceToUsableTick,\n                    QUERY_POOL_ABI,\n                    dexAPR,\n                    strategies,\n                    onSuccess: () => {\n                      State.update({\n                        loading: true,\n                      });\n                      getListData().then((_list) => {\n                        if (!_list.length || !record.agentAddress) return;\n                        const currRecord = _list.find((it) => it.agentAddress === record.agentAddress);\n                        currRecord && handleRecord(currRecord);\n                      });\n                    },\n                  }}\n                />\n              )\n            }\n            {\n              currentTabIdx === 1 && (\n                <Widget\n                  src={\"bluebiu.near/widget/Staking.AgentFi.MyStrategies\"}\n                  props={{\n                    ...props,\n                    record,\n                    handleRecord,\n                    onRecordClose: handleRecordClose,\n                    getTokenBalance,\n                    multiplier,\n                    numKnownMissions,\n                    totalMissions,\n                    listData,\n                    loading: listLoading,\n                    totalDeposited,\n                    rootAgent,\n                    formatTVL,\n                    handleApprove,\n                    tickToPrice,\n                    priceToUsableTick,\n                    QUERY_POOL_ABI,\n                    strategies,\n                    onSuccess: () => {\n                      State.update({\n                        loading: true,\n                      });\n                      getListData().then((_list) => {\n                        if (!_list.length || !record.agentAddress) return;\n                        const currRecord = _list.find((it) => it.agentAddress === record.agentAddress);\n                        currRecord && handleRecord(currRecord);\n                      });\n                    },\n                  }}\n                />\n              )\n            }\n          </StyledContent>\n        </>\n      )\n    }\n    <Widget\n      src=\"bluebiu.near/widget/Staking.AgentFi.Data\"\n      props={{\n        update: loading,\n        account,\n        wethAddress,\n        multicallAddress,\n        multicall,\n        prices,\n        ...dexConfig,\n        onLoad: (data) => {\n          State.update({\n            loading: false,\n            ...data,\n          });\n        },\n      }}\n    />\n    {!isChainSupported && (\n      <Widget\n        src=\"bluebiu.near/widget/Swap.ChainWarnigBox\"\n        props={{\n          chain: curChain,\n          onSwitchChain: onSwitchChain,\n          switchingChain: switchingChain,\n          theme: dexConfig.theme?.button,\n        }}\n      />\n    )}\n  </StyledContainer>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/bluebiu.near/widget/Staking.AgentFi.Index", "fact_widget_deployments_id": "35c8c83d9d39ea0fc3a14e51bf23da95", "inserted_timestamp": "2024-06-13T11:05:20.330Z", "modified_timestamp": "2024-06-13T11:05:20.330Z", "__row_index": 0}