{"tx_hash": "4hiYYpAdeL2Won9bYEwtVM2FfSqeiw14gDm2VsP6Vh5p", "action_id_social": "7aea7oM22L5C21TXs366CEpiwR56V53BS6NrHyDSpDdP-0-widget", "block_id": 115010053, "block_timestamp": "2024-03-19T08:01:59.499Z", "signer_id": "bluebiu.near", "widget_name": "Metis.Swap.HummusExchangeAmountOut", "source_code": "const ROUTER_ABI = [\n  {\n    type: \"function\",\n    stateMutability: \"nonpayable\",\n    outputs: [\n      {\n        type: \"int256[]\",\n        name: \"\",\n        internalType: \"int256[]\",\n      },\n    ],\n    name: \"queryBatchSwap\",\n    inputs: [\n      {\n        type: \"uint8\",\n        name: \"kind\",\n        internalType: \"enum IVault.SwapKind\",\n      },\n      {\n        type: \"tuple[]\",\n        name: \"swaps\",\n        internalType: \"struct IVault.BatchSwapStep[]\",\n        components: [\n          {\n            type: \"bytes32\",\n            name: \"poolId\",\n            internalType: \"bytes32\",\n          },\n          {\n            type: \"uint256\",\n            name: \"assetInIndex\",\n            internalType: \"uint256\",\n          },\n          {\n            type: \"uint256\",\n            name: \"assetOutIndex\",\n            internalType: \"uint256\",\n          },\n          {\n            type: \"uint256\",\n            name: \"amount\",\n            internalType: \"uint256\",\n          },\n          {\n            type: \"bytes\",\n            name: \"userData\",\n            internalType: \"bytes\",\n          },\n        ],\n      },\n      {\n        type: \"address[]\",\n        name: \"assets\",\n        internalType: \"contract IAsset[]\",\n      },\n      {\n        type: \"tuple\",\n        name: \"funds\",\n        internalType: \"struct IVault.FundManagement\",\n        components: [\n          {\n            type: \"address\",\n            name: \"sender\",\n            internalType: \"address\",\n          },\n          {\n            type: \"bool\",\n            name: \"fromInternalBalance\",\n            internalType: \"bool\",\n          },\n          {\n            type: \"address\",\n            name: \"recipient\",\n            internalType: \"address payable\",\n          },\n          {\n            type: \"bool\",\n            name: \"toInternalBalance\",\n            internalType: \"bool\",\n          },\n        ],\n      },\n    ],\n  },\n  {\n    type: \"function\",\n    stateMutability: \"payable\",\n    outputs: [\n      {\n        type: \"int256[]\",\n        name: \"assetDeltas\",\n        internalType: \"int256[]\",\n      },\n    ],\n    name: \"batchSwap\",\n    inputs: [\n      {\n        type: \"uint8\",\n        name: \"kind\",\n        internalType: \"enum IVault.SwapKind\",\n      },\n      {\n        type: \"tuple[]\",\n        name: \"swaps\",\n        internalType: \"struct IVault.BatchSwapStep[]\",\n        components: [\n          {\n            type: \"bytes32\",\n            name: \"poolId\",\n            internalType: \"bytes32\",\n          },\n          {\n            type: \"uint256\",\n            name: \"assetInIndex\",\n            internalType: \"uint256\",\n          },\n          {\n            type: \"uint256\",\n            name: \"assetOutIndex\",\n            internalType: \"uint256\",\n          },\n          {\n            type: \"uint256\",\n            name: \"amount\",\n            internalType: \"uint256\",\n          },\n          {\n            type: \"bytes\",\n            name: \"userData\",\n            internalType: \"bytes\",\n          },\n        ],\n      },\n      {\n        type: \"address[]\",\n        name: \"assets\",\n        internalType: \"contract IAsset[]\",\n      },\n      {\n        type: \"tuple\",\n        name: \"funds\",\n        internalType: \"struct IVault.FundManagement\",\n        components: [\n          {\n            type: \"address\",\n            name: \"sender\",\n            internalType: \"address\",\n          },\n          {\n            type: \"bool\",\n            name: \"fromInternalBalance\",\n            internalType: \"bool\",\n          },\n          {\n            type: \"address\",\n            name: \"recipient\",\n            internalType: \"address payable\",\n          },\n          {\n            type: \"bool\",\n            name: \"toInternalBalance\",\n            internalType: \"bool\",\n          },\n        ],\n      },\n      {\n        type: \"int256[]\",\n        name: \"limits\",\n        internalType: \"int256[]\",\n      },\n      {\n        type: \"uint256\",\n        name: \"deadline\",\n        internalType: \"uint256\",\n      },\n    ],\n  },\n];\n\nconst {\n  updater,\n  routerAddress,\n  wethAddress,\n  inputCurrency,\n  outputCurrency,\n  inputCurrencyAmount,\n  onLoad,\n  slippage,\n  account,\n  fees,\n  pools,\n  prices,\n} = props;\n\nuseEffect(() => {\n  if (!updater || !prices || !pools.length) return;\n\n  if (!inputCurrency || !outputCurrency || !inputCurrencyAmount) {\n    return;\n  }\n\n  const path = [inputCurrency.address, outputCurrency.address];\n\n  const finalPool = pools\n    .filter(\n      (poolData) =>\n        poolData[0].includes(path[0]) && poolData[0].includes(path[1])\n    )\n    .map((poolData) => poolData[1]);\n  if (finalPool.length === 0) {\n    onLoad({\n      noPair: true,\n      outputCurrencyAmount: \"\",\n    });\n    return;\n  }\n\n  const amount = ethers.utils.parseUnits(\n    Big(inputCurrencyAmount || 0).toFixed(inputCurrency.decimals),\n    inputCurrency.decimals\n  );\n\n  const RouterContract = new ethers.Contract(\n    routerAddress,\n    ROUTER_ABI,\n    Ethers.provider().getSigner()\n  );\n\n  const getSwapStepsStruct = (isAmountOut) => {\n    const _inputAddress =\n      inputCurrency.isNative && isAmountOut\n        ? \"0x0000000000000000000000000000000000000000\"\n        : inputCurrency.address;\n    const _outputAddress =\n      outputCurrency.isNative && isAmountOut\n        ? \"0x0000000000000000000000000000000000000000\"\n        : outputCurrency.address;\n    const assets = [_inputAddress, _outputAddress];\n    const funds = [account, false, account, false];\n\n    const swap_steps = [\n      {\n        poolId: finalPool[0],\n        assetIn: _inputAddress,\n        assetOut: _outputAddress,\n        amount,\n      },\n    ];\n\n    const token_indices = {};\n    for (let i = 0; i < assets.length; i++) {\n      token_indices[assets[i]] = i;\n    }\n    const swap_steps_struct = [];\n    for (const step of swap_steps) {\n      swap_steps_struct.push([\n        step[\"poolId\"],\n        token_indices[step[\"assetIn\"]],\n        token_indices[step[\"assetOut\"]],\n        step[\"amount\"],\n        \"0x\",\n      ]);\n    }\n    return { swap_steps_struct, assets, funds };\n  };\n\n  const getAmountOut = () => {\n    const { swap_steps_struct, assets, funds } = getSwapStepsStruct(true);\n    const params = [0, swap_steps_struct, assets, funds];\n    RouterContract.callStatic\n      .queryBatchSwap(...params)\n      .then((res) => {\n        getTransaction({ amountOut: res[1] });\n      })\n      .catch((err) => {\n        onLoad({ noPair: true, outputCurrencyAmount: \"\" });\n      });\n  };\n\n  const getTransaction = (result) => {\n    const deadline = Math.ceil(Date.now() / 1000) + 60;\n    const _amountOut = Big(result.amountOut)\n      .abs()\n      .mul(1 - (slippage || 0.05))\n      .toFixed(0);\n\n    const token_limits = [amount, _amountOut];\n    const { swap_steps_struct, assets, funds } = getSwapStepsStruct(false);\n    const params = [\n      0,\n      swap_steps_struct,\n      assets,\n      funds,\n      token_limits,\n      deadline.toFixed(),\n    ];\n\n    const options = {\n      value: inputCurrency.isNative ? amount : \"0\",\n    };\n\n    const _amount = Big(\n      ethers.utils.formatUnits(result.amountOut, outputCurrency.decimals)\n    ).abs();\n\n    let priceImpact = null;\n\n    if (prices) {\n      const poolPrice = Big(prices[inputCurrency.symbol] || 1).div(\n        prices[outputCurrency.symbol] || 1\n      );\n      const amountoutPrice = Big(_amount).div(inputCurrencyAmount);\n\n      priceImpact = poolPrice\n        .minus(amountoutPrice)\n        .div(poolPrice.eq(0) ? 1 : poolPrice)\n        .mul(100)\n        .toString();\n    }\n\n    const returnData = {\n      inputCurrency,\n      inputCurrencyAmount,\n      outputCurrency,\n      outputCurrencyAmount: Big(_amount).gt(0.01)\n        ? Big(_amount).toPrecision(10)\n        : Big(_amount).toFixed(10),\n      priceImpact,\n      noPair: false,\n    };\n\n    const getTx = (gas) => {\n      RouterContract.populateTransaction\n        .batchSwap(...params, { ...options, gasLimit: gas })\n        .then((res) => {\n          onLoad({\n            ...returnData,\n            gas,\n            unsignedTx: res,\n          });\n        })\n        .catch((err) => {\n          onLoad({\n            ...returnData,\n            gas,\n          });\n        });\n    };\n    RouterContract.estimateGas\n      .batchSwap(...params, options)\n      .then((gas) => {\n        getTx(gas);\n      })\n      .catch((err) => {\n        onLoad({\n          ...returnData,\n          noPair: false,\n        });\n      });\n  };\n\n  getAmountOut();\n}, [updater, prices]);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/bluebiu.near/widget/Metis.Swap.HummusExchangeAmountOut", "fact_widget_deployments_id": "6c0054694a105b9a3ced50acfb9e0717", "inserted_timestamp": "2024-03-19T09:34:29.241Z", "modified_timestamp": "2024-03-19T09:34:29.241Z", "__row_index": 0}