{"tx_hash": "HnzoLNH8WBzwunxpkqZ7HoRD2mv52fJniaUL9WSRd1Vc", "action_id_social": "CiHts9kpBsz4LayhexFqeGrGP2eW2bJRSEnCTS5mY6e6-0-widget", "block_id": 101165111, "block_timestamp": "2023-09-15T07:16:53.379Z", "signer_id": "bluebiu.near", "widget_name": "Arbitrum.Pendle.TradeSwapAction", "source_code": "const ROUTER_ABI = [\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"receiver\",\n        type: \"address\",\n      },\n      {\n        internalType: \"address\",\n        name: \"market\",\n        type: \"address\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"minYtOut\",\n        type: \"uint256\",\n      },\n      {\n        components: [\n          {\n            internalType: \"uint256\",\n            name: \"guessMin\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"guessMax\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"guessOffchain\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"maxIteration\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"eps\",\n            type: \"uint256\",\n          },\n        ],\n        internalType: \"struct ApproxParams\",\n        name: \"guessYtOut\",\n        type: \"tuple\",\n      },\n      {\n        components: [\n          {\n            internalType: \"address\",\n            name: \"tokenIn\",\n            type: \"address\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"netTokenIn\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"address\",\n            name: \"tokenMintSy\",\n            type: \"address\",\n          },\n          {\n            internalType: \"address\",\n            name: \"bulk\",\n            type: \"address\",\n          },\n          {\n            internalType: \"address\",\n            name: \"pendleSwap\",\n            type: \"address\",\n          },\n          {\n            components: [\n              {\n                internalType: \"enum SwapType\",\n                name: \"swapType\",\n                type: \"uint8\",\n              },\n              {\n                internalType: \"address\",\n                name: \"extRouter\",\n                type: \"address\",\n              },\n              {\n                internalType: \"bytes\",\n                name: \"extCalldata\",\n                type: \"bytes\",\n              },\n              {\n                internalType: \"bool\",\n                name: \"needScale\",\n                type: \"bool\",\n              },\n            ],\n            internalType: \"struct SwapData\",\n            name: \"swapData\",\n            type: \"tuple\",\n          },\n        ],\n        internalType: \"struct TokenInput\",\n        name: \"input\",\n        type: \"tuple\",\n      },\n    ],\n    name: \"swapExactTokenForYt\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"netYtOut\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"netSyFee\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"payable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"receiver\",\n        type: \"address\",\n      },\n      {\n        internalType: \"address\",\n        name: \"market\",\n        type: \"address\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"exactYtIn\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"minPtOut\",\n        type: \"uint256\",\n      },\n      {\n        components: [\n          {\n            internalType: \"uint256\",\n            name: \"guessMin\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"guessMax\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"guessOffchain\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"maxIteration\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"eps\",\n            type: \"uint256\",\n          },\n        ],\n        internalType: \"struct ApproxParams\",\n        name: \"guessTotalPtSwapped\",\n        type: \"tuple\",\n      },\n    ],\n    name: \"swapExactYtForPt\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"netPtOut\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"netSyFee\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"receiver\",\n        type: \"address\",\n      },\n      {\n        internalType: \"address\",\n        name: \"market\",\n        type: \"address\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"exactPtIn\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"minYtOut\",\n        type: \"uint256\",\n      },\n      {\n        components: [\n          {\n            internalType: \"uint256\",\n            name: \"guessMin\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"guessMax\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"guessOffchain\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"maxIteration\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"eps\",\n            type: \"uint256\",\n          },\n        ],\n        internalType: \"struct ApproxParams\",\n        name: \"guessTotalPtToSwap\",\n        type: \"tuple\",\n      },\n    ],\n    name: \"swapExactPtForYt\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"netYtOut\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"netSyFee\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"receiver\",\n        type: \"address\",\n      },\n      {\n        internalType: \"address\",\n        name: \"market\",\n        type: \"address\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"exactSyIn\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"minYtOut\",\n        type: \"uint256\",\n      },\n      {\n        components: [\n          {\n            internalType: \"uint256\",\n            name: \"guessMin\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"guessMax\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"guessOffchain\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"maxIteration\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"eps\",\n            type: \"uint256\",\n          },\n        ],\n        internalType: \"struct ApproxParams\",\n        name: \"guessYtOut\",\n        type: \"tuple\",\n      },\n    ],\n    name: \"swapExactSyForYt\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"netYtOut\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"netSyFee\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"receiver\",\n        type: \"address\",\n      },\n      {\n        internalType: \"address\",\n        name: \"market\",\n        type: \"address\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"exactSyIn\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"minPtOut\",\n        type: \"uint256\",\n      },\n      {\n        components: [\n          {\n            internalType: \"uint256\",\n            name: \"guessMin\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"guessMax\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"guessOffchain\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"maxIteration\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"eps\",\n            type: \"uint256\",\n          },\n        ],\n        internalType: \"struct ApproxParams\",\n        name: \"guessPtOut\",\n        type: \"tuple\",\n      },\n    ],\n    name: \"swapExactSyForPt\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"netPtOut\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"netSyFee\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"receiver\",\n        type: \"address\",\n      },\n      {\n        internalType: \"address\",\n        name: \"market\",\n        type: \"address\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"minPtOut\",\n        type: \"uint256\",\n      },\n      {\n        components: [\n          {\n            internalType: \"uint256\",\n            name: \"guessMin\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"guessMax\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"guessOffchain\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"maxIteration\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"eps\",\n            type: \"uint256\",\n          },\n        ],\n        internalType: \"struct ApproxParams\",\n        name: \"guessPtOut\",\n        type: \"tuple\",\n      },\n      {\n        components: [\n          {\n            internalType: \"address\",\n            name: \"tokenIn\",\n            type: \"address\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"netTokenIn\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"address\",\n            name: \"tokenMintSy\",\n            type: \"address\",\n          },\n          {\n            internalType: \"address\",\n            name: \"bulk\",\n            type: \"address\",\n          },\n          {\n            internalType: \"address\",\n            name: \"pendleSwap\",\n            type: \"address\",\n          },\n          {\n            components: [\n              {\n                internalType: \"enum SwapType\",\n                name: \"swapType\",\n                type: \"uint8\",\n              },\n              {\n                internalType: \"address\",\n                name: \"extRouter\",\n                type: \"address\",\n              },\n              {\n                internalType: \"bytes\",\n                name: \"extCalldata\",\n                type: \"bytes\",\n              },\n              {\n                internalType: \"bool\",\n                name: \"needScale\",\n                type: \"bool\",\n              },\n            ],\n            internalType: \"struct SwapData\",\n            name: \"swapData\",\n            type: \"tuple\",\n          },\n        ],\n        internalType: \"struct TokenInput\",\n        name: \"input\",\n        type: \"tuple\",\n      },\n    ],\n    name: \"swapExactTokenForPt\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"netPtOut\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"netSyFee\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"payable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"receiver\",\n        type: \"address\",\n      },\n      {\n        internalType: \"address\",\n        name: \"market\",\n        type: \"address\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"exactPtIn\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"minSyOut\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"swapExactPtForSy\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"netSyOut\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"netSyFee\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"receiver\",\n        type: \"address\",\n      },\n      {\n        internalType: \"address\",\n        name: \"market\",\n        type: \"address\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"exactPtIn\",\n        type: \"uint256\",\n      },\n      {\n        components: [\n          {\n            internalType: \"address\",\n            name: \"tokenOut\",\n            type: \"address\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"minTokenOut\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"address\",\n            name: \"tokenRedeemSy\",\n            type: \"address\",\n          },\n          {\n            internalType: \"address\",\n            name: \"bulk\",\n            type: \"address\",\n          },\n          {\n            internalType: \"address\",\n            name: \"pendleSwap\",\n            type: \"address\",\n          },\n          {\n            components: [\n              {\n                internalType: \"enum SwapType\",\n                name: \"swapType\",\n                type: \"uint8\",\n              },\n              {\n                internalType: \"address\",\n                name: \"extRouter\",\n                type: \"address\",\n              },\n              {\n                internalType: \"bytes\",\n                name: \"extCalldata\",\n                type: \"bytes\",\n              },\n              {\n                internalType: \"bool\",\n                name: \"needScale\",\n                type: \"bool\",\n              },\n            ],\n            internalType: \"struct SwapData\",\n            name: \"swapData\",\n            type: \"tuple\",\n          },\n        ],\n        internalType: \"struct TokenOutput\",\n        name: \"output\",\n        type: \"tuple\",\n      },\n    ],\n    name: \"swapExactPtForToken\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"netTokenOut\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"netSyFee\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"receiver\",\n        type: \"address\",\n      },\n      {\n        internalType: \"address\",\n        name: \"market\",\n        type: \"address\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"exactYtIn\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"minSyOut\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"swapExactYtForSy\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"netSyOut\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"netSyFee\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"receiver\",\n        type: \"address\",\n      },\n      {\n        internalType: \"address\",\n        name: \"market\",\n        type: \"address\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"netYtIn\",\n        type: \"uint256\",\n      },\n      {\n        components: [\n          {\n            internalType: \"address\",\n            name: \"tokenOut\",\n            type: \"address\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"minTokenOut\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"address\",\n            name: \"tokenRedeemSy\",\n            type: \"address\",\n          },\n          {\n            internalType: \"address\",\n            name: \"bulk\",\n            type: \"address\",\n          },\n          {\n            internalType: \"address\",\n            name: \"pendleSwap\",\n            type: \"address\",\n          },\n          {\n            components: [\n              {\n                internalType: \"enum SwapType\",\n                name: \"swapType\",\n                type: \"uint8\",\n              },\n              {\n                internalType: \"address\",\n                name: \"extRouter\",\n                type: \"address\",\n              },\n              {\n                internalType: \"bytes\",\n                name: \"extCalldata\",\n                type: \"bytes\",\n              },\n              {\n                internalType: \"bool\",\n                name: \"needScale\",\n                type: \"bool\",\n              },\n            ],\n            internalType: \"struct SwapData\",\n            name: \"swapData\",\n            type: \"tuple\",\n          },\n        ],\n        internalType: \"struct TokenOutput\",\n        name: \"output\",\n        type: \"tuple\",\n      },\n    ],\n    name: \"swapExactYtForToken\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"netTokenOut\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"netSyFee\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n];\nconst {\n  routerAddress,\n  swapping,\n  account,\n  tradeInfo,\n  market,\n  inputCurrency,\n  outputCurrency,\n  inputCurrencyAmount,\n  onSuccess,\n  onError,\n} = props;\n\nif (!swapping || !tradeInfo) return;\n\nconst handleSwap = () => {\n  const RouterContract = new ethers.Contract(\n    routerAddress,\n    ROUTER_ABI,\n    Ethers.provider().getSigner()\n  );\n\n  if (inputCurrency.address === \"native\")\n    inputCurrency.address = \"0x0000000000000000000000000000000000000000\";\n\n  const amount = ethers.utils.parseUnits(\n    inputCurrencyAmount,\n    inputCurrency.decimals\n  );\n  console.log(\"amount\", amount, tradeInfo.netOut);\n  const minOutputAmount = Big(\n    ethers.utils.parseUnits(tradeInfo.netOut, outputCurrency.decimals)\n  )\n    .mul(1 - 1 * 0.005)\n    .toFixed(0);\n\n  const getMethod = () => {\n    if (inputCurrency.baseType === \"PT\") {\n      return outputCurrency.baseType === \"YT\"\n        ? \"swapExactPtForYt\"\n        : outputCurrency.baseType === \"SY\"\n        ? \"swapExactPtForSy\"\n        : \"swapExactPtForToken\";\n    }\n    if (outputCurrency.baseType === \"PT\") {\n      return inputCurrency.baseType === \"YT\"\n        ? \"swapExactYtForPt\"\n        : inputCurrency.baseType === \"SY\"\n        ? \"swapExactSyForPt\"\n        : \"swapExactTokenForPt\";\n    }\n    if (inputCurrency.baseType === \"YT\") {\n      return inputCurrency.baseType === \"PT\"\n        ? \"swapExactYtForPt\"\n        : inputCurrency.baseType === \"SY\"\n        ? \"swapExactYtForSy\"\n        : \"swapExactYtForToken\";\n    }\n    if (outputCurrency.baseType === \"YT\") {\n      return inputCurrency.baseType === \"PT\"\n        ? \"swapExactPtForYt\"\n        : inputCurrency.baseType === \"SY\"\n        ? \"swapExactSyForYt\"\n        : \"swapExactTokenForYt\";\n    }\n  };\n  const method = getMethod();\n  console.log(\"method\", method);\n  const calcMaxIteration = () => {\n    const x = Big(6 * 0.005).div(\"10000000000000000000000\");\n    if (!x.gt(1)) return 3;\n    return Math.ceil(Math.log2(x)) + 3;\n  };\n  const getPullApproxParams = ({ minOut, decimals }) => {\n    return [\n      Big(ethers.utils.parseUnits(minOut, decimals))\n        .mul(1 - 1 * 0.005)\n        .toFixed(0),\n      Big(ethers.utils.parseUnits(minOut, decimals))\n        .mul(1 - 5 * 0.005)\n        .toFixed(0),\n      Big(ethers.utils.parseUnits(minOut, decimals)).toFixed(0),\n      calcMaxIteration(),\n      \"100000000000000\",\n    ];\n  };\n  const getPushApproxParams = ({ minOut, decimals }) => {\n    return [\n      Big(ethers.utils.parseUnits(minOut, decimals))\n        .mul(1 + 5 * 0.005)\n        .toFixed(0),\n      Big(ethers.utils.parseUnits(minOut, decimals))\n        .mul(1 + 1 * 0.005)\n        .toFixed(0),\n      Big(ethers.utils.parseUnits(minOut, decimals)).toFixed(0),\n      calcMaxIteration(),\n      \"100000000000000\",\n    ];\n  };\n\n  const getParams = (inputData) => {\n    switch (method) {\n      case \"swapExactYtForPt\": // 1\n        return [\n          account,\n          market.address,\n          amount,\n          minOutputAmount,\n          getPushApproxParams({\n            minOut: tradeInfo.totalSwapped,\n            decimals: inputCurrency.decimals,\n          }),\n        ];\n      case \"swapExactSyForPt\": // 1\n      case \"swapExactSyForYt\": // 1\n        return [\n          account,\n          market.address,\n          amount,\n          minOutputAmount,\n          getPullApproxParams({\n            minOut: tradeInfo.netOut,\n            decimals: outputCurrency.decimals,\n          }),\n        ];\n      case \"swapExactPtForYt\": // 1\n        return [\n          account,\n          market.address,\n          amount,\n          minOutputAmount,\n          getPushApproxParams({\n            minOut: tradeInfo.totalSwapped,\n            decimals: inputCurrency.decimals,\n          }),\n        ];\n      case \"swapExactYtForSy\": // 1\n      case \"swapExactPtForSy\": // 1\n        return [account, market.address, amount, minOutputAmount];\n      case \"swapExactTokenForPt\": // 1\n      case \"swapExactTokenForYt\": // 1\n        return [\n          account,\n          market.address,\n          minOutputAmount,\n          getPullApproxParams({\n            minOut: tradeInfo.netOut,\n            decimals: outputCurrency.decimals,\n          }),\n          inputData,\n        ];\n      case \"swapExactPtForToken\": // 1\n      case \"swapExactYtForToken\": // 1\n        return [account, market.address, amount, inputData];\n      default:\n        return [];\n    }\n  };\n  if (\n    ![\n      \"swapExactTokenForPt\",\n      \"swapExactTokenForYt\",\n      \"swapExactPtForToken\",\n      \"swapExactYtForToken\",\n    ].includes(method)\n  ) {\n    console.log(\"simpleParams\", getParams());\n    RouterContract[method](...getParams(), { gasLimit: 5000000 })\n      .then((tx) => {\n        onSuccess(tx);\n      })\n      .catch((err) => {\n        console.log(\"error\", err);\n        onError(err);\n      });\n    return;\n  }\n  let inputData = [];\n  if ([\"swapExactTokenForPt\", \"swapExactTokenForYt\"].includes(method)) {\n    inputData = [\n      inputCurrency.address,\n      Big(\n        ethers.utils.parseUnits(inputCurrencyAmount, inputCurrency.decimals)\n      ).toFixed(),\n      inputCurrency.address,\n      \"0x0000000000000000000000000000000000000000\",\n      \"0x38812c3ac3563bf200482ac9d096952d7cb55f9b\",\n      [0, \"0x0000000000000000000000000000000000000000\", \"0x00\", false],\n    ];\n  }\n  if ([\"swapExactPtForToken\", \"swapExactYtForToken\"].includes(method)) {\n    inputData = [\n      outputCurrency.address,\n      minOutputAmount,\n      outputCurrency.address,\n      \"0x0000000000000000000000000000000000000000\",\n      \"0x38812c3ac3563bf200482ac9d096952d7cb55f9b\",\n      [0, \"0x0000000000000000000000000000000000000000\", \"0x00\", false],\n    ];\n  }\n  console.log(\"token params\", getParams(inputData));\n  const itf = new ethers.utils.Interface(ROUTER_ABI);\n  const encodeData = itf.encodeFunctionData(method, getParams(inputData));\n\n  RouterContract[method](...getParams(inputData), {\n    gasLimit: 5000000,\n    value:\n      inputCurrency.address === \"0x0000000000000000000000000000000000000000\"\n        ? amount\n        : 0,\n  })\n    .then((tx) => {\n      onSuccess(tx);\n    })\n    .catch((err) => {\n      onError(err);\n    });\n};\n\nif (swapping === state.swapping) {\n  return;\n} else {\n  State.update({\n    swapping,\n  });\n  handleSwap();\n}\n\nreturn \"\";\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/bluebiu.near/widget/Arbitrum.Pendle.TradeSwapAction", "fact_widget_deployments_id": "799d1d28c6561a8bf574b53c51cf56fa", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 2}