{"tx_hash": "25zKpMjbfjv7uyZNfoFwnciWYmgV7tuNPU2cj1nbFmCU", "action_id_social": "BKQxck9WMSGUsp3P3mZcS4YVSdsGkbhD4jWH53xPrZYg-0-widget", "block_id": 115902838, "block_timestamp": "2024-04-01T07:08:41.156Z", "signer_id": "bluebiu.near", "widget_name": "Liquidity.Bridge.STEAKHUT.Detail", "source_code": "\nconst {\n  // defaultPair,\n  // pair,\n  data,\n  toast,\n  prices,\n  refetch,\n  addresses,\n  proxyAddress,\n  addAction,\n  userPositions,\n  ICON_VAULT_MAP\n} = props;\n\nconst {\n  StyledFont,\n  StyledFlex\n} = VM.require('bluebiu.near/widget/Liquidity.Handler.Styles')\nconst Row = styled.div`\n  display: flex;\n  flex-direction: row;\n  &.price-input {\n    width: 500px;\n    margin: 0 auto 20px;\n    align-items: center;\n    justify-content: center;\n    gap: 14px;\n  }\n`\nconst Column = styled.div`\n  display: flex;\n  flex-direction: column;\n  flex: 1;\n`\nconst Wrapper = styled.div`\n  \n`\nconst FilterButtonList = styled.div`\n  margin-bottom: 20px;\n  width: 100%;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  border-top: 1px solid #373A53;\n  border-bottom: 1px solid #373A53;\n`\nconst FilterButton = styled.div`\n  cursor: pointer;\n  position: relative;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: 250px;\n  height: 48px;\n  border-left: 1px solid #373A53;\n  border-right: 1px solid #373A53;\n  color: #979ABE;\n  font-family: Gantari;\n  font-size: 16px;\n  font-style: normal;\n  font-weight: 400;\n  &:first-of-type {\n    border-right: none;\n  }\n  &.isActive {\n    color: #FFF;\n    &:after {\n      content: \"\";\n      position: absolute;\n      left: 0;\n      width: 100%;\n      bottom: -2px;\n      height: 5px;\n      flex-shrink: 0;\n      background: #1362E4;\n    }\n  }\n`\nconst InputWrapList = styled.div`\n  margin-bottom: 20px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n`\n\nconst Input = styled.input`\n  border: none;\n  outline: none;\n  background: transparent;\n  margin: 0;\n  width: 100%;\n  height: 100%;\n  color: #FFF;\n  font-family: Gantari;\n  font-size: 13px;\n  font-style: normal;\n  font-weight: 400;\n  padding: 0 80px 0 10px;\n`\nconst InputSuffix = styled.div`\n  position: absolute;\n  top: 13px;\n  right: 12px;\n  display: flex;\n  align-items: center;\n  gap: 6px;\n  span {\n    color: #FFF;\n    text-align: right;\n    font-family: Gantari;\n    font-size: 14px;\n    font-style: normal;\n    font-weight: 500;\n    line-height: normal;\n  }\n  img {\n    width: 20px;\n    border-radius: 50%;\n  }\n\n`\nconst InputWrap = styled.div`\n  position: relative;\n  /* width: 243px; */\n  height: 46px;\n  /* flex-shrink: 0;\n  fill: #1B1E27;\n  stroke-width: 1px;\n  stroke: #33364B; */\n  background: #33364B;\n  border-radius: 12px;\n  border: 1px solid #33364B;\n  input::-webkit-inner-spin-button {\n    -webkit-appearance: none !important;\n  }\n  \n  input::-webkit-outer-spin-button{\n    -webkit-appearance: none !important;\n  }\n  input[type=\"number\"]{\n    -moz-appearance: textfield;\n  }\n  &.inSufficient {\n    border-color: #FF547D;\n  }\n\n`\nconst StyledImageList = styled.div`\n  display: flex;\n  align-items: center;\n  \n`\nconst PriceWrap = styled.div`\n  margin-top: 6px;\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n`\nconst TotalPrice = styled.span`\n  color: #979ABE;\n  font-family: Gantari;\n  font-size: 12px;\n  opacity: 0.3;\n`\nconst BalancePrice = styled.div`\n  display: flex;\n  align-items: center;\n  gap: 4px;\n  color: #979ABE;\n  text-align: right;\n  font-family: Gantari;\n  font-size: 12px;\n  font-style: normal;\n  font-weight: 400;\n  line-height: normal;\n  span {\n    color: #FFF;\n    text-decoration-line: underline;\n    cursor: pointer;\n  }\n`\n\nconst StyledButtonList = styled.div`\n  width: 500px;\n  margin: 0 auto 20px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  gap: 14px;\n`\nconst StyledButton = styled.button`\n  outline: none;\n  border: none;\n  flex: 1;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  height: 46px;\n  border-radius: 8px;\n  /* background: #FFF; */\n  /* color: #1E2028; */\n  background-color: var(--button-color);\n  color: var(--button-text-color);\n  font-family: Gantari;\n  font-size: 16px;\n  font-weight: 500;\n  &[disabled] {\n    opacity: 0.5;\n    cursor: not-allowed;\n  }\n`\n\nconst StyledLoading = styled.div`\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  animation: rotate 1.5s linear  infinite;\n  @keyframes rotate {\n    0% {\n      transform: rotate(0deg);\n    }\n    100% {\n      transform: rotate(360deg);\n    }\n  }\n`\n\nconst iconCircle = (\n  <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" fill=\"none\">\n    <path d=\"M8 15C11.866 15 15 11.866 15 8C15 4.13401 11.866 1 8 1C4.13401 1 1 4.13401 1 8\" stroke=\"#1E2028\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" />\n  </svg>\n\n)\nconst defaultDeposit = props.tab === \"deposit\" || !props.tab;\n\n// const curPositionUSD = userPositions[data.vaultAddress]?.balanceUSD;\n\nState.init({\n  isDeposit: defaultDeposit,\n  lpBalance: \"\",\n  balances: [],\n  amount0: \"\",\n  amount1: \"\",\n  lpAmount: \"\",\n  isError: false,\n  isLoading: false,\n  isToken0Approved: true,\n  isToken1Approved: true,\n  isToken0Approving: false,\n  isToken1Approving: false,\n  loadingMsg: \"\",\n  isPostTx: false,\n  showPairs: false,\n});\n\nconst getFromDepositAmount = (depositAmount, tokenDecimal) => {\n  let a = new Big(depositAmount[0].toString());\n  let b = new Big(depositAmount[1].toString());\n\n  if (a.eq(0) && b.eq(0)) return \"0\";\n\n  let diff;\n  let midpoint;\n  if (a.gt(b)) {\n    diff = a.minus(b);\n    midpoint = diff.div(new Big(2)).plus(b);\n  } else {\n    diff = b.minus(a);\n    midpoint = diff.div(new Big(2)).plus(a);\n  }\n\n  for (let i = tokenDecimal; i > 0; i--) {\n    const midpointFixed = midpoint\n      .div(new Big(10).pow(tokenDecimal))\n      .toFixed(i);\n    if (\n      a.div(Big(10).pow(tokenDecimal)).lte(midpointFixed) &&\n      b.div(Big(10).pow(tokenDecimal)).gte(midpointFixed)\n    ) {\n      return midpointFixed;\n    }\n  }\n\n  return \"0\";\n};\n\nconst sender = Ethers.send(\"eth_requestAccounts\", [])[0];\nconst { token0, token1, decimals0, decimals1, id, poolAddress } = data || defaultPair;\n\nconst hypeAddress = poolAddress;\n\nconst updateLPBalance = () => {\n  const abi = [\"function balanceOf(address) view returns (uint256)\"];\n  const contract = new ethers.Contract(\n    ethers.utils.getAddress(poolAddress),\n    abi,\n    Ethers.provider()\n  );\n  contract.balanceOf(sender).then((balanceBig) => {\n    const adjustedBalance = ethers.utils.formatUnits(balanceBig, 18);\n    State.update({\n      lpBalance: adjustedBalance,\n    });\n  });\n};\nconst updateBalance = (token) => {\n  const { address, decimals, symbol } = token;\n  if (symbol === \"ETH\") {\n    Ethers.provider()\n      .getBalance(sender)\n      .then((balanceBig) => {\n        const adjustedBalance = ethers.utils.formatEther(balanceBig);\n        State.update({\n          balances: {\n            ...state.balances,\n            [symbol]: adjustedBalance,\n          },\n        });\n      });\n  } else {\n    const erc20Abi = [\"function balanceOf(address) view returns (uint256)\"];\n    const tokenContract = new ethers.Contract(\n      address,\n      erc20Abi,\n      Ethers.provider()\n    );\n    tokenContract.balanceOf(sender).then((balanceBig) => {\n      const adjustedBalance = Big(\n        ethers.utils.formatUnits(balanceBig, decimals)\n      ).toString();\n      State.update({\n        balances: {\n          ...state.balances,\n          [symbol]: adjustedBalance,\n        },\n      });\n    });\n  }\n};\n\nconst {\n  isDeposit,\n  balances,\n  amount0,\n  amount1,\n  isLoading,\n  isError,\n  isToken0Approved,\n  isToken1Approved,\n  isToken0Approving,\n  isToken1Approving,\n  loadingMsg,\n  lpBalance,\n  lpAmount,\n  isPostTx,\n} = state;\n\nconst handleCheckApproval = (symbol, amount, decimals) => {\n  const wei = ethers.utils.parseUnits(\n    Big(amount).toFixed(decimals),\n    decimals\n  );\n  const abi = [\n    \"function allowance(address, address) external view returns (uint256)\",\n  ];\n\n  const contract = new ethers.Contract(\n    addresses[symbol],\n    abi,\n    Ethers.provider()\n  );\n\n  contract\n    .allowance(sender, hypeAddress)\n    .then((allowance) => {\n      State.update({\n        [symbol === token0 ? 'isToken0Approved' : 'isToken1Approved']: !new Big(allowance.toString()).lt(wei),\n      });\n    })\n    .catch((e) => console.log(e));\n}\nconst checkApproval = (amount, otherAmount, symbol) => {\n  const otherSymbol = symbol === token0 ? token1 : token0\n  const decimals = symbol === token0 ? decimals0 : decimals1\n  const otherDecimals = symbol === token0 ? decimals1 : decimals0\n\n  handleCheckApproval(symbol, amount, decimals)\n  handleCheckApproval(otherSymbol, otherAmount, otherDecimals)\n};\nconst changeMode = (isDeposit) => {\n  State.update({ isDeposit });\n};\n\nconst handleMax = (isToken0) => {\n  if (isToken0) handleTokenChange(balances[token0], token0);\n  else handleToken1Change(balances[token1], token1);\n};\n\nconst handleTokenChange = (amount, symbol) => {\n  State.update({\n    [symbol === token0 ? 'amount0' : 'amount1']: amount\n  })\n  if (Number(amount) === 0) {\n    State.update({\n      [symbol === token0 ? 'amount1' : 'amount0']: \"\",\n      isToken0Approved: true,\n      isToken1Approved: true\n    })\n    return;\n  }\n  State.update({\n    isLoading: true,\n    isError: false,\n    loadingMsg: \"Computing deposit amount...\"\n  })\n\n  const decimals = (symbol === token0 ? decimals0 : decimals1)\n  const otherDecimals = symbol === token0 ? decimals1 : decimals0\n\n  const amountXDesired = symbol === token0 ? Big(amount)\n    .mul(Big(10).pow(decimals))\n    .toFixed(0) : '1157920892373161954235709850086879078532699846656405'\n  const amountYDesired = symbol === token1 ? Big(amount)\n    .mul(Big(10).pow(decimals))\n    .toFixed(0) : '1157920892373161954235709850086879078532699846656405'\n  const abi = [{\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amountXDesired\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amountYDesired\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"calcSharesAndAmounts\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"shares\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amountX\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amountY\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  }];\n  const contract = new ethers.Contract(\n    ethers.utils.getAddress(poolAddress),\n    abi,\n    Ethers.provider()\n  );\n  contract\n    .calcSharesAndAmounts(amountXDesired, amountYDesired)\n    .then((response) => {\n      const amountX = ethers.utils.formatUnits(response[1], otherDecimals)\n      const amountY = ethers.utils.formatUnits(response[2], otherDecimals)\n      const otherAmount = symbol === token0 ? amountY : amountX // getFromDepositAmount(depositAmount, otherDecimals);\n      State.update({\n        [symbol === token0 ? 'amount1' : 'amount0']: otherAmount\n      })\n      State.update({\n        isLoading: false,\n        [symbol === token0 ? 'amount1' : 'amount0']: otherAmount\n      })\n      checkApproval(amount, otherAmount, symbol);\n    })\n    .catch((e) => {\n      State.update({\n        isLoading: true,\n        isError: true,\n        loadingMsg: \"Something went wrong. Please try again.\"\n      })\n      State.update({\n        [symbol === token0 ? 'amount1' : 'amount0']: 0\n      })\n    });\n};\nconst handleGetUnderlyingAssets = (amount) => {\n  const abi = [\n    {\n      \"inputs\": [\n        {\n          \"internalType\": \"uint256\",\n          \"name\": \"_shares\",\n          \"type\": \"uint256\"\n        }\n      ],\n      \"name\": \"getUnderlyingAssets\",\n      \"outputs\": [\n        {\n          \"internalType\": \"uint256\",\n          \"name\": \"totalX\",\n          \"type\": \"uint256\"\n        },\n        {\n          \"internalType\": \"uint256\",\n          \"name\": \"totalY\",\n          \"type\": \"uint256\"\n        }\n      ],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    }\n  ];\n\n  try {\n    const contract = new ethers.Contract(\n      ethers.utils.getAddress(poolAddress),\n      abi,\n      Ethers.provider().getSigner()\n    );\n    contract\n      .getUnderlyingAssets(Big(amount)\n        .mul(Big(10).pow(18))\n        .toFixed(0))\n      .then(result => {\n        const amountX = Number(ethers.utils.formatUnits(result[0], decimals0)).toFixed(5)\n        const amountY = Number(ethers.utils.formatUnits(result[1], decimals1)).toFixed(5)\n        State.update({\n          amountX,\n          amountY\n        })\n      })\n  } catch (error) {\n    console.log(error)\n  }\n\n}\nconst handleLPChange = (amount) => {\n  handleGetUnderlyingAssets(Number(amount))\n  State.update({\n    lpAmount: amount,\n  });\n};\n\nconst handleApprove = (isToken0) => {\n  const _token = isToken0 ? token0 : token1;\n  const payload = isToken0\n    ? { isToken0Approving: true }\n    : { isToken1Approving: true };\n\n  const amount = isToken0\n    ? Big(amount0).toFixed(decimals0)\n    : Big(amount1).toFixed(decimals1);\n\n  const toastId = toast?.loading({\n    title: `Approve ${amount} ${_token}`,\n  });\n\n  State.update({\n    ...payload,\n    isLoading: true,\n    loadingMsg: `Approving ${_token}...`,\n  });\n\n  const tokenWei = ethers.utils.parseUnits(\n    amount,\n    isToken0 ? decimals0 : decimals1\n  );\n\n  const abi = [\"function approve(address, uint) public\"];\n\n  const tokenContract = new ethers.Contract(\n    addresses[_token],\n    abi,\n    Ethers.provider().getSigner()\n  );\n\n  tokenContract\n    .approve(hypeAddress, tokenWei)\n    .then((tx) => tx.wait())\n    .then((receipt) => {\n      const payload = isToken0\n        ? { isToken0Approved: true, isToken0Approving: false }\n        : { isToken1Approved: true, isToken1Approving: false };\n\n      State.update({ ...payload, isLoading: false, loadingMsg: \"\" });\n      toast?.dismiss(toastId);\n      toast?.success({\n        title: \"Approve Successfully!\",\n        text: `Approve ${amount} ${_token}`,\n        tx: receipt.transactionHash,\n        chainId: props.chainId,\n      });\n    })\n    .catch((error) => {\n      State.update({\n        isError: true,\n        isLoading: false,\n        loadingMsg: error,\n        isToken0Approving: false,\n        isToken1Approving: false,\n      });\n      toast?.dismiss(toastId);\n      toast?.fail({\n        title: \"Approve Failed!\",\n        text: error?.message?.includes(\"user rejected transaction\")\n          ? \"User rejected transaction\"\n          : `Approve ${amount} ${_token}`,\n      });\n    });\n};\nconst handleDeposit = () => {\n  const toastId = toast?.loading({\n    title: `Depositing...`,\n  });\n  State.update({\n    isLoading: true,\n    isError: false,\n    loadingMsg: \"Depositing...\",\n  });\n\n  const amountX = Big(amount0)\n    .mul(Big(10).pow(decimals0))\n    .toFixed(0);\n  const amountY = Big(amount1)\n    .mul(Big(10).pow(decimals1))\n    .toFixed(0);\n\n  const abi = [\n    {\n      \"inputs\": [\n        {\n          \"internalType\": \"uint256\",\n          \"name\": \"amountX\",\n          \"type\": \"uint256\"\n        },\n        {\n          \"internalType\": \"uint256\",\n          \"name\": \"amountY\",\n          \"type\": \"uint256\"\n        },\n        {\n          \"internalType\": \"uint256\",\n          \"name\": \"amountXMin\",\n          \"type\": \"uint256\"\n        },\n        {\n          \"internalType\": \"uint256\",\n          \"name\": \"amountYMin\",\n          \"type\": \"uint256\"\n        }\n      ],\n      \"name\": \"depositAVAXPair\",\n      \"outputs\": [\n        {\n          \"internalType\": \"uint256\",\n          \"name\": \"shares\",\n          \"type\": \"uint256\"\n        },\n        {\n          \"internalType\": \"uint256\",\n          \"name\": \"amountXActual\",\n          \"type\": \"uint256\"\n        },\n        {\n          \"internalType\": \"uint256\",\n          \"name\": \"amountYActual\",\n          \"type\": \"uint256\"\n        }\n      ],\n      \"stateMutability\": \"payable\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        {\n          \"internalType\": \"uint256\",\n          \"name\": \"amountX\",\n          \"type\": \"uint256\"\n        },\n        {\n          \"internalType\": \"uint256\",\n          \"name\": \"amountY\",\n          \"type\": \"uint256\"\n        },\n        {\n          \"internalType\": \"uint256\",\n          \"name\": \"amountXMin\",\n          \"type\": \"uint256\"\n        },\n        {\n          \"internalType\": \"uint256\",\n          \"name\": \"amountYMin\",\n          \"type\": \"uint256\"\n        }\n      ],\n      \"name\": \"deposit\",\n      \"outputs\": [\n        {\n          \"internalType\": \"uint256\",\n          \"name\": \"shares\",\n          \"type\": \"uint256\"\n        },\n        {\n          \"internalType\": \"uint256\",\n          \"name\": \"amountXActual\",\n          \"type\": \"uint256\"\n        },\n        {\n          \"internalType\": \"uint256\",\n          \"name\": \"amountYActual\",\n          \"type\": \"uint256\"\n        }\n      ],\n      \"stateMutability\": \"nonpayable\",\n      \"type\": \"function\"\n    }\n  ];\n\n  const contract = new ethers.Contract(\n    ethers.utils.getAddress(poolAddress),\n    abi,\n    Ethers.provider().getSigner()\n  );\n  contract\n    .depositAVAXPair(amountX, amountY, 0, 0, {\n      value: amountX\n    })\n    .then((tx) => {\n      return tx.wait();\n    })\n    .then((receipt) => {\n      const { status, transactionHash } = receipt;\n      addAction?.({\n        type: \"Liquidity\",\n        action: \"Deposit\",\n        token0,\n        token1,\n        amount: amount0,\n        template: \"SteakHut\",\n        status: status,\n        transactionHash,\n        chain_id: props.chainId,\n      });\n\n      State.update({\n        isLoading: false,\n        isPostTx: true,\n      });\n\n      setTimeout(() => State.update({ isPostTx: false }), 10_000);\n\n      if (refetch) refetch();\n\n      toast?.dismiss(toastId);\n      toast?.success({\n        title: \"Deposit Successfully!\",\n      });\n    })\n    .catch((error) => {\n      State.update({\n        isError: true,\n        isLoading: false,\n        loadingMsg: error,\n      });\n      toast?.dismiss(toastId);\n      toast?.fail({\n        title: \"Deposit Failed!\",\n        text: error?.message?.includes(\"user rejected transaction\")\n          ? \"User rejected transaction\"\n          : \"\",\n      });\n    });\n};\n\nconst handleWithdraw = () => {\n  const toastId = toast?.loading({\n    title: `Withdrawing...`,\n  });\n  State.update({\n    isLoading: true,\n    isError: false,\n    loadingMsg: \"Withdrawing...\",\n  });\n\n  const amount = ethers.utils.parseUnits(Big(lpAmount).toFixed(18), 18);\n  const abi = [\n    {\n      \"inputs\": [\n        {\n          \"internalType\": \"uint256\",\n          \"name\": \"_shares\",\n          \"type\": \"uint256\"\n        }\n      ],\n      \"name\": \"withdrawAVAXPair\",\n      \"outputs\": [\n        {\n          \"internalType\": \"uint256\",\n          \"name\": \"amountX\",\n          \"type\": \"uint256\"\n        },\n        {\n          \"internalType\": \"uint256\",\n          \"name\": \"amountY\",\n          \"type\": \"uint256\"\n        }\n      ],\n      \"stateMutability\": \"nonpayable\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        {\n          \"internalType\": \"uint256\",\n          \"name\": \"_shares\",\n          \"type\": \"uint256\"\n        }\n      ],\n      \"name\": \"withdraw\",\n      \"outputs\": [\n        {\n          \"internalType\": \"uint256\",\n          \"name\": \"amountX\",\n          \"type\": \"uint256\"\n        },\n        {\n          \"internalType\": \"uint256\",\n          \"name\": \"amountY\",\n          \"type\": \"uint256\"\n        }\n      ],\n      \"stateMutability\": \"nonpayable\",\n      \"type\": \"function\"\n    }\n  ];\n\n  const contract = new ethers.Contract(\n    hypeAddress,\n    abi,\n    Ethers.provider().getSigner()\n  );\n\n  contract\n    .withdrawAVAXPair(amount)\n    .then((tx) => {\n      return tx.wait();\n    })\n    .then((receipt) => {\n      State.update({\n        isLoading: false,\n        isPostTx: true,\n      });\n\n      const { status, transactionHash } = receipt;\n\n      addAction?.({\n        type: \"Liquidity\",\n        action: \"Withdraw\",\n        token0,\n        token1,\n        amount: lpAmount,\n        template: \"SteakHut\",\n        status: status,\n        transactionHash,\n        chain_id: state.chainId,\n      });\n\n      setTimeout(() => State.update({ isPostTx: false }), 10_000);\n\n      if (refetch) refetch();\n\n      toast?.dismiss(toastId);\n      toast?.success({\n        title: \"Withdraw Successfully!\",\n      });\n    })\n    .catch((error) => {\n      State.update({\n        isError: true,\n        isLoading: false,\n        loadingMsg: error,\n      });\n      toast?.dismiss(toastId);\n      toast?.fail({\n        title: \"Withdraw Failed!\",\n        text: error?.message?.includes(\"user rejected transaction\")\n          ? \"User rejected transaction\"\n          : \"\",\n      });\n    });\n};\n\nconst tokensPrice = prices;\nconst curPositionUSD = tokensPrice['USDC']\n\nconst isInSufficient =\n  Number(amount0) > Number(balances[token0]) ||\n  Number(amount1) > Number(balances[token1]);\n\nconst isWithdrawInsufficient = Number(lpAmount) > Number(lpBalance);\n\nconst balance0 =\n  !amount0 || !tokensPrice?.[token0]\n    ? \"-\"\n    : parseFloat(Big(amount0).times(tokensPrice[token0]).toFixed(4));\n\nconst balance1 =\n  !amount1 || !tokensPrice?.[token1]\n    ? \"-\"\n    : parseFloat(Big(amount1).times(tokensPrice[token1]).toFixed(4));\n\n\nconst balanceLp =\n  !lpAmount || !lpBalance || !curPositionUSD\n    ? \"-\"\n    : parseFloat(\n      Big(lpAmount)\n        .div(Big(lpBalance).gt(0) ? lpBalance : 1)\n        .times(curPositionUSD)\n        .toFixed(4)\n    );\n\nconst onUpdateLpPercent = (percent) => {\n  State.update({\n    lpPercent: percent,\n  });\n};\n\nconst onChangeSlider = (percent) => {\n  console.log(\"percent: \", percent);\n  const newLpValue = Big(percent)\n    .div(100)\n    .times(lpBalance || 0)\n    .toFixed(6);\n\n  handleLPChange(newLpValue);\n};\n\nuseEffect(() => {\n  if (!sender || !token0 || !token1) return;\n  [\n    { symbol: token0, address: addresses[token0], decimals: decimals0 },\n    { symbol: token1, address: addresses[token1], decimals: decimals1 },\n  ].map(updateBalance);\n\n  updateLPBalance();\n}, [sender, token0, token1]);\n\nuseEffect(() => {\n  if (amount0) {\n    handleTokenChange(amount0, token0);\n  }\n}, [data]);\n\nreturn (\n  <Wrapper>\n    <FilterButtonList>\n      <FilterButton className={isDeposit ? 'isActive' : ''} onClick={() => changeMode(true)}>Deposit</FilterButton>\n      <FilterButton className={!isDeposit ? 'isActive' : ''} onClick={() => changeMode(false)}>Withdraw</FilterButton>\n    </FilterButtonList>\n    {\n      isDeposit ? <>\n        <Row className=\"price-input\">\n          <Column>\n            <InputWrap className={Number(amount0) > Number(balances[token0]) ? \"inSufficient\" : \"\"}>\n              <Input value={amount0} type=\"number\" onChange={(e) => handleTokenChange(e.target.value, token0)} />\n              <InputSuffix>\n                <img src={ICON_VAULT_MAP[token0]} alt={token0} />\n                <span>{token0}</span>\n              </InputSuffix>\n            </InputWrap>\n            <PriceWrap>\n              <TotalPrice>${balance0}</TotalPrice>\n              <BalancePrice>Balance:<span>{Big(balances[token0] ?? 0).toFixed(6)}</span> {token0}</BalancePrice>\n            </PriceWrap>\n          </Column>\n          <Column>\n            <InputWrap className={Number(amount1) > Number(balances[token1]) ? \"inSufficient\" : \"\"}>\n              <Input value={amount1} type=\"number\" onChange={(e) => handleTokenChange(e.target.value, token1)} />\n              <InputSuffix>\n                <img src={ICON_VAULT_MAP[token1]} alt={token1} />\n                <span>{token1}</span>\n              </InputSuffix>\n            </InputWrap>\n            <PriceWrap>\n              <TotalPrice>${balance1}</TotalPrice>\n              <BalancePrice>Balance:<span>{Big(balances[token1] ?? 0).toFixed(6)}</span> {token1}</BalancePrice>\n            </PriceWrap>\n          </Column>\n        </Row>\n        <StyledButtonList>\n          {isInSufficient && <StyledButton disabled>InSufficient Balance</StyledButton>}\n          {\n            !isInSufficient &&\n            (isToken0Approved &&\n              isToken1Approved &&\n              !isToken0Approving &&\n              !isToken1Approving ? (\n\n              <StyledButton disabled={isLoading || !amount0 || !amount1} onClick={handleDeposit}>\n                {\n                  isLoading ? (\n                    <StyledLoading>{iconCircle}</StyledLoading>\n                  ) : (\n                    \"Deposit\"\n                  )\n                }\n              </StyledButton>\n            ) : (\n              <>\n                <StyledButton disabled={isToken0Approved || isToken0Approving} onClick={() => handleApprove(true)}>{\n                  isToken0Approving ? (\n                    <StyledLoading>{iconCircle}</StyledLoading>\n                  ) : (\n                    <>\n                      {isToken0Approved ? \"Approved\" : \"Approve\"} {token0}\n                    </>\n                  )}\n                </StyledButton>\n                <StyledButton disabled={isToken1Approved || isToken1Approving} onClick={() => handleApprove(false)}>{\n                  isToken1Approving ? (\n                    <StyledLoading>{iconCircle}</StyledLoading>\n                  ) : (\n                    <>\n                      {isToken1Approved ? \"Approved\" : \"Approve\"} {token1}\n                    </>\n                  )}\n                </StyledButton>\n              </>\n            ))\n          }\n        </StyledButtonList>\n      </> : <>\n        <Row className=\"price-input\">\n          <Column>\n            <InputWrap>\n              <Input value={lpAmount} type=\"number\" onChange={(e) => {\n                handleLPChange(e.target.value);\n\n                const value = e.target.value;\n\n                if (!value) {\n                  onUpdateLpPercent(0);\n                }\n\n                if (value && Big(value).gt(0)) {\n                  const newSliderPercent = Big(value || 0)\n                    .div(Big(lpBalance).gt(0) ? lpBalance : 1)\n                    .times(100)\n                    .toFixed(0);\n                  onUpdateLpPercent(newSliderPercent);\n                }\n              }} />\n\n              <InputSuffix>\n                <StyledImageList>\n                  <img src={ICON_VAULT_MAP[token0]} alt={token0} />\n                  <img src={ICON_VAULT_MAP[token1]} alt={token1} style={{ marginLeft: -6 }} />\n                </StyledImageList>\n                <span>{token0}/{token1}</span>\n              </InputSuffix>\n            </InputWrap>\n            <PriceWrap>\n              <TotalPrice>${balanceLp}</TotalPrice>\n              <BalancePrice>Balance: <span\n                onClick={() => {\n                  const newSliderPercent = Big(lpBalance || 0)\n                    .div(Big(lpBalance).gt(0) ? lpBalance : 1)\n                    .times(100)\n                    .toFixed(0);\n\n                  onUpdateLpPercent(newSliderPercent);\n\n                  handleLPChange(lpBalance);\n                }}\n                className=\"v\"\n              >\n                {lpBalance}\n              </span></BalancePrice>\n            </PriceWrap>\n\n            <StyledFlex justifyContent=\"space-between\" style={{ marginTop: 16 }}>\n              <StyledFont color=\"#979ABE\">Est. Receive</StyledFont>\n              <StyledFlex gap=\"26px\">\n                <StyledFlex gap=\"9px\">\n                  <img style={{ width: 20, height: 20, borderRadius: '50%', overflow: 'hidden' }} src={ICON_VAULT_MAP[token0]} alt={token0} />\n                  <StyledFont color=\"#FFF\" fontWeight=\"500\">{state.amountX} {token0}</StyledFont>\n                </StyledFlex>\n                <StyledFont color=\"#979ABE\">+</StyledFont>\n                <StyledFlex gap=\"9px\">\n                  <img style={{ width: 20, height: 20, borderRadius: '50%', overflow: 'hidden' }} src={ICON_VAULT_MAP[token1]} alt={token1} />\n                  <StyledFont color=\"#FFF\" fontWeight=\"500\">{state.amountY} {token1}</StyledFont>\n                </StyledFlex>\n              </StyledFlex>\n            </StyledFlex>\n          </Column>\n        </Row>\n        <StyledButtonList>\n          <StyledButton\n            disabled={isWithdrawInsufficient || isLoading || !lpAmount}\n            onClick={handleWithdraw}\n          >\n            {isLoading ? (\n              <StyledLoading>{iconCircle}</StyledLoading>\n            ) : (\n              <>\n                {isWithdrawInsufficient ? \"InSufficient Balance\" : \"Withdraw\"}\n              </>\n            )}\n          </StyledButton>\n        </StyledButtonList>\n      </>\n    }\n\n  </Wrapper>\n)", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/bluebiu.near/widget/Liquidity.Bridge.STEAKHUT.Detail", "fact_widget_deployments_id": "4dc99aac0aeaeaa0d881badc253c0cc1", "inserted_timestamp": "2024-04-01T08:49:06.720Z", "modified_timestamp": "2024-04-01T08:49:06.720Z", "__row_index": 3}