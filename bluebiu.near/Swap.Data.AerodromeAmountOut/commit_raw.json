{"tx_hash": "3mRWzPr7omtdShHcMUUGMuQcHcMJvchZdgt9ZzQPR3Vb", "action_id_social": "BWmgqi22dVhrnAhAYRaLpVTFRHeURbdNYGrsdGhJkenH-0-widget", "block_id": 111258705, "block_timestamp": "2024-01-25T05:46:49.206Z", "signer_id": "bluebiu.near", "widget_name": "Swap.Data.AerodromeAmountOut", "source_code": "const ROUTER_ABI = [\n  {\n    inputs: [\n      { internalType: \"uint256\", name: \"amountIn\", type: \"uint256\" },\n      {\n        components: [\n          { internalType: \"address\", name: \"from\", type: \"address\" },\n          { internalType: \"address\", name: \"to\", type: \"address\" },\n          { internalType: \"bool\", name: \"stable\", type: \"bool\" },\n          { internalType: \"address\", name: \"factory\", type: \"address\" },\n        ],\n        internalType: \"struct IRouter.Route[]\",\n        name: \"routes\",\n        type: \"tuple[]\",\n      },\n    ],\n    name: \"getAmountsOut\",\n    outputs: [\n      { internalType: \"uint256[]\", name: \"amounts\", type: \"uint256[]\" },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"uint256\", name: \"amountIn\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"amountOutMin\", type: \"uint256\" },\n      {\n        components: [\n          { internalType: \"address\", name: \"from\", type: \"address\" },\n          { internalType: \"address\", name: \"to\", type: \"address\" },\n          { internalType: \"bool\", name: \"stable\", type: \"bool\" },\n          { internalType: \"address\", name: \"factory\", type: \"address\" },\n        ],\n        internalType: \"struct RouterV2.route[]\",\n        name: \"routes\",\n        type: \"tuple[]\",\n      },\n      { internalType: \"address\", name: \"to\", type: \"address\" },\n      { internalType: \"uint256\", name: \"deadline\", type: \"uint256\" },\n    ],\n    name: \"swapExactTokensForTokens\",\n    outputs: [\n      { internalType: \"uint256[]\", name: \"amounts\", type: \"uint256[]\" },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"uint256\", name: \"amountOutMin\", type: \"uint256\" },\n      {\n        components: [\n          { internalType: \"address\", name: \"from\", type: \"address\" },\n          { internalType: \"address\", name: \"to\", type: \"address\" },\n          { internalType: \"bool\", name: \"stable\", type: \"bool\" },\n          { internalType: \"address\", name: \"factory\", type: \"address\" },\n        ],\n        internalType: \"struct IRouter.Route[]\",\n        name: \"routes\",\n        type: \"tuple[]\",\n      },\n      { internalType: \"address\", name: \"to\", type: \"address\" },\n      { internalType: \"uint256\", name: \"deadline\", type: \"uint256\" },\n    ],\n    name: \"swapExactETHForTokens\",\n    outputs: [\n      { internalType: \"uint256[]\", name: \"amounts\", type: \"uint256[]\" },\n    ],\n    stateMutability: \"payable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"uint256\", name: \"amountIn\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"amountOutMin\", type: \"uint256\" },\n      {\n        components: [\n          { internalType: \"address\", name: \"from\", type: \"address\" },\n          { internalType: \"address\", name: \"to\", type: \"address\" },\n          { internalType: \"bool\", name: \"stable\", type: \"bool\" },\n          { internalType: \"address\", name: \"factory\", type: \"address\" },\n        ],\n        internalType: \"struct IRouter.Route[]\",\n        name: \"routes\",\n        type: \"tuple[]\",\n      },\n      { internalType: \"address\", name: \"to\", type: \"address\" },\n      { internalType: \"uint256\", name: \"deadline\", type: \"uint256\" },\n    ],\n    name: \"swapExactTokensForETH\",\n    outputs: [\n      { internalType: \"uint256[]\", name: \"amounts\", type: \"uint256[]\" },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"tokenA\", type: \"address\" },\n      { internalType: \"address\", name: \"tokenB\", type: \"address\" },\n      { internalType: \"bool\", name: \"stable\", type: \"bool\" },\n      { internalType: \"address\", name: \"_factory\", type: \"address\" },\n    ],\n    name: \"getReserves\",\n    outputs: [\n      { internalType: \"uint256\", name: \"reserveA\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"reserveB\", type: \"uint256\" },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\n\nconst {\n  updater,\n  routerAddress,\n  factoryAddress,\n  wethAddress,\n  inputCurrency,\n  outputCurrency,\n  inputCurrencyAmount,\n  onLoad,\n  slippage,\n  account,\n} = props;\n\nuseEffect(() => {\n  if (!updater) return;\n\n  if (\n    (!inputCurrency.address && !inputCurrency.isNative) ||\n    (!outputCurrency.address && !outputCurrency.isNative) ||\n    !inputCurrencyAmount\n  ) {\n    return;\n  }\n\n  const wrapType =\n    inputCurrency.address === \"native\" && outputCurrency.address === wethAddress\n      ? 1\n      : inputCurrency.address === wethAddress &&\n        outputCurrency.address === \"native\"\n      ? 2\n      : 0;\n\n  if (wrapType) {\n    onLoad({\n      outputCurrencyAmount: inputCurrencyAmount,\n      noPair: false,\n    });\n    return;\n  }\n\n  const amount = ethers.utils.parseUnits(\n    Big(inputCurrencyAmount || 0).toFixed(inputCurrency.decimals),\n    inputCurrency.decimals\n  );\n\n  const path = [\n    inputCurrency.isNative ? wethAddress : inputCurrency.address,\n    outputCurrency.isNative ? wethAddress : outputCurrency.address,\n  ];\n\n  const RouterContract = new ethers.Contract(\n    routerAddress,\n    ROUTER_ABI,\n    Ethers.provider().getSigner()\n  );\n\n  const getAmountOut = () => {\n    RouterContract.getAmountsOut(amount, [\n      {\n        from: path[0],\n        to: path[1],\n        stable: false,\n        factory: factoryAddress,\n      },\n    ])\n      .then((res) => {\n        const _amount = Big(\n          ethers.utils.formatUnits(res[1], outputCurrency.decimals)\n        );\n        if (_amount.gt(0)) {\n          getReverse({\n            amountoutDesimals: _amount.toString(),\n            amountOut: res[1],\n          });\n        } else {\n          onLoad({\n            noPair: true,\n            outputCurrencyAmount: \"\",\n          });\n        }\n      })\n      .catch((err) => {\n        onLoad({\n          noPair: true,\n          outputCurrencyAmount: \"\",\n        });\n      });\n  };\n  const getReverse = ({ amountOut, amountoutDesimals }) => {\n    RouterContract.getReserves(path[0], path[1], false, factoryAddress, false)\n      .then((res) => {\n        const isReverse = Number(path[0]) > Number(path[1]);\n\n        const token0 = Big(\n          ethers.utils.formatUnits(\n            res[0],\n            isReverse ? outputCurrency.decimals : inputCurrency.decimals\n          )\n        );\n        const token1 = Big(\n          ethers.utils.formatUnits(\n            res[1],\n            isReverse ? inputCurrency.decimals : outputCurrency.decimals\n          )\n        );\n        const poolPrice = token1.div(token0);\n\n        const amountoutPrice = isReverse\n          ? Big(inputCurrencyAmount).div(amountoutDesimals)\n          : Big(amountoutDesimals).div(inputCurrencyAmount);\n\n        const priceImpact = poolPrice\n          .minus(amountoutPrice)\n          .div(poolPrice)\n          .mul(100)\n          .toString();\n        getTransaction({\n          priceImpact,\n          amountoutDesimals,\n          amountOut,\n        });\n      })\n      .catch((err) => {\n        getTransaction({\n          amountoutDesimals,\n          amountOut,\n        });\n      });\n  };\n\n  const getTransaction = ({ amountOut, amountoutDesimals, priceImpact }) => {\n    let method = \"\";\n    const deadline = Math.ceil(Date.now() / 1000) + 120;\n    const _amountOut = Big(amountOut)\n      .mul(1 - (slippage || 0.05))\n      .toFixed(0);\n\n    const options = {};\n    const params = [\n      _amountOut,\n      [{ from: path[0], to: path[1], stable: false, factory: factoryAddress }],\n      account,\n      deadline,\n    ];\n    if (inputCurrency.address === \"native\") {\n      method = \"swapExactETHForTokens\";\n      options.value = amount;\n    } else if (outputCurrency.address === \"native\") {\n      method = \"swapExactTokensForETH\";\n      params.unshift(amount);\n    } else {\n      method = \"swapExactTokensForTokens\";\n      params.unshift(amount);\n    }\n    const returnData = {\n      outputCurrencyAmount: Big(amountoutDesimals).gt(0.01)\n        ? Big(amountoutDesimals).toPrecision(10)\n        : Big(amountoutDesimals).toFixed(10),\n      priceImpact,\n    };\n    const createTx = (gasLimit) => {\n      RouterContract.populateTransaction[method](...params, {\n        ...options,\n        gasLimit: gasLimit || 500000,\n      })\n        .then((res) => {\n          onLoad({\n            ...returnData,\n            noPair: false,\n            gas: gasLimit,\n            unsignedTx: res,\n          });\n        })\n        .catch((err) => {\n          onLoad({\n            ...returnData,\n            noPair: false,\n            gas: gasLimit,\n          });\n        });\n    };\n    RouterContract.estimateGas[method](...params, options)\n      .then((_gas) => {\n        createTx(_gas);\n      })\n      .catch((err) => {\n        onLoad({\n          ...returnData,\n          noPair: false,\n        });\n      });\n  };\n\n  getAmountOut();\n}, [updater]);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/bluebiu.near/widget/Swap.Data.AerodromeAmountOut", "fact_widget_deployments_id": "97fad37f7ceb15716df43fb64dcb4cb8", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 5}