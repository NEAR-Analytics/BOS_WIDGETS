{"tx_hash": "AgFybVHmTjffo1V2TWW3c3fPiGFhn3i5JXamiW3PD6GV", "action_id_social": "4goAATbfcLYe73juU9MbJaBN5cCkY4q3c3yFuAWwDmYH-0-widget", "block_id": 111108080, "block_timestamp": "2024-01-23T09:51:50.160Z", "signer_id": "bluebiu.near", "widget_name": "Lending.Data.LayerBank", "source_code": "const OTOKEN_ABI = [\n  {\n    inputs: [],\n    name: \"totalSupply\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"totalBorrow\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"exchangeRate\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"account\", type: \"address\" }],\n    name: \"accountSnapshot\",\n    outputs: [\n      {\n        components: [\n          {\n            internalType: \"uint256\",\n            name: \"gTokenBalance\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"borrowBalance\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"exchangeRate\",\n            type: \"uint256\",\n          },\n        ],\n        internalType: \"struct Constant.AccountSnapshot\",\n        name: \"\",\n        type: \"tuple\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"getCash\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"totalReserve\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"reserveFactor\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\nconst UNITROLLER_ABI = [\n  {\n    inputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n    name: \"marketInfos\",\n    outputs: [\n      { internalType: \"bool\", name: \"isListed\", type: \"bool\" },\n      { internalType: \"uint256\", name: \"supplyCap\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"borrowCap\", type: \"uint256\" },\n      {\n        internalType: \"uint256\",\n        name: \"collateralFactor\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"account\", type: \"address\" },\n      {\n        internalType: \"contract IOToken\",\n        name: \"oToken\",\n        type: \"address\",\n      },\n    ],\n    name: \"checkMembership\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    constant: true,\n    inputs: [\n      { internalType: \"uint8\", name: \"\", type: \"uint8\" },\n      { internalType: \"address\", name: \"\", type: \"address\" },\n    ],\n    name: \"supplyRewardSpeeds\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    payable: false,\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    constant: true,\n    inputs: [\n      { internalType: \"uint8\", name: \"\", type: \"uint8\" },\n      { internalType: \"address\", name: \"\", type: \"address\" },\n    ],\n    name: \"borrowRewardSpeeds\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    payable: false,\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\nconst ORACLE_ABI = [\n  {\n    inputs: [{ internalType: \"address[]\", name: \"gTokens\", type: \"address[]\" }],\n    name: \"getUnderlyingPrices\",\n    outputs: [{ internalType: \"uint256[]\", name: \"\", type: \"uint256[]\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"asset\", type: \"address\" }],\n    name: \"priceOf\",\n    outputs: [{ internalType: \"uint256\", name: \"priceInUSD\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\nconst ERC20_ABI = [\n  {\n    constant: true,\n    inputs: [\n      {\n        name: \"_owner\",\n        type: \"address\",\n      },\n    ],\n    name: \"balanceOf\",\n    outputs: [\n      {\n        name: \"balance\",\n        type: \"uint256\",\n      },\n    ],\n    payable: false,\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\nconst RATE_ABI = [\n  {\n    inputs: [\n      { internalType: \"uint256\", name: \"cash\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"borrows\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"reserves\", type: \"uint256\" },\n    ],\n    name: \"getBorrowRate\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"uint256\", name: \"cash\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"borrows\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"reserves\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"reserveFactor\", type: \"uint256\" },\n    ],\n    name: \"getSupplyRate\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\nconst DISTRIBUTION_ABI = [\n  {\n    inputs: [\n      { internalType: \"address[]\", name: \"markets\", type: \"address[]\" },\n      { internalType: \"address\", name: \"account\", type: \"address\" },\n    ],\n    name: \"accuredLAB\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"market\", type: \"address\" },\n      { internalType: \"address\", name: \"account\", type: \"address\" },\n    ],\n    name: \"apyDistributionOf\",\n    outputs: [\n      {\n        components: [\n          {\n            internalType: \"uint256\",\n            name: \"apySupplyLab\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"apyBorrowLab\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"apyAccountSupplyLab\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"apyAccountBorrowLab\",\n            type: \"uint256\",\n          },\n        ],\n        internalType: \"struct Constant.DistributionAPY\",\n        name: \"\",\n        type: \"tuple\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\n\nconst {\n  multicallAddress,\n  unitrollerAddress,\n  rateModelSlopeAddress,\n  distributionAddress,\n  oracleAddress,\n  account,\n  update,\n  dapp,\n  onLoad,\n  markets,\n  multicall,\n  prices,\n  rewardToken,\n} = props;\n\nif (!multicallAddress || !unitrollerAddress || !update || !account) return \"\";\nlet _cTokensData = {};\nlet _loanToValue = null;\nlet _underlyPrice = {};\nlet _liquidity = null;\nlet _underlyingBalance = null;\nlet _userMerberShip = null;\nlet _rewardsApy = {};\nlet _accountRewards = {};\n\nlet count = 0;\nlet oTokensLength = Object.values(markets).length;\n\nconst formatedData = (key) => {\n  console.log(`${dapp}-${key}`, count);\n  if (count < 6) return;\n  try {\n    count = 0;\n    oTokensLength = Object.values(markets).length;\n    let totalSupplyUsd = Big(0);\n    let totalBorrowUsd = Big(0);\n    let userTotalSupplyUsd = Big(0);\n    let userTotalBorrowUsd = Big(0);\n    let totalCollateralUsd = Big(0);\n    let totalAccountDistributionApy = Big(0);\n    const markets = {};\n    Object.values(_cTokensData).forEach((market) => {\n      const underlyingPrice = _underlyPrice[market.address] || 1;\n      const marketSupplyUsd = Big(market.totalSupply || 0).mul(underlyingPrice);\n      const marketBorrowUsd = Big(market.totalBorrows || 0).mul(\n        underlyingPrice\n      );\n      totalSupplyUsd = totalSupplyUsd.plus(marketSupplyUsd);\n      totalBorrowUsd = totalBorrowUsd.plus(marketBorrowUsd);\n      userTotalSupplyUsd = userTotalSupplyUsd.plus(\n        Big(market.userSupply).mul(underlyingPrice)\n      );\n      userTotalBorrowUsd = userTotalBorrowUsd.plus(\n        Big(market.userBorrow).mul(underlyingPrice)\n      );\n      if (_userMerberShip[market.address]) {\n        totalCollateralUsd = totalCollateralUsd.plus(\n          Big(market.userSupply)\n            .mul(underlyingPrice)\n            .mul(_loanToValue[market.address])\n            .div(100)\n        );\n      }\n\n      const supplyApy = Big(market.supplyRatePerTimestamp)\n        .mul(60 * 60 * 24)\n        .plus(1)\n        .pow(365)\n        .minus(1)\n        .mul(100);\n\n      const borrowApy = Big(market.borrowRatePerTimestamp)\n        .mul(60 * 60 * 24)\n        .plus(1)\n        .pow(365)\n        .minus(1)\n        .mul(100);\n      const rewardApy = _rewardsApy[market.address];\n      const distributionApy = {\n        ...rewardToken,\n        supply: Big(rewardApy.apySupply).mul(3).toFixed(2) + \"%\",\n        borrow: Big(rewardApy.apyBorrow).mul(3).toFixed(2) + \"%\",\n      };\n      if (Big(rewardApy.apyAccountSupply).gt(0)) {\n        distributionApy.apyAccountSupply =\n          Big(rewardApy.apyAccountSupply).toFixed(2) + \"%\";\n        totalAccountDistributionApy = totalAccountDistributionApy.plus(\n          rewardApy.apyAccountSupply\n        );\n      }\n      if (Big(rewardApy.apyAccountBorrow).gt(0)) {\n        distributionApy.apyAccountBorrow =\n          Big(rewardApy.apyAccountBorrow).toFixed(2) + \"%\";\n        totalAccountDistributionApy = totalAccountDistributionApy.plus(\n          rewardApy.apyAccountBorrow\n        );\n      }\n      markets[market.address] = {\n        ...market,\n        loanToValue: _loanToValue[market.address],\n        liquidity: _liquidity[market.address],\n        underlyingPrice: underlyingPrice,\n        userUnderlyingBalance: _underlyingBalance[market.address],\n        userMerberShip: _userMerberShip[market.address],\n        supplyApy: supplyApy.toFixed(2) + \"%\",\n        borrowApy: borrowApy.toFixed(2) + \"%\",\n        distributionApy: [distributionApy],\n        dapp,\n        rewards,\n      };\n    });\n    let rewards;\n    if (_accountRewards && Big(_accountRewards.reward || 0).gt(0)) {\n      const dailyRewards = totalAccountDistributionApy\n        .mul(userTotalSupplyUsd.add(userTotalBorrowUsd))\n        .div(365 * 100)\n        .div(_accountRewards.price);\n      rewards = [\n        {\n          icon: \"https://ipfs.near.social/ipfs/bafkreiecfhuuc6grbyfxfv4uzgaciofdug6sdqv7efruu4uwmzclfqmcs4\",\n          symbol: \"LAB\",\n          dailyRewards: dailyRewards.toString(),\n          price: _accountRewards.price,\n          unclaimed: _accountRewards.reward,\n        },\n      ];\n    }\n    onLoad({\n      markets,\n      rewards,\n      totalSupplyUsd: totalSupplyUsd.toString(),\n      totalBorrowUsd: totalBorrowUsd.toString(),\n      userTotalSupplyUsd: userTotalSupplyUsd.toString(),\n      userTotalBorrowUsd: userTotalBorrowUsd.toString(),\n      totalCollateralUsd: totalCollateralUsd.toString(),\n    });\n  } catch (err) {\n    console.log(\"format error\", err);\n  }\n};\nconst getUnitrollerData = () => {\n  const calls = [];\n  const oTokens = Object.values(markets);\n  oTokens.forEach((token) => {\n    calls.push({\n      address: unitrollerAddress,\n      name: \"marketInfos\",\n      params: [token.address],\n    });\n    if (account) {\n      calls.push({\n        address: unitrollerAddress,\n        name: \"checkMembership\",\n        params: [account, token.address],\n      });\n    }\n  });\n  multicall({\n    abi: UNITROLLER_ABI,\n    calls,\n    options: {},\n    multicallAddress,\n    provider: Ethers.provider(),\n  })\n    .then((res) => {\n      _loanToValue = {};\n      _userMerberShip = {};\n      for (let i = 0, len = res.length; i < len; i++) {\n        const index = Math.floor(i / (account ? 2 : 1));\n        const mod = i % (account ? 2 : 1);\n        switch (mod) {\n          case 0:\n            _loanToValue[oTokens[index].address] = ethers.utils.formatUnits(\n              res[i][3]._hex,\n              16\n            );\n            break;\n          case 1:\n            _userMerberShip[oTokens[index].address] = res[i][0];\n            break;\n          default:\n        }\n      }\n      count++;\n      formatedData(\"getUnitrollerData\");\n      getUnderlyPrice();\n      getOTokenLiquidity();\n    })\n    .catch((err) => {\n      console.log(\"error-getUnitrollerData\", err);\n      setTimeout(() => {\n        getUnitrollerData();\n      }, 1000);\n    });\n};\nconst getUnderlyPrice = () => {\n  if (!oracleAddress) return;\n  const oTokens = Object.keys(markets);\n  const UnderlyingContract = new ethers.Contract(\n    oracleAddress,\n    ORACLE_ABI,\n    Ethers.provider().getSigner()\n  );\n  UnderlyingContract.getUnderlyingPrices(oTokens)\n    .then((res) => {\n      _underlyPrice = {};\n      for (let i = 0, len = res.length; i < len; i++) {\n        _underlyPrice[oTokens[i]] = ethers.utils.formatUnits(res[i]._hex, 18);\n      }\n      count++;\n      formatedData(\"getUnderlyPrice\");\n    })\n    .catch((err) => {\n      console.log(\"error-getUnderlyPrice\", err);\n    });\n};\nconst getOTokenLiquidity = () => {\n  const assets = Object.values(markets);\n  let nativeOToken = \"\";\n  const calls = assets\n    .filter((market) => {\n      if (market.underlyingToken.address === \"native\")\n        nativeOToken = market.address;\n      return (\n        market.underlyingToken.address &&\n        market.underlyingToken.address !== \"native\"\n      );\n    })\n    .map((market) => ({\n      address: market.underlyingToken.address,\n      name: \"balanceOf\",\n      params: [market.address],\n    }));\n  multicall({\n    abi: ERC20_ABI,\n    calls,\n    options: {},\n    multicallAddress,\n    provider: Ethers.provider(),\n  })\n    .then((res) => {\n      _liquidity = {};\n      for (let i = 0, len = res.length; i < len; i++) {\n        const oToken = markets[calls[i].params[0]];\n        _liquidity[oToken.address] = ethers.utils.formatUnits(\n          res[i][0]._hex,\n          oToken.underlyingToken.decimals\n        );\n      }\n      const provider = Ethers.provider();\n      if (nativeOToken) {\n        provider.getBalance(nativeOToken).then((rawBalance) => {\n          _liquidity[nativeOToken] = ethers.utils.formatUnits(\n            rawBalance._hex,\n            18\n          );\n          count++;\n          formatedData(\"getOTokenLiquidity\");\n        });\n      } else {\n        count++;\n        formatedData(\"getOTokenLiquidity\");\n      }\n    })\n    .catch(() => {\n      setTimeout(() => {\n        getOTokenLiquidity();\n      }, 500);\n    });\n};\nconst getWalletBalance = () => {\n  let nativeOToken = \"\";\n  const underlyingTokens = Object.values(markets)\n    .filter((market) => {\n      if (market.underlyingToken.address === \"native\")\n        nativeOToken = market.address;\n      return (\n        market.underlyingToken.address &&\n        market.underlyingToken.address !== \"native\"\n      );\n    })\n    .map((market) => ({\n      ...market.underlyingToken,\n      oTokenAddress: market.address,\n    }));\n  const calls = underlyingTokens.map((token) => ({\n    address: token.address,\n    name: \"balanceOf\",\n    params: [account],\n  }));\n  multicall({\n    abi: ERC20_ABI,\n    calls,\n    options: {},\n    multicallAddress,\n    provider: Ethers.provider(),\n  })\n    .then((res) => {\n      _underlyingBalance = {};\n      for (let i = 0, len = res.length; i < len; i++) {\n        _underlyingBalance[underlyingTokens[i].oTokenAddress] = res[i][0]\n          ? ethers.utils.formatUnits(\n              res[i][0]._hex,\n              underlyingTokens[i].decimals\n            )\n          : \"0\";\n      }\n      if (nativeOToken) {\n        const provider = Ethers.provider();\n        provider.getBalance(account).then((rawBalance) => {\n          _underlyingBalance[nativeOToken] = ethers.utils.formatUnits(\n            rawBalance._hex,\n            18\n          );\n          count++;\n          formatedData(\"underlyingTokens\");\n          getRewards();\n        });\n      } else {\n        count++;\n        formatedData(\"underlyingTokens\");\n        getRewards();\n      }\n    })\n    .catch((err) => {\n      setTimeout(() => {\n        getWalletBalance();\n      }, 500);\n    });\n};\nconst getCTokenData = (oToken) => {\n  if (oTokensLength === 0) return;\n  const calls = [\n    {\n      address: oToken.address,\n      name: \"exchangeRate\",\n    },\n    {\n      address: oToken.address,\n      name: \"totalSupply\",\n    },\n    {\n      address: oToken.address,\n      name: \"totalBorrow\",\n    },\n    {\n      address: oToken.address,\n      name: \"accountSnapshot\",\n      params: [account],\n    },\n    {\n      address: oToken.address,\n      name: \"getCash\",\n    },\n    {\n      address: oToken.address,\n      name: \"totalReserve\",\n    },\n    {\n      address: oToken.address,\n      name: \"reserveFactor\",\n    },\n  ];\n  multicall({\n    abi: OTOKEN_ABI,\n    calls,\n    options: {},\n    multicallAddress,\n    provider: Ethers.provider(),\n  })\n    .then((res) => {\n      const exchangeRateStored = ethers.utils.formatUnits(res[0][0]._hex, 18);\n      const userSupply = ethers.utils.formatUnits(\n        res[3][0][0]._hex,\n        oToken.underlyingToken.decimals\n      );\n      const totalSupply = ethers.utils.formatUnits(\n        res[1][0]._hex,\n        oToken.underlyingToken.decimals\n      );\n      _cTokensData[oToken.address] = {\n        ...oToken,\n        exchangeRateStored,\n        totalSupply: Big(totalSupply).mul(exchangeRateStored).toString(),\n        totalBorrows: ethers.utils.formatUnits(\n          res[2][0]._hex,\n          oToken.underlyingToken.decimals\n        ),\n        userSupply: Big(userSupply).mul(exchangeRateStored).toString(),\n        userBorrow: ethers.utils.formatUnits(\n          res[3][0][1]._hex,\n          oToken.underlyingToken.decimals\n        ),\n      };\n      const rateCalls = [\n        {\n          address: rateModelSlopeAddress,\n          name: \"getBorrowRate\",\n          params: [res[4][0], res[2][0], res[5][0]],\n        },\n        {\n          address: rateModelSlopeAddress,\n          name: \"getSupplyRate\",\n          params: [res[4][0], res[2][0], res[5][0], res[6][0]],\n        },\n      ];\n      multicall({\n        abi: RATE_ABI,\n        calls: rateCalls,\n        options: {},\n        multicallAddress,\n        provider: Ethers.provider(),\n      })\n        .then((rateRes) => {\n          oTokensLength--;\n          _cTokensData[oToken.address].borrowRatePerTimestamp =\n            ethers.utils.formatUnits(rateRes[0][0]._hex, 18);\n          _cTokensData[oToken.address].supplyRatePerTimestamp =\n            ethers.utils.formatUnits(rateRes[1][0]._hex, 18);\n          if (oTokensLength === 0) {\n            count++;\n            formatedData(\"oTokens data\");\n          }\n        })\n        .catch((err) => {\n          setTimeout(() => {\n            getCTokenData(oToken);\n          }, 1000);\n        });\n    })\n    .catch(() => {\n      setTimeout(() => {\n        getCTokenData(oToken);\n      }, 1000);\n    });\n};\nconst getCTokensData = () => {\n  Object.values(markets).forEach((market) => {\n    getCTokenData(market);\n  });\n};\nconst getRewards = () => {\n  const PriceToken = new ethers.Contract(\n    oracleAddress,\n    ORACLE_ABI,\n    Ethers.provider().getSigner()\n  );\n  PriceToken.priceOf(rewardToken.address).then((priceRes) => {\n    const price = Big(ethers.utils.formatUnits(priceRes._hex, 18)).toString();\n    getUserRewards(price);\n  });\n};\nconst getUserRewards = (price) => {\n  const cTokens = Object.keys(markets);\n  const calls = cTokens.map((cToken) => ({\n    address: distributionAddress,\n    name: \"apyDistributionOf\",\n    params: [cToken, account],\n  }));\n  calls.push({\n    address: distributionAddress,\n    name: \"accuredLAB\",\n    params: [cTokens, account],\n  });\n  multicall({\n    abi: DISTRIBUTION_ABI,\n    calls,\n    options: {},\n    multicallAddress,\n    provider: Ethers.provider(),\n  })\n    .then((res) => {\n      _accountRewards.price = price;\n      for (let i = 0; i < res.length; i++) {\n        if (i === res.length - 1) {\n          const accured = res[i][0]\n            ? ethers.utils.formatUnits(res[i][0]._hex, 18)\n            : \"0\";\n          _accountRewards.reward = accured;\n          count++;\n          formatedData(\"rewards\");\n          return;\n        }\n        _rewardsApy[cTokens[i]] = {\n          apySupply: ethers.utils.formatUnits(res[i][0][0]._hex, 16),\n          apyBorrow: ethers.utils.formatUnits(res[i][0][1]._hex, 16),\n          apyAccountSupply: ethers.utils.formatUnits(res[i][0][2]._hex, 16),\n          apyAccountBorrow: ethers.utils.formatUnits(res[i][0][3]._hex, 16),\n        };\n      }\n    })\n    .catch((err) => {\n      console.log(\"error-rewards\", err);\n    });\n};\n\nconst init = () => {\n  getUnitrollerData();\n  getWalletBalance();\n  getCTokensData();\n};\n\nuseEffect(() => {\n  init();\n}, []);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/bluebiu.near/widget/Lending.Data.LayerBank", "fact_widget_deployments_id": "ecd998a54fdd0d26323c61f9620bebf6", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 1}