{"tx_hash": "ByPNXJ7vu31fgm4LsMiPHkrCjVzj2AHGbAeEKdRcpEfr", "action_id_social": "79P8i8HsvAdcJSuQb84haHTYpnBPcgYB2rrjCXgrtfPH-0-widget", "block_id": 116671462, "block_timestamp": "2024-04-12T08:34:08.104Z", "signer_id": "bluebiu.near", "widget_name": "Lending.Data.LayerBank", "source_code": "const OTOKEN_ABI = [\n  {\n    inputs: [],\n    name: \"totalSupply\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"totalBorrow\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"exchangeRate\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"account\", type: \"address\" }],\n    name: \"accountSnapshot\",\n    outputs: [\n      {\n        components: [\n          {\n            internalType: \"uint256\",\n            name: \"gTokenBalance\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"borrowBalance\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"exchangeRate\",\n            type: \"uint256\",\n          },\n        ],\n        internalType: \"struct Constant.AccountSnapshot\",\n        name: \"\",\n        type: \"tuple\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"getCash\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"totalReserve\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"reserveFactor\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\nconst UNITROLLER_ABI = [\n  {\n    inputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n    name: \"marketInfos\",\n    outputs: [\n      { internalType: \"bool\", name: \"isListed\", type: \"bool\" },\n      { internalType: \"uint256\", name: \"supplyCap\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"borrowCap\", type: \"uint256\" },\n      {\n        internalType: \"uint256\",\n        name: \"collateralFactor\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"account\", type: \"address\" },\n      {\n        internalType: \"contract IOToken\",\n        name: \"oToken\",\n        type: \"address\",\n      },\n    ],\n    name: \"checkMembership\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    constant: true,\n    inputs: [\n      { internalType: \"uint8\", name: \"\", type: \"uint8\" },\n      { internalType: \"address\", name: \"\", type: \"address\" },\n    ],\n    name: \"supplyRewardSpeeds\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    payable: false,\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    constant: true,\n    inputs: [\n      { internalType: \"uint8\", name: \"\", type: \"uint8\" },\n      { internalType: \"address\", name: \"\", type: \"address\" },\n    ],\n    name: \"borrowRewardSpeeds\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    payable: false,\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\nconst ORACLE_ABI = [\n  {\n    inputs: [{ internalType: \"address[]\", name: \"gTokens\", type: \"address[]\" }],\n    name: \"getUnderlyingPrices\",\n    outputs: [{ internalType: \"uint256[]\", name: \"\", type: \"uint256[]\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"asset\", type: \"address\" }],\n    name: \"priceOf\",\n    outputs: [{ internalType: \"uint256\", name: \"priceInUSD\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\nconst ERC20_ABI = [\n  {\n    constant: true,\n    inputs: [\n      {\n        name: \"_owner\",\n        type: \"address\",\n      },\n    ],\n    name: \"balanceOf\",\n    outputs: [\n      {\n        name: \"balance\",\n        type: \"uint256\",\n      },\n    ],\n    payable: false,\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\nconst RATE_ABI = [\n  {\n    inputs: [\n      { internalType: \"uint256\", name: \"cash\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"borrows\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"reserves\", type: \"uint256\" },\n    ],\n    name: \"getBorrowRate\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"uint256\", name: \"cash\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"borrows\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"reserves\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"reserveFactor\", type: \"uint256\" },\n    ],\n    name: \"getSupplyRate\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\nconst DISTRIBUTION_ABI = [\n  {\n    inputs: [\n      { internalType: \"address[]\", name: \"markets\", type: \"address[]\" },\n      { internalType: \"address\", name: \"account\", type: \"address\" },\n    ],\n    name: \"accuredLAB\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"market\", type: \"address\" },\n      { internalType: \"address\", name: \"account\", type: \"address\" },\n    ],\n    name: \"apyDistributionOf\",\n    outputs: [\n      {\n        components: [\n          {\n            internalType: \"uint256\",\n            name: \"apySupplyLab\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"apyBorrowLab\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"apyAccountSupplyLab\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"apyAccountBorrowLab\",\n            type: \"uint256\",\n          },\n        ],\n        internalType: \"struct Constant.DistributionAPY\",\n        name: \"\",\n        type: \"tuple\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\n\nconst {\n  multicallAddress,\n  unitrollerAddress,\n  rateModelSlopeAddress,\n  distributionAddress,\n  oracleAddress,\n  account,\n  update,\n  name,\n  onLoad,\n  markets,\n  multicall,\n  prices,\n  rewardToken,\n} = props;\n\nuseEffect(() => {\n  if (!multicallAddress || !unitrollerAddress || !update || !account) return \"\";\n  let _cTokensData = {};\n  let _loanToValue = null;\n  let _underlyPrice = {};\n  let _liquidity = null;\n  let _underlyingBalance = null;\n  let _userMerberShip = null;\n  let _rewardsApy = {};\n  let _accountRewards = {};\n\n  let count = 0;\n  let oTokensLength = Object.values(markets).length;\n\n  const formatedData = (key) => {\n    console.log(`${name}-${key}`, count);\n    if (count < 6) return;\n    try {\n      count = 0;\n      oTokensLength = Object.values(markets).length;\n      let totalSupplyUsd = Big(0);\n      let totalBorrowUsd = Big(0);\n      let userTotalSupplyUsd = Big(0);\n      let userTotalBorrowUsd = Big(0);\n      let totalCollateralUsd = Big(0);\n      let totalAccountDistributionApy = Big(0);\n      const markets = {};\n      Object.values(_cTokensData).forEach((market) => {\n        const underlyingPrice = _underlyPrice[market.address] || 1;\n        const marketSupplyUsd = Big(market.totalSupply || 0).mul(\n          underlyingPrice\n        );\n        const marketBorrowUsd = Big(market.totalBorrows || 0).mul(\n          underlyingPrice\n        );\n        totalSupplyUsd = totalSupplyUsd.plus(marketSupplyUsd);\n        totalBorrowUsd = totalBorrowUsd.plus(marketBorrowUsd);\n        userTotalSupplyUsd = userTotalSupplyUsd.plus(\n          Big(market.userSupply).mul(underlyingPrice)\n        );\n        userTotalBorrowUsd = userTotalBorrowUsd.plus(\n          Big(market.userBorrow).mul(underlyingPrice)\n        );\n        if (_userMerberShip[market.address]) {\n          totalCollateralUsd = totalCollateralUsd.plus(\n            Big(market.userSupply)\n              .mul(underlyingPrice)\n              .mul(_loanToValue[market.address])\n              .div(100)\n          );\n        }\n\n        const supplyApy = Big(market.supplyRatePerTimestamp)\n          .mul(60 * 60 * 24)\n          .plus(1)\n          .pow(365)\n          .minus(1)\n          .mul(100);\n\n        const borrowApy = Big(market.borrowRatePerTimestamp)\n          .mul(60 * 60 * 24)\n          .plus(1)\n          .pow(365)\n          .minus(1)\n          .mul(100);\n        const rewardApy = _rewardsApy[market.address];\n        const distributionApy = {\n          ...rewardToken,\n          supply: Big(rewardApy.apySupply).mul(3).toFixed(2) + \"%\",\n          borrow: Big(rewardApy.apyBorrow).mul(3).toFixed(2) + \"%\",\n        };\n        if (Big(rewardApy.apyAccountSupply).gt(0)) {\n          distributionApy.apyAccountSupply =\n            Big(rewardApy.apyAccountSupply).toFixed(2) + \"%\";\n          totalAccountDistributionApy = totalAccountDistributionApy.plus(\n            rewardApy.apyAccountSupply\n          );\n        }\n        if (Big(rewardApy.apyAccountBorrow).gt(0)) {\n          distributionApy.apyAccountBorrow =\n            Big(rewardApy.apyAccountBorrow).toFixed(2) + \"%\";\n          totalAccountDistributionApy = totalAccountDistributionApy.plus(\n            rewardApy.apyAccountBorrow\n          );\n        }\n        markets[market.address] = {\n          ...market,\n          loanToValue: _loanToValue[market.address],\n          liquidity: _liquidity[market.address],\n          underlyingPrice: underlyingPrice,\n          userUnderlyingBalance: _underlyingBalance[market.address],\n          userMerberShip: _userMerberShip[market.address],\n          supplyApy: supplyApy.toFixed(2) + \"%\",\n          borrowApy: borrowApy.toFixed(2) + \"%\",\n          distributionApy: [distributionApy],\n          dapp: name,\n          rewards,\n        };\n      });\n      let rewards;\n      if (_accountRewards && Big(_accountRewards.reward || 0).gt(0)) {\n        const dailyRewards = totalAccountDistributionApy\n          .mul(userTotalSupplyUsd.add(userTotalBorrowUsd))\n          .div(365 * 100)\n          .div(_accountRewards.price);\n        rewards = [\n          {\n            icon: \"https://ipfs.near.social/ipfs/bafkreiecfhuuc6grbyfxfv4uzgaciofdug6sdqv7efruu4uwmzclfqmcs4\",\n            symbol: \"LAB\",\n            dailyRewards: dailyRewards.toString(),\n            price: _accountRewards.price,\n            unclaimed: _accountRewards.reward,\n          },\n        ];\n      }\n\n      onLoad({\n        markets,\n        rewards,\n        totalSupplyUsd: totalSupplyUsd.toString(),\n        totalBorrowUsd: totalBorrowUsd.toString(),\n        userTotalSupplyUsd: userTotalSupplyUsd.toString(),\n        userTotalBorrowUsd: userTotalBorrowUsd.toString(),\n        totalCollateralUsd: totalCollateralUsd.toString(),\n      });\n    } catch (err) {\n      console.log(\"format error\", err);\n    }\n  };\n  const getUnitrollerData = () => {\n    const calls = [];\n    const oTokens = Object.values(markets);\n    oTokens.forEach((token) => {\n      calls.push({\n        address: unitrollerAddress,\n        name: \"marketInfos\",\n        params: [token.address],\n      });\n      if (account) {\n        calls.push({\n          address: unitrollerAddress,\n          name: \"checkMembership\",\n          params: [account, token.address],\n        });\n      }\n    });\n    multicall({\n      abi: UNITROLLER_ABI,\n      calls,\n      options: {},\n      multicallAddress,\n      provider: Ethers.provider(),\n    })\n      .then((res) => {\n        _loanToValue = {};\n        _userMerberShip = {};\n        for (let i = 0, len = res.length; i < len; i++) {\n          const index = Math.floor(i / (account ? 2 : 1));\n          const mod = i % (account ? 2 : 1);\n          switch (mod) {\n            case 0:\n              _loanToValue[oTokens[index].address] = ethers.utils.formatUnits(\n                res[i][3]._hex,\n                16\n              );\n              break;\n            case 1:\n              _userMerberShip[oTokens[index].address] = res[i][0] || false;\n              break;\n            default:\n          }\n        }\n        count++;\n        formatedData(\"getUnitrollerData\");\n        getUnderlyPrice();\n        getOTokenLiquidity();\n      })\n      .catch((err) => {\n        console.log(\"error-getUnitrollerData\", err);\n        setTimeout(() => {\n          getUnitrollerData();\n        }, 1000);\n      });\n  };\n  const getUnderlyPrice = () => {\n    if (!oracleAddress) return;\n    const oTokens = Object.keys(markets);\n    const UnderlyingContract = new ethers.Contract(\n      oracleAddress,\n      ORACLE_ABI,\n      Ethers.provider().getSigner()\n    );\n    UnderlyingContract.getUnderlyingPrices(oTokens)\n      .then((res) => {\n        _underlyPrice = {};\n        for (let i = 0, len = res.length; i < len; i++) {\n          _underlyPrice[oTokens[i]] = ethers.utils.formatUnits(res[i]._hex, 18);\n        }\n        count++;\n        formatedData(\"getUnderlyPrice\");\n      })\n      .catch((err) => {\n        console.log(\"error-getUnderlyPrice\", err);\n      });\n  };\n  const getOTokenLiquidity = () => {\n    const assets = Object.values(markets);\n    let nativeOToken = \"\";\n    const calls = assets\n      .filter((market) => {\n        if (market.underlyingToken.isNative) nativeOToken = market.address;\n        return (\n          market.underlyingToken.address && !market.underlyingToken.isNative\n        );\n      })\n      .map((market) => ({\n        address: market.underlyingToken.address,\n        name: \"balanceOf\",\n        params: [market.address],\n      }));\n    multicall({\n      abi: ERC20_ABI,\n      calls,\n      options: {},\n      multicallAddress,\n      provider: Ethers.provider(),\n    })\n      .then((res) => {\n        _liquidity = {};\n        for (let i = 0, len = res.length; i < len; i++) {\n          const oToken = markets[calls[i].params[0]];\n          _liquidity[oToken.address] = ethers.utils.formatUnits(\n            res[i][0]._hex,\n            oToken.underlyingToken.decimals\n          );\n        }\n        const provider = Ethers.provider();\n        if (nativeOToken) {\n          provider.getBalance(nativeOToken).then((rawBalance) => {\n            _liquidity[nativeOToken] = ethers.utils.formatUnits(\n              rawBalance._hex,\n              18\n            );\n            count++;\n            formatedData(\"getOTokenLiquidity\");\n          });\n        } else {\n          count++;\n          formatedData(\"getOTokenLiquidity\");\n        }\n      })\n      .catch(() => {\n        setTimeout(() => {\n          getOTokenLiquidity();\n        }, 500);\n      });\n  };\n  const getWalletBalance = () => {\n    let nativeOToken = \"\";\n    const underlyingTokens = Object.values(markets)\n      .filter((market) => {\n        if (market.underlyingToken.isNative) nativeOToken = market.address;\n        return (\n          market.underlyingToken.address && !market.underlyingToken.isNative\n        );\n      })\n      .map((market) => ({\n        ...market.underlyingToken,\n        oTokenAddress: market.address,\n      }));\n    const calls = underlyingTokens.map((token) => ({\n      address: token.address,\n      name: \"balanceOf\",\n      params: [account],\n    }));\n    multicall({\n      abi: ERC20_ABI,\n      calls,\n      options: {},\n      multicallAddress,\n      provider: Ethers.provider(),\n    })\n      .then((res) => {\n        _underlyingBalance = {};\n        for (let i = 0, len = res.length; i < len; i++) {\n          _underlyingBalance[underlyingTokens[i].oTokenAddress] = res[i]\n            ? ethers.utils.formatUnits(\n                res[i][0]._hex,\n                underlyingTokens[i].decimals\n              )\n            : \"0\";\n        }\n        if (nativeOToken) {\n          const provider = Ethers.provider();\n          provider.getBalance(account).then((rawBalance) => {\n            _underlyingBalance[nativeOToken] = ethers.utils.formatUnits(\n              rawBalance._hex,\n              18\n            );\n            count++;\n            formatedData(\"underlyingTokens\");\n            getRewards();\n          });\n        } else {\n          count++;\n          formatedData(\"underlyingTokens\");\n          getRewards();\n        }\n      })\n      .catch((err) => {\n        console.log(err);\n        setTimeout(() => {\n          getWalletBalance();\n        }, 500);\n      });\n  };\n  const getCTokenData = (oToken) => {\n    if (oTokensLength === 0) return;\n    const calls = [\n      {\n        address: oToken.address,\n        name: \"exchangeRate\",\n      },\n      {\n        address: oToken.address,\n        name: \"totalSupply\",\n      },\n      {\n        address: oToken.address,\n        name: \"totalBorrow\",\n      },\n      {\n        address: oToken.address,\n        name: \"accountSnapshot\",\n        params: [account],\n      },\n      {\n        address: oToken.address,\n        name: \"getCash\",\n      },\n      {\n        address: oToken.address,\n        name: \"totalReserve\",\n      },\n      {\n        address: oToken.address,\n        name: \"reserveFactor\",\n      },\n    ];\n    multicall({\n      abi: OTOKEN_ABI,\n      calls,\n      options: {},\n      multicallAddress,\n      provider: Ethers.provider(),\n    })\n      .then((res) => {\n        const exchangeRateStored = res[0]\n          ? ethers.utils.formatUnits(res[0][0]._hex, 18)\n          : \"0\";\n        const userSupply = res[3]\n          ? ethers.utils.formatUnits(\n              res[3][0][0]._hex,\n              oToken.underlyingToken.decimals\n            )\n          : \"0\";\n        const totalSupply = res[1]\n          ? ethers.utils.formatUnits(\n              res[1][0]._hex,\n              oToken.underlyingToken.decimals\n            )\n          : \"0\";\n        _cTokensData[oToken.address] = {\n          ...oToken,\n          exchangeRateStored,\n          totalSupply: Big(totalSupply).mul(exchangeRateStored).toString(),\n          totalBorrows: res[2]\n            ? ethers.utils.formatUnits(\n                res[2][0]._hex,\n                oToken.underlyingToken.decimals\n              )\n            : \"0\",\n          userSupply: Big(userSupply).mul(exchangeRateStored).toString(),\n          userBorrow: res[3]\n            ? ethers.utils.formatUnits(\n                res[3][0][1]._hex,\n                oToken.underlyingToken.decimals\n              )\n            : \"0\",\n        };\n        const rateCalls = [\n          {\n            address: rateModelSlopeAddress,\n            name: \"getBorrowRate\",\n            params: [res[4][0], res[2][0], res[5][0] || \"0\"],\n          },\n          {\n            address: rateModelSlopeAddress,\n            name: \"getSupplyRate\",\n            params: [res[4][0], res[2][0], res[5][0] || \"0\", res[6][0]],\n          },\n        ];\n        multicall({\n          abi: RATE_ABI,\n          calls: rateCalls,\n          options: {},\n          multicallAddress,\n          provider: Ethers.provider(),\n        })\n          .then((rateRes) => {\n            oTokensLength--;\n            _cTokensData[oToken.address].borrowRatePerTimestamp = rateRes[0]\n              ? ethers.utils.formatUnits(rateRes[0][0]._hex || \"0\", 18)\n              : \"0\";\n            _cTokensData[oToken.address].supplyRatePerTimestamp = rateRes[1]\n              ? ethers.utils.formatUnits(rateRes[1][0]._hex || \"0\", 18)\n              : \"0\";\n            if (oTokensLength === 0) {\n              count++;\n              formatedData(\"oTokens data\");\n            }\n          })\n          .catch((err) => {\n            console.log(\"oTokens data err\", err);\n            // setTimeout(() => {\n            //   getCTokenData(oToken);\n            // }, 1000);\n          });\n      })\n      .catch(() => {\n        setTimeout(() => {\n          getCTokenData(oToken);\n        }, 1000);\n      });\n  };\n  const getCTokensData = () => {\n    Object.values(markets).forEach((market) => {\n      getCTokenData(market);\n    });\n  };\n  const getRewards = () => {\n    const PriceToken = new ethers.Contract(\n      oracleAddress,\n      ORACLE_ABI,\n      Ethers.provider().getSigner()\n    );\n    PriceToken.priceOf(rewardToken.address).then((priceRes) => {\n      const price = Big(ethers.utils.formatUnits(priceRes._hex, 18)).toString();\n      getUserRewards(price);\n    });\n  };\n  const getUserRewards = (price) => {\n    const cTokens = Object.keys(markets);\n    const calls = cTokens.map((cToken) => ({\n      address: distributionAddress,\n      name: \"apyDistributionOf\",\n      params: [cToken, account],\n    }));\n    calls.push({\n      address: distributionAddress,\n      name: \"accuredLAB\",\n      params: [cTokens, account],\n    });\n    multicall({\n      abi: DISTRIBUTION_ABI,\n      calls,\n      options: {},\n      multicallAddress,\n      provider: Ethers.provider(),\n    })\n      .then((res) => {\n        _accountRewards.price = price;\n        for (let i = 0; i < res.length; i++) {\n          if (i === res.length - 1) {\n            const accured = res[i]\n              ? ethers.utils.formatUnits(res[i][0]._hex, 18)\n              : \"0\";\n            _accountRewards.reward = accured;\n            count++;\n            formatedData(\"rewards\");\n            return;\n          }\n          _rewardsApy[cTokens[i]] = {\n            apySupply: res[i]\n              ? ethers.utils.formatUnits(res[i][0][0]._hex, 16)\n              : \"0\",\n            apyBorrow: res[i]\n              ? ethers.utils.formatUnits(res[i][0][1]._hex, 16)\n              : \"0\",\n            apyAccountSupply: res[i]\n              ? ethers.utils.formatUnits(res[i][0][2]._hex, 16)\n              : \"0\",\n            apyAccountBorrow: res[i]\n              ? ethers.utils.formatUnits(res[i][0][3]._hex, 16)\n              : \"0\",\n          };\n        }\n      })\n      .catch((err) => {\n        console.log(\"error-rewards\", err);\n      });\n  };\n\n  getUnitrollerData();\n  getWalletBalance();\n  getCTokensData();\n}, [update, account]);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/bluebiu.near/widget/Lending.Data.LayerBank", "fact_widget_deployments_id": "51fea0735c0324fbbcec275acb6bde2b", "inserted_timestamp": "2024-04-12T10:36:03.279Z", "modified_timestamp": "2024-04-12T10:36:03.279Z", "__row_index": 0}