{"tx_hash": "DSbAVdTtUy8dLNcneUE4tHgLThbSxAmAwH3ZmZgNTxSt", "action_id_social": "FcuzZhSq5JibVdJ7XwsCTH4NQVrhG37fu6qDPr53CHQ-0-widget", "block_id": 120859283, "block_timestamp": "2024-06-10T14:04:13.984Z", "signer_id": "bluebiu.near", "widget_name": "Staking.AgentFi.Liquidity", "source_code": "const StyledContainer = styled.div`\n  position: relative;\n`;\nconst StyledLoadingMask = styled.div`\n  position: absolute;\n  z-index: 1;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n`;\nconst StyledFormItem = styled.div`\n  border-bottom: 1px solid #373A53;\n  padding-bottom: 18px;\n  padding-top: 18px;\n\n  &.inline {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n  }\n\n  &:first-child {\n    padding-top: 0;\n  }\n`;\nconst StyledFormItemTitle = styled.div`\n  font-size: 14px;\n  font-weight: 400;\n  line-height: 17px;\n  color: #979ABE;\n`;\nconst StyledFormItemBody = styled.div`\n  margin-top: 8px;\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  gap: 20px;\n`;\nconst StyledFormItemFoot = styled.div`\n  margin-top: 8px;\n  display: flex;\n  justify-content: space-between;\n  font-size: 12px;\n  font-weight: 400;\n  line-height: 14.4px;\n  color: rgba(151, 154, 190, 1);\n`;\nconst StyledInput = styled.input`\n  flex: 1;\n  width: 0;\n  color: #fff;\n  font-size: 20px;\n  font-weight: 500;\n  border: none;\n  height: 24px;\n  outline: none;\n  background-color: transparent;\n  padding: 0;\n\n  &:focus {\n    color: #fff;\n    background-color: transparent;\n    border-color: transparent;\n    outline: none;\n    box-shadow: none;\n  }\n`;\nconst StyledButton = styled.button`\n  background: var(--switch-color);\n  color: var(--button-text-color);\n\n  display: block;\n  width: 100%;\n  font-size: 16px;\n  font-weight: 600;\n  height: 56px;\n  line-height: 56px;\n  border-radius: 6px;\n  cursor: pointer;\n  transition: 0.5s;\n  margin-top: 20px;\n  text-align: center;\n\n  &:hover {\n    opacity: 0.8;\n  }\n\n  &:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n  }\n`;\nconst StyledFullSelect = styled.div`\n  width: 100%;\n\n  > div {\n    width: 100%;\n\n    > div[type=\"button\"] {\n      width: 100%;\n    }\n  }\n`;\nconst StyledPriceRangeList = styled.div`\n  display: flex;\n  justify-content: center;\n  align-items: stretch;\n  flex-wrap: nowrap;\n  gap: 0;\n  border: 1px solid #373A53;\n  border-radius: 6px;\n\n  .min-price,\n  .range-price,\n  .max-price {\n    padding: 8px 16px;\n    display: flex;\n    flex-direction: column;\n    justify-content: center;\n    align-items: center;\n    gap: 8px;\n  }\n\n  .min-price {\n  }\n\n  .range-price {\n    border-left: 1px solid #373A53;\n  }\n\n  .max-price {\n    border-left: 1px solid #373A53;\n  }\n\n  .range-value {\n    color: #ffffff;\n    font-size: 18px;\n    font-weight: bold;\n  }\n\n  .range-label {\n    color: #979ABE;\n    font-size: 14px;\n  }\n`;\n\nconst DEPOSIT_POOL_ABI = [\n  {\n    inputs: [\n      {\n        components: [\n          { internalType: \"address\", name: \"manager\", type: \"address\" },\n          { internalType: \"address\", name: \"pool\", type: \"address\" },\n          { internalType: \"uint24\", name: \"slippageLiquidity\", type: \"uint24\" },\n          { internalType: \"int24\", name: \"tickLower\", type: \"int24\" },\n          { internalType: \"int24\", name: \"tickUpper\", type: \"int24\" },\n          { internalType: \"uint160\", name: \"sqrtPriceX96\", type: \"uint160\" },\n        ],\n        name: \"mintParams\",\n        type: \"tuple\",\n      },\n      {\n        components: [\n          { internalType: \"address\", name: \"token\", type: \"address\" },\n          { internalType: \"uint256\", name: \"amount\", type: \"uint256\" },\n        ],\n        name: \"deposit0\",\n        type: \"tuple\",\n      },\n      {\n        components: [\n          { internalType: \"address\", name: \"token\", type: \"address\" },\n          { internalType: \"uint256\", name: \"amount\", type: \"uint256\" },\n        ],\n        name: \"deposit1\",\n        type: \"tuple\",\n      },\n    ],\n    name: \"createConcentratedLiquidityAgentAndExplorerAndRefundExcess\",\n    outputs: [],\n    stateMutability: \"payable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { internalType: \"address\", name: \"manager\", type: \"address\" },\n          { internalType: \"address\", name: \"pool\", type: \"address\" },\n          { internalType: \"uint24\", name: \"slippageLiquidity\", type: \"uint24\" },\n          { internalType: \"int24\", name: \"tickLower\", type: \"int24\" },\n          { internalType: \"int24\", name: \"tickUpper\", type: \"int24\" },\n          { internalType: \"uint160\", name: \"sqrtPriceX96\", type: \"uint160\" },\n        ],\n        name: \"mintParams\",\n        type: \"tuple\",\n      },\n      {\n        components: [\n          { internalType: \"address\", name: \"token\", type: \"address\" },\n          { internalType: \"uint256\", name: \"amount\", type: \"uint256\" },\n        ],\n        name: \"deposit0\",\n        type: \"tuple\",\n      },\n      {\n        components: [\n          { internalType: \"address\", name: \"token\", type: \"address\" },\n          { internalType: \"uint256\", name: \"amount\", type: \"uint256\" },\n        ],\n        name: \"deposit1\",\n        type: \"tuple\",\n      },\n      { internalType: \"address\", name: \"rootAgentAddress\", type: \"address\" },\n    ],\n    name: \"createConcentratedLiquidityAgentForRootAndRefundExcess\",\n    outputs: [],\n    stateMutability: \"payable\",\n    type: \"function\",\n  },\n];\n\nconst { parseUnits, formatUnits } = ethers.utils;\n\nconst {\n  prices,\n  currentStrategy,\n  dexConfig,\n  getTokenBalance,\n  rootAgent,\n  onSuccess,\n  addAction,\n  toast,\n  chainId,\n  handleApprove,\n  tickToPrice,\n  priceToUsableTick,\n  QUERY_POOL_ABI,\n} = props;\n\nconst { StakeTokens } = dexConfig;\n\nconst actionText = \"Stake\";\n\nState.init({\n  currentDex: currentStrategy.meta.dexList[0],\n  currentFeeTier: currentStrategy.meta.feeTierList[0],\n  pending: false,\n\n  currentEthToken: {},\n  ethAmount: \"\",\n  ethTokens: [],\n  currentEthTokenBalance: 0,\n\n  currentUsdToken: {},\n  usdAmount: \"\",\n  usdTokens: [],\n  currentUsdTokenBalance: 0,\n\n  slippage: 20,\n\n  minPrice: 0,\n  maxPrice: 0,\n  sqrtPriceX96: 0,\n\n  currentEth2UsdPrice: 0,\n});\n\nconst queryPoolInfo = ({ fee, token0, token1 }) => {\n  State.update({ pending: true });\n  fee = fee || state.currentFeeTier;\n  token0 = token0 || state.currentEthToken;\n  token1 = token1 || state.currentUsdToken;\n  const contract = new ethers.Contract(\n    fee.pool,\n    QUERY_POOL_ABI,\n    Ethers.provider().getSigner(),\n  );\n  const params = [];\n  contract.slot0(...params).then((poolAddress) => {\n    const [sqrtPriceX96, tick] = poolAddress;\n    const currentEth2UsdPrice = tickToPrice({ tick, token0, token1 });\n    const currentUsd2EthPrice = tickToPrice({ tick, token0: token1, token1: token0 });\n    State.update({\n      currentEth2UsdPrice,\n      currentUsd2EthPrice,\n      sqrtPriceX96,\n      pending: false,\n    });\n  }).catch((err) => {\n    console.log('queryPoolInfo failed, ', err);\n    State.update({ pending: false });\n  });\n};\n\nconst handleEthAmount = (ev) => {\n  if (isNaN(Number(ev.target.value))) return;\n  let amount = ev.target.value.replace(/\\s+/g, \"\");\n\n  if (!amount) {\n    State.update({\n      ethAmount: \"\",\n      usdAmount: \"\",\n    });\n    return;\n  }\n\n  if (Big(amount || 0).gt(Big(state.currentEthTokenBalance || 0))) {\n    amount = Big(state.currentEthTokenBalance || 0).toFixed(4, 0);\n  }\n  State.update({\n    ethAmount: amount,\n    usdAmount: Big(amount).times(state.currentEth2UsdPrice).toFixed(state.currentUsdToken.decimals, 0),\n  });\n};\n\nconst handleEthToken = (option) => {\n  if (option.value === state.currentEthToken.value) return;\n  State.update({\n    currentEthToken: option,\n    ethAmount: \"\",\n  });\n  const currToken = StakeTokens.find((it) => it.symbol === option.value);\n  currToken && getTokenBalance(currToken).then((value) => {\n    State.update({\n      currentEthTokenBalance: value,\n    });\n  });\n  queryPoolInfo({ token0: option });\n};\n\nconst handleEthBalance = (value) => {\n  // auto enter usd amount\n  const updates = {\n    ethAmount: Big(value).toFixed(4, 0),\n  };\n  updates.usdAmount = Big(updates.ethAmount).times(state.currentEth2UsdPrice).toFixed(state.currentUsdToken.decimals, 0);\n  State.update(updates);\n};\n\nconst handleFeeTier = (option) => {\n  if (state.currentFeeTier.value === option.value) return;\n  State.update({\n    currentFeeTier: option,\n  });\n  queryPoolInfo({ fee: option });\n};\n\nconst formatAddAction = (actionText, _amount, status, transactionHash, tokenSymbol) => {\n  addAction?.({\n    type: \"Staking\",\n    action: actionText,\n    token: {\n      symbol: tokenSymbol,\n    },\n    amount: _amount,\n    template: props.name,\n    add: false,\n    status,\n    transactionHash,\n  });\n};\n\nconst handleSubmit = () => {\n  const tickLower = priceToUsableTick({\n    price: state.minPrice,\n    token0: state.currentEthToken,\n    token1: state.currentUsdToken,\n    fee: state.currentFeeTier.value,\n  });\n  const tickUpper = priceToUsableTick({\n    price: state.maxPrice,\n    token0: state.currentEthToken,\n    token1: state.currentUsdToken,\n    fee: state.currentFeeTier.value,\n  });\n  const [_tickLower, _tickUpper] = tickLower > tickUpper ? [tickUpper, tickLower] : [tickLower, tickUpper];\n\n  if (Big(state.ethAmount).lte(0) || Big(state.usdAmount).lte(0)) return;\n  // if rootAgent.agentAddress: use createConcentratedLiquidityAgentForRootAndRefundExcess\n  // else: use createConcentratedLiquidityAgentAndExplorerAndRefundExcess\n  State.update({\n    pending: true,\n  });\n  const approveList = [\n    handleApprove(currentStrategy.meta.contract, state.currentEthToken.address, state.ethAmount, state.currentEthToken.decimals),\n    handleApprove(currentStrategy.meta.contract, state.currentUsdToken.address, state.usdAmount, state.currentUsdToken.decimals),\n  ];\n  Promise.all(approveList).then((approveRes) => {\n    if (approveRes.some((approved) => !approved)) {\n      State.update({\n        pending: false,\n      });\n      return;\n    }\n    let method = \"createConcentratedLiquidityAgentAndExplorerAndRefundExcess\";\n    const params = [\n      [\n        // manager\n        state.currentDex.contract,\n        // pool\n        state.currentFeeTier.pool,\n        // slippageLiquidity\n        1000000,\n        // tickLower\n        _tickLower,\n        // tickUpper\n        _tickUpper,\n        // sqrtPriceX96\n        state.sqrtPriceX96,\n      ],\n      [\n        // token\n        state.currentUsdToken.address,\n        // amount\n        parseUnits(state.usdAmount, state.currentUsdToken.decimals),\n      ],\n      [\n        // token\n        state.currentEthToken.address,\n        // amount\n        parseUnits(state.ethAmount, state.currentEthToken.decimals),\n      ],\n    ];\n\n    if (rootAgent && rootAgent.agentAddress) {\n      // rootAgentAddress\n      params.push(rootAgent.agentAddress);\n      method = \"createConcentratedLiquidityAgentForRootAndRefundExcess\";\n    }\n\n    const contract = new ethers.Contract(\n      currentStrategy.meta.contract,\n      DEPOSIT_POOL_ABI,\n      Ethers.provider().getSigner(),\n    );\n\n    const getTx = (gas) => {\n      const contractOption = {\n        gasLimit: gas || 4000000,\n        value: parseUnits(state.ethAmount, state.currentEthToken.decimals),\n      };\n      contract[method](...params, contractOption)\n        .then((tx) => {\n          tx.wait()\n            .then((res) => {\n              const { status, transactionHash } = res;\n              State.update({\n                pending: false,\n              });\n              if (status !== 1) throw new Error(\"\");\n              onSuccess();\n              formatAddAction(actionText, state.ethAmount, status, transactionHash, state.currentEthToken.value);\n              toast?.success({\n                title: `${actionText} Successfully!`,\n                text: `${actionText} ${Big(state.ethAmount).toFixed(2)} ${state.currentEthToken.value} & ${Big(state.usdAmount).toFixed(2)} ${state.currentUsdToken.value}`,\n                tx: transactionHash,\n                chainId,\n              });\n            })\n            .catch((err) => {\n              console.log(\"tx error: \", err);\n              State.update({\n                pending: false,\n              });\n              toast?.fail({\n                title: `${actionText} Failed!`,\n                text: err?.message?.includes(\"user rejected transaction\")\n                  ? \"User rejected transaction\"\n                  : ``,\n              });\n            });\n        })\n        .catch((err) => {\n          console.log(\"contract fn error: \", err);\n          State.update({\n            pending: false,\n          });\n          toast?.fail({\n            title: `${actionText} Failed!`,\n            text: err?.message?.includes(\"user rejected transaction\")\n              ? \"User rejected transaction\"\n              : ``,\n          });\n        });\n    };\n\n    const estimateGas = () => {\n      contract.estimateGas[method](\n        ...params,\n        { value: parseUnits(state.ethAmount, state.currentEthToken.decimals) },\n      ).then((gas) => {\n        getTx(gas);\n      }).catch((err) => {\n        console.log(\"get gas failed: \", err);\n        getTx();\n      });\n    };\n\n    estimateGas();\n  });\n};\n\nconst handleDex = (option) => {\n  State.update({\n    currentDex: option,\n  });\n};\n\nconst handleUsdAmount = (ev) => {\n  if (isNaN(Number(ev.target.value))) return;\n  let amount = ev.target.value.replace(/\\s+/g, \"\");\n\n  if (!amount) {\n    State.update({\n      ethAmount: \"\",\n      usdAmount: \"\",\n    });\n    return;\n  }\n\n  if (Big(amount || 0).gt(Big(state.currentUsdTokenBalance || 0))) {\n    amount = Big(state.currentUsdTokenBalance || 0).toFixed(4, 0);\n  }\n  State.update({\n    usdAmount: amount,\n    ethAmount: Big(amount).div(state.currentEth2UsdPrice).toFixed(state.currentEthToken.decimals, 0),\n  });\n};\n\nconst handleUsdToken = (option) => {\n  if (option.value === state.currentUsdToken.value) return;\n  State.update({\n    currentUsdToken: option,\n    usdAmount: \"\",\n    ethAmount: \"\",\n  });\n  const currToken = StakeTokens.find((it) => it.symbol === option.value);\n  currToken && getTokenBalance(currToken).then((value) => {\n    State.update({\n      currentUsdTokenBalance: value,\n    });\n  });\n};\n\nconst handleUsdBalance = (value) => {\n  // auto enter eth amount\n  const updates = {\n    usdAmount: Big(value).toFixed(4, 0),\n  };\n  updates.ethAmount = Big(updates.usdAmount).div(state.currentEth2UsdPrice).toFixed(state.currentEthToken.decimals, 0);\n  State.update(updates);\n};\n\nconst handleSlippageChange = (value) => {\n  if (isNaN(Number(value))) {\n    State.update({\n      slippage: 1,\n    });\n    return;\n  }\n  let amount = value.replace(/\\s+/g, \"\");\n\n  if (!amount) {\n    State.update({\n      slippage: 1,\n    });\n    return;\n  }\n\n  if (Big(amount).lte(0)) {\n    State.update({\n      slippage: 1,\n    });\n    return;\n  }\n\n  if (Big(amount).gt(50)) {\n    State.update({\n      slippage: 50,\n    });\n    return;\n  }\n\n  State.update({\n    slippage: Math.floor(amount),\n  });\n};\n\nconst {\n  pending,\n  currentDex,\n  currentFeeTier,\n  ethAmount,\n  currentEthToken,\n  ethTokens,\n  currentEthTokenBalance,\n  usdAmount,\n  usdTokens,\n  currentUsdToken,\n  currentUsdTokenBalance,\n  slippage,\n  currentEth2UsdPrice,\n  minPrice,\n  maxPrice,\n} = state;\n\nuseEffect(() => {\n  const _ethTokens = [];\n  const _usdTokens = [];\n  const EthStakeTokens = StakeTokens.filter((it) => [\"ETH\", \"WETH\"].includes(it.symbol));\n  const UsdStakeTokens = StakeTokens.filter((it) => [\"USDB\"].includes(it.symbol));\n  EthStakeTokens.forEach((it) => {\n    _ethTokens.push({\n      ...it,\n      text: it.symbol,\n      value: it.symbol,\n      icons: [it.icon],\n      address: it.address === \"native\" ? \"0x0000000000000000000000000000000000000000\" : it.address,\n    });\n  });\n  UsdStakeTokens.forEach((it) => {\n    _usdTokens.push({\n      ...it,\n      text: it.symbol,\n      value: it.symbol,\n      icons: [it.icon],\n    });\n  });\n  State.update({\n    ethTokens: _ethTokens,\n    currentEthToken: _ethTokens[0],\n    usdTokens: _usdTokens,\n    currentUsdToken: _usdTokens[0],\n  });\n  getTokenBalance(EthStakeTokens[0]).then((value) => {\n    State.update({\n      currentEthTokenBalance: value,\n    });\n  });\n  getTokenBalance(UsdStakeTokens[0]).then((value) => {\n    State.update({\n      currentUsdTokenBalance: value,\n    });\n  });\n  queryPoolInfo({\n    fee: currentStrategy.meta.feeTierList[0],\n    token0: _ethTokens[0],\n    token1: _usdTokens[0],\n  });\n}, []);\n\nuseEffect(() => {\n  const slippageValue = Big(currentEth2UsdPrice).times(Big(slippage).div(100)).div(2);\n  const _minPrice = Math.floor(Big(currentEth2UsdPrice).minus(slippageValue).toNumber());\n  const _maxPrice = Math.floor(Big(currentEth2UsdPrice).plus(slippageValue).toNumber());\n  State.update({\n    minPrice: _minPrice,\n    maxPrice: _maxPrice,\n  });\n}, [currentEth2UsdPrice, slippage]);\n\nreturn (\n  <StyledContainer>\n    {\n      pending && (\n        <StyledLoadingMask>\n          <Widget src=\"bluebiu.near/widget/Lending.Spinner\" />\n        </StyledLoadingMask>\n      )\n    }\n    <StyledFormItem>\n      <StyledFormItemTitle>\n        DEX\n      </StyledFormItemTitle>\n      <StyledFormItemBody>\n        <StyledFullSelect>\n          <Widget\n            src=\"bluebiu.near/widget/UI.Select.Index\"\n            props={{\n              options: currentStrategy.meta.dexList,\n              value: currentDex,\n              onChange: handleDex,\n            }}\n          />\n        </StyledFullSelect>\n      </StyledFormItemBody>\n    </StyledFormItem>\n    <StyledFormItem>\n      <StyledFormItemTitle>\n        Pool Fee Tier\n      </StyledFormItemTitle>\n      <StyledFormItemBody>\n        <StyledFullSelect>\n          <Widget\n            src=\"bluebiu.near/widget/UI.Select.Index\"\n            props={{\n              options: currentStrategy.meta.feeTierList,\n              value: currentFeeTier,\n              onChange: handleFeeTier,\n            }}\n          />\n        </StyledFullSelect>\n      </StyledFormItemBody>\n    </StyledFormItem>\n    <StyledFormItem>\n      <StyledFormItemTitle>\n        Assets and Amounts\n      </StyledFormItemTitle>\n      <StyledFormItemBody>\n        <StyledInput\n          type=\"text\"\n          placeholder=\"0\"\n          value={ethAmount}\n          onChange={handleEthAmount}\n        />\n        <Widget\n          src=\"bluebiu.near/widget/UI.Select.Index\"\n          props={{\n            options: ethTokens,\n            value: currentEthToken,\n            onChange: handleEthToken,\n          }}\n        />\n      </StyledFormItemBody>\n      <StyledFormItemFoot>\n        <div className=\"prices\">\n          ${Big(ethAmount || 0).times(Big(prices[currentEthToken.value] || 1)).toFixed(2, 0)}\n        </div>\n        <div className=\"balance\">\n          Balance:\n          <Widget\n            src=\"bluebiu.near/widget/Staking.Kelp.Balance\"\n            props={{\n              value: currentEthTokenBalance,\n              digit: 5,\n              onClick: handleEthBalance,\n              symbol: currentEthToken.value,\n            }}\n          />\n        </div>\n      </StyledFormItemFoot>\n      <StyledFormItemBody>\n        <StyledInput\n          type=\"text\"\n          placeholder=\"0\"\n          value={usdAmount}\n          onChange={handleUsdAmount}\n        />\n        <Widget\n          src=\"bluebiu.near/widget/UI.Select.Index\"\n          props={{\n            options: usdTokens,\n            value: currentUsdToken,\n            onChange: handleUsdToken,\n          }}\n        />\n      </StyledFormItemBody>\n      <StyledFormItemFoot>\n        <div className=\"prices\">\n          ${Big(usdAmount || 0).times(Big(prices[currentUsdToken.value] || 1)).toFixed(2, 0)}\n        </div>\n        <div className=\"balance\">\n          Balance:\n          <Widget\n            src=\"bluebiu.near/widget/Staking.Kelp.Balance\"\n            props={{\n              value: currentUsdTokenBalance,\n              digit: 5,\n              onClick: handleUsdBalance,\n              symbol: currentUsdToken.value,\n            }}\n          />\n        </div>\n      </StyledFormItemFoot>\n    </StyledFormItem>\n    <StyledFormItem>\n      <StyledFormItemTitle>\n        Price Range\n      </StyledFormItemTitle>\n      <StyledFormItemBody style={{ justifyContent: \"space-between\" }}>\n        <div style={{ width: \"60px\", display: \"flex\" }}>\n          <StyledInput\n            type=\"text\"\n            placeholder=\"LP Range\"\n            value={slippage}\n            onChange={(e) => handleSlippageChange(e.target.value)}\n          />\n          <span style={{ color: \"#ffffff\" }}>%</span>\n        </div>\n        <div className=\"current-usdb\" style={{ color: \"#fff\" }}>\n          {Big(currentEth2UsdPrice).toFixed(0)} USDB\n        </div>\n        <StyledPriceRangeList>\n          <div className=\"min-price\">\n            <span className=\"range-value\">{minPrice}</span>\n            <span className=\"range-label\">min</span>\n          </div>\n          <div className=\"range-price\">\n            <span className=\"range-value\">{slippage}%</span>\n            <span className=\"range-label\">range</span>\n          </div>\n          <div className=\"max-price\">\n            <span className=\"range-value\">{maxPrice}</span>\n            <span className=\"range-label\">max</span>\n          </div>\n        </StyledPriceRangeList>\n      </StyledFormItemBody>\n    </StyledFormItem>\n\n    <StyledButton\n      disabled={pending || !ethAmount}\n      onClick={handleSubmit}\n    >\n      {pending ? (\n        <Widget\n          src=\"bluebiu.near/widget/0vix.LendingLoadingIcon\"\n          props={{\n            size: 16,\n          }}\n        />\n      ) : (ethAmount ? \"Launch Strategy\" : \"Enter Deposit Amount\")}\n    </StyledButton>\n  </StyledContainer>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/bluebiu.near/widget/Staking.AgentFi.Liquidity", "fact_widget_deployments_id": "709c539756a477773b5225501fdf820e", "inserted_timestamp": "2024-06-10T16:05:32.153Z", "modified_timestamp": "2024-06-10T16:05:32.153Z", "__row_index": 2}