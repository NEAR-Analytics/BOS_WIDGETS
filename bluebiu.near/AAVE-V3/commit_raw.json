{"tx_hash": "97SCwboHZ6EdpURwuwLAJRzsAto1k4a1d9UpHkfZnKU3", "action_id_social": "CEDRUq3vMi3H47TtqK5r8ZWLxgkUCHUdBHWKDC8jpFqf-0-widget", "block_id": 116621641, "block_timestamp": "2024-04-11T16:40:18.608Z", "signer_id": "bluebiu.near", "widget_name": "AAVE-V3", "source_code": "const Wrap = styled.div`\n  padding: 24px 15px;\n  /* background: #0e0e26; */\n  min-height: 100vh;\n  color: white;\n  font-family: Gantari;\n`;\n\nconst FlexContainer = styled.div``;\n\nconst ChainsWrap = styled.div`\n  display: flex;\n  justify-content: flex-end;\n`;\nconst Yours = styled.div`\n  display: flex;\n  gap: 20px;\n  margin-top: 16px;\n`;\nconst YoursTableWrapper = styled.div`\n  background-color: rgba(53, 55, 73, 0.2);\n  border-radius: 6px;\n  width: 50%;\n`;\nconst Title = styled.div`\n  padding: 10px 20px 0;\n  /* border-bottom: 1px solid #292c42; */\n`;\nconst SubTitle = styled.div`\n  display: flex;\n  align-items: center;\n`;\nconst Label = styled.div`\n  color: #979abe;\n  font-size: 16px;\n  font-weight: 400;\n  margin-right: 5px;\n`;\nconst Value = styled.div`\n  color: #fff;\n  font-size: 16px;\n  font-weight: 500;\n  margin-right: 15px;\n`;\n\nconst ROUND_DOWN = 0;\nconst NATIVE_SYMBOL_ADDRESS_MAP_KEY = \"0x0\";\nconst ACTUAL_BORROW_AMOUNT_RATE = 0.99;\n\nconst account = Ethers.send(\"eth_requestAccounts\", [])[0];\nconst {\n  CHAIN_LIST,\n  curChain,\n  onSwitchChain,\n  GAS_LIMIT_RECOMMENDATIONS,\n  chainId,\n  prices,\n  multicallAddress,\n  multicall,\n  isChainSupported,\n  switchingChain,\n  dexConfig,\n  theme,\n  toast,\n  addAction,\n} = props;\nconst { CONTRACT_ABI } = dexConfig;\nconsole.log(\"PROPS: \", props);\n\nfunction isValid(a) {\n  if (!a) return false;\n  if (isNaN(Number(a))) return false;\n  if (a === \"\") return false;\n  return true;\n}\n\nfunction getGasPrice() {\n  return Ethers.provider().getGasPrice();\n}\n\nfunction gasEstimation(action) {\n  const assetsToSupply = state.assetsToSupply;\n  if (!assetsToSupply) {\n    return \"-\";\n  }\n  const baseAsset = assetsToSupply.find(\n    (asset) => asset.symbol === config.nativeCurrency.symbol\n  );\n  if (!baseAsset) {\n    return \"-\";\n  }\n\n  const { tokenPrice, decimals } = baseAsset;\n  return getGasPrice()\n    .then((gasPrice) => {\n      const gasLimit = GAS_LIMIT_RECOMMENDATIONS[action].limit;\n      // console.log(\"gasPrice--\", gasPrice);\n      return Big(gasPrice.toString())\n        .mul(gasLimit)\n        .div(Big(10).pow(decimals))\n        .mul(tokenPrice)\n        .toFixed(2);\n    })\n    .catch((err) => {\n      console.log(\"gasEstimation error\");\n    });\n}\n\nfunction depositETHGas() {\n  return gasEstimation(\"deposit\");\n}\n\nfunction depositERC20Gas() {\n  return gasEstimation(\"supplyWithPermit\");\n}\n\nfunction withdrawETHGas() {\n  return gasEstimation(\"withdrawETH\");\n}\n\nfunction withdrawERC20Gas() {\n  return gasEstimation(\"withdraw\");\n}\n\nfunction borrowETHGas() {\n  return gasEstimation(\"borrowETH\");\n}\n\nfunction borrowERC20Gas() {\n  return gasEstimation(\"borrow\");\n}\n\nfunction repayETHGas() {\n  return gasEstimation(\"repay\");\n}\n\nfunction repayERC20Gas() {\n  return gasEstimation(\"repayWithPermit\");\n}\nfunction formatNumber(value, digits) {\n  return Big(value || 0).lt(0.01)\n    ? \"< $0.01\"\n    : `$ ${Number(value).toFixed(digits || 2)}`;\n}\n\n// App config\nfunction getConfig() {\n  const abis = {\n    wrappedTokenGatewayV3ABI: fetch(CONTRACT_ABI.wrappedTokenGatewayV3ABI),\n    erc20Abi: fetch(CONTRACT_ABI.erc20Abi),\n    aavePoolV3ABI: fetch(CONTRACT_ABI.aavePoolV3ABI),\n    variableDebtTokenABI: fetch(CONTRACT_ABI.variableDebtTokenABI),\n    walletBalanceProviderABI: fetch(CONTRACT_ABI.walletBalanceProviderABI),\n  };\n\n  const constants = {\n    FIXED_LIQUIDATION_VALUE: \"1.0\",\n    MAX_UINT_256:\n      \"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\",\n    AAVE_API_BASE_URL: \"https://aave-data-service-7a85eea3aebe.herokuapp.com\",\n  };\n\n  return {\n    ...dexConfig.config,\n    ...abis,\n    ...constants,\n  };\n}\n\nconst config = getConfig();\n// console.log(\"CONFIG: \", config);\n\nconst markets = dexConfig?.rawMarkets?.map((item) => ({\n  ...item,\n  tokenPrice: prices[item.symbol],\n}));\nconst underlyingTokens = dexConfig?.rawMarkets?.map(\n  (market) => market.underlyingAsset\n);\n\n// App states\nState.init({\n  imports: {},\n\n  showWithdrawModal: false,\n  showSupplyModal: false,\n  showRepayModal: false,\n  showBorrowModal: false,\n\n  threshold: 1,\n  assetsToSupply: markets,\n  yourSupplies: undefined,\n  yourBorrows: undefined,\n  netWorthUSD: \"\",\n  netAPY: \"\",\n  healthFactor: \"\",\n  availableBorrowsUSD: \"\",\n\n  selectTab: \"MARKET\", // MARKET | YOURS\n  fresh: 0, // fresh rewards\n  yourSupplyApy: 0,\n  yourBorrowApy: 0,\n  yourTotalCollateral: 0,\n\n  emissionPerSeconds: [],\n  aTokenTotal: [],\n  debtTotal: [],\n  poolData: [],\n\n  step1: false,\n  step2: false,\n\n  updater: 0,\n});\n\nfunction calcAvailableBorrows(availableBorrowsUSD, tokenPrice) {\n  let r =\n    isValid(availableBorrowsUSD) && isValid(tokenPrice)\n      ? Big(availableBorrowsUSD || 0)\n          .div(tokenPrice)\n          .toFixed()\n      : Number(0).toFixed();\n\n  return r;\n}\n\nfunction bigMin(_a, _b) {\n  const a = Big(_a || 0);\n  const b = Big(_b || 0);\n  return a.gt(b) ? b : a;\n}\n\nfunction formatHealthFactor(hf) {\n  if (hf === \"\u221e\") return hf;\n\n  if (!hf || !isValid(hf)) return \"-\";\n\n  if (Big(hf).gt(10000)) return \"\u221e\";\n  if (Number(hf) === -1) return \"\u221e\";\n  return Big(hf).toFixed(2, ROUND_DOWN);\n}\n\nfunction calcHealthFactor(type, symbol, amount) {\n  // console.log(\n  //   \"calcHealthFactor\",\n  //   type,\n  //   symbol,\n  //   amount,\n  //   isValid(state.yourTotalCollateral),\n  //   isValid(state.yourTotalBorrow),\n  //   isValid(amount)\n  // );\n  if (\n    // !isValid(state.yourTotalCollateral) ||\n    // !isValid(state.yourTotalBorrow) ||\n    isNaN(Number(state.yourTotalCollateral)) ||\n    isNaN(Number(state.yourTotalBorrow)) ||\n    !isValid(amount)\n  )\n    return \"-\";\n  let newHealthFactor;\n  let totalCollateral = Big(state.yourTotalCollateral);\n  let totalBorrows = Big(state.yourTotalBorrow);\n\n  const assetsUSD = Big(prices[symbol]).times(Big(amount));\n  if (type === \"SUPPLY\") {\n    totalCollateral = Big(state.yourTotalCollateral).plus(assetsUSD);\n  }\n  if (type === \"INC_COLLATERAL\") {\n    totalCollateral = Big(state.yourTotalCollateral).plus(assetsUSD);\n  }\n  if (type === \"WITHDRAW\") {\n    totalCollateral = Big(state.yourTotalCollateral).minus(assetsUSD);\n  }\n  if (type === \"DEC_COLLATERAL\") {\n    totalCollateral = Big(state.yourTotalCollateral).minus(assetsUSD);\n  }\n  if (type === \"BORROW\") {\n    totalBorrows = Big(state.yourTotalBorrow).plus(assetsUSD);\n  }\n  if (type === \"REPAY\") {\n    totalBorrows = Big(state.yourTotalBorrow).minus(assetsUSD);\n  }\n  if (totalBorrows.eq(0)) return \"\u221e\";\n  newHealthFactor = totalCollateral\n    .times(Big(state.threshold))\n    .div(totalBorrows);\n\n  console.log(\"calcHealthFactor--\", newHealthFactor);\n  return newHealthFactor.toFixed(2);\n}\n\nfunction batchBalanceOf(chainId, userAddress, tokenAddresses, abi) {\n  const balanceProvider = new ethers.Contract(\n    config.balanceProviderAddress,\n    abi.body,\n    Ethers.provider().getSigner()\n  );\n\n  return balanceProvider.batchBalanceOf([userAddress], tokenAddresses);\n}\n\nfunction getLiquidity() {\n  const aTokenAddresss = markets?.map((item) => item.aTokenAddress);\n  const variableDebtTokenAddresss = markets?.map(\n    (item) => item.variableDebtTokenAddress\n  );\n\n  const calls = aTokenAddresss\n    .map((addr) => ({\n      address: addr,\n      name: \"totalSupply\",\n    }))\n    .concat(\n      variableDebtTokenAddresss?.map((addr) => ({\n        address: addr,\n        name: \"totalSupply\",\n      }))\n    );\n\n  multicall({\n    abi: [\n      {\n        inputs: [],\n        name: \"totalSupply\",\n        outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n      },\n    ],\n    calls,\n    options: {},\n    multicallAddress,\n    provider: Ethers.provider(),\n  })\n    .then((res) => {\n      try {\n        console.log(\"getLiquidity_res\", res);\n        const l = res.length;\n        const aTokenTotal = res.slice(0, l / 2);\n        const debtTotal = res.slice(l / 2);\n\n        const _assetsToSupply = [...state.assetsToSupply];\n        for (let i = 0; i < _assetsToSupply.length; i++) {\n          const liquidityAmount = Big(aTokenTotal[i] || 0)\n            .minus(Big(debtTotal[i] || 0))\n            .toFixed();\n\n          _assetsToSupply[i].availableLiquidity = liquidityAmount;\n          _assetsToSupply[i].availableLiquidityUSD = Big(\n            ethers.utils.formatUnits(\n              liquidityAmount,\n              _assetsToSupply[i].decimals\n            )\n          )\n            .mul(Big(prices[_assetsToSupply[i].symbol]) || 0)\n            .toFixed();\n\n          const _availableBorrowsUSD = bigMin(\n            state.availableBorrowsUSD,\n            ethers.utils.formatUnits(\n              liquidityAmount,\n              _assetsToSupply[i].decimals\n            )\n          )\n            .times(ACTUAL_BORROW_AMOUNT_RATE)\n            .toFixed();\n\n          const availableBorrows = calcAvailableBorrows(\n            _availableBorrowsUSD,\n            _assetsToSupply[i].tokenPrice\n          );\n\n          _assetsToSupply[i].availableBorrowsUSD = _availableBorrowsUSD;\n          _assetsToSupply[i].availableBorrows = availableBorrows;\n        }\n        State.update({\n          assetsToSupply: _assetsToSupply,\n          aTokenTotal,\n          debtTotal,\n        });\n      } catch (error) {\n        console.log(\"catch getLiquidity\", error);\n      }\n    })\n    .catch((err) => {\n      console.log(\"getLiquidity_err\", err);\n    });\n}\n// update data in async manner\nfunction getUserBalance() {\n  // check abi loaded\n  if (\n    Object.keys(CONTRACT_ABI)\n      ?.map((key) => config[key])\n      .filter((ele) => !!ele).length !== Object.keys(CONTRACT_ABI).length\n  ) {\n    return;\n  }\n  const provider = Ethers.provider();\n  provider\n    .getSigner()\n    ?.getBalance()\n    .then((balance) => {\n      return balance;\n    })\n    .then((baseAssetBalance) => {\n      // get user balances\n      batchBalanceOf(\n        chainId,\n        account,\n        markets?.map((market) => market.underlyingAsset),\n        config.walletBalanceProviderABI\n      )\n        .then((balances) => {\n          return balances?.map((balance) => balance.toString());\n        })\n        .then((userBalances) => {\n          console.log(\"getUserBalance--\", userBalances);\n          const _assetsToSupply = [...state.assetsToSupply];\n          for (let index = 0; index < _assetsToSupply.length; index++) {\n            const item = _assetsToSupply[index];\n            const _bal =\n              item.symbol === config.nativeCurrency.symbol\n                ? baseAssetBalance\n                : userBalances[index];\n            const balanceRaw = Big(_bal || 0).div(Big(10).pow(item.decimals));\n            const _balance = balanceRaw.toFixed(item.decimals, ROUND_DOWN);\n\n            const _balanceInUSD = balanceRaw\n              .mul(item.tokenPrice || 0)\n              .toFixed(3, ROUND_DOWN);\n            item.balance = _balance;\n            item.balanceInUSD = _balanceInUSD;\n          }\n\n          State.update({\n            assetsToSupply: _assetsToSupply,\n          });\n        })\n        .catch((err) => {\n          console.log(\"batchBalanceOfERROR:\", err);\n        });\n    });\n}\n\nfunction onActionSuccess({ msg, callback }) {\n  console.log(\"onActionSuccess--\");\n  // update data if action finishes\n  getUserBalance();\n\n  State.update({\n    step1: false,\n    step2: false,\n    updater: state.updater + 1,\n  });\n  // update UI after data has almost loaded\n  setTimeout(() => {\n    if (callback) {\n      callback();\n    }\n    if (msg) {\n      State.update({ alertModalText: msg });\n    }\n  }, 5000);\n}\n\nfunction getPoolDataProvider() {\n  const underlyingTokens = dexConfig?.rawMarkets?.map(\n    (market) => market.underlyingAsset\n  );\n  // console.log(\"getPoolDataProvider--\", underlyingTokens);\n  const calls = underlyingTokens?.map((addr) => ({\n    address: config.PoolDataProvider,\n    name: \"getReserveData\",\n    params: [addr],\n  }));\n\n  multicall({\n    abi: [\n      {\n        inputs: [{ internalType: \"address\", name: \"asset\", type: \"address\" }],\n        name: \"getReserveData\",\n        outputs: [\n          { internalType: \"uint256\", name: \"unbacked\", type: \"uint256\" },\n          {\n            internalType: \"uint256\",\n            name: \"accruedToTreasuryScaled\",\n            type: \"uint256\",\n          },\n          { internalType: \"uint256\", name: \"totalAToken\", type: \"uint256\" },\n          {\n            internalType: \"uint256\",\n            name: \"totalStableDebt\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"totalVariableDebt\",\n            type: \"uint256\",\n          },\n          { internalType: \"uint256\", name: \"liquidityRate\", type: \"uint256\" },\n          {\n            internalType: \"uint256\",\n            name: \"variableBorrowRate\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"stableBorrowRate\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"averageStableBorrowRate\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"liquidityIndex\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"variableBorrowIndex\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint40\",\n            name: \"lastUpdateTimestamp\",\n            type: \"uint40\",\n          },\n        ],\n        stateMutability: \"view\",\n        type: \"function\",\n      },\n    ],\n    calls,\n    options: {},\n    multicallAddress,\n    provider: Ethers.provider(),\n  })\n    .then((res) => {\n      console.log(\"getPoolDataProvider_res\", res);\n\n      State.update({\n        poolData: res,\n      });\n    })\n    .catch((err) => {\n      console.log(\"getPoolDataProvider_err\", err);\n    });\n}\n// seamless use\nfunction getPoolDataProviderTotalSupply() {\n  const prevAssetsToSupply = [...state.assetsToSupply];\n\n  const underlyingTokens = dexConfig?.rawMarkets?.map(\n    (market) => market.underlyingAsset\n  );\n  // console.log(\"getPoolDataProviderTotalSupply--\", underlyingTokens);\n  const calls = underlyingTokens?.map((addr) => ({\n    address: config.PoolDataProvider,\n    name: \"getATokenTotalSupply\",\n    params: [addr],\n  }));\n\n  multicall({\n    abi: [\n      {\n        inputs: [{ internalType: \"address\", name: \"asset\", type: \"address\" }],\n        name: \"getATokenTotalSupply\",\n        outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n      },\n    ],\n    calls,\n    options: {},\n    multicallAddress,\n    provider: Ethers.provider(),\n  })\n    .then((res) => {\n      console.log(\"getPoolDataProviderTotal_res\", res);\n\n      for (let i = 0; i < res.length; i++) {\n        const _totalSupply = ethers.utils.formatUnits(\n          res[i][0],\n          prevAssetsToSupply[i].decimals\n        );\n        prevAssetsToSupply[i].totalSupply = _totalSupply;\n        // console.log(\n        //   \"_totalSupply--\",\n        //   _totalSupply,\n        //   prevAssetsToSupply[i].symbol,\n        //   prices[prevAssetsToSupply[i].symbol]\n        // );\n        prevAssetsToSupply[i].totalSupplyUSD = Big(_totalSupply || 0)\n          .times(prices[prevAssetsToSupply[i].symbol])\n          .toFixed();\n      }\n      State.update({\n        assetsToSupply: prevAssetsToSupply,\n      });\n    })\n    .catch((err) => {\n      console.log(\"getPoolDataProviderTotal_err\", err);\n    });\n}\n// seamless use\nfunction getPoolDataProviderTotalDebt() {\n  const prevAssetsToSupply = [...state.assetsToSupply];\n\n  const underlyingTokens = dexConfig?.rawMarkets?.map(\n    (market) => market.underlyingAsset\n  );\n  // console.log(\"getPoolDataProviderTotalDebt--\", underlyingTokens);\n  const calls = underlyingTokens?.map((addr) => ({\n    address: config.PoolDataProvider,\n    name: \"getTotalDebt\",\n    params: [addr],\n  }));\n\n  multicall({\n    abi: [\n      {\n        inputs: [{ internalType: \"address\", name: \"asset\", type: \"address\" }],\n        name: \"getTotalDebt\",\n        outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n      },\n    ],\n    calls,\n    options: {},\n    multicallAddress,\n    provider: Ethers.provider(),\n  })\n    .then((res) => {\n      console.log(\"getPoolDataProviderTotal_res\", res);\n\n      for (let i = 0; i < res.length; i++) {\n        const _totalDebts = ethers.utils.formatUnits(\n          res[i][0],\n          prevAssetsToSupply[i].decimals\n        );\n        prevAssetsToSupply[i].totalDebts = _totalDebts;\n        prevAssetsToSupply[i].totalDebtsUSD = Big(_totalDebts)\n          .times(prices[prevAssetsToSupply[i].symbol])\n          .toFixed();\n      }\n      State.update({\n        assetsToSupply: prevAssetsToSupply,\n      });\n    })\n    .catch((err) => {\n      console.log(\"getPoolDataProviderTotal_err\", err);\n    });\n}\nfunction getPoolDataProviderCaps() {\n  const prevAssetsToSupply = [...state.assetsToSupply];\n\n  const underlyingTokens = dexConfig?.rawMarkets?.map(\n    (market) => market.underlyingAsset\n  );\n  // console.log(\"getPoolDataProviderCaps--\", underlyingTokens);\n  const calls = underlyingTokens?.map((addr) => ({\n    address: config.PoolDataProvider,\n    name: \"getReserveCaps\",\n    params: [addr],\n  }));\n\n  multicall({\n    abi: [\n      {\n        inputs: [{ internalType: \"address\", name: \"asset\", type: \"address\" }],\n        name: \"getReserveCaps\",\n        outputs: [\n          { internalType: \"uint256\", name: \"borrowCap\", type: \"uint256\" },\n          { internalType: \"uint256\", name: \"supplyCap\", type: \"uint256\" },\n        ],\n        stateMutability: \"view\",\n        type: \"function\",\n      },\n    ],\n    calls,\n    options: {},\n    multicallAddress,\n    provider: Ethers.provider(),\n  })\n    .then((res) => {\n      console.log(\"getPoolDataProviderCaps_res\", res);\n\n      for (let i = 0; i < res.length; i++) {\n        const [borrowCap, supplyCap] = res[i];\n\n        prevAssetsToSupply[i].borrowCap = borrowCap.toNumber();\n        prevAssetsToSupply[i].borrowCapUSD = Big(borrowCap)\n          .times(prices[prevAssetsToSupply[i].symbol])\n          .toFixed();\n        prevAssetsToSupply[i].supplyCap = supplyCap.toNumber();\n        prevAssetsToSupply[i].supplyCapUSD = Big(supplyCap)\n          .times(prices[prevAssetsToSupply[i].symbol])\n          .toFixed();\n      }\n      State.update({\n        assetsToSupply: prevAssetsToSupply,\n      });\n    })\n    .catch((err) => {\n      console.log(\"getPoolDataProviderCaps_err\", err);\n    });\n}\n\nfunction getUserAccountData() {\n  const contract = new ethers.Contract(\n    config.aavePoolV3Address,\n    config.aavePoolV3ABI.body,\n    Ethers.provider()\n  );\n  contract\n    .getUserAccountData(account)\n    .then((res) => {\n      console.log(\"getUserAccountData_res:\", res);\n      const [\n        totalCollateralBase,\n        totalDebtBase,\n        availableBorrowsBase,\n        currentLiquidationThreshold,\n        ltv,\n        healthFactor,\n      ] = res;\n\n      const totalDebtBaseUSD = ethers.utils.formatUnits(\n        totalDebtBase.toString(),\n        8\n      );\n\n      const totalCollateralBaseUSD = ethers.utils.formatUnits(\n        totalCollateralBase.toString(),\n        8\n      );\n      const threshold = ethers.utils.formatUnits(\n        currentLiquidationThreshold.toString(),\n        4\n      );\n\n      const _totalCollateralBaseUSD = Big(totalCollateralBaseUSD).times(\n        Big(threshold)\n      );\n      const BorrowPowerUsed = Big(totalDebtBaseUSD || 0)\n        .div(_totalCollateralBaseUSD.eq(0) ? 1 : _totalCollateralBaseUSD)\n        .times(100)\n        .toFixed();\n      // console.log(\n      //   \"HF--\",\n      //   ethers.utils.formatUnits(healthFactor),\n      //   formatHealthFactor(ethers.utils.formatUnits(healthFactor))\n      // );\n      State.update({\n        step2: true,\n        threshold,\n        currentLiquidationThreshold,\n        BorrowPowerUsed,\n        healthFactor: !totalCollateralBase.toNumber()\n          ? formatHealthFactor(0)\n          : formatHealthFactor(ethers.utils.formatUnits(healthFactor)),\n\n        availableBorrowsUSD: ethers.utils.formatUnits(availableBorrowsBase, 8),\n      });\n    })\n    .catch((err) => {\n      console.log(\"getUserAccountData_error\", err);\n    });\n}\nfunction valueToBigNumber(amount) {\n  if (amount instanceof BigNumber) {\n    return amount;\n  }\n\n  return new BigNumber(amount);\n}\nconst LTV_PRECISION = 4;\n// return  HealthFactorFromBalanceRequest): BigNumber\nfunction calculateHealthFactorFromBalances({\n  borrowBalanceMarketReferenceCurrency,\n  collateralBalanceMarketReferenceCurrency,\n  currentLiquidationThreshold,\n}) {\n  if (valueToBigNumber(borrowBalanceMarketReferenceCurrency).eq(0)) {\n    return valueToBigNumber(\"-1\"); // Invalid number\n  }\n\n  return valueToBigNumber(collateralBalanceMarketReferenceCurrency)\n    .multipliedBy(currentLiquidationThreshold)\n    .shiftedBy(LTV_PRECISION * -1)\n    .div(borrowBalanceMarketReferenceCurrency || 1);\n}\n\nfunction getYourSupplies() {\n  const aTokenAddresss = markets?.map((item) => item.aTokenAddress);\n\n  const calls = aTokenAddresss?.map((addr) => ({\n    address: addr,\n    name: \"balanceOf\",\n    params: [account],\n  }));\n  multicall({\n    abi: [\n      {\n        inputs: [\n          {\n            internalType: \"address\",\n            name: \"user\",\n            type: \"address\",\n          },\n        ],\n        name: \"balanceOf\",\n        outputs: [\n          {\n            internalType: \"uint256\",\n            name: \"\",\n            type: \"uint256\",\n          },\n        ],\n        stateMutability: \"view\",\n        type: \"function\",\n      },\n    ],\n    calls,\n    options: {},\n    multicallAddress,\n    provider: Ethers.provider(),\n  })\n    .then((res) => {\n      console.log(\"getUsetDeposits_res\", res);\n      let userDeposits = [];\n      for (let index = 0; index < res.length; index++) {\n        if (res[index]) {\n          // let underlyingBalance=\n          let market = state.assetsToSupply.find(\n            (item) => item.aTokenAddress === aTokenAddresss[index]\n          );\n          if (!market) return;\n\n          let _bal = ethers.utils.formatUnits(res[index][0], market.decimals);\n          market.underlyingBalance = _bal;\n          market.underlyingBalanceUSD = Big(_bal)\n            .mul(prices[market.symbol])\n            .toFixed();\n          userDeposits.push(market);\n        }\n      }\n      const mm = state.assetsToSupply.reduce((prev, cur) => {\n        prev[cur.underlyingAsset] = cur;\n        return prev;\n      }, {});\n      const _yourSupplies = userDeposits?.map((userDeposit) => {\n        const market = mm[userDeposit.underlyingAsset];\n\n        return {\n          ...market,\n          ...userDeposit,\n          ...(market.symbol === config.nativeCurrency.symbol\n            ? {\n                ...config.nativeCurrency,\n                supportPermit: true,\n              }\n            : {}),\n        };\n      });\n      let obj = {};\n      const yourSupplies = _yourSupplies.reduce((prev, cur) => {\n        obj[cur.aTokenAddress]\n          ? \"\"\n          : (obj[cur.aTokenAddress] = true && prev.push(cur));\n        return prev;\n      }, []);\n      console.log(\"yourSupplies:\", yourSupplies);\n      // State.update({\n      //   yourSupplies,\n      // });\n      return yourSupplies;\n    })\n    .then((_yourSupplies) => {\n      if (!_yourSupplies || !_yourSupplies.length) return;\n      const calls = [\n        {\n          address: config.aavePoolV3Address,\n          name: \"getUserConfiguration\",\n          params: [account],\n        },\n        {\n          address: config.aavePoolV3Address,\n          name: \"getReservesList\",\n        },\n      ];\n\n      multicall({\n        abi: config.aavePoolV3ABI.body,\n        calls,\n        options: {},\n        multicallAddress,\n        provider: Ethers.provider(),\n      })\n        .then((res) => {\n          console.log(\"getCollateralStatus-res:\", res);\n          const [[rawStatus], [addrs]] = res;\n          const _status = parseInt(rawStatus.toString()).toString(2).split(\"\");\n          // console.log(\"_status--\", _status);\n          const _statusArray = chunk(_status, 2);\n          // console.log(\"_status--\", _statusArray, addrs, _yourSupplies);\n\n          for (let i = 0; i < _yourSupplies.length; i++) {\n            const item = _yourSupplies[i];\n\n            const index = addrs.findIndex(\n              (addr) =>\n                addr.toLowerCase() === item.underlyingAsset.toLowerCase()\n            );\n\n            _yourSupplies[i].isCollateraled = Number(_statusArray[index][0]);\n          }\n\n          const yourTotalCollateral = _yourSupplies\n            .filter((item) => item.isCollateraled === 1)\n            .reduce(\n              (prev, curr) =>\n                Big(prev)\n                  .plus(Big(curr.underlyingBalanceUSD || 0))\n                  .toFixed(),\n              0\n            );\n\n          State.update((prev) => ({\n            ...prev,\n            yourSupplies: _yourSupplies,\n            yourTotalCollateral,\n          }));\n        })\n        .catch((err) => {\n          console.log(\"getCollateralStatus-error:\", err);\n        });\n    })\n    .catch((err) => {\n      console.log(\"getUsetDeposits_err\", err);\n    });\n}\n\nfunction getUserDebts() {\n  const variableDebtTokenAddresss = markets?.map(\n    (item) => item.variableDebtTokenAddress\n  );\n\n  const calls = variableDebtTokenAddresss?.map((addr) => ({\n    address: addr,\n    name: \"balanceOf\",\n    params: [account],\n  }));\n\n  multicall({\n    abi: [\n      {\n        inputs: [\n          {\n            internalType: \"address\",\n            name: \"user\",\n            type: \"address\",\n          },\n        ],\n        name: \"balanceOf\",\n        outputs: [\n          {\n            internalType: \"uint256\",\n            name: \"\",\n            type: \"uint256\",\n          },\n        ],\n        stateMutability: \"view\",\n        type: \"function\",\n      },\n    ],\n    calls,\n    options: {},\n    multicallAddress,\n    provider: Ethers.provider(),\n  })\n    .then((res) => {\n      console.log(\"getUserDebts_res\", res);\n      let userDebs = [];\n      const _assetsToSupply = [...state.assetsToSupply];\n      for (let index = 0; index < res.length; index++) {\n        if (res[index]) {\n          let market = _assetsToSupply.find(\n            (item) =>\n              item.variableDebtTokenAddress === variableDebtTokenAddresss[index]\n          );\n\n          let _debt = ethers.utils.formatUnits(res[index][0], market.decimals);\n\n          market.debt = _debt;\n          market.debtInUSD = Big(_debt || 0)\n            .mul(prices[market.symbol] || 1)\n            .toFixed();\n          userDebs.push(market);\n        }\n      }\n      let hash = {};\n      let _yourBorrows = userDebs.reduce((accum, item) => {\n        hash[item[\"aTokenAddress\"]]\n          ? \"\"\n          : (hash[item[\"aTokenAddress\"]] = true && accum.push(item));\n        return accum;\n      }, []);\n\n      console.log(\"yourBorrows--\", _yourBorrows);\n      State.update({\n        yourBorrows: _yourBorrows,\n      });\n    })\n    .catch((err) => {\n      console.log(\"getUserDebts_err\", err);\n    });\n}\n\nfunction chunk(arr, size) {\n  let result = [];\n\n  let temp = [];\n  for (let i = arr.length - 1; i > -1; i--) {\n    temp.unshift(arr[i]);\n    if (temp.length === size) {\n      result.push(temp);\n\n      temp = [];\n    }\n  }\n  if (temp.length !== 0) result.push(temp);\n  return result;\n}\n\nuseEffect(() => {\n  if (!account || !isChainSupported) return;\n  getUserBalance();\n  getUserAccountData();\n\n  getPoolDataProvider();\n  if (dexConfig.name === \"Seamless Protocol\") {\n    getPoolDataProviderTotalSupply();\n    getPoolDataProviderTotalDebt();\n    getPoolDataProviderCaps();\n  }\n  if (state.step1) {\n    getYourSupplies();\n    getUserDebts();\n  }\n}, [account, isChainSupported, state.step1, updater]);\n\nuseEffect(() => {\n  if (state.step2) {\n    getLiquidity();\n  }\n}, [state.step2]);\n\nuseEffect(() => {\n  console.log(\"CALC APY\");\n  if (!Array.isArray(state.poolData) || !state.poolData.length) return;\n\n  const _assetsToSupply = [...state.assetsToSupply];\n\n  for (let i = 0; i < state.poolData.length; i++) {\n    if (state.poolData[i]) {\n      const [\n        unbacked,\n        accruedToTreasuryScaled,\n        totalAToken,\n        totalStableDebt,\n        totalVariableDebt,\n        liquidityRate,\n        variableBorrowRate,\n        stableBorrowRate,\n        averageStableBorrowRate,\n        liquidityIndex,\n        variableBorrowIndex,\n        lastUpdateTimestamp,\n      ] = state.poolData[i];\n      const RAY = Big(10).pow(27);\n      const SECONDS_PER_YEAR = 31_536_000;\n      const depositAPR = Big(liquidityRate).div(RAY || 1);\n      const depositAPY0 = Big(1)\n        .plus(depositAPR.div(Big(SECONDS_PER_YEAR)))\n        .toNumber();\n\n      const _supplyAPY = Big(\n        Math.pow(depositAPY0, SECONDS_PER_YEAR) - 1\n      ).toFixed();\n      console.log(\n        \"_supplyAPY--\",\n        _supplyAPY,\n        _assetsToSupply,\n        i,\n        _assetsToSupply[i]\n      );\n\n      if (!_assetsToSupply[i]) return;\n      const variableBorrowAPR = Big(variableBorrowRate).div(RAY || 1);\n\n      const variableBorrowAPY0 = Big(1)\n        .plus(Big(variableBorrowAPR).div(Big(SECONDS_PER_YEAR)))\n        .toNumber();\n\n      const _borrowAPY = Big(\n        Math.pow(variableBorrowAPY0, SECONDS_PER_YEAR) - 1\n      ).toFixed();\n\n      _assetsToSupply[i].supplyAPY = _supplyAPY;\n      _assetsToSupply[i].borrowAPY = _borrowAPY;\n    }\n  }\n  State.update({\n    assetsToSupply: _assetsToSupply,\n  });\n}, [state.poolData]);\n\nuseEffect(() => {\n  if (!account || !isChainSupported) return;\n  if (dexConfig.name !== \"Seamless Protocol\") return;\n  if (!Array.isArray(state.assetsToSupply)) return;\n  console.log(\"calc totalMarketSize\");\n  const totalMarketSize = state.assetsToSupply.reduce((prev, curr) => {\n    return Big(prev).plus(Big(curr.totalSupplyUSD)).toFixed();\n  }, 0);\n  const totalBorrows = state.assetsToSupply.reduce((prev, curr) => {\n    return Big(prev).plus(Big(curr.totalDebtsUSD)).toFixed();\n  }, 0);\n  const totalAvailable = Big(totalMarketSize)\n    .minus(Big(totalBorrows))\n    .toFixed();\n  State.update({\n    totalMarketSize,\n    totalAvailable,\n    totalBorrows,\n  });\n}, [account, isChainSupported, state.assetsToSupply]);\n\nuseEffect(() => {\n  if (!account || !isChainSupported) return;\n\n  // console.log(\"dexConfig--\", dexConfig);\n  // if (dexConfig.rewardToken) {\n  //   getAllUserRewards();\n  //   fetchRewardsData();\n  // }\n}, [account, isChainSupported, fresh]);\n\nuseEffect(() => {\n  console.log(\n    \"calc reward apy\",\n    state.emissionPerSeconds,\n    state.aTokenTotal,\n    state.debtTotal\n  );\n  if (\n    !state.emissionPerSeconds.length ||\n    !state.aTokenTotal.length ||\n    !state.debtTotal.length\n  )\n    return;\n  const RWARD_TOKEN_DECIMALS = Math.pow(10, 18);\n  const SECONDS_PER_YEAR = 31536000;\n  let rewardTokenPrice = 0;\n  if (dexConfig.name === \"ZeroLend\") {\n    rewardTokenPrice = 0.00025055;\n  }\n  if (dexConfig.name === \"Seamless Protocol\") {\n    rewardTokenPrice = prices[\"SEAM\"];\n  }\n\n  try {\n    const _assetsToSupply = [...state.assetsToSupply];\n    for (let i = 0; i < _assetsToSupply.length; i++) {\n      let tokenTotalSupplyNormalized = ethers.utils.formatUnits(\n        state.aTokenTotal[i].toString(),\n        _assetsToSupply[i].decimals\n      );\n      let tokenTotalBorrowNormalized = ethers.utils.formatUnits(\n        state.debtTotal[i].toString(),\n        _assetsToSupply[i].decimals\n      );\n      let normalizedEmissionPerSecond = Big(state.emissionPerSeconds[i][1]).div(\n        Big(RWARD_TOKEN_DECIMALS)\n      );\n\n      let normalizedTotalTokenSupply = Big(tokenTotalSupplyNormalized).times(\n        Big(prices[_assetsToSupply[i].symbol])\n      );\n      let normalizedTotalTokenBorrow = Big(tokenTotalBorrowNormalized).times(\n        Big(prices[_assetsToSupply[i].symbol])\n      );\n\n      let supplyRewardApy = normalizedEmissionPerSecond\n        .times(Big(rewardTokenPrice))\n        .times(SECONDS_PER_YEAR)\n        .div(normalizedTotalTokenSupply)\n        .toFixed();\n\n      let borrowRewardApy = normalizedEmissionPerSecond\n        .times(Big(rewardTokenPrice))\n        .times(SECONDS_PER_YEAR)\n        .div(normalizedTotalTokenBorrow)\n        .toFixed();\n      console.log(\"supplyRewardApy---\", supplyRewardApy);\n      _assetsToSupply[i].supplyRewardApy = supplyRewardApy;\n      if (dexConfig.name === \"ZeroLend\") {\n        _assetsToSupply[i].borrowRewardApy = borrowRewardApy;\n      }\n\n      State.update({\n        assetsToSupply: _assetsToSupply,\n        step1: true,\n      });\n    }\n  } catch (error) {\n    console.log(\"CATCH:\", error);\n  }\n}, [state.emissionPerSeconds, state.aTokenTotal, state.debtTotal]);\n\nuseEffect(() => {\n  if (!state.step1) return;\n  // if (![\"ZeroLend\", \"AAVE V3\"].includes(dexConfig.name)) return;\n\n  if (!state.yourSupplies || !state.yourBorrows) return;\n  console.log(\"calc net apy\", state.yourSupplies, state.yourBorrows);\n  //calc net worth\n  const supplyBal = state.yourSupplies.reduce(\n    (total, cur) =>\n      Big(total || 0)\n        .plus(cur.underlyingBalanceUSD)\n        .toFixed(),\n    0\n  );\n  console.log(\"supplyBal--\", supplyBal);\n  const debtsBal = state.yourBorrows.reduce(\n    (total, cur) =>\n      Big(total || 0)\n        .plus(cur.debtInUSD)\n        .toFixed(),\n    0\n  );\n  console.log(\"debtsBal--\", debtsBal, supplyBal);\n  const netWorth = Big(supplyBal || 0)\n    .minus(debtsBal)\n    .toFixed(2, ROUND_DOWN);\n  console.log(\"netWorth--\", netWorth, state.yourSupplies);\n  if (!Number(netWorth)) return;\n\n  //calc net apy\n\n  const weightedAverageSupplyAPY = state.yourSupplies.reduce(\n    (total, cur) =>\n      Big(total || 0)\n        .plus(\n          Big(cur.underlyingBalanceUSD || 0)\n            .times(Big(cur.supplyAPY || 0))\n            .div(supplyBal || 1)\n        )\n        .toFixed(),\n    0\n  );\n  const yourSupplyRewardAPY = state.yourSupplies.reduce((total, cur) => {\n    return Big(total || 0)\n      .plus(Big(cur.supplyRewardApy || 0))\n      .toFixed();\n  }, 0);\n\n  console.log(\"weightedAverageSupplyAPY--\", weightedAverageSupplyAPY);\n  const weightedAverageBorrowsAPY = state.yourBorrows.reduce((total, cur) => {\n    return Big(total || 0)\n      .plus(\n        Big(cur.debtInUSD)\n          .times(Big(cur.borrowAPY))\n          .div(debtsBal || 1)\n      )\n      .toFixed();\n  }, 0);\n  console.log(\"weightedAverageBorrowsAPY--\", weightedAverageBorrowsAPY);\n\n  const a = Big(weightedAverageSupplyAPY || 0)\n    .times(supplyBal)\n    .div(netWorth || 1)\n    .toFixed();\n  console.log(\"a--\", a);\n  const b = Big(weightedAverageBorrowsAPY || 0)\n    .times(debtsBal)\n    .div(netWorth || 1)\n    .toFixed();\n  console.log(\"b--\", b);\n  const netAPY = Big(a).minus(Big(b)).toFixed();\n  console.log(\"netAPY--\", netAPY);\n  const yourTotalSupply = state.yourSupplies.reduce(\n    (prev, curr) =>\n      Big(prev)\n        .plus(Big(curr.underlyingBalanceUSD || 0))\n        .toFixed(),\n    0\n  );\n  console.log(\"yourTotalSupply--\", yourTotalSupply);\n\n  const yourTotalBorrow = state.yourBorrows.reduce(\n    (prev, curr) =>\n      Big(prev)\n        .plus(Big(curr.debtInUSD || 0))\n        .toFixed(),\n    0\n  );\n  console.log(\"yourTotalBorrow--\", yourTotalBorrow);\n\n  State.update((prev) => ({\n    ...prev,\n    netAPY,\n    netWorthUSD: netWorth,\n    yourTotalSupply,\n    yourTotalBorrow,\n    yourSupplyApy: Big(weightedAverageSupplyAPY)\n      .plus(yourSupplyRewardAPY)\n      .toFixed(),\n    yourBorrowApy: weightedAverageBorrowsAPY,\n  }));\n}, [state.yourSupplies, state.yourBorrows, state.step1]);\n\nfunction onSuccess() {\n  State.update({\n    ...state,\n    fresh: state.fresh + 1,\n  });\n}\n\nconsole.log(\"STATE: \", state);\n\nconst body = isChainSupported ? (\n  <Wrap>\n    <FlexContainer>\n      <ChainsWrap>\n        <Widget\n          src=\"bluebiu.near/widget/Lending.Chains\"\n          props={{\n            chains: CHAIN_LIST,\n            curChain,\n            onSwitchChain,\n            // onChange: (tab) => {\n            //   State.update({\n            //     tab: tab.key,\n            //   });\n            // },\n          }}\n        />\n      </ChainsWrap>\n      <Widget\n        src={`${config.ownerId}/widget/AAVE.HeroData`}\n        props={{\n          config,\n          netWorth: `$ ${\n            state.netWorthUSD ? Big(state.netWorthUSD || 0).toFixed(2) : \"-\"\n          }`,\n          netAPY: `${\n            state.netAPY\n              ? Number(\n                  Big(state.netAPY || 0)\n                    .times(100)\n                    .toFixed(2)\n                )\n              : \"-\"\n          }%`,\n          healthFactor: formatHealthFactor(state.healthFactor),\n          totalMarketSize: state.totalMarketSize,\n          totalAvailable: state.totalAvailable,\n          totalBorrows: state.totalBorrows,\n          theme: dexConfig?.theme,\n          yourBorrows: state.yourBorrows,\n        }}\n      />\n    </FlexContainer>\n    <Widget\n      src={`${config.ownerId}/widget/AAVE.TabSwitcher`}\n      props={{\n        config,\n        theme: dexConfig?.theme,\n        select: state.selectTab,\n        setSelect: (tabName) => State.update({ selectTab: tabName }),\n      }}\n    />\n    {state.selectTab === \"MARKET\" && (\n      <>\n        <Widget\n          src={`${config.ownerId}/widget/AAVE.Card.Markets`}\n          props={{\n            formatUSD,\n            config,\n            dexConfig,\n            chainId: chainId,\n            assetsToSupply: state.assetsToSupply,\n            showSupplyModal: state.showSupplyModal,\n            setShowSupplyModal: (isShow) =>\n              State.update({ showSupplyModal: isShow }),\n            onActionSuccess,\n            healthFactor: formatHealthFactor(state.healthFactor),\n            formatHealthFactor,\n            calcHealthFactor,\n            depositETHGas,\n            depositERC20Gas,\n            borrowETHGas,\n            borrowERC20Gas,\n            yourSupplies: state.yourSupplies,\n            yourTotalSupply: state.yourTotalSupply,\n            theme: dexConfig?.theme,\n            addAction,\n            dexConfig,\n          }}\n        />\n      </>\n    )}\n    {state.selectTab === \"YOURS\" && (\n      <>\n        <Yours>\n          <YoursTableWrapper>\n            <Title>\n              You Supplies\n              {state.yourSupplies && state.yourSupplies.length ? (\n                <SubTitle>\n                  <Label>Balance:</Label>\n                  <Value>$ {Number(state.yourTotalSupply).toFixed(2)}</Value>\n\n                  <Label>APY:</Label>\n                  <Value>\n                    {Big(state.yourSupplyApy).times(100).toFixed(2)} %\n                  </Value>\n\n                  <Label>Collateral:</Label>\n                  <Value>\n                    $ {Number(state.yourTotalCollateral).toFixed(2)}\n                  </Value>\n                </SubTitle>\n              ) : null}\n            </Title>\n            <Widget\n              src={`${config.ownerId}/widget/AAVE.Card.YourSupplies`}\n              props={{\n                formatNumber,\n                config,\n                chainId: chainId,\n                yourSupplies: state.yourSupplies,\n                showWithdrawModal: state.showWithdrawModal,\n                setShowWithdrawModal: (isShow) =>\n                  State.update({ showWithdrawModal: isShow }),\n                onActionSuccess,\n                healthFactor: formatHealthFactor(state.healthFactor),\n                formatHealthFactor,\n                calcHealthFactor,\n                withdrawETHGas,\n                withdrawERC20Gas,\n                account,\n                prices,\n                threshold: state.threshold,\n                addAction,\n                dexConfig,\n                yourTotalCollateral: state.yourTotalCollateral,\n                yourTotalBorrow: state.yourTotalBorrow,\n                theme: dexConfig?.theme,\n              }}\n            />\n          </YoursTableWrapper>\n          <YoursTableWrapper>\n            <Title>\n              You Borrows\n              {state.yourBorrows && state.yourBorrows.length ? (\n                <SubTitle>\n                  <Label>Balance:</Label>\n                  <Value>$ {Number(state.yourTotalBorrow).toFixed(2)}</Value>\n\n                  <Label>APY:</Label>\n                  <Value>\n                    {Big(state.yourBorrowApy).times(100).toFixed(2)} %\n                  </Value>\n\n                  <Label>Borrow power used:</Label>\n                  <Value>{Number(state.BorrowPowerUsed).toFixed(2)}%</Value>\n                </SubTitle>\n              ) : null}\n            </Title>\n            <Widget\n              src={`${config.ownerId}/widget/AAVE.Card.YourBorrows`}\n              props={{\n                config,\n                chainId: chainId,\n                assetsToSupply: state.assetsToSupply,\n                yourBorrows: state.yourBorrows,\n                showRepayModal: state.showRepayModal,\n                setShowRepayModal: (isShow) =>\n                  State.update({ showRepayModal: isShow }),\n                showBorrowModal: state.showBorrowModal,\n                setShowBorrowModal: (isShow) =>\n                  State.update({ showBorrowModal: isShow }),\n                formatHealthFactor,\n                calcHealthFactor,\n                onActionSuccess,\n                repayETHGas,\n                repayERC20Gas,\n                borrowETHGas,\n                borrowERC20Gas,\n                addAction,\n                dexConfig,\n                healthFactor: formatHealthFactor(state.healthFactor),\n                theme: dexConfig?.theme,\n              }}\n            />\n          </YoursTableWrapper>\n        </Yours>\n        {dexConfig.rewardToken ? (\n          <Widget\n            src={`${config.ownerId}/widget/AAVE.Card.RewardsTable`}\n            props={{\n              account,\n              config,\n              data: state.rewardData,\n              dapps: dexConfig,\n              onSuccess,\n              markets,\n              prices,\n              formatNumber,\n              rewardAddress: config.incentivesProxy,\n              toast,\n              theme: dexConfig?.theme,\n            }}\n          />\n        ) : null}\n      </>\n    )}\n    {state.alertModalText && (\n      <Widget\n        src={`${config.ownerId}/widget/AAVE.Modal.AlertModal`}\n        props={{\n          config,\n          theme: dexConfig?.theme,\n          title: \"All done!\",\n          description: state.alertModalText,\n          onRequestClose: () => State.update({ alertModalText: false }),\n        }}\n      />\n    )}\n    {dexConfig.data ? (\n      <Widget\n        src={dexConfig.data}\n        props={{\n          // update: state.loading,\n          account,\n          rewardToken: dexConfig.rewardToken,\n          config,\n          wethAddress,\n          multicallAddress,\n          multicall,\n          markets,\n          assetsToSupply: state.assetsToSupply,\n          onLoad: (data) => {\n            console.log(\"DATA_onLoad:\", data);\n            State.update({\n              // loading: false,\n              ...data,\n            });\n          },\n        }}\n      />\n    ) : null}\n  </Wrap>\n) : (\n  <>\n    <ChainsWrap>\n      <Widget\n        src=\"bluebiu.near/widget/Lending.Chains\"\n        props={{\n          chains: CHAIN_LIST,\n          curChain,\n          onSwitchChain,\n          // onChange: (tab) => {\n          //   State.update({\n          //     tab: tab.key,\n          //   });\n          // },\n        }}\n      />\n    </ChainsWrap>\n    <Widget\n      src=\"bluebiu.near/widget/Swap.ChainWarnigBox\"\n      props={{\n        chain: curChain,\n        onSwitchChain: onSwitchChain,\n        switchingChain: switchingChain,\n        theme: dexConfig.theme,\n      }}\n    />\n  </>\n);\n// );\n\nreturn (\n  <div>\n    {/* Component Head */}\n    {/* <Widget\n      src={`${config.ownerId}/widget/Utils.Import`}\n      props={{ modules, onLoad: importFunctions }}\n    /> */}\n\n    {body}\n  </div>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/bluebiu.near/widget/AAVE-V3", "fact_widget_deployments_id": "ea464e6f05c286f278bade213d11b6ea", "inserted_timestamp": "2024-04-11T17:44:28.072Z", "modified_timestamp": "2024-04-11T18:41:57.885Z", "__row_index": 33}