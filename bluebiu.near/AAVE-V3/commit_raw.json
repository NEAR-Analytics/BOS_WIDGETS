{"tx_hash": "APYH1FmWcL9SpFqNjPD1B62jcPQwTZ3R4V1XZwAb3ZMV", "action_id_social": "BGqPYwfu8c22uUCzax5pwUpGsWVJh7egAeXgLQxCBaMp-0-widget", "block_id": 115392436, "block_timestamp": "2024-03-24T19:35:13.737Z", "signer_id": "bluebiu.near", "widget_name": "AAVE-V3", "source_code": "const Wrap = styled.div`\n  padding: 24px 15px;\n  /* background: #0e0e26; */\n  min-height: 100vh;\n  color: white;\n  font-family: Gantari;\n`;\n\nconst FlexContainer = styled.div``;\n\nconst ChainsWrap = styled.div`\n  display: flex;\n  justify-content: flex-end;\n`;\nconst Yours = styled.div`\n  display: flex;\n  gap: 20px;\n  margin-top: 16px;\n`;\nconst YoursTableWrapper = styled.div`\n  background-color: rgba(53, 55, 73, 0.2);\n  border-radius: 6px;\n  width: 50%;\n`;\nconst Title = styled.div`\n  padding: 10px 20px 0;\n  /* border-bottom: 1px solid #292c42; */\n`;\nconst SubTitle = styled.div`\n  display: flex;\n  align-items: center;\n`;\nconst Label = styled.div`\n  color: #979abe;\n  font-size: 16px;\n  font-weight: 400;\n  margin-right: 5px;\n`;\nconst Value = styled.div`\n  color: #fff;\n  font-size: 16px;\n  font-weight: 500;\n  margin-right: 15px;\n`;\n\nconst ROUND_DOWN = 0;\nconst NATIVE_SYMBOL_ADDRESS_MAP_KEY = \"0x0\";\nconst ACTUAL_BORROW_AMOUNT_RATE = 0.99;\n\nconst account = Ethers.send(\"eth_requestAccounts\", [])[0];\nconst {\n  CHAIN_LIST,\n  curChain,\n  onSwitchChain,\n  GAS_LIMIT_RECOMMENDATIONS,\n  chainId,\n  prices,\n  multicallAddress,\n  multicall,\n  isChainSupported,\n  switchingChain,\n  dexConfig,\n  theme,\n  toast,\n} = props;\nconst { CONTRACT_ABI } = dexConfig;\nconsole.log(\"AAVE.V3: \", props);\n\nfunction isValid(a) {\n  if (!a) return false;\n  if (isNaN(Number(a))) return false;\n  if (a === \"\") return false;\n  return true;\n}\n\nfunction getGasPrice() {\n  return Ethers.provider().getGasPrice();\n}\n\nfunction gasEstimation(action) {\n  const assetsToSupply = state.assetsToSupply;\n  if (!assetsToSupply) {\n    return \"-\";\n  }\n  const baseAsset = assetsToSupply.find(\n    (asset) => asset.symbol === config.nativeCurrency.symbol\n  );\n  if (!baseAsset) {\n    return \"-\";\n  }\n\n  const { marketReferencePriceInUsd, decimals } = baseAsset;\n  return getGasPrice().then((gasPrice) => {\n    const gasLimit = GAS_LIMIT_RECOMMENDATIONS[action].limit;\n\n    return Big(gasPrice.toString())\n      .mul(gasLimit)\n      .div(Big(10).pow(decimals))\n      .mul(marketReferencePriceInUsd)\n      .toFixed(2);\n  });\n}\n\nfunction depositETHGas() {\n  return gasEstimation(\"deposit\");\n}\n\nfunction depositERC20Gas() {\n  return gasEstimation(\"supplyWithPermit\");\n}\n\nfunction withdrawETHGas() {\n  return gasEstimation(\"withdrawETH\");\n}\n\nfunction withdrawERC20Gas() {\n  return gasEstimation(\"withdraw\");\n}\n\nfunction borrowETHGas() {\n  return gasEstimation(\"borrowETH\");\n}\n\nfunction borrowERC20Gas() {\n  return gasEstimation(\"borrow\");\n}\n\nfunction repayETHGas() {\n  return gasEstimation(\"repay\");\n}\n\nfunction repayERC20Gas() {\n  return gasEstimation(\"repayWithPermit\");\n}\n\n// App config\nfunction getConfig() {\n  const abis = {\n    wrappedTokenGatewayV3ABI: fetch(CONTRACT_ABI.wrappedTokenGatewayV3ABI),\n    erc20Abi: fetch(CONTRACT_ABI.erc20Abi),\n    aavePoolV3ABI: fetch(CONTRACT_ABI.aavePoolV3ABI),\n    variableDebtTokenABI: fetch(CONTRACT_ABI.variableDebtTokenABI),\n    walletBalanceProviderABI: fetch(CONTRACT_ABI.walletBalanceProviderABI),\n  };\n\n  const constants = {\n    FIXED_LIQUIDATION_VALUE: \"1.0\",\n    MAX_UINT_256:\n      \"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\",\n    AAVE_API_BASE_URL: \"https://aave-data-service-7a85eea3aebe.herokuapp.com\",\n  };\n\n  return {\n    ...dexConfig.config,\n    ...abis,\n    ...constants,\n  };\n}\n\nconst config = getConfig();\n// console.log(\"CONFIG: \", config);\nconst markets = dexConfig?.rawMarkets?.map((item) => ({\n  ...item,\n  marketReferencePriceInUsd: prices[item.symbol],\n}));\nconst underlyingTokens = dexConfig?.rawMarkets?.map(\n  (market) => market.underlyingAsset\n);\n\nfunction getLiquidity() {\n  const aTokenAddresss = markets.map((item) => item.aTokenAddress);\n  const variableDebtTokenAddresss = markets.map(\n    (item) => item.variableDebtTokenAddress\n  );\n\n  const calls = aTokenAddresss\n    .map((addr) => ({\n      address: addr,\n      name: \"totalSupply\",\n    }))\n    .concat(\n      variableDebtTokenAddresss.map((addr) => ({\n        address: addr,\n        name: \"totalSupply\",\n      }))\n    );\n\n  multicall({\n    abi: [\n      {\n        inputs: [],\n        name: \"totalSupply\",\n        outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n      },\n    ],\n    calls,\n    options: {},\n    multicallAddress,\n    provider: Ethers.provider(),\n  })\n    .then((res) => {\n      console.log(\"getLiquidity_res\", res);\n      const l = res.length;\n      const aTokenTotal = res.slice(0, l / 2);\n      const debtTotal = res.slice(l / 2);\n\n      for (let i = 0; i < markets.length; i++) {\n        const liquidityAmount = Big(aTokenTotal[i])\n          .minus(Big(debtTotal[i]))\n          .toFixed();\n        markets[i].availableLiquidity = liquidityAmount;\n        markets[i].availableLiquidityUSD = Big(\n          ethers.utils.formatUnits(liquidityAmount, markets[i].decimals)\n        )\n          .mul(prices[markets[i].symbol])\n          .toFixed();\n      }\n    })\n    .catch((err) => {\n      console.log(\"getLiquidity_err\", err);\n    });\n}\ngetLiquidity();\n\nconst marketsMapping = markets.reduce((prev, cur) => {\n  prev[cur.underlyingAsset] = cur;\n  return prev;\n}, {});\n// console.log(\"marketsMapping: \", marketsMapping);\n\n// const nativeMarket = markets.find(\n//   (market) => market.symbol === config.nativeWrapCurrency.symbol\n// );\n// markets.push({\n//   ...nativeMarket,\n//   ...{\n//     ...config.nativeCurrency,\n//     supportPermit: true,\n//   },\n// });\n// console.log(\"full markerts:\", markets);\n\n// App states\nState.init({\n  imports: {},\n  showWithdrawModal: false,\n  showSupplyModal: false,\n  showRepayModal: false,\n  showBorrowModal: false,\n\n  assetsToSupply: undefined, //[{markets}]\n  yourSupplies: undefined, //[{markets}]\n  netWorthUSD: \"\",\n  totalNetApy: \"\",\n  healthFactor: \"\",\n  assetsToBorrow: {\n    availableBorrowsUSD: \"\",\n    debts: markets,\n    // netApy: \"\",\n  },\n  yourBorrows: {\n    availableBorrowsUSD: \"\",\n    debts: [],\n    // netApy: '',\n  },\n  baseAssetBalance: undefined,\n  selectTab: \"MARKET\", // MARKET | YOURS\n  fresh: 0, // fresh rewards\n});\n\nconst loading =\n  !state.assetsToSupply || !state.yourSupplies || !state.assetsToBorrow;\n\n// Import functions to state.imports\nfunction importFunctions(imports) {\n  if (loading) {\n    State.update({\n      imports,\n    });\n  }\n}\n\n// Define the modules you'd like to import\nconst modules = {\n  number: `${config.ownerId}/widget/Utils.Number`,\n  date: `${config.ownerId}/widget/Utils.Date`,\n  data: `${config.ownerId}/widget/AAVE.Data`,\n};\n// Import functions\n// const { formatAmount } = state.imports.number;\n// const { formatDateTime } = state.imports.date;\n\nfunction calculateAvailableBorrows({\n  availableBorrowsUSD,\n  marketReferencePriceInUsd,\n}) {\n  return isValid(availableBorrowsUSD) && isValid(marketReferencePriceInUsd)\n    ? Big(availableBorrowsUSD || 0)\n        .div(marketReferencePriceInUsd)\n        .toFixed()\n    : Number(0).toFixed();\n}\n\nfunction bigMin(_a, _b) {\n  const a = Big(_a || 0);\n  const b = Big(_b || 0);\n  return a.gt(b) ? b : a;\n}\n\nfunction formatHealthFactor(healthFactor) {\n  if (healthFactor === \"\u221e\") return healthFactor;\n  if (!healthFactor || !isValid(healthFactor)) return \"-\";\n  if (Number(healthFactor) === -1) return \"\u221e\";\n  return Big(healthFactor).toFixed(2, ROUND_DOWN);\n}\n\nfunction batchBalanceOf(chainId, userAddress, tokenAddresses, abi) {\n  const balanceProvider = new ethers.Contract(\n    config.balanceProviderAddress,\n    abi.body,\n    Ethers.provider().getSigner()\n  );\n\n  return balanceProvider.batchBalanceOf([userAddress], tokenAddresses);\n}\n\n// update data in async manner\nfunction updateData(refresh) {\n  // check abi loaded\n  if (\n    Object.keys(CONTRACT_ABI)\n      .map((key) => config[key])\n      .filter((ele) => !!ele).length !== Object.keys(CONTRACT_ABI).length\n  ) {\n    return;\n  }\n  const provider = Ethers.provider();\n  provider\n    .getSigner()\n    ?.getBalance()\n    .then((balance) => State.update({ baseAssetBalance: balance }));\n  if (!account || !state.baseAssetBalance) {\n    return;\n  }\n\n  // get user balances\n  batchBalanceOf(\n    chainId,\n    account,\n    markets.map((market) => market.underlyingAsset),\n    config.walletBalanceProviderABI\n  )\n    .then((balances) => {\n      // console.log(\n      //   \"getBalance\",\n      //   balances,\n      //   balances.map((balance) => balance.toString())\n      // );\n      return balances.map((balance) => balance.toString());\n    })\n    .then((userBalances) => {\n      const assetsToSupply = markets.map((market, idx) => {\n        const _bal =\n          market.symbol === config.nativeCurrency.symbol\n            ? state.baseAssetBalance\n            : userBalances[idx];\n        const balanceRaw = Big(_bal || 0).div(Big(10).pow(market.decimals));\n\n        const balance = balanceRaw.toFixed(market.decimals, ROUND_DOWN);\n\n        const balanceInUSD = balanceRaw\n          .mul(market.marketReferencePriceInUsd || 0)\n          .toFixed(3, ROUND_DOWN);\n\n        const availableBorrowsUSD = bigMin(\n          state.assetsToBorrow.availableBorrowsUSD,\n          market.availableLiquidityUSD\n        )\n          .times(ACTUAL_BORROW_AMOUNT_RATE)\n          .toFixed();\n\n        const availableBorrows = calculateAvailableBorrows({\n          availableBorrowsUSD,\n          marketReferencePriceInUsd: market.marketReferencePriceInUsd,\n        });\n        // console.log(44444, availableBorrows);\n        // item.availableBorrows = availableBorrows;\n\n        return {\n          ...market,\n          availableBorrowsUSD,\n          availableBorrows,\n          balance,\n          balanceInUSD,\n        };\n      });\n      // .sort((asset1, asset2) => {\n      //   const balanceInUSD1 = Number(asset1.balanceInUSD);\n      //   const balanceInUSD2 = Number(asset2.balanceInUSD);\n      //   if (balanceInUSD1 !== balanceInUSD2)\n      //     return balanceInUSD2 - balanceInUSD1;\n      //   return asset1.symbol.localeCompare(asset2.symbol);\n      // });\n\n      State.update({\n        assetsToSupply,\n      });\n      // get user borrow data\n      // updateUserDebts(marketsMapping, assetsToSupply, refresh);\n    })\n    .catch((err) => {\n      console.log(\"batchBalanceOfERROR:\", err);\n    });\n  // get user supplies\n  // updateUserSupplies(marketsMapping, refresh);\n  // });\n}\n\nfunction updateUserDebts(marketsMapping, assetsToSupply, refresh) {\n  if (!marketsMapping || !assetsToSupply) {\n    return;\n  }\n\n  const _assetsToSupply = [...state.assetsToSupply];\n\n  _assetsToSupply.forEach((item) => {\n    const availableBorrowsUSD = bigMin(\n      state.assetsToBorrow.availableBorrowsUSD,\n      item.availableLiquidityUSD\n    )\n      .times(ACTUAL_BORROW_AMOUNT_RATE)\n      .toFixed();\n    console.log(33333, availableBorrowsUSD);\n    item.availableBorrowsUSD = availableBorrowsUSD;\n    const availableBorrows = calculateAvailableBorrows({\n      availableBorrowsUSD,\n      marketReferencePriceInUsd: item.marketReferencePriceInUsd,\n    });\n    console.log(44444, availableBorrows);\n    item.availableBorrows = availableBorrows;\n    item.abcd = 1234;\n  });\n  console.log(222222, _assetsToSupply);\n  State.update({\n    assetsToSupply: _assetsToSupply,\n  });\n  return;\n  const prevYourBorrows = { ...state.yourBorrows };\n\n  // userDebts depends on the balance from assetsToSupply\n  const assetsToSupplyMap = assetsToSupply.reduce((prev, cur) => {\n    if (cur.symbol !== config.nativeCurrency.symbol) {\n      prev[cur.underlyingAsset] = cur;\n    } else {\n      prev[NATIVE_SYMBOL_ADDRESS_MAP_KEY] = cur;\n    }\n    return prev;\n  }, {});\n  console.log(111111, markets, assetsToSupplyMap);\n  const debts = markets\n    .map((userDebt) => {\n      const market = assetsToSupplyMap[userDebt.underlyingAsset];\n\n      if (!market) {\n        return;\n      }\n      const { availableLiquidityUSD } = market;\n      const availableBorrowsUSD = bigMin(\n        state.assetsToBorrow.availableBorrowsUSD,\n        availableLiquidityUSD\n      )\n        .times(ACTUAL_BORROW_AMOUNT_RATE)\n        .toFixed();\n\n      const assetsToSupplyMapKey =\n        market.symbol === config.nativeWrapCurrency.symbol\n          ? NATIVE_SYMBOL_ADDRESS_MAP_KEY\n          : userDebt.underlyingAsset;\n      return {\n        ...market,\n        ...userDebt,\n        ...(market.symbol === config.nativeWrapCurrency.symbol\n          ? {\n              ...config.nativeCurrency,\n              supportPermit: true,\n            }\n          : {}),\n        availableBorrows: calculateAvailableBorrows({\n          availableBorrowsUSD,\n          marketReferencePriceInUsd: market.marketReferencePriceInUsd,\n        }),\n        availableBorrowsUSD,\n        balance: assetsToSupplyMap[assetsToSupplyMapKey].balance,\n        balanceInUSD: assetsToSupplyMap[assetsToSupplyMapKey].balanceInUSD,\n      };\n    })\n    // .filter((asset) => !!asset)\n    // .sort((asset1, asset2) => {\n    //   const availableBorrowsUSD1 = Number(asset1.availableBorrowsUSD);\n    //   const availableBorrowsUSD2 = Number(asset2.availableBorrowsUSD);\n    //   if (availableBorrowsUSD1 !== availableBorrowsUSD2)\n    //     return availableBorrowsUSD2 - availableBorrowsUSD1;\n    //   return asset1.symbol.localeCompare(asset2.symbol);\n    // })\n    .filter((asset) => {\n      return asset.borrowingEnabled;\n    });\n\n  const assetsToBorrow = {\n    ...state.assetsToBorrow,\n    debts,\n  };\n\n  const yourBorrows = {\n    ...assetsToBorrow,\n    debts: assetsToBorrow.debts.filter(\n      (row) =>\n        !isNaN(Number(row.variableBorrowsUSD)) &&\n        Number(row.variableBorrowsUSD) > 0\n    ),\n  };\n\n  State.update({\n    yourBorrows,\n    assetsToBorrow,\n  });\n\n  if (\n    refresh &&\n    JSON.stringify(prevYourBorrows) === JSON.stringify(yourBorrows)\n  ) {\n    console.log(\"refresh borrows again ...\", prevYourBorrows, yourBorrows);\n    setTimeout(updateData, 500);\n  }\n  // });\n}\n\nfunction onActionSuccess({ msg, callback }) {\n  // update data if action finishes\n  updateData(true);\n  // update UI after data has almost loaded\n  setTimeout(() => {\n    if (callback) {\n      callback();\n    }\n    if (msg) {\n      State.update({ alertModalText: msg });\n    }\n  }, 5000);\n}\n\nif (chainId && isChainSupported && loading) {\n  updateData();\n}\n\nfunction getPoolDataProvider() {\n  const _debts = [...state.assetsToBorrow.debts];\n  const prevAssetsToSupply = [...state.assetsToSupply];\n  const prevAssetsToBorrow = { ...state.assetsToBorrow };\n  // const underlyingTokens = prevAssetsToSupply.map(\n  //   (item) => item.underlyingAsset\n  // );\n  const underlyingTokens = dexConfig?.rawMarkets?.map(\n    (market) => market.underlyingAsset\n  );\n\n  const calls = underlyingTokens.map((addr) => ({\n    address: config.PoolDataProvider,\n    name: \"getReserveData\",\n    params: [addr],\n  }));\n\n  multicall({\n    abi: [\n      {\n        inputs: [{ internalType: \"address\", name: \"asset\", type: \"address\" }],\n        name: \"getReserveData\",\n        outputs: [\n          { internalType: \"uint256\", name: \"unbacked\", type: \"uint256\" },\n          {\n            internalType: \"uint256\",\n            name: \"accruedToTreasuryScaled\",\n            type: \"uint256\",\n          },\n          { internalType: \"uint256\", name: \"totalAToken\", type: \"uint256\" },\n          {\n            internalType: \"uint256\",\n            name: \"totalStableDebt\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"totalVariableDebt\",\n            type: \"uint256\",\n          },\n          { internalType: \"uint256\", name: \"liquidityRate\", type: \"uint256\" },\n          {\n            internalType: \"uint256\",\n            name: \"variableBorrowRate\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"stableBorrowRate\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"averageStableBorrowRate\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"liquidityIndex\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"variableBorrowIndex\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint40\",\n            name: \"lastUpdateTimestamp\",\n            type: \"uint40\",\n          },\n        ],\n        stateMutability: \"view\",\n        type: \"function\",\n      },\n    ],\n    calls,\n    options: {},\n    multicallAddress,\n    provider: Ethers.provider(),\n  })\n    .then((res) => {\n      console.log(\"getPoolDataProvider_res\", res);\n\n      for (let i = 0; i < res.length; i++) {\n        if (res[i]) {\n          const [\n            unbacked,\n            accruedToTreasuryScaled,\n            totalAToken,\n            totalStableDebt,\n            totalVariableDebt,\n            liquidityRate,\n            variableBorrowRate,\n            stableBorrowRate,\n            averageStableBorrowRate,\n            liquidityIndex,\n            variableBorrowIndex,\n            lastUpdateTimestamp,\n          ] = res[i];\n          const RAY = Big(10).pow(27);\n          const SECONDS_PER_YEAR = 31_536_000;\n          const depositAPR = Big(liquidityRate).div(RAY);\n          const depositAPY0 = Big(1)\n            .plus(depositAPR.div(Big(SECONDS_PER_YEAR)))\n            .toNumber();\n          const depositAPY = Big(\n            Math.pow(depositAPY0, SECONDS_PER_YEAR) - 1\n          ).toFixed();\n\n          const variableBorrowAPR = Big(variableBorrowRate).div(RAY);\n\n          const variableBorrowAPY0 = Big(1)\n            .plus(Big(variableBorrowAPR).div(Big(SECONDS_PER_YEAR)))\n            .toNumber();\n\n          const variableBorrowAPYRaw = Big(\n            100 * (Math.pow(variableBorrowAPY0, SECONDS_PER_YEAR) - 1)\n          );\n\n          const variableBorrowAPY = Big(\n            Math.pow(variableBorrowAPY0, SECONDS_PER_YEAR) - 1\n          ).toFixed();\n          const netApy = Big(depositAPY0).minus(variableBorrowAPYRaw).toFixed();\n          prevAssetsToSupply[i].supplyAPY = depositAPY;\n          prevAssetsToSupply[i].variableBorrowAPY = variableBorrowAPY;\n          _debts[i].supplyAPY = depositAPY;\n          _debts[i].variableBorrowAPY = variableBorrowAPY;\n\n          // prevAssetsToBorrow.netApy = netApy;\n          prevAssetsToBorrow.variableBorrowAPY = variableBorrowAPY;\n        }\n      }\n      State.update({\n        assetsToSupply: prevAssetsToSupply,\n        assetsToBorrow: {\n          ...state.assetsToBorrow,\n          // netApy,\n          debts: _debts,\n        },\n      });\n    })\n    .catch((err) => {\n      console.log(\"getPoolDataProvider_err\", err);\n    });\n}\n\nfunction fetchUserAccountData() {\n  const contract = new ethers.Contract(\n    config.aavePoolV3Address,\n    config.aavePoolV3ABI.body,\n    Ethers.provider()\n  );\n  contract\n    .getUserAccountData(account)\n    .then((res) => {\n      console.log(\"getUserAccountData_res:\", res);\n      const [\n        totalCollateralBase,\n        totalDebtBase,\n        availableBorrowsBase,\n        currentLiquidationThreshold,\n        ltv,\n        healthFactor,\n      ] = res;\n\n      // onLoad({\n      //   deposits: ethers.utils.formatUnits(res),\n      // });\n      State.update({\n        currentLiquidationThreshold,\n        healthFactor: formatHealthFactor(\n          ethers.utils.formatUnits(healthFactor)\n        ),\n        assetsToBorrow: {\n          ...state.assetsToBorrow,\n          availableBorrowsUSD: ethers.utils.formatUnits(\n            availableBorrowsBase,\n            8\n          ),\n        },\n      });\n    })\n    .catch((err) => {\n      console.log(\"getUserAccountData_error\", err);\n    });\n}\nfunction valueToBigNumber(amount) {\n  if (amount instanceof BigNumber) {\n    return amount;\n  }\n\n  return new BigNumber(amount);\n}\nconst LTV_PRECISION = 4;\n// return  HealthFactorFromBalanceRequest): BigNumber\nfunction calculateHealthFactorFromBalances({\n  borrowBalanceMarketReferenceCurrency,\n  collateralBalanceMarketReferenceCurrency,\n  currentLiquidationThreshold,\n}) {\n  if (valueToBigNumber(borrowBalanceMarketReferenceCurrency).eq(0)) {\n    return valueToBigNumber(\"-1\"); // Invalid number\n  }\n\n  return valueToBigNumber(collateralBalanceMarketReferenceCurrency)\n    .multipliedBy(currentLiquidationThreshold)\n    .shiftedBy(LTV_PRECISION * -1)\n    .div(borrowBalanceMarketReferenceCurrency);\n}\n\nfunction getUserDeposits() {\n  const aTokenAddresss = markets.map((item) => item.aTokenAddress);\n\n  const calls = aTokenAddresss.map((addr) => ({\n    address: addr,\n    name: \"balanceOf\",\n    params: [account],\n  }));\n  multicall({\n    abi: [\n      {\n        inputs: [\n          {\n            internalType: \"address\",\n            name: \"user\",\n            type: \"address\",\n          },\n        ],\n        name: \"balanceOf\",\n        outputs: [\n          {\n            internalType: \"uint256\",\n            name: \"\",\n            type: \"uint256\",\n          },\n        ],\n        stateMutability: \"view\",\n        type: \"function\",\n      },\n    ],\n    calls,\n    options: {},\n    multicallAddress,\n    provider: Ethers.provider(),\n  })\n    .then((res) => {\n      console.log(\"getUsetDeposits_res\", res);\n      let userDeposits = [];\n      for (let index = 0; index < res.length; index++) {\n        if (res[index]) {\n          // let underlyingBalance=\n          let market = state.assetsToSupply.find(\n            (item) => item.aTokenAddress === aTokenAddresss[index]\n          );\n\n          let _bal = ethers.utils.formatUnits(res[index][0], market.decimals);\n          market.underlyingBalance = _bal;\n          market.underlyingBalanceUSD = Big(_bal)\n            .mul(prices[market.symbol])\n            .toFixed();\n          userDeposits.push(market);\n        }\n      }\n      const mm = state.assetsToSupply.reduce((prev, cur) => {\n        prev[cur.underlyingAsset] = cur;\n        return prev;\n      }, {});\n      const _yourSupplies = userDeposits.map((userDeposit) => {\n        const market = mm[userDeposit.underlyingAsset];\n\n        return {\n          ...market,\n          ...userDeposit,\n          ...(market.symbol === config.nativeCurrency.symbol\n            ? {\n                ...config.nativeCurrency,\n                supportPermit: true,\n              }\n            : {}),\n        };\n      });\n      let obj = {};\n      const yourSupplies = _yourSupplies.reduce((prev, cur) => {\n        obj[cur.aTokenAddress]\n          ? \"\"\n          : (obj[cur.aTokenAddress] = true && prev.push(cur));\n        return prev;\n      }, []);\n      console.log(\"yourSupplies:\", yourSupplies);\n      State.update({\n        yourSupplies,\n      });\n    })\n    .catch((err) => {\n      console.log(\"getUsetDeposits_err\", err);\n    })\n    .finally(() => {\n      getUserDebts();\n    });\n}\n\nfunction getUserDebts() {\n  const variableDebtTokenAddresss = markets.map(\n    (item) => item.variableDebtTokenAddress\n  );\n\n  const calls = variableDebtTokenAddresss.map((addr) => ({\n    address: addr,\n    name: \"balanceOf\",\n    params: [account],\n  }));\n\n  multicall({\n    abi: [\n      {\n        inputs: [\n          {\n            internalType: \"address\",\n            name: \"user\",\n            type: \"address\",\n          },\n        ],\n        name: \"balanceOf\",\n        outputs: [\n          {\n            internalType: \"uint256\",\n            name: \"\",\n            type: \"uint256\",\n          },\n        ],\n        stateMutability: \"view\",\n        type: \"function\",\n      },\n    ],\n    calls,\n    options: {},\n    multicallAddress,\n    provider: Ethers.provider(),\n  })\n    .then((res) => {\n      console.log(\"getUserDebts_res\", res);\n      let userDebs = [];\n      const _debts = [...state.assetsToBorrow.debts];\n      for (let index = 0; index < res.length; index++) {\n        if (res[index]) {\n          let market = _debts.find(\n            (item) =>\n              item.variableDebtTokenAddress === variableDebtTokenAddresss[index]\n          );\n\n          let _bal = ethers.utils.formatUnits(res[index][0], market.decimals);\n          market.balance = _bal;\n          market.balanceInUSD = Big(_bal).mul(prices[market.symbol]).toFixed();\n          userDebs.push(market);\n        }\n      }\n      // const yourBorrows = userDebs.map((userDebt) => {\n      //   const market = marketsMapping[userDebt.underlyingAsset];\n      //   return {\n      //     ...market,\n      //     ...userDebt,\n      //     ...(market.symbol === config.nativeWrapCurrency.symbol\n      //       ? {\n      //           ...config.nativeCurrency,\n      //           supportPermit: true,\n      //         }\n      //       : {}),\n      //   };\n      // });\n      console.log(\"yourBorrows:\", state.yourBorrows);\n      console.log(\"userDebs:\", userDebs);\n      State.update({\n        yourBorrows: {\n          ...state.yourBorrows,\n          debts: userDebs,\n        },\n      });\n    })\n    .catch((err) => {\n      console.log(\"getUserDebts_err\", err);\n    });\n}\n\nfunction getAllUserRewards() {\n  const arr = markets\n    .map((item) => [\n      item.aTokenAddress,\n      // item.stableDebtTokenAddress,\n      item.variableDebtTokenAddress,\n    ])\n    .flat();\n  const addrs = [...new Set(arr)];\n\n  const rewardsProvider = new ethers.Contract(\n    config.incentivesProxy,\n    [\n      {\n        inputs: [\n          { internalType: \"address[]\", name: \"assets\", type: \"address[]\" },\n          { internalType: \"address\", name: \"user\", type: \"address\" },\n        ],\n        name: \"getAllUserRewards\",\n        outputs: [\n          {\n            internalType: \"address[]\",\n            name: \"rewardsList\",\n            type: \"address[]\",\n          },\n          {\n            internalType: \"uint256[]\",\n            name: \"unclaimedAmounts\",\n            type: \"uint256[]\",\n          },\n        ],\n        stateMutability: \"view\",\n        type: \"function\",\n      },\n    ],\n    Ethers.provider().getSigner()\n  );\n\n  rewardsProvider\n    .getAllUserRewards(addrs, account)\n    .then((res) => {\n      console.log(\n        \"getAllUserRewards_res:\",\n        res,\n        ethers.utils.formatUnits(res[1][1])\n      );\n      const _amount = ethers.utils.formatUnits(res[1][1]);\n      State.update({\n        rewardsAmount: _amount,\n      });\n    })\n    .catch((err) => {\n      console.log(\"getAllUserRewards_error:\", err);\n    });\n}\n\nuseEffect(() => {\n  if (!isChainSupported) return;\n\n  fetchUserAccountData();\n}, [isChainSupported]);\n\nuseEffect(() => {\n  if (!account) return;\n\n  if (dexConfig.rewardToken) {\n    getAllUserRewards();\n  }\n}, [fresh]);\n\nuseEffect(() => {\n  if (!isChainSupported || !state.assetsToSupply) return;\n\n  getPoolDataProvider();\n  getUserDeposits();\n}, [state.assetsToSupply]);\n\nfunction calcNetWorth() {\n  if (!state.yourSupplies || !state.yourBorrows) return;\n\n  const supplyBal = state.yourSupplies.reduce(\n    (total, cur) => Big(total).plus(cur.underlyingBalanceUSD).toFixed(),\n    0\n  );\n  const debtsBal = state.yourBorrows.debts.reduce(\n    (total, cur) => Big(total).plus(cur.balanceInUSD).toFixed(),\n    0\n  );\n  const netWorth = Big(supplyBal).minus(debtsBal).toFixed(2, ROUND_DOWN);\n  State.update({\n    netWorthUSD: netWorth,\n  });\n}\n\nuseEffect(() => {\n  if (![\"zerolend\", \"AAVE V3\"].includes(dexConfig.name)) return;\n\n  if (!state.yourSupplies || !state.yourBorrows) return;\n\n  //calc net worth\n  const supplyBal = state.yourSupplies.reduce(\n    (total, cur) => Big(total).plus(cur.underlyingBalanceUSD).toFixed(),\n    0\n  );\n  const debtsBal = state.yourBorrows.debts.reduce(\n    (total, cur) => Big(total).plus(cur.balanceInUSD).toFixed(),\n    0\n  );\n  const netWorth = Big(supplyBal).minus(debtsBal).toFixed(2, ROUND_DOWN);\n\n  //calc net apy\n\n  const weightedAverageSupplyAPY = state.yourSupplies.reduce(\n    (total, cur) =>\n      Big(total)\n        .plus(\n          Big(cur.underlyingBalanceUSD).times(Big(cur.supplyAPY)).div(supplyBal)\n        )\n        .toFixed(),\n    0\n  );\n  const weightedAverageBorrowsAPY = state.yourBorrows.debts.reduce(\n    (total, cur) =>\n      Big(total)\n        .plus(\n          Big(cur.balanceInUSD).times(Big(cur.variableBorrowAPY)).div(debtsBal)\n        )\n        .toFixed(),\n    0\n  );\n\n  const a = Big(weightedAverageSupplyAPY)\n    .times(supplyBal)\n    .div(netWorth)\n    .toFixed();\n  const b = Big(weightedAverageBorrowsAPY)\n    .times(debtsBal)\n    .div(netWorth)\n    .toFixed();\n  const totalNetApy = Big(a).minus(Big(b)).toFixed();\n\n  const yourTotalSupply = state.yourSupplies.reduce(\n    (prev, curr) =>\n      Big(prev)\n        .plus(Big(curr.underlyingBalanceUSD || 0))\n        .toFixed(),\n    0\n  );\n  const yourTotalBorrow = state.yourBorrows.debts.reduce(\n    (prev, curr) =>\n      Big(prev)\n        .plus(Big(curr.balanceInUSD || 0))\n        .toFixed(),\n    0\n  );\n\n  State.update({\n    totalNetApy,\n    netWorthUSD: netWorth,\n    yourTotalSupply,\n    yourTotalBorrow,\n  });\n}, [state.yourSupplies, state.yourBorrows]);\n\nfunction onSuccess() {\n  State.update({\n    ...state,\n    fresh: state.fresh + 1,\n  });\n}\n\nconsole.log(\"STATE: \", state);\n\nconst body = isChainSupported ? (\n  <Wrap>\n    <FlexContainer>\n      <ChainsWrap>\n        <Widget\n          src=\"bluebiu.near/widget/Lending.Chains\"\n          props={{\n            chains: CHAIN_LIST,\n            curChain,\n            onSwitchChain,\n            // onChange: (tab) => {\n            //   State.update({\n            //     tab: tab.key,\n            //   });\n            // },\n          }}\n        />\n      </ChainsWrap>\n      <Widget\n        src={`${config.ownerId}/widget/AAVE.HeroData`}\n        props={{\n          config,\n          netWorth: `$ ${\n            state.netWorthUSD ? Big(state.netWorthUSD).toFixed(2) : \"-\"\n          }`,\n          netApy: `${\n            state.totalNetApy\n              ? Number(Big(state.totalNetApy).times(100).toFixed(2))\n              : \"-\"\n          }%`,\n          healthFactor: formatHealthFactor(state.healthFactor),\n          theme: dexConfig?.theme,\n        }}\n      />\n    </FlexContainer>\n    <Widget\n      src={`${config.ownerId}/widget/AAVE.TabSwitcher`}\n      props={{\n        config,\n        theme: dexConfig?.theme,\n        select: state.selectTab,\n        setSelect: (tabName) => State.update({ selectTab: tabName }),\n      }}\n    />\n    {state.selectTab === \"MARKET\" && (\n      <>\n        <Widget\n          src={`${config.ownerId}/widget/AAVE.Card.AssetsToSupply`}\n          props={{\n            config,\n            chainId: chainId,\n            assetsToSupply: state.assetsToSupply,\n            showSupplyModal: state.showSupplyModal,\n            setShowSupplyModal: (isShow) =>\n              State.update({ showSupplyModal: isShow }),\n            onActionSuccess,\n            healthFactor: formatHealthFactor(state.healthFactor),\n            formatHealthFactor,\n            depositETHGas,\n            depositERC20Gas,\n            borrowETHGas,\n            borrowERC20Gas,\n            yourSupplies: state.yourSupplies,\n            theme: dexConfig?.theme,\n          }}\n        />\n        {/* <Widget\n          src={`${config.ownerId}/widget/AAVE.Card.AssetsToBorrow`}\n          props={{\n            config,\n            chainId: chainId,\n            assetsToBorrow: state.assetsToBorrow,\n            showBorrowModal: state.showBorrowModal,\n            yourSupplies: state.yourSupplies,\n            setShowBorrowModal: (isShow) =>\n              State.update({ showBorrowModal: isShow }),\n            formatHealthFactor,\n            onActionSuccess,\n            borrowETHGas,\n            borrowERC20Gas,\n            theme: dexConfig?.theme,\n          }}\n        /> */}\n      </>\n    )}\n    {state.selectTab === \"YOURS\" && (\n      <>\n        <Yours>\n          <YoursTableWrapper>\n            <Title>\n              You Supplies\n              <SubTitle>\n                <Label>Balance:</Label>\n                <Value>$ {Number(state.yourTotalSupply).toFixed(2)}</Value>\n\n                <Label>APY:</Label>\n                <Value> %</Value>\n\n                <Label>Collateral:</Label>\n                <Value>$ </Value>\n              </SubTitle>\n            </Title>\n            <Widget\n              src={`${config.ownerId}/widget/AAVE.Card.YourSupplies`}\n              props={{\n                config,\n                chainId: chainId,\n                yourSupplies: state.yourSupplies,\n                showWithdrawModal: state.showWithdrawModal,\n                setShowWithdrawModal: (isShow) =>\n                  State.update({ showWithdrawModal: isShow }),\n                onActionSuccess,\n                healthFactor: formatHealthFactor(state.healthFactor),\n                formatHealthFactor,\n                withdrawETHGas,\n                withdrawERC20Gas,\n                account,\n                theme: dexConfig?.theme,\n              }}\n            />\n          </YoursTableWrapper>\n          <YoursTableWrapper>\n            <Title>\n              You Borrows\n              <SubTitle>\n                <Label>Balance:</Label>\n                <Value>$ {Number(state.yourTotalBorrow).toFixed(2)}</Value>\n\n                <Label>APY:</Label>\n                <Value> %</Value>\n\n                <Label>Borrow power used:</Label>\n                <Value>$ </Value>\n              </SubTitle>\n            </Title>\n            <Widget\n              src={`${config.ownerId}/widget/AAVE.Card.YourBorrows`}\n              props={{\n                config,\n                chainId: chainId,\n                yourBorrows: state.yourBorrows,\n                showRepayModal: state.showRepayModal,\n                setShowRepayModal: (isShow) =>\n                  State.update({ showRepayModal: isShow }),\n                showBorrowModal: state.showBorrowModal,\n                setShowBorrowModal: (isShow) =>\n                  State.update({ showBorrowModal: isShow }),\n                formatHealthFactor,\n                onActionSuccess,\n                repayETHGas,\n                repayERC20Gas,\n                borrowETHGas,\n                borrowERC20Gas,\n                theme: dexConfig?.theme,\n              }}\n            />\n          </YoursTableWrapper>\n        </Yours>\n        <Widget\n          src={`${config.ownerId}/widget/AAVE.Card.RewardsTable`}\n          props={{\n            account,\n            config,\n            data: [].concat({\n              ...dexConfig.rewardToken,\n              unclaimed: state.rewardsAmount,\n            }),\n            dapps: dexConfig,\n            onSuccess,\n            markets,\n            rewardAddress: config.incentivesProxy,\n            toast,\n          }}\n        />\n      </>\n    )}\n    {state.alertModalText && (\n      <Widget\n        src={`${config.ownerId}/widget/AAVE.Modal.AlertModal`}\n        props={{\n          config,\n          theme: dexConfig?.theme,\n          title: \"All done!\",\n          description: state.alertModalText,\n          onRequestClose: () => State.update({ alertModalText: false }),\n        }}\n      />\n    )}\n  </Wrap>\n) : (\n  <Widget\n    src=\"bluebiu.near/widget/Swap.ChainWarnigBox\"\n    props={{\n      chain: curChain,\n      onSwitchChain: onSwitchChain,\n      switchingChain: switchingChain,\n      theme: dexConfig.theme,\n    }}\n  />\n);\n// );\n\nreturn (\n  <div>\n    {/* Component Head */}\n    <Widget\n      src={`${config.ownerId}/widget/Utils.Import`}\n      props={{ modules, onLoad: importFunctions }}\n    />\n\n    {body}\n  </div>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/bluebiu.near/widget/AAVE-V3", "fact_widget_deployments_id": "434c2c94891179d856d73ec82f08bde4", "inserted_timestamp": "2024-03-24T21:26:43.760Z", "modified_timestamp": "2024-03-24T21:26:43.760Z", "__row_index": 43}