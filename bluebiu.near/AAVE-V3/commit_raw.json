{"tx_hash": "GEvyUhgh5VNB2AJAGAqhGAtm3DVA71taVrHqD6Gy4wN2", "action_id_social": "FAsNN8hy3zar6tKeTHsd2dJsRDuXEE3PfdBhpbjoYHHc-0-widget", "block_id": 115922179, "block_timestamp": "2024-04-01T14:11:18.065Z", "signer_id": "bluebiu.near", "widget_name": "AAVE-V3", "source_code": "const Wrap = styled.div`\n  padding: 24px 15px;\n  /* background: #0e0e26; */\n  min-height: 100vh;\n  color: white;\n  font-family: Gantari;\n`;\n\nconst FlexContainer = styled.div``;\n\nconst ChainsWrap = styled.div`\n  display: flex;\n  justify-content: flex-end;\n`;\nconst Yours = styled.div`\n  display: flex;\n  gap: 20px;\n  margin-top: 16px;\n`;\nconst YoursTableWrapper = styled.div`\n  background-color: rgba(53, 55, 73, 0.2);\n  border-radius: 6px;\n  width: 50%;\n`;\nconst Title = styled.div`\n  padding: 10px 20px 0;\n  /* border-bottom: 1px solid #292c42; */\n`;\nconst SubTitle = styled.div`\n  display: flex;\n  align-items: center;\n`;\nconst Label = styled.div`\n  color: #979abe;\n  font-size: 16px;\n  font-weight: 400;\n  margin-right: 5px;\n`;\nconst Value = styled.div`\n  color: #fff;\n  font-size: 16px;\n  font-weight: 500;\n  margin-right: 15px;\n`;\n\nconst ROUND_DOWN = 0;\nconst NATIVE_SYMBOL_ADDRESS_MAP_KEY = \"0x0\";\nconst ACTUAL_BORROW_AMOUNT_RATE = 0.99;\n\nconst account = Ethers.send(\"eth_requestAccounts\", [])[0];\nconst {\n  CHAIN_LIST,\n  curChain,\n  onSwitchChain,\n  GAS_LIMIT_RECOMMENDATIONS,\n  chainId,\n  prices,\n  multicallAddress,\n  multicall,\n  isChainSupported,\n  switchingChain,\n  dexConfig,\n  theme,\n  toast,\n} = props;\nconst { CONTRACT_ABI } = dexConfig;\nconsole.log(\"AAVE.V3: \", props);\n\nfunction isValid(a) {\n  if (!a) return false;\n  if (isNaN(Number(a))) return false;\n  if (a === \"\") return false;\n  return true;\n}\n\nfunction getGasPrice() {\n  return Ethers.provider().getGasPrice();\n}\n\nfunction gasEstimation(action) {\n  const assetsToSupply = state.assetsToSupply;\n  if (!assetsToSupply) {\n    return \"-\";\n  }\n  const baseAsset = assetsToSupply.find(\n    (asset) => asset.symbol === config.nativeCurrency.symbol\n  );\n  if (!baseAsset) {\n    return \"-\";\n  }\n\n  const { marketReferencePriceInUsd, decimals } = baseAsset;\n  return getGasPrice()\n    .then((gasPrice) => {\n      const gasLimit = GAS_LIMIT_RECOMMENDATIONS[action].limit;\n      console.log(\"gasPrice--\", gasPrice);\n      return Big(gasPrice.toString())\n        .mul(gasLimit)\n        .div(Big(10).pow(decimals))\n        .mul(marketReferencePriceInUsd)\n        .toFixed(2);\n    })\n    .catch((err) => {\n      console.log(\"gasEstimation error\");\n    });\n}\n\nfunction depositETHGas() {\n  return gasEstimation(\"deposit\");\n}\n\nfunction depositERC20Gas() {\n  return gasEstimation(\"supplyWithPermit\");\n}\n\nfunction withdrawETHGas() {\n  return gasEstimation(\"withdrawETH\");\n}\n\nfunction withdrawERC20Gas() {\n  return gasEstimation(\"withdraw\");\n}\n\nfunction borrowETHGas() {\n  return gasEstimation(\"borrowETH\");\n}\n\nfunction borrowERC20Gas() {\n  return gasEstimation(\"borrow\");\n}\n\nfunction repayETHGas() {\n  return gasEstimation(\"repay\");\n}\n\nfunction repayERC20Gas() {\n  return gasEstimation(\"repayWithPermit\");\n}\n\n// App config\nfunction getConfig() {\n  const abis = {\n    wrappedTokenGatewayV3ABI: fetch(CONTRACT_ABI.wrappedTokenGatewayV3ABI),\n    erc20Abi: fetch(CONTRACT_ABI.erc20Abi),\n    aavePoolV3ABI: fetch(CONTRACT_ABI.aavePoolV3ABI),\n    variableDebtTokenABI: fetch(CONTRACT_ABI.variableDebtTokenABI),\n    walletBalanceProviderABI: fetch(CONTRACT_ABI.walletBalanceProviderABI),\n  };\n\n  const constants = {\n    FIXED_LIQUIDATION_VALUE: \"1.0\",\n    MAX_UINT_256:\n      \"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\",\n    AAVE_API_BASE_URL: \"https://aave-data-service-7a85eea3aebe.herokuapp.com\",\n  };\n\n  return {\n    ...dexConfig.config,\n    ...abis,\n    ...constants,\n  };\n}\n\nconst config = getConfig();\n// console.log(\"CONFIG: \", config);\nconsole.log(\"markets--\", dexConfig);\nconst markets = dexConfig?.rawMarkets?.map((item) => ({\n  ...item,\n  marketReferencePriceInUsd: prices[item.symbol],\n}));\nconst underlyingTokens = dexConfig?.rawMarkets?.map(\n  (market) => market.underlyingAsset\n);\n\nfunction getLiquidity() {\n  const aTokenAddresss = markets?.map((item) => item.aTokenAddress);\n  const variableDebtTokenAddresss = markets?.map(\n    (item) => item.variableDebtTokenAddress\n  );\n\n  const calls = aTokenAddresss\n    .map((addr) => ({\n      address: addr,\n      name: \"totalSupply\",\n    }))\n    .concat(\n      variableDebtTokenAddresss?.map((addr) => ({\n        address: addr,\n        name: \"totalSupply\",\n      }))\n    );\n\n  multicall({\n    abi: [\n      {\n        inputs: [],\n        name: \"totalSupply\",\n        outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n      },\n    ],\n    calls,\n    options: {},\n    multicallAddress,\n    provider: Ethers.provider(),\n  })\n    .then((res) => {\n      try {\n        console.log(\"getLiquidity_res\", res);\n        const l = res.length;\n        const aTokenTotal = res.slice(0, l / 2);\n        const debtTotal = res.slice(l / 2);\n\n        for (let i = 0; i < markets.length; i++) {\n          // console.log(\n          //   \"getLiquidity-price\",\n          //   markets.length,\n          //   i,\n          //   markets[i].symbol,\n          //   prices[markets[i].symbol]\n          // );\n          const liquidityAmount = Big(aTokenTotal[i] || 0)\n            .minus(Big(debtTotal[i] || 0))\n            .toFixed();\n          // console.log(\"liquidityAmount:\", liquidityAmount);\n          markets[i].availableLiquidity = liquidityAmount;\n          markets[i].availableLiquidityUSD = Big(\n            ethers.utils.formatUnits(liquidityAmount, markets[i].decimals)\n          )\n            .mul(Big(prices[markets[i].symbol]) || 0)\n            .toFixed();\n        }\n      } catch (error) {\n        console.log(\"catch getLiquidity\", error);\n      }\n    })\n    .catch((err) => {\n      console.log(\"getLiquidity_err\", err);\n    });\n}\n\nconst marketsMapping = markets.reduce((prev, cur) => {\n  prev[cur.underlyingAsset] = cur;\n  return prev;\n}, {});\n\n// App states\nState.init({\n  imports: {},\n  showWithdrawModal: false,\n  showSupplyModal: false,\n  showRepayModal: false,\n  showBorrowModal: false,\n  threshold: 1,\n  assetsToSupply: undefined, //[{markets}]\n  yourSupplies: undefined, //[{markets}]\n  netWorthUSD: \"\",\n  totalNetApy: \"\",\n  healthFactor: \"\",\n  assetsToBorrow: {\n    availableBorrowsUSD: \"\",\n    debts: markets,\n    // netApy: \"\",\n  },\n  yourBorrows: {\n    availableBorrowsUSD: \"\",\n    debts: [],\n    // netApy: '',\n  },\n  baseAssetBalance: undefined,\n  selectTab: \"MARKET\", // MARKET | YOURS\n  fresh: 0, // fresh rewards\n  yourSupplyApy: 0,\n  yourBorrowApy: 0,\n});\n\nconst loading =\n  !state.assetsToSupply || !state.yourSupplies || !state.assetsToBorrow;\n\n// Import functions to state.imports\nfunction importFunctions(imports) {\n  if (loading) {\n    State.update({\n      imports,\n    });\n  }\n}\n\n// Define the modules you'd like to import\nconst modules = {\n  number: `${config.ownerId}/widget/Utils.Number`,\n  date: `${config.ownerId}/widget/Utils.Date`,\n  data: `${config.ownerId}/widget/AAVE.Data`,\n};\n// Import functions\n// const { formatAmount } = state.imports.number;\n// const { formatDateTime } = state.imports.date;\n\nfunction calculateAvailableBorrows({\n  availableBorrowsUSD,\n  marketReferencePriceInUsd,\n}) {\n  return isValid(availableBorrowsUSD) && isValid(marketReferencePriceInUsd)\n    ? Big(availableBorrowsUSD || 0)\n        .div(marketReferencePriceInUsd)\n        .toFixed()\n    : Number(0).toFixed();\n}\n\nfunction bigMin(_a, _b) {\n  const a = Big(_a || 0);\n  const b = Big(_b || 0);\n  return a.gt(b) ? b : a;\n}\n\nfunction formatHealthFactor(healthFactor) {\n  if (healthFactor === \"\u221e\") return healthFactor;\n  if (!healthFactor || !isValid(healthFactor)) return \"-\";\n  if (Number(healthFactor) === -1) return \"\u221e\";\n  return Big(healthFactor).toFixed(2, ROUND_DOWN);\n}\n\nfunction calcHealthFactor(type, symbol, amount) {\n  let newHealthFactor, deno;\n  console.log(\"calcHealthFactor--\", type, symbol, amount, prices[symbol]);\n  const assetsUSD = Big(prices[symbol]).times(Big(amount));\n  if (type === \"SUPPLY\") {\n    deno = Big(state.yourTotalCollateral).plus(assetsUSD);\n  }\n  if (type === \"WITHDRAW\") {\n    deno = Big(state.yourTotalCollateral).minus(assetsUSD);\n  }\n  if (type === \"BORROW\") {\n    deno = Big(state.yourTotalBorrow).plus(assetsUSD);\n  }\n  if (type === \"REPAY\") {\n    deno = Big(state.yourTotalBorrow).minus(assetsUSD);\n  }\n  newHealthFactor = deno\n    .times(Big(state.threshold))\n    .div(Big(state.yourTotalBorrow));\n\n  console.log(\"calcHealthFactor--\", newHealthFactor);\n  return newHealthFactor.toFixed(2);\n}\n\nfunction batchBalanceOf(chainId, userAddress, tokenAddresses, abi) {\n  const balanceProvider = new ethers.Contract(\n    config.balanceProviderAddress,\n    abi.body,\n    Ethers.provider().getSigner()\n  );\n\n  return balanceProvider.batchBalanceOf([userAddress], tokenAddresses);\n}\n\n// update data in async manner\nfunction updateData(refresh) {\n  // check abi loaded\n  if (\n    Object.keys(CONTRACT_ABI)\n      ?.map((key) => config[key])\n      .filter((ele) => !!ele).length !== Object.keys(CONTRACT_ABI).length\n  ) {\n    return;\n  }\n  const provider = Ethers.provider();\n  provider\n    .getSigner()\n    ?.getBalance()\n    .then((balance) => State.update({ baseAssetBalance: balance }));\n  if (!account || !state.baseAssetBalance) {\n    return;\n  }\n\n  // get user balances\n  batchBalanceOf(\n    chainId,\n    account,\n    markets?.map((market) => market.underlyingAsset),\n    config.walletBalanceProviderABI\n  )\n    .then((balances) => {\n      console.log(\n        \"getBalance\",\n        balances,\n        balances.map((balance) => balance.toString())\n      );\n      return balances?.map((balance) => balance.toString());\n    })\n    .then((userBalances) => {\n      const assetsToSupply = markets?.map((market, idx) => {\n        const _bal =\n          market.symbol === config.nativeCurrency.symbol\n            ? state.baseAssetBalance\n            : userBalances[idx];\n        const balanceRaw = Big(_bal || 0).div(Big(10).pow(market.decimals));\n\n        const balance = balanceRaw.toFixed(market.decimals, ROUND_DOWN);\n\n        const balanceInUSD = balanceRaw\n          .mul(market.marketReferencePriceInUsd || 0)\n          .toFixed(3, ROUND_DOWN);\n\n        const availableBorrowsUSD = bigMin(\n          state.assetsToBorrow.availableBorrowsUSD,\n          market.availableLiquidityUSD\n        )\n          .times(ACTUAL_BORROW_AMOUNT_RATE)\n          .toFixed();\n\n        const availableBorrows = calculateAvailableBorrows({\n          availableBorrowsUSD,\n          marketReferencePriceInUsd: market.marketReferencePriceInUsd,\n        });\n        // console.log(44444, availableBorrows);\n        // item.availableBorrows = availableBorrows;\n\n        return {\n          ...market,\n          availableBorrowsUSD,\n          availableBorrows,\n          balance,\n          balanceInUSD,\n        };\n      });\n\n      State.update({\n        assetsToSupply,\n      });\n    })\n    .catch((err) => {\n      console.log(\"batchBalanceOfERROR:\", err);\n    });\n}\n\nfunction updateUserDebts(marketsMapping, assetsToSupply, refresh) {\n  if (!marketsMapping || !assetsToSupply) {\n    return;\n  }\n\n  const _assetsToSupply = [...state.assetsToSupply];\n\n  _assetsToSupply.forEach((item) => {\n    const availableBorrowsUSD = bigMin(\n      state.assetsToBorrow.availableBorrowsUSD,\n      item.availableLiquidityUSD\n    )\n      .times(ACTUAL_BORROW_AMOUNT_RATE)\n      .toFixed();\n\n    item.availableBorrowsUSD = availableBorrowsUSD;\n    const availableBorrows = calculateAvailableBorrows({\n      availableBorrowsUSD,\n      marketReferencePriceInUsd: item.marketReferencePriceInUsd,\n    });\n\n    item.availableBorrows = availableBorrows;\n  });\n\n  State.update({\n    assetsToSupply: _assetsToSupply,\n  });\n}\n\nfunction onActionSuccess({ msg, callback }) {\n  // update data if action finishes\n  updateData(true);\n  // update UI after data has almost loaded\n  setTimeout(() => {\n    if (callback) {\n      callback();\n    }\n    if (msg) {\n      State.update({ alertModalText: msg });\n    }\n  }, 5000);\n}\n\nif (chainId && isChainSupported && loading) {\n  updateData();\n}\n\nfunction getPoolDataProvider() {\n  const _debts = [...state.assetsToBorrow.debts];\n  const prevAssetsToSupply = [...state.assetsToSupply];\n  const prevAssetsToBorrow = { ...state.assetsToBorrow };\n  // const underlyingTokens = prevAssetsToSupply.map(\n  //   (item) => item.underlyingAsset\n  // );\n\n  const underlyingTokens = dexConfig?.rawMarkets?.map(\n    (market) => market.underlyingAsset\n  );\n  console.log(\"getPoolDataProvider--\", underlyingTokens);\n  const calls = underlyingTokens?.map((addr) => ({\n    address: config.PoolDataProvider,\n    name: \"getReserveData\",\n    params: [addr],\n  }));\n\n  multicall({\n    abi: [\n      {\n        inputs: [{ internalType: \"address\", name: \"asset\", type: \"address\" }],\n        name: \"getReserveData\",\n        outputs: [\n          { internalType: \"uint256\", name: \"unbacked\", type: \"uint256\" },\n          {\n            internalType: \"uint256\",\n            name: \"accruedToTreasuryScaled\",\n            type: \"uint256\",\n          },\n          { internalType: \"uint256\", name: \"totalAToken\", type: \"uint256\" },\n          {\n            internalType: \"uint256\",\n            name: \"totalStableDebt\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"totalVariableDebt\",\n            type: \"uint256\",\n          },\n          { internalType: \"uint256\", name: \"liquidityRate\", type: \"uint256\" },\n          {\n            internalType: \"uint256\",\n            name: \"variableBorrowRate\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"stableBorrowRate\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"averageStableBorrowRate\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"liquidityIndex\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"variableBorrowIndex\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint40\",\n            name: \"lastUpdateTimestamp\",\n            type: \"uint40\",\n          },\n        ],\n        stateMutability: \"view\",\n        type: \"function\",\n      },\n    ],\n    calls,\n    options: {},\n    multicallAddress,\n    provider: Ethers.provider(),\n  })\n    .then((res) => {\n      console.log(\"getPoolDataProvider_res\", res);\n\n      for (let i = 0; i < res.length; i++) {\n        if (res[i]) {\n          const [\n            unbacked,\n            accruedToTreasuryScaled,\n            totalAToken,\n            totalStableDebt,\n            totalVariableDebt,\n            liquidityRate,\n            variableBorrowRate,\n            stableBorrowRate,\n            averageStableBorrowRate,\n            liquidityIndex,\n            variableBorrowIndex,\n            lastUpdateTimestamp,\n          ] = res[i];\n          const RAY = Big(10).pow(27);\n          const SECONDS_PER_YEAR = 31_536_000;\n          const depositAPR = Big(liquidityRate).div(RAY || 1);\n          const depositAPY0 = Big(1)\n            .plus(depositAPR.div(Big(SECONDS_PER_YEAR)))\n            .toNumber();\n          const depositAPY = Big(\n            Math.pow(depositAPY0, SECONDS_PER_YEAR) - 1\n          ).toFixed();\n          console.log(\"depositAPY--\", depositAPY);\n\n          const variableBorrowAPR = Big(variableBorrowRate).div(RAY || 1);\n\n          const variableBorrowAPY0 = Big(1)\n            .plus(Big(variableBorrowAPR).div(Big(SECONDS_PER_YEAR)))\n            .toNumber();\n\n          const variableBorrowAPYRaw = Big(\n            100 * (Math.pow(variableBorrowAPY0, SECONDS_PER_YEAR) - 1)\n          );\n\n          const variableBorrowAPY = Big(\n            Math.pow(variableBorrowAPY0, SECONDS_PER_YEAR) - 1\n          ).toFixed();\n          const netApy = Big(depositAPY0).minus(variableBorrowAPYRaw).toFixed();\n          prevAssetsToSupply[i].supplyAPY = depositAPY;\n          prevAssetsToSupply[i].variableBorrowAPY = variableBorrowAPY;\n          _debts[i].supplyAPY = depositAPY;\n          _debts[i].variableBorrowAPY = variableBorrowAPY;\n\n          // prevAssetsToBorrow.netApy = netApy;\n          prevAssetsToBorrow.variableBorrowAPY = variableBorrowAPY;\n        }\n      }\n      State.update({\n        assetsToSupply: prevAssetsToSupply,\n        assetsToBorrow: {\n          ...state.assetsToBorrow,\n          debts: _debts,\n        },\n      });\n    })\n    .catch((err) => {\n      console.log(\"getPoolDataProvider_err\", err);\n    });\n}\n// seamless use\nfunction getPoolDataProviderTotalSupply() {\n  const prevAssetsToSupply = [...state.assetsToSupply];\n\n  const underlyingTokens = dexConfig?.rawMarkets?.map(\n    (market) => market.underlyingAsset\n  );\n  console.log(\"getPoolDataProviderTotalSupply--\", underlyingTokens);\n  const calls = underlyingTokens?.map((addr) => ({\n    address: config.PoolDataProvider,\n    name: \"getATokenTotalSupply\",\n    params: [addr],\n  }));\n\n  multicall({\n    abi: [\n      {\n        inputs: [{ internalType: \"address\", name: \"asset\", type: \"address\" }],\n        name: \"getATokenTotalSupply\",\n        outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n      },\n    ],\n    calls,\n    options: {},\n    multicallAddress,\n    provider: Ethers.provider(),\n  })\n    .then((res) => {\n      console.log(\"getPoolDataProviderTotal_res\", res);\n\n      for (let i = 0; i < res.length; i++) {\n        const _totalSupply = ethers.utils.formatUnits(\n          res[i][0],\n          prevAssetsToSupply[i].decimals\n        );\n        prevAssetsToSupply[i].totalSupply = _totalSupply;\n        console.log(\n          \"_totalSupply--\",\n          _totalSupply,\n          prevAssetsToSupply[i].symbol,\n          prices[prevAssetsToSupply[i].symbol]\n        );\n        prevAssetsToSupply[i].totalSupplyUSD = Big(_totalSupply || 0)\n          .times(prices[prevAssetsToSupply[i].symbol])\n          .toFixed();\n      }\n      State.update({\n        assetsToSupply: prevAssetsToSupply,\n      });\n    })\n    .catch((err) => {\n      console.log(\"getPoolDataProviderTotal_err\", err);\n    });\n}\n// seamless use\nfunction getPoolDataProviderTotalDebt() {\n  const prevAssetsToSupply = [...state.assetsToSupply];\n\n  const underlyingTokens = dexConfig?.rawMarkets?.map(\n    (market) => market.underlyingAsset\n  );\n  console.log(\"getPoolDataProviderTotalDebt--\", underlyingTokens);\n  const calls = underlyingTokens?.map((addr) => ({\n    address: config.PoolDataProvider,\n    name: \"getTotalDebt\",\n    params: [addr],\n  }));\n\n  multicall({\n    abi: [\n      {\n        inputs: [{ internalType: \"address\", name: \"asset\", type: \"address\" }],\n        name: \"getTotalDebt\",\n        outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n      },\n    ],\n    calls,\n    options: {},\n    multicallAddress,\n    provider: Ethers.provider(),\n  })\n    .then((res) => {\n      console.log(\"getPoolDataProviderTotal_res\", res);\n\n      for (let i = 0; i < res.length; i++) {\n        const _totalDebts = ethers.utils.formatUnits(\n          res[i][0],\n          prevAssetsToSupply[i].decimals\n        );\n        prevAssetsToSupply[i].totalDebts = _totalDebts;\n        prevAssetsToSupply[i].totalDebtsUSD = Big(_totalDebts)\n          .times(prices[prevAssetsToSupply[i].symbol])\n          .toFixed();\n      }\n      State.update({\n        assetsToSupply: prevAssetsToSupply,\n      });\n    })\n    .catch((err) => {\n      console.log(\"getPoolDataProviderTotal_err\", err);\n    });\n}\nfunction getPoolDataProviderCaps() {\n  const prevAssetsToSupply = [...state.assetsToSupply];\n\n  const underlyingTokens = dexConfig?.rawMarkets?.map(\n    (market) => market.underlyingAsset\n  );\n  console.log(\"getPoolDataProviderCaps--\", underlyingTokens);\n  const calls = underlyingTokens?.map((addr) => ({\n    address: config.PoolDataProvider,\n    name: \"getReserveCaps\",\n    params: [addr],\n  }));\n\n  multicall({\n    abi: [\n      {\n        inputs: [{ internalType: \"address\", name: \"asset\", type: \"address\" }],\n        name: \"getReserveCaps\",\n        outputs: [\n          { internalType: \"uint256\", name: \"borrowCap\", type: \"uint256\" },\n          { internalType: \"uint256\", name: \"supplyCap\", type: \"uint256\" },\n        ],\n        stateMutability: \"view\",\n        type: \"function\",\n      },\n    ],\n    calls,\n    options: {},\n    multicallAddress,\n    provider: Ethers.provider(),\n  })\n    .then((res) => {\n      console.log(\"getPoolDataProviderCaps_res\", res);\n\n      for (let i = 0; i < res.length; i++) {\n        const [borrowCap, supplyCap] = res[i];\n        prevAssetsToSupply[i].borrowCap = borrowCap.toNumber();\n        prevAssetsToSupply[i].supplyCap = supplyCap.toNumber();\n      }\n      State.update({\n        assetsToSupply: prevAssetsToSupply,\n      });\n    })\n    .catch((err) => {\n      console.log(\"getPoolDataProviderCaps_err\", err);\n    });\n}\n\nfunction fetchUserAccountData() {\n  const contract = new ethers.Contract(\n    config.aavePoolV3Address,\n    config.aavePoolV3ABI.body,\n    Ethers.provider()\n  );\n  contract\n    .getUserAccountData(account)\n    .then((res) => {\n      console.log(\"getUserAccountData_res:\", res);\n      const [\n        totalCollateralBase,\n        totalDebtBase,\n        availableBorrowsBase,\n        currentLiquidationThreshold,\n        ltv,\n        healthFactor,\n      ] = res;\n\n      const totalDebtBaseUSD = ethers.utils.formatUnits(\n        totalDebtBase.toString(),\n        8\n      );\n\n      const totalCollateralBaseUSD = ethers.utils.formatUnits(\n        totalCollateralBase.toString(),\n        8\n      );\n      const threshold = ethers.utils.formatUnits(\n        currentLiquidationThreshold.toString(),\n        4\n      );\n\n      const _totalCollateralBaseUSD = Big(totalCollateralBaseUSD).times(\n        Big(threshold)\n      );\n      const BorrowPowerUsed = Big(totalDebtBaseUSD || 0)\n        .div(_totalCollateralBaseUSD.eq(0) ? 1 : _totalCollateralBaseUSD)\n        .times(100)\n        .toFixed();\n\n      State.update({\n        threshold,\n        currentLiquidationThreshold,\n        BorrowPowerUsed,\n        healthFactor: !totalCollateralBase.toNumber()\n          ? formatHealthFactor(0)\n          : formatHealthFactor(ethers.utils.formatUnits(healthFactor)),\n        assetsToBorrow: {\n          ...state.assetsToBorrow,\n          availableBorrowsUSD: ethers.utils.formatUnits(\n            availableBorrowsBase,\n            8\n          ),\n        },\n      });\n    })\n    .catch((err) => {\n      console.log(\"getUserAccountData_error\", err);\n    });\n}\nfunction valueToBigNumber(amount) {\n  if (amount instanceof BigNumber) {\n    return amount;\n  }\n\n  return new BigNumber(amount);\n}\nconst LTV_PRECISION = 4;\n// return  HealthFactorFromBalanceRequest): BigNumber\nfunction calculateHealthFactorFromBalances({\n  borrowBalanceMarketReferenceCurrency,\n  collateralBalanceMarketReferenceCurrency,\n  currentLiquidationThreshold,\n}) {\n  if (valueToBigNumber(borrowBalanceMarketReferenceCurrency).eq(0)) {\n    return valueToBigNumber(\"-1\"); // Invalid number\n  }\n\n  return valueToBigNumber(collateralBalanceMarketReferenceCurrency)\n    .multipliedBy(currentLiquidationThreshold)\n    .shiftedBy(LTV_PRECISION * -1)\n    .div(borrowBalanceMarketReferenceCurrency || 1);\n}\n\nfunction getUserDeposits() {\n  const aTokenAddresss = markets?.map((item) => item.aTokenAddress);\n  console.log(\"getUserDeposits--\", markets);\n\n  const calls = aTokenAddresss?.map((addr) => ({\n    address: addr,\n    name: \"balanceOf\",\n    params: [account],\n  }));\n  multicall({\n    abi: [\n      {\n        inputs: [\n          {\n            internalType: \"address\",\n            name: \"user\",\n            type: \"address\",\n          },\n        ],\n        name: \"balanceOf\",\n        outputs: [\n          {\n            internalType: \"uint256\",\n            name: \"\",\n            type: \"uint256\",\n          },\n        ],\n        stateMutability: \"view\",\n        type: \"function\",\n      },\n    ],\n    calls,\n    options: {},\n    multicallAddress,\n    provider: Ethers.provider(),\n  })\n    .then((res) => {\n      console.log(\"getUsetDeposits_res\", res);\n      let userDeposits = [];\n      for (let index = 0; index < res.length; index++) {\n        if (res[index]) {\n          // let underlyingBalance=\n          let market = state.assetsToSupply.find(\n            (item) => item.aTokenAddress === aTokenAddresss[index]\n          );\n\n          let _bal = ethers.utils.formatUnits(res[index][0], market.decimals);\n          market.underlyingBalance = _bal;\n          market.underlyingBalanceUSD = Big(_bal)\n            .mul(prices[market.symbol])\n            .toFixed();\n          userDeposits.push(market);\n        }\n      }\n      const mm = state.assetsToSupply.reduce((prev, cur) => {\n        prev[cur.underlyingAsset] = cur;\n        return prev;\n      }, {});\n      const _yourSupplies = userDeposits?.map((userDeposit) => {\n        const market = mm[userDeposit.underlyingAsset];\n\n        return {\n          ...market,\n          ...userDeposit,\n          ...(market.symbol === config.nativeCurrency.symbol\n            ? {\n                ...config.nativeCurrency,\n                supportPermit: true,\n              }\n            : {}),\n        };\n      });\n      let obj = {};\n      const yourSupplies = _yourSupplies.reduce((prev, cur) => {\n        obj[cur.aTokenAddress]\n          ? \"\"\n          : (obj[cur.aTokenAddress] = true && prev.push(cur));\n        return prev;\n      }, []);\n      console.log(\"yourSupplies:\", yourSupplies);\n      State.update({\n        yourSupplies,\n      });\n    })\n    .catch((err) => {\n      console.log(\"getUsetDeposits_err\", err);\n    })\n    .finally(() => {\n      getUserDebts();\n    });\n}\n\nfunction getUserDebts() {\n  const variableDebtTokenAddresss = markets?.map(\n    (item) => item.variableDebtTokenAddress\n  );\n\n  const calls = variableDebtTokenAddresss?.map((addr) => ({\n    address: addr,\n    name: \"balanceOf\",\n    params: [account],\n  }));\n\n  multicall({\n    abi: [\n      {\n        inputs: [\n          {\n            internalType: \"address\",\n            name: \"user\",\n            type: \"address\",\n          },\n        ],\n        name: \"balanceOf\",\n        outputs: [\n          {\n            internalType: \"uint256\",\n            name: \"\",\n            type: \"uint256\",\n          },\n        ],\n        stateMutability: \"view\",\n        type: \"function\",\n      },\n    ],\n    calls,\n    options: {},\n    multicallAddress,\n    provider: Ethers.provider(),\n  })\n    .then((res) => {\n      console.log(\"getUserDebts_res\", res);\n      let userDebs = [];\n      const _debts = [...state.assetsToBorrow.debts];\n      for (let index = 0; index < res.length; index++) {\n        if (res[index]) {\n          let market = _debts.find(\n            (item) =>\n              item.variableDebtTokenAddress === variableDebtTokenAddresss[index]\n          );\n\n          let _bal = ethers.utils.formatUnits(res[index][0], market.decimals);\n          console.log(\"_bal--\", _bal);\n          market.balance = _bal;\n          market.balanceInUSD = Big(_bal || 0)\n            .mul(prices[market.symbol] || 1)\n            .toFixed();\n          userDebs.push(market);\n        }\n      }\n      let hash = {};\n      let _userDebs = userDebs.reduce((accum, item) => {\n        hash[item[\"aTokenAddress\"]]\n          ? \"\"\n          : (hash[item[\"aTokenAddress\"]] = true && accum.push(item));\n        return accum;\n      }, []);\n\n      console.log(\"yourBorrows:\", state.yourBorrows);\n      console.log(\"userDebs:\", _userDebs);\n      State.update({\n        yourBorrows: {\n          ...state.yourBorrows,\n          debts: _userDebs,\n        },\n      });\n    })\n    .catch((err) => {\n      console.log(\"getUserDebts_err\", err);\n    });\n}\n\nfunction getAllUserRewards() {\n  console.log(\"getAllUserRewards--\", markets);\n  const arr = markets\n    ?.map((item) => [\n      item.aTokenAddress,\n      // item.stableDebtTokenAddress,\n      item.variableDebtTokenAddress,\n    ])\n    .flat();\n  const addrs = [...new Set(arr)];\n\n  const rewardsProvider = new ethers.Contract(\n    config.incentivesProxy,\n    [\n      {\n        inputs: [\n          { internalType: \"address[]\", name: \"assets\", type: \"address[]\" },\n          { internalType: \"address\", name: \"user\", type: \"address\" },\n        ],\n        name: \"getAllUserRewards\",\n        outputs: [\n          {\n            internalType: \"address[]\",\n            name: \"rewardsList\",\n            type: \"address[]\",\n          },\n          {\n            internalType: \"uint256[]\",\n            name: \"unclaimedAmounts\",\n            type: \"uint256[]\",\n          },\n        ],\n        stateMutability: \"view\",\n        type: \"function\",\n      },\n    ],\n    Ethers.provider().getSigner()\n  );\n\n  rewardsProvider\n    .getAllUserRewards(addrs, account)\n    .then((res) => {\n      console.log(\n        \"getAllUserRewards_res:\",\n        res,\n        ethers.utils.formatUnits(res[1][1])\n      );\n      const _amount = ethers.utils.formatUnits(res[1][1]);\n      State.update({\n        rewardsAmount: _amount,\n      });\n    })\n    .catch((err) => {\n      console.log(\"getAllUserRewards_error:\", err);\n    });\n}\n\nfunction chunk(arr, size) {\n  let result = [];\n\n  let temp = [];\n  for (let i = arr.length - 1; i > -1; i--) {\n    temp.push(arr[i]);\n    if (temp.length === size) {\n      result.push(temp);\n\n      temp = [];\n    }\n  }\n  if (temp.length !== 0) result.push(temp);\n  return result;\n}\n\n// to get collateral status\nfunction getCollateralStatus() {\n  const calls = [\n    {\n      address: config.aavePoolV3Address,\n      name: \"getUserConfiguration\",\n      params: [account],\n    },\n    {\n      address: config.aavePoolV3Address,\n      name: \"getReservesList\",\n    },\n  ];\n\n  multicall({\n    abi: config.aavePoolV3ABI.body,\n    calls,\n    options: {},\n    multicallAddress,\n    provider: Ethers.provider(),\n  })\n    .then((res) => {\n      console.log(\"getCollateralStatus-res:\", res);\n      const [[rawStatus], [addrs]] = res;\n      const _status = parseInt(rawStatus.toString()).toString(2).split(\"\");\n      const _statusArray = chunk(_status, 2);\n      // console.log(\"_status--\", _statusArray, addrs);\n      const _yourSupplies = [...state.yourSupplies];\n      for (let i = 0; i < _yourSupplies.length; i++) {\n        const item = _yourSupplies[i];\n        const index = addrs.findIndex((addr) => addr === item.underlyingAsset);\n\n        _yourSupplies[i].isCollateraled = Number(_statusArray[index][0]);\n      }\n\n      const yourTotalCollateral = _yourSupplies\n        .filter((item) => item.isCollateraled === 1)\n        .reduce(\n          (prev, curr) =>\n            Big(prev)\n              .plus(Big(curr.underlyingBalanceUSD || 0))\n              .toFixed(),\n          0\n        );\n\n      State.update({\n        yourSupplies: _yourSupplies,\n        yourTotalCollateral,\n      });\n    })\n    .catch((err) => {\n      console.log(\"getCollateralStatus-error:\", err);\n    });\n}\n\nuseEffect(() => {\n  if (!isChainSupported) return;\n  getLiquidity();\n  fetchUserAccountData();\n}, [isChainSupported]);\n\nuseEffect(() => {\n  if (!account) return;\n\n  if (dexConfig.rewardToken) {\n    getAllUserRewards();\n  }\n}, [dexConfig, fresh]);\n\nuseEffect(() => {\n  if (!isChainSupported || !state.assetsToSupply) return;\n\n  getPoolDataProvider();\n  getPoolDataProviderTotalSupply();\n  getPoolDataProviderTotalDebt();\n  if (dexConfig.name === \"Seamless Protocol\") {\n    getPoolDataProviderCaps();\n  }\n  getUserDeposits();\n}, [state.assetsToSupply]);\n\nuseEffect(() => {\n  if (dexConfig.name !== \"Seamless Protocol\") return;\n  if (!Array.isArray(state.assetsToSupply)) return;\n  console.log(\"calc totalMarketSize\");\n  const totalMarketSize = state.assetsToSupply.reduce((prev, curr) => {\n    return Big(prev).plus(Big(curr.totalSupplyUSD)).toFixed();\n  }, 0);\n  const totalBorrows = state.assetsToSupply.reduce((prev, curr) => {\n    return Big(prev).plus(Big(curr.totalDebtsUSD)).toFixed();\n  }, 0);\n  const totalAvailable = Big(totalMarketSize)\n    .minus(Big(totalBorrows))\n    .toFixed();\n  State.update({\n    totalMarketSize,\n    totalAvailable,\n    totalBorrows,\n  });\n}, [state.assetsToSupply]);\n\nuseEffect(() => {\n  if (![\"zerolend\", \"AAVE V3\"].includes(dexConfig.name)) return;\n\n  if (!state.yourSupplies || !state.yourBorrows) return;\n  console.log(\"calc net apy\");\n  //calc net worth\n  const supplyBal = state.yourSupplies.reduce(\n    (total, cur) =>\n      Big(total || 0)\n        .plus(cur.underlyingBalanceUSD)\n        .toFixed(),\n    0\n  );\n  console.log(\"supplyBal--\", supplyBal);\n  const debtsBal = state.yourBorrows.debts.reduce(\n    (total, cur) =>\n      Big(total || 0)\n        .plus(cur.balanceInUSD)\n        .toFixed(),\n    0\n  );\n  console.log(\"debtsBal--\", debtsBal, supplyBal);\n  const netWorth = Big(supplyBal || 0)\n    .minus(debtsBal)\n    .toFixed(2, ROUND_DOWN);\n  console.log(\"netWorth--\", netWorth, state.yourSupplies);\n  if (!Number(netWorth)) return;\n\n  //calc net apy\n\n  const weightedAverageSupplyAPY = state.yourSupplies.reduce(\n    (total, cur) =>\n      Big(total || 0)\n        .plus(\n          Big(cur.underlyingBalanceUSD || 0)\n            .times(Big(cur.supplyAPY || 0))\n            .div(supplyBal || 1)\n        )\n        .toFixed(),\n    0\n  );\n  console.log(\"weightedAverageSupplyAPY--\", weightedAverageSupplyAPY);\n  const weightedAverageBorrowsAPY = state.yourBorrows.debts.reduce(\n    (total, cur) =>\n      Big(total || 0)\n        .plus(\n          Big(cur.balanceInUSD)\n            .times(Big(cur.variableBorrowAPY))\n            .div(debtsBal || 1)\n        )\n        .toFixed(),\n    0\n  );\n  console.log(\"weightedAverageBorrowsAPY--\", weightedAverageBorrowsAPY);\n\n  const a = Big(weightedAverageSupplyAPY || 0)\n    .times(supplyBal)\n    .div(netWorth || 1)\n    .toFixed();\n  console.log(\"a--\", a);\n  const b = Big(weightedAverageBorrowsAPY || 0)\n    .times(debtsBal)\n    .div(netWorth || 1)\n    .toFixed();\n  console.log(\"b--\", b);\n  const totalNetApy = Big(a).minus(Big(b)).toFixed();\n  console.log(\"totalNetApy--\", totalNetApy);\n  const yourTotalSupply = state.yourSupplies.reduce(\n    (prev, curr) =>\n      Big(prev)\n        .plus(Big(curr.underlyingBalanceUSD || 0))\n        .toFixed(),\n    0\n  );\n  console.log(\"yourTotalSupply--\", yourTotalSupply);\n\n  const yourTotalBorrow = state.yourBorrows.debts.reduce(\n    (prev, curr) =>\n      Big(prev)\n        .plus(Big(curr.balanceInUSD || 0))\n        .toFixed(),\n    0\n  );\n  console.log(\"yourTotalBorrow--\", yourTotalBorrow);\n\n  State.update({\n    totalNetApy,\n    netWorthUSD: netWorth,\n    yourTotalSupply,\n    yourTotalBorrow,\n    //TODO + reward apy\n    yourSupplyApy: weightedAverageSupplyAPY,\n    yourBorrowApy: weightedAverageBorrowsAPY,\n  });\n}, [state.yourSupplies, state.yourBorrows]);\n\nuseEffect(() => {\n  if (state.selectTab === \"YOURS\") {\n    getCollateralStatus();\n  }\n}, [state.selectTab]);\n\nfunction onSuccess() {\n  State.update({\n    ...state,\n    fresh: state.fresh + 1,\n  });\n}\n\nconsole.log(\"STATE: \", state);\n\nconst body = isChainSupported ? (\n  <Wrap>\n    <FlexContainer>\n      <ChainsWrap>\n        <Widget\n          src=\"bluebiu.near/widget/Lending.Chains\"\n          props={{\n            chains: CHAIN_LIST,\n            curChain,\n            onSwitchChain,\n            // onChange: (tab) => {\n            //   State.update({\n            //     tab: tab.key,\n            //   });\n            // },\n          }}\n        />\n      </ChainsWrap>\n      <Widget\n        src={`${config.ownerId}/widget/AAVE.HeroData`}\n        props={{\n          config,\n          netWorth: `$ ${\n            state.netWorthUSD ? Big(state.netWorthUSD || 0).toFixed(2) : \"-\"\n          }`,\n          netApy: `${\n            state.totalNetApy\n              ? Number(\n                  Big(state.totalNetApy || 0)\n                    .times(100)\n                    .toFixed(2)\n                )\n              : \"-\"\n          }%`,\n          healthFactor: formatHealthFactor(state.healthFactor),\n          totalMarketSize: state.totalMarketSize,\n          totalAvailable: state.totalAvailable,\n          totalBorrows: state.totalBorrows,\n          theme: dexConfig?.theme,\n        }}\n      />\n    </FlexContainer>\n    <Widget\n      src={`${config.ownerId}/widget/AAVE.TabSwitcher`}\n      props={{\n        config,\n        theme: dexConfig?.theme,\n        select: state.selectTab,\n        setSelect: (tabName) => State.update({ selectTab: tabName }),\n      }}\n    />\n    {state.selectTab === \"MARKET\" && (\n      <>\n        <Widget\n          src={`${config.ownerId}/widget/AAVE.Card.AssetsToSupply`}\n          props={{\n            config,\n            dexConfig,\n            chainId: chainId,\n            assetsToSupply: state.assetsToSupply,\n            showSupplyModal: state.showSupplyModal,\n            setShowSupplyModal: (isShow) =>\n              State.update({ showSupplyModal: isShow }),\n            onActionSuccess,\n            healthFactor: formatHealthFactor(state.healthFactor),\n            formatHealthFactor,\n            calcHealthFactor,\n            depositETHGas,\n            depositERC20Gas,\n            borrowETHGas,\n            borrowERC20Gas,\n            yourSupplies: state.yourSupplies,\n            yourTotalSupply: state.yourTotalSupply,\n            theme: dexConfig?.theme,\n          }}\n        />\n      </>\n    )}\n    {state.selectTab === \"YOURS\" && (\n      <>\n        <Yours>\n          <YoursTableWrapper>\n            <Title>\n              You Supplies\n              <SubTitle>\n                <Label>Balance:</Label>\n                <Value>$ {Number(state.yourTotalSupply).toFixed(2)}</Value>\n\n                <Label>APY:</Label>\n                <Value>\n                  {Big(state.yourSupplyApy).times(100).toFixed(2)} %\n                </Value>\n\n                <Label>Collateral:</Label>\n                <Value>$ {Number(state.yourTotalCollateral).toFixed(2)}</Value>\n              </SubTitle>\n            </Title>\n            <Widget\n              src={`${config.ownerId}/widget/AAVE.Card.YourSupplies`}\n              props={{\n                config,\n                chainId: chainId,\n                yourSupplies: state.yourSupplies,\n                showWithdrawModal: state.showWithdrawModal,\n                setShowWithdrawModal: (isShow) =>\n                  State.update({ showWithdrawModal: isShow }),\n                onActionSuccess,\n                healthFactor: formatHealthFactor(state.healthFactor),\n                formatHealthFactor,\n                calcHealthFactor,\n                withdrawETHGas,\n                withdrawERC20Gas,\n                account,\n                theme: dexConfig?.theme,\n              }}\n            />\n          </YoursTableWrapper>\n          <YoursTableWrapper>\n            <Title>\n              You Borrows\n              <SubTitle>\n                <Label>Balance:</Label>\n                <Value>$ {Number(state.yourTotalBorrow).toFixed(2)}</Value>\n\n                <Label>APY:</Label>\n                <Value>\n                  {Big(state.yourBorrowApy).times(100).toFixed(2)} %\n                </Value>\n\n                <Label>Borrow power used:</Label>\n                <Value>{Number(state.BorrowPowerUsed).toFixed(2)}%</Value>\n              </SubTitle>\n            </Title>\n            <Widget\n              src={`${config.ownerId}/widget/AAVE.Card.YourBorrows`}\n              props={{\n                config,\n                chainId: chainId,\n                assetsToSupply: state.assetsToSupply,\n                yourBorrows: state.yourBorrows,\n                showRepayModal: state.showRepayModal,\n                setShowRepayModal: (isShow) =>\n                  State.update({ showRepayModal: isShow }),\n                showBorrowModal: state.showBorrowModal,\n                setShowBorrowModal: (isShow) =>\n                  State.update({ showBorrowModal: isShow }),\n                formatHealthFactor,\n                calcHealthFactor,\n                onActionSuccess,\n                repayETHGas,\n                repayERC20Gas,\n                borrowETHGas,\n                borrowERC20Gas,\n                theme: dexConfig?.theme,\n              }}\n            />\n          </YoursTableWrapper>\n        </Yours>\n        {dexConfig.rewardToken ? (\n          <Widget\n            src={`${config.ownerId}/widget/AAVE.Card.RewardsTable`}\n            props={{\n              account,\n              config,\n              data: [].concat({\n                ...dexConfig.rewardToken,\n                unclaimed: state.rewardsAmount,\n              }),\n              dapps: dexConfig,\n              onSuccess,\n              markets,\n              rewardAddress: config.incentivesProxy,\n              toast,\n            }}\n          />\n        ) : null}\n      </>\n    )}\n    {state.alertModalText && (\n      <Widget\n        src={`${config.ownerId}/widget/AAVE.Modal.AlertModal`}\n        props={{\n          config,\n          theme: dexConfig?.theme,\n          title: \"All done!\",\n          description: state.alertModalText,\n          onRequestClose: () => State.update({ alertModalText: false }),\n        }}\n      />\n    )}\n  </Wrap>\n) : (\n  <Widget\n    src=\"bluebiu.near/widget/Swap.ChainWarnigBox\"\n    props={{\n      chain: curChain,\n      onSwitchChain: onSwitchChain,\n      switchingChain: switchingChain,\n      theme: dexConfig.theme,\n    }}\n  />\n);\n// );\n\nreturn (\n  <div>\n    {/* Component Head */}\n    <Widget\n      src={`${config.ownerId}/widget/Utils.Import`}\n      props={{ modules, onLoad: importFunctions }}\n    />\n\n    {body}\n  </div>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/bluebiu.near/widget/AAVE-V3", "fact_widget_deployments_id": "bad3abaa86a06b5ffbae06beac01c1cc", "inserted_timestamp": "2024-04-01T15:30:54.729Z", "modified_timestamp": "2024-04-01T15:30:54.729Z", "__row_index": 46}