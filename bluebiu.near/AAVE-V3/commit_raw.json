{"tx_hash": "7rtj6RNpv9MSjThFKJ6sMTFpoRdzinwTPeHiveoBWCGk", "action_id_social": "6iVwRhNQhMva86gwrX9HmXQWuJ7wW9f2nW2ksqJYVXoL-0-widget", "block_id": 112098136, "block_timestamp": "2024-02-04T16:25:51.073Z", "signer_id": "bluebiu.near", "widget_name": "AAVE-V3", "source_code": "const Body = styled.div`\n  padding: 24px 15px;\n  /* background: #0e0e26; */\n  min-height: 100vh;\n  color: white;\n`;\n\nconst FlexContainer = styled.div`\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  flex-direction: column;\n`;\n\nconst ROUND_DOWN = 0;\nconst CONTRACT_ABI = {\n  wrappedTokenGatewayV3ABI:\n    \"https://raw.githubusercontent.com/corndao/aave-v3-bos-app/main/abi/WrappedTokenGatewayV3ABI.json\",\n  erc20Abi:\n    \"https://raw.githubusercontent.com/corndao/aave-v3-bos-app/main/abi/ERC20Permit.json\",\n  aavePoolV3ABI:\n    \"https://raw.githubusercontent.com/corndao/aave-v3-bos-app/main/abi/AAVEPoolV3.json\",\n  variableDebtTokenABI:\n    \"https://raw.githubusercontent.com/corndao/aave-v3-bos-app/main/abi/VariableDebtToken.json\",\n  walletBalanceProviderABI:\n    \"https://raw.githubusercontent.com/corndao/aave-v3-bos-app/main/abi/WalletBalanceProvider.json\",\n};\nconst DEFAULT_CHAIN_ID = 1;\nconst NATIVE_SYMBOL_ADDRESS_MAP_KEY = \"0x0\";\nconst ETH_TOKEN = { name: \"Ethereum\", symbol: \"ETH\", decimals: 18 };\nconst WETH_TOKEN = { name: \"Wrapped Ether\", symbol: \"WETH\", decimals: 18 };\nconst MATIC_TOKEN = { name: \"Matic\", symbol: \"MATIC\", decimals: 18 };\nconst WMATIC_TOKEN = { name: \"Wrapped Matic\", symbol: \"WMATIC\", decimals: 18 };\nconst ACTUAL_BORROW_AMOUNT_RATE = 0.99;\n\nconst account = Ethers.send(\"eth_requestAccounts\", [])[0];\nconst {\n  GAS_LIMIT_RECOMMENDATIONS,\n  chainId,\n  prices,\n  multicallAddress,\n  multicall,\n  isChainSupported,\n  curChain,\n  onSwitchChain,\n  switchingChain,\n  dexConfig,\n} = props;\n\n// Get AAVE network config by chain id\nfunction getNetworkConfig(chainId) {\n  const abis = {\n    wrappedTokenGatewayV3ABI: fetch(CONTRACT_ABI.wrappedTokenGatewayV3ABI),\n    erc20Abi: fetch(CONTRACT_ABI.erc20Abi),\n    aavePoolV3ABI: fetch(CONTRACT_ABI.aavePoolV3ABI),\n    variableDebtTokenABI: fetch(CONTRACT_ABI.variableDebtTokenABI),\n    walletBalanceProviderABI: fetch(CONTRACT_ABI.walletBalanceProviderABI),\n  };\n\n  const constants = {\n    FIXED_LIQUIDATION_VALUE: \"1.0\",\n    MAX_UINT_256:\n      \"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\",\n    AAVE_API_BASE_URL: \"https://aave-data-service-7a85eea3aebe.herokuapp.com\",\n  };\n\n  switch (chainId) {\n    case 1: // ethereum mainnet\n      return {\n        chainName: \"Ethereum Mainnet\",\n        nativeCurrency: ETH_TOKEN,\n        nativeWrapCurrency: WETH_TOKEN,\n        rpcUrl: \"https://rpc.ankr.com/eth\",\n        aavePoolV3Address: \"0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2\",\n        wrappedTokenGatewayV3Address:\n          \"0xD322A49006FC828F9B5B37Ab215F99B4E5caB19C\",\n        balanceProviderAddress: \"0xC7be5307ba715ce89b152f3Df0658295b3dbA8E2\",\n        ...abis,\n        ...constants,\n      };\n    case 42161: // arbitrum one\n      return {\n        chainName: \"Arbitrum Mainnet\",\n        nativeCurrency: ETH_TOKEN,\n        nativeWrapCurrency: WETH_TOKEN,\n        rpcUrl: \"https://arb1.arbitrum.io/rpc\",\n        aavePoolV3Address: \"0x794a61358D6845594F94dc1DB02A252b5b4814aD\",\n        wrappedTokenGatewayV3Address:\n          \"0xB5Ee21786D28c5Ba61661550879475976B707099\",\n        balanceProviderAddress: \"0xBc790382B3686abffE4be14A030A96aC6154023a\",\n        ...abis,\n        ...constants,\n      };\n    case 137: // polygon mainnet\n      return {\n        chainName: \"Polygon Mainnet\",\n        nativeCurrency: MATIC_TOKEN,\n        nativeWrapCurrency: WMATIC_TOKEN,\n        rpcUrl: \"https://rpc.ankr.com/polygon\",\n        aavePoolV3Address: \"0x794a61358D6845594F94dc1DB02A252b5b4814aD\",\n        wrappedTokenGatewayV3Address:\n          \"0x1e4b7A6b903680eab0c5dAbcb8fD429cD2a9598c\",\n        balanceProviderAddress: \"0xBc790382B3686abffE4be14A030A96aC6154023a\",\n        ...abis,\n        ...constants,\n      };\n    case 324: // zkSync\n      return {\n        chainName: \"zkSync Mainnet\",\n        nativeCurrency: ETH_TOKEN,\n        nativeWrapCurrency: WETH_TOKEN,\n        rpcUrl: \"https://1rpc.io/zksync2-era\",\n        aavePoolV3Address: \"0x4d9429246EA989C9CeE203B43F6d1C7D83e3B8F8\",\n        PoolDataProvider: \"0xB73550bC1393207960A385fC8b34790e5133175E\",\n        wrappedTokenGatewayV3Address:\n          \"0x767b4A087c11d7581Ac95eaFfc1FeBFA26bad3d2\",\n        balanceProviderAddress: \"0xdeEa10da04D867e3303AB6E50FA26C2d8a5e9f70\",\n        incentivesProxy: \"0x54AB34aB3C723bD2674c7082aA6fFcdfd3A5BEdc\", //CLAIM\n        ...abis,\n        ...constants,\n      };\n\n      return {\n        chainName: \"Polygon zkEVM Testnet\",\n        nativeCurrency: ETH_TOKEN,\n        nativeWrapCurrency: WETH_TOKEN,\n        rpcUrl: \"https://rpc.public.zkevm-test.net\",\n        aavePoolV3Address: \"0x4412c92f6579D9FC542D108382c8D1d6D2Be63d9\",\n        wrappedTokenGatewayV3Address:\n          \"0xD82940E16D25aB1349914e1C369eF1b287d457BF\",\n        balanceProviderAddress: \"0x0da6DCAd2bE4801b644AEE679e0AdE008bB4bc6b\",\n        ...abis,\n        ...constants,\n      };\n    default:\n      return {};\n    // throw new Error(\"unknown chain id\");\n  }\n}\n\nfunction isValid(a) {\n  if (!a) return false;\n  if (isNaN(Number(a))) return false;\n  if (a === \"\") return false;\n  return true;\n}\n\nfunction getGasPrice() {\n  return Ethers.provider().getGasPrice();\n}\n\nfunction gasEstimation(action) {\n  const assetsToSupply = state.assetsToSupply;\n  if (!assetsToSupply) {\n    return \"-\";\n  }\n  const baseAsset = assetsToSupply.find(\n    (asset) => asset.symbol === config.nativeCurrency.symbol\n  );\n  if (!baseAsset) {\n    return \"-\";\n  }\n\n  const { marketReferencePriceInUsd, decimals } = baseAsset;\n  return getGasPrice().then((gasPrice) => {\n    const gasLimit = GAS_LIMIT_RECOMMENDATIONS[action].limit;\n\n    return Big(gasPrice.toString())\n      .mul(gasLimit)\n      .div(Big(10).pow(decimals))\n      .mul(marketReferencePriceInUsd)\n      .toFixed(2);\n  });\n}\n\nfunction depositETHGas() {\n  return gasEstimation(\"deposit\");\n}\n\nfunction depositERC20Gas() {\n  return gasEstimation(\"supplyWithPermit\");\n}\n\nfunction withdrawETHGas() {\n  return gasEstimation(\"withdrawETH\");\n}\n\nfunction withdrawERC20Gas() {\n  return gasEstimation(\"withdraw\");\n}\n\nfunction borrowETHGas() {\n  return gasEstimation(\"borrowETH\");\n}\n\nfunction borrowERC20Gas() {\n  return gasEstimation(\"borrow\");\n}\n\nfunction repayETHGas() {\n  return gasEstimation(\"repay\");\n}\n\nfunction repayERC20Gas() {\n  return gasEstimation(\"repayWithPermit\");\n}\n\n// App config\nfunction getConfig(network) {\n  switch (network) {\n    case \"mainnet\":\n      return {\n        // ownerId: \"aave-v3.near\",\n        ownerId: \"bluebiu.near\",\n        nodeUrl: \"https://rpc.mainnet.near.org\",\n        ipfsPrefix: \"https://ipfs.near.social/ipfs\",\n        ...(chainId ? getNetworkConfig(chainId) : {}),\n      };\n    default:\n      throw Error(`Unconfigured environment '${network}'.`);\n  }\n}\n\nconst config = getConfig(context.networkId);\n// console.log(\"CONFIG: \", config);\n\nconst markets = [\n  {\n    aTokenAddress: \"0x9002ecb8a06060e3b56669c6B8F18E1c3b119914\",\n    availableLiquidity: 0, //TODO\n    availableLiquidityUSD: \"\",\n    borrowingEnabled: true,\n    decimals: 18,\n    id: \"\",\n    isIsolated: false,\n    marketReferencePriceInUsd: prices[\"ETH\"],\n    name: \"Ethereum\",\n    supplyAPY: \"\",\n    supportPermit: true,\n    symbol: \"ETH\",\n    underlyingAsset: \"0x5AEa5775959fBC2557Cc8789bC1bf90A239D9a91\",\n    usageAsCollateralEnabled: true,\n    variableBorrowAPY: \"\",\n    variableDebtTokenAddress: \"0x56f58d9BE10929CdA709c4134eF7343D73B080Cf\",\n  },\n  {\n    id: \"\",\n    underlyingAsset: \"0x5AEa5775959fBC2557Cc8789bC1bf90A239D9a91\",\n    name: \"Wrapped Ether\",\n    symbol: \"WETH\",\n    decimals: 18,\n    supplyAPY: \"\",\n    marketReferencePriceInUsd: prices[\"WETH\"],\n    usageAsCollateralEnabled: true,\n    borrowingEnabled: true,\n    aTokenAddress: \"0x9002ecb8a06060e3b56669c6B8F18E1c3b119914\",\n    variableDebtTokenAddress: \"0x56f58d9BE10929CdA709c4134eF7343D73B080Cf\",\n    isIsolated: false,\n    availableLiquidity: 0,\n    availableLiquidityUSD: \"\",\n    variableBorrowAPY: \"\",\n    supportPermit: false,\n  },\n  {\n    id: \"\",\n    underlyingAsset: \"0x3355df6D4c9C3035724Fd0e3914dE96A5a83aaf4\",\n    name: \"USD Coin\",\n    symbol: \"USDC\",\n    decimals: 6,\n    supplyAPY: \"\",\n    marketReferencePriceInUsd: prices[\"USDC\"],\n    usageAsCollateralEnabled: true,\n    borrowingEnabled: true,\n    aTokenAddress: \"0x016341e6Da8da66b33Fd32189328c102f32Da7CC\",\n    variableDebtTokenAddress: \"0xE60E1953aF56Db378184997cab20731d17c65004\",\n    isIsolated: false,\n    availableLiquidity: 0,\n    availableLiquidityUSD: \"\",\n    variableBorrowAPY: \"\",\n    supportPermit: false,\n  },\n\n  {\n    id: \"\",\n    underlyingAsset: \"0x493257fd37edb34451f62edf8d2a0c418852ba4c\",\n    name: \"Tether USD\",\n    symbol: \"USDT\",\n    decimals: 6,\n    supplyAPY: \"\",\n    marketReferencePriceInUsd: prices[\"USDT\"],\n    usageAsCollateralEnabled: true,\n    borrowingEnabled: true,\n    aTokenAddress: \"0x9ca4806fa54984Bf5dA4E280b7AA8bB821D21505\",\n    variableDebtTokenAddress: \"0xa333c6FF89525939271E796FbDe2a2D9A970F831\",\n    isIsolated: false,\n    availableLiquidity: 0,\n    availableLiquidityUSD: \"\",\n    variableBorrowAPY: \"\",\n    supportPermit: false,\n  },\n  {\n    id: \"\",\n    underlyingAsset: \"0x493257fd37edb34451f62edf8d2a0c418852ba4c\",\n    name: \"Dai Stablecoin\",\n    symbol: \"DAI\",\n    decimals: 18,\n    supplyAPY: \"\",\n    marketReferencePriceInUsd: prices[\"DAI\"],\n    usageAsCollateralEnabled: true,\n    borrowingEnabled: true,\n    aTokenAddress: \"0x15b362768465F966F1E5983b7AE87f4C5Bf75C55\",\n    variableDebtTokenAddress: \"0x0325F21eB0A16802E2bACD931964434929985548\",\n    isIsolated: false,\n    availableLiquidity: 0,\n    availableLiquidityUSD: \"\",\n    variableBorrowAPY: \"\",\n    supportPermit: false,\n  },\n  {\n    id: \"\",\n    underlyingAsset: \"0x503234F203fC7Eb888EEC8513210612a43Cf6115\",\n    decimals: 18,\n    symbol: \"LUSD\",\n    name: \"LUSD Stablecoin\",\n    supplyAPY: \"\",\n    marketReferencePriceInUsd: prices[\"LUSD\"],\n    usageAsCollateralEnabled: true,\n    borrowingEnabled: true,\n    aTokenAddress: \"0xd97Ac0ce99329EE19b97d03E099eB42D7Aa19ddB\",\n    variableDebtTokenAddress: \"0x41c618CCE58Fb27cAF4EEb1dd25de1d03A0DAAc6\",\n    isIsolated: false,\n    availableLiquidity: 0,\n    availableLiquidityUSD: \"\",\n    variableBorrowAPY: \"\",\n    supportPermit: false,\n  },\n];\n\n// console.log(\"markets\", markets);\nconst marketsMapping = markets.reduce((prev, cur) => {\n  prev[cur.underlyingAsset] = cur;\n  return prev;\n}, {});\n// console.log(\"marketsMapping: \", marketsMapping);\n\n// const nativeMarket = markets.find(\n//   (market) => market.symbol === config.nativeWrapCurrency.symbol\n// );\n// markets.push({\n//   ...nativeMarket,\n//   ...{\n//     ...config.nativeCurrency,\n//     supportPermit: true,\n//   },\n// });\n// console.log(\"full markerts:\", markets);\n\n// App states\nState.init({\n  imports: {},\n  showWithdrawModal: false,\n  showSupplyModal: false,\n  showRepayModal: false,\n  showBorrowModal: false,\n\n  assetsToSupply: undefined, //[{markets}]\n  yourSupplies: undefined, //[{markets}]\n  assetsToBorrow: {\n    availableBorrowsUSD: \"\",\n    debts: markets, //TODO?\n    healthFactor: \"\",\n    netApy: \"\",\n    netWorthUSD: \"\",\n  },\n  yourBorrows: {\n    availableBorrowsUSD: \"\",\n    debts: [],\n    healthFactor: \"\",\n    netAPY: 0.013302895831857352,\n    netWorthUSD: \"3.94563967927797537582010364\",\n  },\n  baseAssetBalance: undefined,\n  selectTab: \"supply\", // supply | borrow\n});\n\nconst loading =\n  !state.assetsToSupply || !state.yourSupplies || !state.assetsToBorrow;\n\n// Import functions to state.imports\nfunction importFunctions(imports) {\n  if (loading) {\n    State.update({\n      imports,\n    });\n  }\n}\n\n// Define the modules you'd like to import\nconst modules = {\n  number: `${config.ownerId}/widget/Utils.Number`,\n  date: `${config.ownerId}/widget/Utils.Date`,\n  data: `${config.ownerId}/widget/AAVE.Data`,\n};\n// Import functions\n// const { formatAmount } = state.imports.number;\n// const { formatDateTime } = state.imports.date;\n\nfunction calculateAvailableBorrows({\n  availableBorrowsUSD,\n  marketReferencePriceInUsd,\n}) {\n  return isValid(availableBorrowsUSD) && isValid(marketReferencePriceInUsd)\n    ? Big(availableBorrowsUSD).div(marketReferencePriceInUsd).toFixed()\n    : Number(0).toFixed();\n}\n\nfunction bigMin(_a, _b) {\n  const a = Big(_a);\n  const b = Big(_b);\n  return a.gt(b) ? b : a;\n}\n\nfunction formatHealthFactor(healthFactor) {\n  // console.log(\"formatHealthFactor:\", healthFactor);\n  if (healthFactor === \"\u221e\") return healthFactor;\n  if (!healthFactor || !isValid(healthFactor)) return \"-\";\n  if (Number(healthFactor) === -1) return \"\u221e\";\n  return Big(healthFactor).toFixed(2, ROUND_DOWN);\n}\n\nfunction batchBalanceOf(chainId, userAddress, tokenAddresses, abi) {\n  const balanceProvider = new ethers.Contract(\n    config.balanceProviderAddress,\n    abi.body,\n    Ethers.provider().getSigner()\n  );\n\n  return balanceProvider.batchBalanceOf([userAddress], tokenAddresses);\n}\n\n// update data in async manner\nfunction updateData(refresh) {\n  // check abi loaded\n  if (\n    Object.keys(CONTRACT_ABI)\n      .map((key) => config[key])\n      .filter((ele) => !!ele).length !== Object.keys(CONTRACT_ABI).length\n  ) {\n    return;\n  }\n  const provider = Ethers.provider();\n  provider\n    .getSigner()\n    ?.getBalance()\n    .then((balance) => State.update({ baseAssetBalance: balance }));\n  if (!account || !state.baseAssetBalance) {\n    return;\n  }\n\n  // get user balances\n  batchBalanceOf(\n    chainId,\n    account,\n    markets.map((market) => market.underlyingAsset),\n    config.walletBalanceProviderABI\n  )\n    .then((balances) => {\n      // console.log(\n      //   \"getBalance\",\n      //   balances,\n      //   balances.map((balance) => balance.toString())\n      // );\n      return balances.map((balance) => balance.toString());\n    })\n    .then((userBalances) => {\n      const assetsToSupply = markets\n        .map((market, idx) => {\n          const balanceRaw = Big(\n            market.symbol === config.nativeCurrency.symbol\n              ? state.baseAssetBalance\n              : userBalances[idx]\n          ).div(Big(10).pow(market.decimals));\n          const balance = balanceRaw.toFixed(market.decimals, ROUND_DOWN);\n          const balanceInUSD = balanceRaw\n            .mul(market.marketReferencePriceInUsd)\n            .toFixed(3, ROUND_DOWN);\n          return {\n            ...market,\n            balance,\n            balanceInUSD,\n          };\n        })\n        .sort((asset1, asset2) => {\n          const balanceInUSD1 = Number(asset1.balanceInUSD);\n          const balanceInUSD2 = Number(asset2.balanceInUSD);\n          if (balanceInUSD1 !== balanceInUSD2)\n            return balanceInUSD2 - balanceInUSD1;\n          return asset1.symbol.localeCompare(asset2.symbol);\n        });\n\n      State.update({\n        assetsToSupply,\n      });\n      // get user borrow data\n      // updateUserDebts(marketsMapping, assetsToSupply, refresh);\n    })\n    .catch((err) => {\n      console.log(\"batchBalanceOfERROR:\", err);\n    });\n  // get user supplies\n  // updateUserSupplies(marketsMapping, refresh);\n  // });\n}\n\n// function updateUserDebts(marketsMapping, assetsToSupply, refresh) {\n//   if (!marketsMapping || !assetsToSupply) {\n//     return;\n//   }\n\n//   const prevYourBorrows = state.yourBorrows;\n//   // userDebts depends on the balance from assetsToSupply\n//   const assetsToSupplyMap = assetsToSupply.reduce((prev, cur) => {\n//     if (cur.symbol !== config.nativeCurrency.symbol) {\n//       prev[cur.underlyingAsset] = cur;\n//     } else {\n//       prev[NATIVE_SYMBOL_ADDRESS_MAP_KEY] = cur;\n//     }\n//     return prev;\n//   }, {});\n\n//   const debts = debts\n//     .map((userDebt) => {\n//       const market = marketsMapping[userDebt.underlyingAsset];\n//       if (!market) {\n//         return;\n//       }\n//       const { availableLiquidityUSD } = market;\n//       const availableBorrowsUSD = bigMin(\n//         userDebts.availableBorrowsUSD,\n//         availableLiquidityUSD\n//       )\n//         .times(ACTUAL_BORROW_AMOUNT_RATE)\n//         .toFixed();\n//       const assetsToSupplyMapKey =\n//         market.symbol === config.nativeWrapCurrency.symbol\n//           ? NATIVE_SYMBOL_ADDRESS_MAP_KEY\n//           : userDebt.underlyingAsset;\n//       return {\n//         ...market,\n//         ...userDebt,\n//         ...(market.symbol === config.nativeWrapCurrency.symbol\n//           ? {\n//               ...config.nativeCurrency,\n//               supportPermit: true,\n//             }\n//           : {}),\n//         availableBorrows: calculateAvailableBorrows({\n//           availableBorrowsUSD,\n//           marketReferencePriceInUsd: market.marketReferencePriceInUsd,\n//         }),\n//         availableBorrowsUSD,\n//         balance: assetsToSupplyMap[assetsToSupplyMapKey].balance,\n//         balanceInUSD: assetsToSupplyMap[assetsToSupplyMapKey].balanceInUSD,\n//       };\n//     })\n//     .filter((asset) => !!asset)\n//     .sort((asset1, asset2) => {\n//       const availableBorrowsUSD1 = Number(asset1.availableBorrowsUSD);\n//       const availableBorrowsUSD2 = Number(asset2.availableBorrowsUSD);\n//       if (availableBorrowsUSD1 !== availableBorrowsUSD2)\n//         return availableBorrowsUSD2 - availableBorrowsUSD1;\n//       return asset1.symbol.localeCompare(asset2.symbol);\n//     })\n//     .filter((asset) => {\n//       return asset.borrowingEnabled;\n//     });\n\n//   const assetsToBorrow = {\n//     // healthFactor: formatHealthFactor(userDebts.healthFactor),\n//     debts,\n//   };\n//   const yourBorrows = {\n//     ...assetsToBorrow,\n//     debts: assetsToBorrow.debts.filter(\n//       (row) =>\n//         !isNaN(Number(row.variableBorrowsUSD)) &&\n//         Number(row.variableBorrowsUSD) > 0\n//     ),\n//   };\n\n//   State.update({\n//     yourBorrows,\n//     assetsToBorrow,\n//   });\n\n//   if (\n//     refresh &&\n//     JSON.stringify(prevYourBorrows) === JSON.stringify(yourBorrows)\n//   ) {\n//     console.log(\"refresh borrows again ...\", prevYourBorrows, yourBorrows);\n//     setTimeout(updateData, 500);\n//   }\n//   // });\n// }\n\nfunction onActionSuccess({ msg, callback }) {\n  // update data if action finishes\n  updateData(true);\n  // update UI after data has almost loaded\n  setTimeout(() => {\n    if (callback) {\n      callback();\n    }\n    if (msg) {\n      State.update({ alertModalText: msg });\n    }\n  }, 5000);\n}\n\nif (chainId && isChainSupported && loading) {\n  updateData();\n}\n\nfunction getPoolDataProvider() {\n  if (!state.assetsToSupply) return;\n  const prevAssetsToSupply = state.assetsToSupply;\n  const prevAssetsToBorrow = state.assetsToBorrow;\n  const underlyingTokens = prevAssetsToSupply.map(\n    (item) => item.underlyingAsset\n  );\n\n  const calls = underlyingTokens.map((addr) => ({\n    address: config.PoolDataProvider,\n    name: \"getReserveData\",\n    params: [addr],\n  }));\n\n  multicall({\n    abi: [\n      {\n        inputs: [{ internalType: \"address\", name: \"asset\", type: \"address\" }],\n        name: \"getReserveData\",\n        outputs: [\n          { internalType: \"uint256\", name: \"unbacked\", type: \"uint256\" },\n          {\n            internalType: \"uint256\",\n            name: \"accruedToTreasuryScaled\",\n            type: \"uint256\",\n          },\n          { internalType: \"uint256\", name: \"totalAToken\", type: \"uint256\" },\n          {\n            internalType: \"uint256\",\n            name: \"totalStableDebt\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"totalVariableDebt\",\n            type: \"uint256\",\n          },\n          { internalType: \"uint256\", name: \"liquidityRate\", type: \"uint256\" },\n          {\n            internalType: \"uint256\",\n            name: \"variableBorrowRate\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"stableBorrowRate\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"averageStableBorrowRate\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"liquidityIndex\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"variableBorrowIndex\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint40\",\n            name: \"lastUpdateTimestamp\",\n            type: \"uint40\",\n          },\n        ],\n        stateMutability: \"view\",\n        type: \"function\",\n      },\n    ],\n    calls,\n    options: {},\n    multicallAddress,\n    provider: Ethers.provider(),\n  })\n    .then((res) => {\n      console.log(\"getPoolDataProvider_res\", res);\n\n      for (let i = 0; i < res.length; i++) {\n        if (res[i]) {\n          const [\n            unbacked,\n            accruedToTreasuryScaled,\n            totalAToken,\n            totalStableDebt,\n            totalVariableDebt,\n            liquidityRate,\n            variableBorrowRate,\n            stableBorrowRate,\n            averageStableBorrowRate,\n            liquidityIndex,\n            variableBorrowIndex,\n            lastUpdateTimestamp,\n          ] = res[i];\n          const RAY = Big(10).pow(27);\n          const SECONDS_PER_YEAR = 31_536_000;\n          const depositAPR = Big(liquidityRate).div(RAY);\n          const depositAPY0 = Big(1)\n            .plus(depositAPR.div(Big(SECONDS_PER_YEAR)))\n            .toNumber();\n          const depositAPY = Big(\n            Math.pow(depositAPY0, SECONDS_PER_YEAR) - 1\n          ).toFixed();\n\n          const variableBorrowAPR = Big(variableBorrowRate).div(RAY);\n\n          const variableBorrowAPY0 = Big(1)\n            .plus(Big(variableBorrowAPR).div(Big(SECONDS_PER_YEAR)))\n            .toNumber();\n\n          const variableBorrowAPYRaw = Big(\n            100 * (Math.pow(variableBorrowAPY0, SECONDS_PER_YEAR) - 1)\n          );\n\n          const variableBorrowAPY = Big(\n            Math.pow(variableBorrowAPY0, SECONDS_PER_YEAR) - 1\n          ).toFixed();\n          // const netApy = Big(depositAPY0).minus(variableBorrowAPYRaw).toFixed();\n          prevAssetsToSupply[i].supplyAPY = depositAPY;\n          prevAssetsToSupply[i].variableBorrowAPY = variableBorrowAPY;\n          // prevAssetsToBorrow.netApy = netApy;\n          // prevAssetsToBorrow.variableBorrowAPY = variableBorrowAPY;\n        }\n      }\n      State.update({\n        assetsToSupply: prevAssetsToSupply,\n        assetsToBorrow: {\n          ...state.assetsToBorrow,\n          netApy,\n          debts: prevAssetsToSupply,\n        },\n      });\n    })\n    .catch((err) => {\n      console.log(\"getPoolDataProvider_err\", err);\n    });\n}\n\n// healthFactor\nfunction fetchUserAccountData() {\n  const contract = new ethers.Contract(\n    config.aavePoolV3Address,\n    config.aavePoolV3ABI.body,\n    Ethers.provider()\n  );\n  contract\n    .getUserAccountData(account)\n    .then((res) => {\n      console.log(\"getUserAccountData_res:\", res);\n      const [\n        totalCollateralBase,\n        totalDebtBase,\n        availableBorrowsBase,\n        currentLiquidationThreshold,\n        ltv,\n        healthFactor,\n      ] = res;\n      // onLoad({\n      //   deposits: ethers.utils.formatUnits(res),\n      // });\n      State.update({\n        assetsToBorrow: {\n          ...state.assetsToBorrow,\n          healthFactor: ethers.utils.formatUnits(healthFactor),\n        },\n      });\n      // formatHealthFactor(healthFactor)\n    })\n    .catch((err) => {\n      console.log(\"getUserAccountData_error\", err);\n    });\n}\n\nfunction getUserDeposits() {\n  const aTokenAddresss = markets.map((item) => item.aTokenAddress);\n\n  const calls = aTokenAddresss.map((addr) => ({\n    address: addr,\n    name: \"balanceOf\",\n    params: [account],\n  }));\n  multicall({\n    abi: [\n      {\n        inputs: [\n          {\n            internalType: \"address\",\n            name: \"user\",\n            type: \"address\",\n          },\n        ],\n        name: \"balanceOf\",\n        outputs: [\n          {\n            internalType: \"uint256\",\n            name: \"\",\n            type: \"uint256\",\n          },\n        ],\n        stateMutability: \"view\",\n        type: \"function\",\n      },\n    ],\n    calls,\n    options: {},\n    multicallAddress,\n    provider: Ethers.provider(),\n  })\n    .then((res) => {\n      console.log(\"getUsetDeposits_res\", res);\n      let userDeposits = [];\n      for (let index = 0; index < res.length; index++) {\n        if (res[index]) {\n          // let underlyingBalance=\n          let market = markets.find(\n            (item) => item.aTokenAddress === aTokenAddresss[index]\n          );\n\n          let _bal = ethers.utils.formatUnits(res[index][0], market.decimals);\n          market.underlyingBalance = _bal;\n          market.underlyingBalanceUSD = Big(_bal)\n            .mul(prices[market.symbol])\n            .toFixed();\n          userDeposits.push(market);\n        }\n      }\n\n      const yourSupplies = userDeposits.map((userDeposit) => {\n        const market = marketsMapping[userDeposit.underlyingAsset];\n        return {\n          ...market,\n          ...userDeposit,\n          ...(market.symbol === config.nativeWrapCurrency.symbol\n            ? {\n                ...config.nativeCurrency,\n                supportPermit: true,\n              }\n            : {}),\n        };\n      });\n      console.log(\"yourSupplies:\", yourSupplies);\n      State.update({\n        yourSupplies,\n      });\n    })\n    .catch((err) => {\n      console.log(\"getUsetDeposits_err\", err);\n    })\n    .finally(() => {\n      getUserDebts();\n    });\n}\n\nfunction getUserDebts() {\n  const variableDebtTokenAddresss = markets.map(\n    (item) => item.variableDebtTokenAddress\n  );\n\n  const calls = variableDebtTokenAddresss.map((addr) => ({\n    address: addr,\n    name: \"balanceOf\",\n    params: [account],\n  }));\n\n  multicall({\n    abi: [\n      {\n        inputs: [\n          {\n            internalType: \"address\",\n            name: \"user\",\n            type: \"address\",\n          },\n        ],\n        name: \"balanceOf\",\n        outputs: [\n          {\n            internalType: \"uint256\",\n            name: \"\",\n            type: \"uint256\",\n          },\n        ],\n        stateMutability: \"view\",\n        type: \"function\",\n      },\n    ],\n    calls,\n    options: {},\n    multicallAddress,\n    provider: Ethers.provider(),\n  })\n    .then((res) => {\n      console.log(\"getUserDebts_res\", res);\n      let userDebs = [];\n      for (let index = 0; index < res.length; index++) {\n        if (res[index]) {\n          let market = markets.find(\n            (item) =>\n              item.variableDebtTokenAddress === variableDebtTokenAddresss[index]\n          );\n\n          let _bal = ethers.utils.formatUnits(res[index][0], market.decimals);\n          market.balance = _bal;\n          market.balanceInUSD = Big(_bal).mul(prices[market.symbol]).toFixed();\n          userDebs.push(market);\n        }\n      }\n      // const yourBorrows = userDebs.map((userDebt) => {\n      //   const market = marketsMapping[userDebt.underlyingAsset];\n      //   return {\n      //     ...market,\n      //     ...userDebt,\n      //     ...(market.symbol === config.nativeWrapCurrency.symbol\n      //       ? {\n      //           ...config.nativeCurrency,\n      //           supportPermit: true,\n      //         }\n      //       : {}),\n      //   };\n      // });\n      console.log(\"yourBorrows:\", state.yourBorrows);\n      State.update({\n        yourBorrows: {\n          ...state.yourBorrows,\n          debts: userDebs,\n        },\n      });\n    })\n    .catch((err) => {\n      console.log(\"getUserDebts_err\", err);\n    });\n}\n\nuseEffect(() => {\n  if (isChainSupported) {\n    fetchUserAccountData();\n    getUserDeposits();\n  }\n}, []);\nuseEffect(() => {\n  if (isChainSupported) {\n    getPoolDataProvider();\n  }\n}, [state.assetsToSupply]);\n\nfunction calcNetWorth() {\n  if (!state.yourSupplies || !state.yourBorrows) return;\n\n  const supplyBal = state.yourSupplies.reduce(\n    (total, cur) => Big(total).plus(cur.underlyingBalanceUSD).toFixed(),\n    0\n  );\n  const debtsBal = state.yourBorrows.debts.reduce(\n    (total, cur) => Big(total).plus(cur.balanceInUSD).toFixed(),\n    0\n  );\n  const netWorth = Big(supplyBal).minus(debtsBal).toFixed(2, ROUND_DOWN);\n  State.update({\n    assetsToBorrow: {\n      ...state.assetsToBorrow,\n      netWorthUSD: netWorth,\n    },\n  });\n}\n\n//calc net worth\nuseEffect(() => {\n  if (!state.yourSupplies || !state.yourBorrows) return;\n\n  const supplyBal = state.yourSupplies.reduce(\n    (total, cur) => Big(total).plus(cur.underlyingBalanceUSD).toFixed(),\n    0\n  );\n  const debtsBal = state.yourBorrows.debts.reduce(\n    (total, cur) => Big(total).plus(cur.balanceInUSD).toFixed(),\n    0\n  );\n  const netWorth = Big(supplyBal).minus(debtsBal).toFixed(2, ROUND_DOWN);\n  State.update({\n    assetsToBorrow: {\n      ...state.assetsToBorrow,\n      netWorthUSD: netWorth,\n    },\n  });\n}, [state.yourSupplies, state.yourBorrows]);\n\nconsole.log(\"STATE: \", state);\n\nconst body = isChainSupported ? (\n  <Body>\n    <FlexContainer>\n      <Widget\n        src={`${config.ownerId}/widget/AAVE.HeroData`}\n        props={{\n          config,\n          netWorth: `$ ${\n            state.assetsToBorrow?.netWorthUSD\n              ? Big(state.assetsToBorrow.netWorthUSD).toFixed(2)\n              : \"-\"\n          }`,\n          netApy: `${\n            state.assetsToBorrow?.netAPY\n              ? Number(\n                  Big(state.assetsToBorrow.netAPY).times(100).toFixed(2)\n                ) === 0\n                ? \"0.00\"\n                : Big(state.assetsToBorrow.netAPY).times(100).toFixed(2)\n              : \"-\"\n          }%`,\n          healthFactor: formatHealthFactor(state.assetsToBorrow.healthFactor),\n          //TODO\n          // showHealthFactor:\n          //   state.yourBorrows &&\n          //   state.yourBorrows.debts &&\n          //   state.yourBorrows.debts.length > 0,\n          showHealthFactor: true,\n        }}\n      />\n    </FlexContainer>\n    <Widget\n      src={`${config.ownerId}/widget/AAVE.TabSwitcher`}\n      props={{\n        config,\n        select: state.selectTab,\n        setSelect: (tabName) => State.update({ selectTab: tabName }),\n      }}\n    />\n    {state.selectTab === \"supply\" && (\n      <>\n        <Widget\n          src={`${config.ownerId}/widget/AAVE.Card.YourSupplies`}\n          props={{\n            config,\n            chainId: chainId,\n            yourSupplies: state.yourSupplies,\n            showWithdrawModal: state.showWithdrawModal,\n            setShowWithdrawModal: (isShow) =>\n              State.update({ showWithdrawModal: isShow }),\n            onActionSuccess,\n            healthFactor: formatHealthFactor(state.assetsToBorrow.healthFactor),\n            formatHealthFactor,\n            withdrawETHGas,\n            withdrawERC20Gas,\n          }}\n        />\n        <Widget\n          src={`${config.ownerId}/widget/AAVE.Card.AssetsToSupply`}\n          props={{\n            config,\n            chainId: chainId,\n            assetsToSupply: state.assetsToSupply,\n            showSupplyModal: state.showSupplyModal,\n            setShowSupplyModal: (isShow) =>\n              State.update({ showSupplyModal: isShow }),\n            onActionSuccess,\n            healthFactor: formatHealthFactor(state.assetsToBorrow.healthFactor),\n            formatHealthFactor,\n            depositETHGas,\n            depositERC20Gas,\n          }}\n        />\n      </>\n    )}\n    {state.selectTab === \"borrow\" && (\n      <>\n        <Widget\n          src={`${config.ownerId}/widget/AAVE.Card.YourBorrows`}\n          props={{\n            config,\n            chainId: chainId,\n            yourBorrows: state.yourBorrows,\n            showRepayModal: state.showRepayModal,\n            setShowRepayModal: (isShow) =>\n              State.update({ showRepayModal: isShow }),\n            showBorrowModal: state.showBorrowModal,\n            setShowBorrowModal: (isShow) =>\n              State.update({ showBorrowModal: isShow }),\n            formatHealthFactor,\n            onActionSuccess,\n            repayETHGas,\n            repayERC20Gas,\n            borrowETHGas,\n            borrowERC20Gas,\n          }}\n        />\n        <Widget\n          src={`${config.ownerId}/widget/AAVE.Card.AssetsToBorrow`}\n          props={{\n            config,\n            chainId: chainId,\n            assetsToBorrow: state.assetsToBorrow,\n            showBorrowModal: state.showBorrowModal,\n            yourSupplies: state.yourSupplies,\n            setShowBorrowModal: (isShow) =>\n              State.update({ showBorrowModal: isShow }),\n            formatHealthFactor,\n            onActionSuccess,\n            borrowETHGas,\n            borrowERC20Gas,\n          }}\n        />\n      </>\n    )}\n    {state.alertModalText && (\n      <Widget\n        src={`${config.ownerId}/widget/AAVE.Modal.AlertModal`}\n        props={{\n          config,\n          title: \"All done!\",\n          description: state.alertModalText,\n          onRequestClose: () => State.update({ alertModalText: false }),\n        }}\n      />\n    )}\n  </Body>\n) : (\n  <Widget\n    src=\"bluebiu.near/widget/Swap.ChainWarnigBox\"\n    props={{\n      chain: curChain,\n      onSwitchChain: onSwitchChain,\n      switchingChain: switchingChain,\n      theme: dexConfig.theme?.button,\n    }}\n  />\n);\n// );\n\nreturn (\n  <div>\n    {/* Component Head */}\n    <Widget\n      src={`${config.ownerId}/widget/Utils.Import`}\n      props={{ modules, onLoad: importFunctions }}\n    />\n\n    {body}\n  </div>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/bluebiu.near/widget/AAVE-V3", "fact_widget_deployments_id": "69e35f1f449bde02ab8cab1d641cb43f", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 40}