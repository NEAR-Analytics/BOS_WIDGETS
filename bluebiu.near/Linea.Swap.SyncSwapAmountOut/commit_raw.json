{"tx_hash": "3mRWzPr7omtdShHcMUUGMuQcHcMJvchZdgt9ZzQPR3Vb", "action_id_social": "BWmgqi22dVhrnAhAYRaLpVTFRHeURbdNYGrsdGhJkenH-0-widget", "block_id": 111258705, "block_timestamp": "2024-01-25T05:46:49.206Z", "signer_id": "bluebiu.near", "widget_name": "Linea.Swap.SyncSwapAmountOut", "source_code": "const POOL_ABI = [\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\",\n      },\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\",\n      },\n    ],\n    name: \"getPool\",\n    outputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\nconst PAIR_ABI = [\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"_tokenIn\",\n        type: \"address\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"_amountIn\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"address\",\n        name: \"_sender\",\n        type: \"address\",\n      },\n    ],\n    name: \"getAmountOut\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"_amountOut\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"getReserves\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"_reserve0\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"_reserve1\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\n\nconst ROUTER_ABI = [\n  {\n    inputs: [\n      {\n        components: [\n          {\n            components: [\n              {\n                internalType: \"address\",\n                name: \"pool\",\n                type: \"address\",\n              },\n              {\n                internalType: \"bytes\",\n                name: \"data\",\n                type: \"bytes\",\n              },\n              {\n                internalType: \"address\",\n                name: \"callback\",\n                type: \"address\",\n              },\n              {\n                internalType: \"bytes\",\n                name: \"callbackData\",\n                type: \"bytes\",\n              },\n            ],\n            internalType: \"struct IRouter.SwapStep[]\",\n            name: \"steps\",\n            type: \"tuple[]\",\n          },\n          {\n            internalType: \"address\",\n            name: \"tokenIn\",\n            type: \"address\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"amountIn\",\n            type: \"uint256\",\n          },\n        ],\n        internalType: \"struct IRouter.SwapPath[]\",\n        name: \"paths\",\n        type: \"tuple[]\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"amountOutMin\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"deadline\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"swap\",\n    outputs: [\n      {\n        components: [\n          {\n            internalType: \"address\",\n            name: \"token\",\n            type: \"address\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"amount\",\n            type: \"uint256\",\n          },\n        ],\n        internalType: \"struct IPool.TokenAmount\",\n        name: \"amountOut\",\n        type: \"tuple\",\n      },\n    ],\n    stateMutability: \"payable\",\n    type: \"function\",\n  },\n];\n\nconst ZERO_ADDRESS = \"0x0000000000000000000000000000000000000000\";\n\nconst {\n  updater,\n  routerAddress,\n  classicPoolAddres,\n  stablePoolAddress,\n  wethAddress,\n  inputCurrency,\n  outputCurrency,\n  inputCurrencyAmount,\n  onLoad,\n  slippage,\n  account,\n} = props;\n\nuseEffect(() => {\n  if (!updater) return;\n\n  if (\n    (!inputCurrency.address && !inputCurrency.isNative) ||\n    (!outputCurrency.address && !outputCurrency.isNative) ||\n    !inputCurrencyAmount\n  ) {\n    return;\n  }\n\n  const wrapType =\n    inputCurrency.address === \"native\" && outputCurrency.address === wethAddress\n      ? 1\n      : inputCurrency.address === wethAddress &&\n        outputCurrency.address === \"native\"\n      ? 2\n      : 0;\n\n  if (wrapType) {\n    onLoad({\n      outputCurrencyAmount: inputCurrencyAmount,\n      noPair: false,\n    });\n    return;\n  }\n\n  const amount = ethers.utils.parseUnits(\n    Big(inputCurrencyAmount || 0).toFixed(inputCurrency.decimals),\n    inputCurrency.decimals\n  );\n\n  const path = [\n    inputCurrency.isNative ? wethAddress : inputCurrency.address,\n    outputCurrency.isNative ? wethAddress : outputCurrency.address,\n  ];\n\n  const getStablePoolAddress = () => {\n    const StablePoolContract = new ethers.Contract(\n      stablePoolAddress,\n      POOL_ABI,\n      Ethers.provider().getSigner()\n    );\n    StablePoolContract.getPool(...path)\n      .then((pool) => {\n        if (pool === ZERO_ADDRESS) {\n          onLoad({\n            noPair: true,\n          });\n        } else {\n          getAmountOut(pool);\n        }\n      })\n      .catch((err) => {\n        onLoad({\n          noPair: true,\n        });\n      });\n  };\n\n  const getPoolAddress = () => {\n    const ClassicPoolContract = new ethers.Contract(\n      classicPoolAddres,\n      POOL_ABI,\n      Ethers.provider().getSigner()\n    );\n    ClassicPoolContract.getPool(...path)\n      .then((pool) => {\n        if (pool === ZERO_ADDRESS) {\n          getStablePoolAddress();\n        } else {\n          getAmountOut(pool);\n        }\n      })\n      .catch((err) => {\n        getStablePoolAddress();\n      });\n  };\n  const getAmountOut = (_poolAddress) => {\n    const PairContract = new ethers.Contract(\n      _poolAddress,\n      PAIR_ABI,\n      Ethers.provider().getSigner()\n    );\n    PairContract.getAmountOut(path[0], amount, account)\n      .then((res) => {\n        const amountoutDesimals = Big(\n          ethers.utils.formatUnits(res, outputCurrency.decimals)\n        );\n\n        if (amountoutDesimals.gt(0)) {\n          getReverse({\n            amountOut: res,\n            amountoutDesimals: amountoutDesimals.toString(),\n            poolAddress: _poolAddress,\n          });\n        } else {\n          onLoad({\n            noPair: true,\n          });\n        }\n      })\n      .catch((err) => {\n        onLoad({\n          noPair: true,\n        });\n      });\n  };\n  const getReverse = ({ amountOut, amountoutDesimals, poolAddress }) => {\n    const PairContract = new ethers.Contract(\n      poolAddress,\n      PAIR_ABI,\n      Ethers.provider().getSigner()\n    );\n\n    PairContract.getReserves()\n      .then((res) => {\n        const isReverse = Number(path[0]) > Number(path[1]);\n\n        const token0 = Big(\n          ethers.utils.formatUnits(\n            res[0],\n            isReverse ? outputCurrency.decimals : inputCurrency.decimals\n          )\n        );\n        const token1 = Big(\n          ethers.utils.formatUnits(\n            res[1],\n            isReverse ? inputCurrency.decimals : outputCurrency.decimals\n          )\n        );\n        const poolPrice = token1.div(token0);\n\n        const amountoutPrice = isReverse\n          ? Big(inputCurrencyAmount).div(amountoutDesimals)\n          : Big(amountoutDesimals).div(inputCurrencyAmount);\n\n        const priceImpact = poolPrice\n          .minus(amountoutPrice)\n          .div(poolPrice)\n          .mul(100)\n          .toString();\n\n        getTransaction({\n          priceImpact,\n          amountoutDesimals,\n          amountOut,\n          poolAddress,\n        });\n      })\n      .catch((err) => {\n        getTransaction({\n          amountoutDesimals,\n          amountOut,\n          poolAddress,\n        });\n      });\n  };\n\n  const getTransaction = ({\n    amountOut,\n    amountoutDesimals,\n    priceImpact,\n    poolAddress,\n  }) => {\n    const RouterContract = new ethers.Contract(\n      routerAddress,\n      ROUTER_ABI,\n      Ethers.provider().getSigner()\n    );\n    const deadline = Math.ceil(Date.now() / 1000) + 60;\n    const _amountOut = Big(amountOut)\n      .mul(1 - (slippage || 0.05))\n      .toFixed(0);\n    const withdrawMode = outputCurrency.address === \"native\" ? 1 : 2;\n    const options = {\n      value: inputCurrency.address === \"native\" ? amount : 0,\n    };\n    const swapData = ethers.utils.defaultAbiCoder.encode(\n      [\"address\", \"address\", \"uint8\"],\n      [path[0], account, withdrawMode]\n    );\n    const steps = [\n      {\n        pool: poolAddress,\n        data: swapData,\n        callback: ZERO_ADDRESS, // we don't have a callback\n        callbackData: \"0x\",\n      },\n    ];\n    const paths = [\n      {\n        steps: steps,\n        tokenIn: inputCurrency.isNative ? ZERO_ADDRESS : inputCurrency.address,\n        amountIn: amount,\n      },\n    ];\n\n    const returnData = {\n      outputCurrencyAmount: Big(amountoutDesimals).gt(0.01)\n        ? Big(amountoutDesimals).toPrecision(10)\n        : Big(amountoutDesimals).toFixed(10),\n      priceImpact,\n    };\n\n    const params = [paths, _amountOut, deadline];\n\n    RouterContract.estimateGas\n      .swap(...params, options)\n      .then((_gas) => {\n        RouterContract.populateTransaction\n          .swap(...params, {\n            ...options,\n            gasLimit: _gas,\n          })\n          .then((res) => {\n            onLoad({\n              ...returnData,\n              noPair: false,\n              gas: _gas,\n              unsignedTx: res,\n            });\n          })\n          .catch((err) => {\n            onLoad({\n              ...returnData,\n              noPair: false,\n              gas: _gas,\n            });\n          });\n      })\n      .catch((err) => {\n        onLoad({\n          ...returnData,\n          noPair: false,\n        });\n      });\n  };\n  getPoolAddress();\n}, [updater]);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/bluebiu.near/widget/Linea.Swap.SyncSwapAmountOut", "fact_widget_deployments_id": "76aa6e1bdf45fa48161f39c1c0102154", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 0}