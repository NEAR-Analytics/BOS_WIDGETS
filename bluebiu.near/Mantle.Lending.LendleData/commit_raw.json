{"tx_hash": "Gv6b6dJ351Run7nwH3dRxt7HhzbirWBPe73NKo118bjq", "action_id_social": "hAX7K8qDbyuEwnRZ6DiUc4SvMFDzFhaDV26ZHEuXDu8-0-widget", "block_id": 108519441, "block_timestamp": "2023-12-22T02:00:49.455Z", "signer_id": "bluebiu.near", "widget_name": "Mantle.Lending.LendleData", "source_code": "const native = {\n  address: \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n  decimals: 18,\n  symbol: \"BNB\",\n  name: \"BNB\",\n  description: \"native\",\n  icon: \"https://ipfs.near.social/ipfs/bafkreiaeq6ca67je5ocago6vk2efwxiqurxgemputx7p2nt6n2p3zo65xq\",\n};\n\nconst wethAddress = \"null\";\n\nconst Tokens = {\n  \"0xdEAddEaDdeadDEadDEADDEAddEADDEAddead1111\": {\n    address: \"0xdEAddEaDdeadDEadDEADDEAddEADDEAddead1111\",\n    decimals: 18,\n    symbol: \"WETH\",\n    name: \"WETH\",\n    icon: \"https://ipfs.near.social/ipfs/bafkreihyzmiuawyekwiyofkzm25xzrrfenhvadi6lb42juvq7tah2u7ha4\",\n  },\n\n  \"0x78c1b0C915c4FAA5FffA6CAbf0219DA63d7f4cb8\": {\n    address: \"0x78c1b0C915c4FAA5FffA6CAbf0219DA63d7f4cb8\",\n    decimals: 18,\n    symbol: \"WMNT\",\n    name: \"WMNT\",\n    icon: \"https://ipfs.near.social/ipfs/bafkreiboetskbxmub4djn3j73aj7tawfpqnh4sf3adhdghsnfo55cz5h24\",\n  },\n\n  \"0xCAbAE6f6Ea1ecaB08Ad02fE02ce9A44F09aebfA2\": {\n    address: \"0xCAbAE6f6Ea1ecaB08Ad02fE02ce9A44F09aebfA2\",\n    decimals: 8,\n    symbol: \"WBTC\",\n    name: \"WBTC\",\n    icon: \"https://ipfs.near.social/ipfs/bafkreigdklwcldjo4w7viyrym54hdb43wgpv23mbicetszygzapttbgo7q\",\n  },\n\n  \"0x201EBa5CC46D216Ce6DC03F6a759e8E766e956aE\": {\n    address: \"0x201EBa5CC46D216Ce6DC03F6a759e8E766e956aE\",\n    decimals: 6,\n    symbol: \"USDT\",\n    name: \"USDT\",\n    icon: \"https://ipfs.near.social/ipfs/bafkreih45jy7ggj45ck34rf736kb67smsoa52wd7e46c2grh6etd3bhe5i\",\n  },\n\n  \"0x09Bc4E0D864854c6aFB6eB9A9cdF58aC190D0dF9\": {\n    address: \"0x09Bc4E0D864854c6aFB6eB9A9cdF58aC190D0dF9\",\n    decimals: 6,\n    symbol: \"USDC\",\n    name: \"USDC\",\n    icon: \"https://ipfs.near.social/ipfs/bafkreie4jihoa76mgyzxhw2yrapihzu2qhkjz6m7u4opoxjebzg6zc2lla\",\n  },\n};\n\nconst RewardToken = {\n  symbol: \"LEND\",\n  address: \"0x25356aeca4210ef7553140edb9b8026089e49396\",\n  decimals: 18,\n  name: \"LEND\",\n  icon: \"https://ipfs.near.social/ipfs/bafkreig36gyyl6bv2s6f5c2kq22x4omgaclfzyf5ifvjmsxl55svptlq3e\",\n};\n\nconst aaveProtocolDataProviderAbi = [\n  {\n    inputs: [\n      {\n        internalType: \"contract ILendingPoolAddressesProvider\",\n        name: \"addressesProvider\",\n        type: \"address\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"constructor\",\n  },\n  {\n    inputs: [],\n    name: \"ADDRESSES_PROVIDER\",\n    outputs: [\n      {\n        internalType: \"contract ILendingPoolAddressesProvider\",\n        name: \"\",\n        type: \"address\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"getAllATokens\",\n    outputs: [\n      {\n        components: [\n          { internalType: \"string\", name: \"symbol\", type: \"string\" },\n          { internalType: \"address\", name: \"tokenAddress\", type: \"address\" },\n        ],\n        internalType: \"struct AaveProtocolDataProvider.TokenData[]\",\n        name: \"\",\n        type: \"tuple[]\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"getAllReservesTokens\",\n    outputs: [\n      {\n        components: [\n          { internalType: \"string\", name: \"symbol\", type: \"string\" },\n          { internalType: \"address\", name: \"tokenAddress\", type: \"address\" },\n        ],\n        internalType: \"struct AaveProtocolDataProvider.TokenData[]\",\n        name: \"\",\n        type: \"tuple[]\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"asset\", type: \"address\" }],\n    name: \"getReserveConfigurationData\",\n    outputs: [\n      { internalType: \"uint256\", name: \"decimals\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"ltv\", type: \"uint256\" },\n      {\n        internalType: \"uint256\",\n        name: \"liquidationThreshold\",\n        type: \"uint256\",\n      },\n      { internalType: \"uint256\", name: \"liquidationBonus\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"reserveFactor\", type: \"uint256\" },\n      { internalType: \"bool\", name: \"usageAsCollateralEnabled\", type: \"bool\" },\n      { internalType: \"bool\", name: \"borrowingEnabled\", type: \"bool\" },\n      { internalType: \"bool\", name: \"stableBorrowRateEnabled\", type: \"bool\" },\n      { internalType: \"bool\", name: \"isActive\", type: \"bool\" },\n      { internalType: \"bool\", name: \"isFrozen\", type: \"bool\" },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"asset\", type: \"address\" }],\n    name: \"getReserveData\",\n    outputs: [\n      { internalType: \"uint256\", name: \"availableLiquidity\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"totalStableDebt\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"totalVariableDebt\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"liquidityRate\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"variableBorrowRate\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"stableBorrowRate\", type: \"uint256\" },\n      {\n        internalType: \"uint256\",\n        name: \"averageStableBorrowRate\",\n        type: \"uint256\",\n      },\n      { internalType: \"uint256\", name: \"liquidityIndex\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"variableBorrowIndex\", type: \"uint256\" },\n      { internalType: \"uint40\", name: \"lastUpdateTimestamp\", type: \"uint40\" },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"asset\", type: \"address\" }],\n    name: \"getReserveTokensAddresses\",\n    outputs: [\n      { internalType: \"address\", name: \"aTokenAddress\", type: \"address\" },\n      {\n        internalType: \"address\",\n        name: \"stableDebtTokenAddress\",\n        type: \"address\",\n      },\n      {\n        internalType: \"address\",\n        name: \"variableDebtTokenAddress\",\n        type: \"address\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"asset\", type: \"address\" },\n      { internalType: \"address\", name: \"user\", type: \"address\" },\n    ],\n    name: \"getUserReserveData\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"currentATokenBalance\",\n        type: \"uint256\",\n      },\n      { internalType: \"uint256\", name: \"currentStableDebt\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"currentVariableDebt\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"principalStableDebt\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"scaledVariableDebt\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"stableBorrowRate\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"liquidityRate\", type: \"uint256\" },\n      { internalType: \"uint40\", name: \"stableRateLastUpdated\", type: \"uint40\" },\n      { internalType: \"bool\", name: \"usageAsCollateralEnabled\", type: \"bool\" },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\n\nconst ORACLE_ABI = [\n  {\n    inputs: [{ internalType: \"address\", name: \"asset\", type: \"address\" }],\n    name: \"getAssetPrice\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address[]\", name: \"assets\", type: \"address[]\" }],\n    name: \"getAssetsPrices\",\n    outputs: [{ internalType: \"uint256[]\", name: \"\", type: \"uint256[]\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\n\nconst {\n  aaveProtocolDataProviderAddress,\n  oracleAddress,\n  account,\n  update,\n  onLoad,\n  PoolAddressProvider,\n  lendingPoolAddress,\n  wethGateway,\n  initConfig,\n  loaded,\n} = props;\n\nconst { incentiveController } = initConfig;\n\nif ((!update || !account) && !state.tokensPrice) return \"\";\n\nlet rewardPrice = \"0\";\nconst _yearRewards = Storage.privateGet(\"yearRewards\") || {};\n\nconst rndtPriceData = fetch(\n  \"https://api.coingecko.com/api/v3/simple/price?ids=lendle&vs_currencies=usd\"\n);\n\nif (rndtPriceData) {\n  const data = rndtPriceData.body || [];\n\n  rewardPrice = data[\"lendle\"].usd;\n}\n\nconst getUserRewards = (aTokenAddress) => {\n  const incentiveControllerAbi = [\n    {\n      type: \"function\",\n      stateMutability: \"view\",\n      outputs: [\n        { type: \"uint256\", name: \"amount\", internalType: \"uint256\" },\n        { type: \"uint256\", name: \"rewardDebt\", internalType: \"uint256\" },\n      ],\n      name: \"userInfo\",\n      inputs: [\n        { type: \"address\", name: \"\", internalType: \"address\" },\n        { type: \"address\", name: \"\", internalType: \"address\" },\n      ],\n    },\n    {\n      inputs: [\n        {\n          internalType: \"address\",\n          name: \"_user\",\n          type: \"address\",\n        },\n        {\n          internalType: \"address[]\",\n          name: \"_tokens\",\n          type: \"address[]\",\n        },\n      ],\n      name: \"claimableReward\",\n      outputs: [\n        {\n          internalType: \"uint256[]\",\n          name: \"\",\n          type: \"uint256[]\",\n        },\n      ],\n      stateMutability: \"view\",\n      type: \"function\",\n    },\n    {\n      inputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n      name: \"poolInfo\",\n      outputs: [\n        { internalType: \"uint256\", name: \"totalSupply\", type: \"uint256\" },\n        { internalType: \"uint256\", name: \"allocPoint\", type: \"uint256\" },\n        { internalType: \"uint256\", name: \"lastRewardTime\", type: \"uint256\" },\n        { internalType: \"uint256\", name: \"accRewardPerShare\", type: \"uint256\" },\n        {\n          internalType: \"contract IOnwardIncentivesController\",\n          name: \"onwardIncentives\",\n          type: \"address\",\n        },\n      ],\n      stateMutability: \"view\",\n      type: \"function\",\n    },\n    {\n      inputs: [],\n      name: \"totalAllocPoint\",\n      outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n      stateMutability: \"view\",\n      type: \"function\",\n    },\n    {\n      inputs: [],\n      name: \"rewardsPerSecond\",\n      outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n      stateMutability: \"view\",\n      type: \"function\",\n    },\n\n    {\n      type: \"function\",\n      stateMutability: \"view\",\n      outputs: [{ type: \"uint256\", name: \"\", internalType: \"uint256\" }],\n      name: \"poolLength\",\n      inputs: [],\n    },\n  ];\n\n  const incentiveControllerContract = new ethers.Contract(\n    incentiveController,\n    incentiveControllerAbi,\n    Ethers.provider().getSigner()\n  );\n\n  const ACC_REWARD_PRECISION = Big(10).pow(12);\n\n  return incentiveControllerContract\n    .totalAllocPoint()\n    .then((res) => {\n      return res.toString();\n    })\n    .then((totalAllocPoint) => {\n      return incentiveControllerContract\n        .rewardsPerSecond()\n        .then((res) => {\n          const rewardsPerSecond = res.toString();\n\n          return {\n            totalAllocPoint,\n            rewardsPerSecond,\n          };\n        })\n        .then(({ totalAllocPoint, rewardsPerSecond }) => {\n          return incentiveControllerContract\n            .poolInfo(aTokenAddress)\n            .then((res) => {\n              const totalSupply = res[0].toString();\n              const allocPoint = res[1].toString();\n\n              const dailyRewardToThisPool = Big(60 * 60 * 24)\n                .times(rewardsPerSecond)\n                .times(allocPoint)\n                .div(totalAllocPoint);\n\n              const rewardPerShareThisPool = dailyRewardToThisPool\n                .mul(ACC_REWARD_PRECISION)\n                .div(totalSupply)\n                .toFixed();\n\n              _yearRewards[aTokenAddress] = Big(60 * 60 * 24 * 365)\n                .times(rewardsPerSecond)\n                .times(allocPoint)\n                .div(totalAllocPoint)\n                .div(Big(10).pow(18))\n                .toString();\n\n              Storage.privateSet(\"yearRewards\", _yearRewards);\n              return rewardPerShareThisPool;\n            })\n            .then((rewardPerShareThisPool) => {\n              return incentiveControllerContract\n                .userInfo(aTokenAddress, account)\n                .then((res) => {\n                  const amount = res[0].toString();\n\n                  const userDailyReward = Big(rewardPerShareThisPool)\n                    .times(Big(amount))\n                    .div(ACC_REWARD_PRECISION)\n                    .toFixed();\n\n                  return userDailyReward;\n                })\n                .then((userDailyReward) => {\n                  if (Big(userDailyReward).eq(0)) return undefined;\n\n                  return incentiveControllerContract\n                    .claimableReward(account, [aTokenAddress])\n                    .then((res) => {\n                      const unclaimed = res[0].toString();\n\n                      if (Big(unclaimed).eq(0)) return undefined;\n\n                      const dailyRewards = Big(userDailyReward)\n                        .div(Big(10).pow(RewardToken.decimals))\n                        .toFixed();\n\n                      return {\n                        ...RewardToken,\n                        unclaimed: Big(unclaimed)\n                          .div(Big(10).pow(RewardToken.decimals))\n                          .toFixed(),\n                        price: rewardPrice,\n                        dailyRewards,\n                        rewardAddress: aTokenAddress,\n                      };\n                    });\n                });\n            });\n        });\n    })\n    .catch(() => {\n      return undefined;\n    });\n};\n\nconst dataProviderContract = new ethers.Contract(\n  aaveProtocolDataProviderAddress,\n  aaveProtocolDataProviderAbi,\n  Ethers.provider().getSigner()\n);\n\nconst getTokensPrices = () => {\n  const oracleContract = new ethers.Contract(\n    oracleAddress,\n    ORACLE_ABI,\n    Ethers.provider().getSigner()\n  );\n  oracleContract.getAssetsPrices(Object.keys(Tokens)).then((res) => {\n    const parsedRes = res.map((price, i) => {\n      return Big(price.toString()).div(1000000000000000000).toFixed();\n    });\n\n    const tokensPrice = {};\n    Object.keys(Tokens).forEach((address, index) => {\n      tokensPrice[address] = parsedRes[index];\n    });\n\n    State.update({\n      tokensPrice,\n    });\n  });\n};\n\nconst getMarkets = () => {\n  dataProviderContract.getAllReservesTokens().then((marketsRaw) => {\n    const markets = marketsRaw.filter((market) => {\n      const add = market[1];\n      return Object.keys(Tokens)\n        .map((t) => t.toLowerCase())\n        .includes(add.toLowerCase());\n    });\n\n    State.update({\n      markets: markets,\n    });\n  });\n};\n\nconst getTokenReserveData = (\n  tokenAddress,\n  symbol,\n  price,\n  aTokenAddress,\n  variableDebtTokenAddress,\n  loanToValue,\n  userReserveParsed,\n  rewards\n) => {\n  dataProviderContract.getReserveData(tokenAddress).then((data) => {\n    const [\n      availableLiquidity,\n      totalStableDebt,\n      totalVariableDebt,\n      liquidityRate,\n      variableBorrowRate,\n      stableBorrowRate,\n      averageStableBorrowRate,\n      liquidityIndex,\n      variableBorrowIndex,\n      lastUpdateTimestamp,\n    ] = data;\n\n    const decimalBig = Big(10).pow(Tokens[tokenAddress].decimals);\n\n    const totalDebt = Big(totalStableDebt.toString())\n      .plus(totalVariableDebt.toString())\n      .div(decimalBig)\n      .toFixed();\n\n    const totalDebtRaw = Big(totalStableDebt.toString())\n      .plus(totalVariableDebt.toString())\n      .toFixed();\n\n    const totalDeposit = Big(availableLiquidity.toString())\n      .plus(totalDebtRaw)\n      .div(decimalBig)\n      .toFixed();\n\n    const marketSize = Big(availableLiquidity.toString())\n      .div(decimalBig)\n      .toFixed();\n\n    const Ray = Big(10).pow(27);\n\n    const SECONDS_PER_YEAR = 31536000;\n\n    const depositAPR = Big(liquidityRate).div(Ray);\n\n    const variableBorrowAPR = Big(variableBorrowRate).div(Ray);\n\n    const depositAPY0 = Big(1)\n      .plus(depositAPR.div(Big(SECONDS_PER_YEAR)))\n      .toNumber();\n\n    const depositAPY = Big(\n      100 * (Math.pow(depositAPY0, SECONDS_PER_YEAR) - 1)\n    ).toFixed(2);\n\n    const variableBorrowAPY0 = Big(1)\n      .plus(Big(variableBorrowAPR).div(Big(SECONDS_PER_YEAR)))\n      .toNumber();\n\n    const variableBorrowAPYRaw = Big(\n      100 * (Math.pow(variableBorrowAPY0, SECONDS_PER_YEAR) - 1)\n    );\n\n    const variableBorrowAPY = Big(\n      100 * (Math.pow(variableBorrowAPY0, SECONDS_PER_YEAR) - 1)\n    ).toFixed(2);\n\n    const netApyBig = Big(depositAPY0).minus(variableBorrowAPYRaw);\n\n    State.update({\n      [tokenAddress]: {\n        availableLiquidity,\n        totalStableDebt,\n        totalVariableDebt,\n        totalBorrows: !price ? \"-\" : Big(totalDebt).toFixed(4),\n        totalSupply: !price ? \"-\" : Big(totalDeposit).toFixed(4),\n        liquidity: !price ? \"-\" : Big(marketSize).toFixed(4),\n        liquidityRate,\n        variableBorrowRate,\n        stableBorrowRate,\n        averageStableBorrowRate,\n        liquidityIndex,\n        variableBorrowIndex,\n        lastUpdateTimestamp,\n        tokenAddress,\n        depositAPY,\n        loanToValue,\n        supplyApy: depositAPY + \"%\",\n        variableBorrowAPY,\n        borrowApy: variableBorrowAPY + \"%\",\n        underlyingPrice: price,\n        underlyingToken:\n          tokenAddress.toLowerCase() === wethAddress.toLowerCase()\n            ? native\n            : Tokens[tokenAddress],\n        dapp: initConfig.name,\n        dappName: initConfig.name,\n        address: tokenAddress,\n        ...(tokenAddress.toLowerCase() === wethAddress.toLowerCase()\n          ? native\n          : Tokens[tokenAddress]),\n        netApy: netApyBig.toFixed(),\n        aTokenAddress,\n        variableDebtTokenAddress,\n        wethAddress,\n        userReserveParsed,\n        rewards,\n      },\n    });\n  });\n};\n\nconst getUserReverveData = (market) => {\n  const address = market[1];\n\n  return dataProviderContract\n    .getUserReserveData(address, account)\n    .then((data) => {\n      const underlyingAsset = Tokens[address];\n      const userSupply = Big(data[0].toString()).div(\n        Big(10).pow(underlyingAsset.decimals)\n      );\n      const scaledATokenBalanceUsd = userSupply\n        .times(state.tokensPrice[address])\n        .toFixed(4);\n\n      const aTokenBalance = Big(data[0].toString())\n        .div(Big(10).pow(underlyingAsset.decimals))\n        .toFixed();\n\n      const usageAsCollateralEnabledOnUser = data[8];\n\n      const scaledVariableDebt = Big(data[2].toString())\n        .div(Big(10).pow(underlyingAsset.decimals))\n\n        .toFixed(4);\n\n      const scaledVariableDebtUsd = Big(data[2].toString())\n        .div(Big(10).pow(underlyingAsset.decimals))\n        .times(state.tokensPrice[address])\n        .toFixed(4);\n\n      const userReserveParsed = {\n        address,\n        underlyingAsset,\n        scaledATokenBalanceUsd,\n        userSupply: userSupply.toFixed(4),\n        usageAsCollateralEnabledOnUser,\n        scaledVariableDebt,\n        scaledVariableDebtUsd,\n        aTokenBalance,\n        userMerberShip: usageAsCollateralEnabledOnUser,\n      };\n\n      return userReserveParsed;\n    });\n};\n\nif (!state.tokensPrice) {\n  getTokensPrices();\n}\n\nif (!state.markets && state.tokensPrice) {\n  getMarkets();\n}\n\nif (\n  state.markets &&\n  Object.keys(state).length === 2 &&\n  !state.userDataLoading\n) {\n  State.update({\n    userDataLoading: true,\n  });\n\n  state.markets.forEach((market) => {\n    const [symbol, address] = market;\n\n    const tokensPrice = state.tokensPrice;\n\n    dataProviderContract\n      .getReserveConfigurationData(address)\n      .then((res) => {\n        const loanToValue = Big(res[1].toString()).div(100).toNumber();\n\n        return loanToValue;\n      })\n      .then((loanToValue) => {\n        dataProviderContract.getReserveTokensAddresses(address).then((data) => {\n          const aTokenAddress = data[0];\n          const variableDebtTokenAddress = data[2];\n          getUserRewards(aTokenAddress, signer)\n            .then((res) => {\n              return res;\n            })\n            .then((atokenReward) => {\n              return getUserRewards(variableDebtTokenAddress, signer).then(\n                (variableDebtTokenReward) => {\n                  if (!atokenReward) return variableDebtTokenReward;\n                  else if (atokenReward && !variableDebtTokenReward)\n                    return atokenReward;\n                  else {\n                    return {\n                      ...atokenReward,\n                      unclaimed: Big(atokenReward.unclaimed)\n                        .plus(variableDebtTokenReward.unclaimed)\n                        .toFixed(),\n                      dailyRewards: Big(atokenReward.dailyRewards)\n                        .plus(variableDebtTokenReward.dailyRewards)\n                        .toFixed(),\n                    };\n                  }\n                }\n              );\n            })\n            .then((rawRewards) => {\n              const rewards = !rawRewards ? undefined : [rawRewards];\n\n              getUserReverveData(market).then((userReserveParsed) => {\n                getTokenReserveData(\n                  address,\n                  symbol,\n                  tokensPrice[address],\n                  aTokenAddress,\n                  variableDebtTokenAddress,\n                  loanToValue,\n                  userReserveParsed,\n                  rewards\n                );\n              });\n            });\n        });\n      });\n  });\n}\n\nif (\n  state.markets &&\n  state.tokensPrice &&\n  Object.keys(state).length === state.markets.length + 3\n) {\n  const { markets, tokensPrice, balances, userDataLoading, ...marketData } =\n    state;\n\n  const parsedData = [];\n\n  Object.keys(marketData).forEach((address) => {\n    const market = marketData[address];\n\n    parsedData.push(market.userReserveParsed);\n  });\n\n  let userTotalSupplyUsd = Big(0);\n  let userTotalBorrowUsd = Big(0);\n  let totalCollateralUsd = Big(0);\n  parsedData.forEach((data) => {\n    if (data.usageAsCollateralEnabledOnUser) {\n      const loanToValue = marketData[data.address].loanToValue;\n      totalCollateralUsd = totalCollateralUsd.plus(\n        Big(data.scaledATokenBalanceUsd).mul(loanToValue / 100)\n      );\n    }\n\n    userTotalSupplyUsd = userTotalSupplyUsd.plus(data.scaledATokenBalanceUsd);\n\n    userTotalBorrowUsd = userTotalBorrowUsd.plus(data.scaledVariableDebtUsd);\n  });\n\n  State.update({\n    userData: {\n      userTotalSupplyUsd: userTotalSupplyUsd.toString(),\n      userTotalBorrowUsd: userTotalBorrowUsd.toString(),\n      totalCollateralUsd: totalCollateralUsd.toString(),\n      parsedData,\n    },\n  });\n}\nif (\n  state.userData &&\n  state.markets &&\n  Object.keys(state).length === state.markets.length + 4\n) {\n  const {\n    markets,\n    tokensPrice,\n    balances,\n    userData,\n    userDataLoading,\n    ...marketData\n  } = state;\n\n  userData.parsedData.forEach((d) => {\n    const { address } = d;\n    marketData[address].userMerberShip = d.userMerberShip;\n  });\n\n  let netApy = Big(0);\n\n  userData.parsedData.forEach((d) => {\n    const { address } = d;\n    marketData[address] = {\n      ...marketData[address],\n      ...d,\n      userSupply: d.userSupply,\n      userBorrow: d.scaledVariableDebt,\n    };\n  });\n\n  let reduceUnclaimed = Big(0);\n\n  let reduceDailyRewards = Big(0);\n\n  const allPools = [];\n  Object.keys(marketData).forEach((address) => {\n    const market = marketData[address];\n    if (market.rewards) {\n      const unclaimed = market.rewards[0].unclaimed;\n      const dailyRewards = market.rewards[0].dailyRewards;\n\n      reduceUnclaimed = reduceUnclaimed.plus(Big(unclaimed || 0));\n\n      reduceDailyRewards = reduceDailyRewards.plus(Big(dailyRewards || 0));\n    }\n\n    market.rewards = undefined;\n\n    market.distributionApy = [\n      {\n        ...RewardToken,\n        supply:\n          Big(_yearRewards[market.aTokenAddress])\n            .mul(rewardPrice)\n            .div(market.totalSupply)\n            .div(market.underlyingPrice)\n            .mul(100)\n            .toFixed(2) + \"%\",\n        borrow:\n          Big(_yearRewards[market.aTokenAddress])\n            .mul(rewardPrice)\n            .div(market.totalBorrows)\n            .div(market.underlyingPrice)\n            .mul(100)\n            .toFixed(2) + \"%\",\n      },\n    ];\n\n    const { netApy: netApyRaw } = market;\n    netApy = netApy.plus(netApyRaw);\n\n    market.userUnderlyingBalance = market.aTokenBalance;\n\n    market.lendingPoolAddress = lendingPoolAddress;\n\n    market.wethGateway = wethGateway;\n\n    market.address = market.aTokenAddress;\n\n    allPools.push(market.aTokenAddress);\n  });\n\n  userData.netApy = netApy.toFixed(2);\n\n  const parsedMarketData = {};\n\n  Object.entries(marketData).map(([address, market], index) => {\n    parsedMarketData[market.aTokenAddress] = market;\n\n    if (index === 0 && reduceUnclaimed.gt(0)) {\n      market.rewards = [\n        {\n          ...RewardToken,\n          unclaimed: reduceUnclaimed.toFixed(),\n          dailyRewards: reduceDailyRewards.toFixed(),\n          price: rewardPrice,\n        },\n      ];\n    }\n  });\n  const rewards = [\n    {\n      ...RewardToken,\n      dailyRewards: reduceDailyRewards.lt(0.000001)\n        ? \"0.000001\"\n        : reduceDailyRewards.toString(),\n      price: rewardPrice,\n      unclaimed: reduceUnclaimed.toString(),\n      allPools,\n    },\n  ];\n  onLoad({\n    ...{ ...userData, ...props },\n    rewards,\n    markets: parsedMarketData,\n    name: initConfig.name,\n  });\n}\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/bluebiu.near/widget/Mantle.Lending.LendleData", "fact_widget_deployments_id": "c286efb89e160028a1bdf27a733afee4", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 0}