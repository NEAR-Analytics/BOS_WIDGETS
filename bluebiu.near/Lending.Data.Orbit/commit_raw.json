{"tx_hash": "TQtp3aNPbVNGrPwZNuRMXEgAQ1w1xZcQZJtHfmx7AUt", "action_id_social": "7UiGeY4AYZdTeXG1PZiGxx5efMB7YUa9rdM63du1WprM-0-widget", "block_id": 117820554, "block_timestamp": "2024-04-28T16:08:59.324Z", "signer_id": "bluebiu.near", "widget_name": "Lending.Data.Orbit", "source_code": "const OTOKEN_ABI = [\n  {\n    inputs: [],\n    name: \"totalSupply\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"exchangeRateCurrent\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    constant: true,\n    inputs: [{ internalType: \"address\", name: \"owner\", type: \"address\" }],\n    name: \"balanceOf\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    payable: false,\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    constant: true,\n    inputs: [{ internalType: \"address\", name: \"account\", type: \"address\" }],\n    name: \"borrowBalanceCurrent\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    payable: false,\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"supplyRatePerBlock\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"borrowRatePerBlock\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"reserveFactorMantissa\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  //\n  {\n    inputs: [{ internalType: \"address\", name: \"owner\", type: \"address\" }],\n    name: \"balanceOfUnderlying\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"account\", type: \"address\" }],\n    name: \"borrowBalanceStored\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"getCash\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"totalBorrows\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"totalReserves\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\nconst ERC20_ABI = [\n  {\n    constant: true,\n    inputs: [\n      {\n        name: \"_owner\",\n        type: \"address\",\n      },\n    ],\n    name: \"balanceOf\",\n    outputs: [\n      {\n        name: \"balance\",\n        type: \"uint256\",\n      },\n    ],\n    payable: false,\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\n\nconst {\n  multicallAddress,\n  account,\n  update,\n  name,\n  onLoad,\n  multicall,\n  ORBIT_MARKETS,\n  RENZO_MARKETS,\n  KELP_MARKETS,\n  unitrollerAddress,\n  prices,\n  orbitTab,\n} = props;\n\nconst { formatUnits } = ethers.utils;\nconsole.log(\"ORIBIT-DATA-PROPS--\", props);\nuseEffect(() => {\n  if (!multicallAddress || !update || !account) return \"\";\n  let markets;\n  if (orbitTab === \"ORBIT\") {\n    markets = ORBIT_MARKETS;\n  }\n  if (orbitTab === \"RENZO\") {\n    markets = RENZO_MARKETS;\n  }\n  if (orbitTab === \"KELP\") {\n    markets = KELP_MARKETS;\n  }\n  console.log(`${name}-update`);\n  let _cTokensData = {};\n  let _underlyPrice = {};\n  let _liquidity = null;\n  let _underlyingBalance = null;\n  let count = 0;\n  const oTokens = Object.values(markets);\n  let oTokensLength = Object.values(markets).length;\n\n  const formatedData = (key) => {\n    console.log(`${name}-${key}`, count);\n    if (count < 10) return;\n    count = 0;\n    oTokensLength = Object.values(markets).length;\n\n    let userTotalSupplyUsd = Big(0);\n    let userTotalBorrowUsd = Big(0);\n    let totalCollateralUsd = Big(0);\n    const markets = {};\n    Object.values(_cTokensData).forEach((market) => {\n      // console.log(\"---\", market);\n      // console.log(\n      //   market.symbol,\n      //   prices[market.symbol],\n      //   market.userSupply\n      // );\n      let underlyingPrice;\n      if (market.symbol === \"fwWETH\") {\n        underlyingPrice = prices[\"oETH\"];\n      } else {\n        underlyingPrice = prices[market.symbol] || 1;\n      }\n\n      userTotalSupplyUsd = userTotalSupplyUsd.plus(\n        Big(market.userSupply).mul(underlyingPrice)\n      );\n      userTotalBorrowUsd = userTotalBorrowUsd.plus(\n        Big(market.userBorrow).mul(underlyingPrice)\n      );\n\n      const _collaterd = market.isCollateral\n        ? Big(market.userSupply).mul(underlyingPrice)\n        : 0;\n\n      totalCollateralUsd = totalCollateralUsd.plus(_collaterd);\n\n      const supplyApy = Big(market.supplyRatePerBlock).mul(15768000).mul(100);\n      const borrowApy = Big(market.borrowRatePerBlock).mul(15768000).mul(100);\n\n      const _poolSize = Big(market.cash || 0)\n        .plus(Big(market.totalBorrows || 0))\n        .plus(Big(market.totalReserves || 0))\n        .times(Big(underlyingPrice))\n        .toString();\n\n      markets[market.address] = {\n        ...market,\n        // liquidity: _liquidity[market.address],\n        underlyingPrice: underlyingPrice,\n        userUnderlyingBalance: _underlyingBalance[market.address],\n        supplyApy: supplyApy.toFixed(2) + \"%\",\n        borrowApy: borrowApy.toFixed(2) + \"%\",\n        poolSize: _poolSize,\n        dapp: name,\n      };\n    });\n    // orbit ltv=0.75\n    const _borrowLimitUsd = totalCollateralUsd\n      .mul(0.75)\n      .minus(userTotalBorrowUsd);\n\n    onLoad({\n      markets,\n      userTotalSupplyUsd: userTotalSupplyUsd.toString(),\n      userTotalBorrowUsd: userTotalBorrowUsd.toString(),\n      totalCollateralUsd: totalCollateralUsd.toString(),\n      borrowLimitUsd: _borrowLimitUsd.gt(0) ? _borrowLimitUsd.toString() : 0,\n    });\n  };\n  const getUnderlyPrice = () => {\n    Object.values(markets).forEach((market) => {\n      _underlyPrice[market.address] =\n        prices[\n          market.underlyingToken.priceKey || market.underlyingToken.symbol\n        ] || \"1\";\n    });\n    count++;\n    formatedData(\"getUnderlyPrice\");\n  };\n\n  const getWalletBalance = () => {\n    let nativeOToken = \"\";\n    const underlyingTokens = Object.values(markets)\n      .filter((market) => {\n        if (market.underlyingToken.address === \"native\")\n          nativeOToken = market.address;\n        return (\n          market.underlyingToken.address &&\n          market.underlyingToken.address !== \"native\"\n        );\n      })\n      .map((market) => ({\n        ...market.underlyingToken,\n        oTokenAddress: market.address,\n      }));\n    const calls = underlyingTokens.map((token) => ({\n      address: token.address,\n      name: \"balanceOf\",\n      params: [account],\n    }));\n    multicall({\n      abi: ERC20_ABI,\n      calls,\n      options: {},\n      multicallAddress,\n      provider: Ethers.provider(),\n    })\n      .then((res) => {\n        _underlyingBalance = {};\n        for (let i = 0, len = res.length; i < len; i++) {\n          _underlyingBalance[underlyingTokens[i].oTokenAddress] = res[i][0]\n            ? ethers.utils.formatUnits(\n                res[i][0]._hex,\n                underlyingTokens[i].decimals\n              )\n            : \"0\";\n        }\n        if (nativeOToken) {\n          const provider = Ethers.provider();\n          provider.getBalance(account).then((rawBalance) => {\n            _underlyingBalance[nativeOToken] = ethers.utils.formatUnits(\n              rawBalance._hex,\n              18\n            );\n            count++;\n            formatedData(\"getWalletBalance\");\n          });\n        } else {\n          count++;\n          formatedData(\"getWalletBalance\");\n        }\n      })\n      .catch(() => {\n        setTimeout(() => {\n          getWalletBalance();\n        }, 500);\n      });\n  };\n  const getBorrowRatePerBlock = () => {\n    const calls = oTokens.map((oToken) => ({\n      address: oToken.address,\n      name: \"borrowRatePerBlock\",\n    }));\n    multicall({\n      abi: OTOKEN_ABI,\n      calls,\n      options: {},\n      multicallAddress,\n      provider: Ethers.provider(),\n    })\n      .then((res) => {\n        console.log(\"getBorrowRatePerBlock_res:\", res);\n        oTokens.forEach((oToken, index) => {\n          if (_cTokensData[oToken.address]) {\n            _cTokensData[oToken.address] = {\n              ..._cTokensData[oToken.address],\n              borrowRatePerBlock: res[index] ? formatUnits(res[index][0]) : 0,\n            };\n          } else {\n            _cTokensData[oToken.address] = {\n              ...oToken,\n              borrowRatePerBlock: res[index] ? formatUnits(res[index][0]) : 0,\n            };\n          }\n        });\n        count++;\n        formatedData(\"oTokens data\");\n      })\n      .catch((err) => {\n        console.log(\"getBorrowRatePerBlock_error:\", err);\n      });\n  };\n\n  const getSupplyRatePerBlock = () => {\n    const calls = oTokens.map((oToken) => ({\n      address: oToken.address,\n      name: \"supplyRatePerBlock\",\n    }));\n    multicall({\n      abi: OTOKEN_ABI,\n      calls,\n      options: {},\n      multicallAddress,\n      provider: Ethers.provider(),\n    })\n      .then((res) => {\n        console.log(\"getSupplyRatePerBlock_res:\", res);\n        oTokens.forEach((oToken, index) => {\n          if (_cTokensData[oToken.address]) {\n            _cTokensData[oToken.address] = {\n              ..._cTokensData[oToken.address],\n              supplyRatePerBlock: res[index] ? formatUnits(res[index][0]) : 0,\n            };\n          } else {\n            _cTokensData[oToken.address] = {\n              ...oToken,\n              supplyRatePerBlock: res[index] ? formatUnits(res[index][0]) : 0,\n            };\n          }\n        });\n        count++;\n        formatedData(\"oTokens data\");\n      })\n      .catch((err) => {\n        console.log(\"getSupplyRatePerBlock_error:\", err);\n      });\n  };\n\n  const getUserSupply = () => {\n    const calls = oTokens.map((oToken) => ({\n      address: oToken.address,\n      name: \"balanceOfUnderlying\",\n      params: [account],\n    }));\n    multicall({\n      abi: OTOKEN_ABI,\n      calls,\n      options: {},\n      multicallAddress,\n      provider: Ethers.provider(),\n    })\n      .then((res) => {\n        console.log(\"getUserSupply_res:\", res, _cTokensData);\n        oTokens.forEach((oToken, index) => {\n          if (_cTokensData[oToken.address]) {\n            _cTokensData[oToken.address] = {\n              ..._cTokensData[oToken.address],\n              userSupply: res[index]\n                ? formatUnits(res[index][0], oToken.decimals)\n                : 0,\n            };\n          } else {\n            _cTokensData[oToken.address] = {\n              ...oToken,\n              userSupply: res[index]\n                ? formatUnits(res[index][0], oToken.decimals)\n                : 0,\n            };\n          }\n        });\n        count++;\n        formatedData(\"oTokens data\");\n      })\n      .catch((err) => {\n        console.log(\"getUserSupply_error:\", err);\n      });\n  };\n  const getUserBorrows = () => {\n    const calls = oTokens.map((oToken) => ({\n      address: oToken.address,\n      name: \"borrowBalanceStored\",\n      params: [account],\n    }));\n    multicall({\n      abi: OTOKEN_ABI,\n      calls,\n      options: {},\n      multicallAddress,\n      provider: Ethers.provider(),\n    })\n      .then((res) => {\n        console.log(\"getUserBorrows_res:\", res, _cTokensData);\n        oTokens.forEach((oToken, index) => {\n          if (_cTokensData[oToken.address]) {\n            _cTokensData[oToken.address] = {\n              ..._cTokensData[oToken.address],\n              userBorrow: res[index]\n                ? formatUnits(res[index][0], oToken.decimals)\n                : 0,\n            };\n          } else {\n            _cTokensData[oToken.address] = {\n              ...oToken,\n              userBorrow: res[index]\n                ? formatUnits(res[index][0], oToken.decimals)\n                : 0,\n            };\n          }\n        });\n        count++;\n        formatedData(\"User Borrows\");\n      })\n      .catch((err) => {\n        console.log(\"getUserBorrows_error:\", err);\n      });\n  };\n  const getCollateralStatus = () => {\n    const unitrollerContract = new ethers.Contract(\n      unitrollerAddress,\n      [\n        {\n          inputs: [\n            { internalType: \"address\", name: \"account\", type: \"address\" },\n          ],\n          name: \"getAssetsIn\",\n          outputs: [\n            { internalType: \"contract OToken[]\", name: \"\", type: \"address[]\" },\n          ],\n          stateMutability: \"view\",\n          type: \"function\",\n        },\n      ],\n      Ethers.provider()\n    );\n    unitrollerContract\n      .getAssetsIn(account)\n      .then((res) => {\n        console.log(\"getCollateralStatus-res:\", res);\n        if (Array.isArray(res) && res.length) {\n          res.forEach((addr) => {\n            const _market = oTokens.find(\n              (item) =>\n                item.address.toLocaleLowerCase() === addr.toLocaleLowerCase()\n            );\n\n            if (_market) {\n              _market.isCollateral = true;\n            }\n          });\n\n          oTokens.forEach((oToken, index) => {\n            if (_cTokensData[oToken.address]) {\n              _cTokensData[oToken.address] = {\n                ..._cTokensData[oToken.address],\n                isCollateral: oToken.isCollateral,\n              };\n            } else {\n              _cTokensData[oToken.address] = {\n                ...oToken,\n                isCollateral: oToken.isCollateral,\n              };\n            }\n          });\n        }\n\n        count++;\n        formatedData(\"User Borrows\");\n      })\n      .catch((err) => {\n        console.log(\"CATCH_getCollateralStatus_ERROR:\", err);\n      });\n  };\n  const getPoolCash = () => {\n    const calls = oTokens.map((oToken) => ({\n      address: oToken.address,\n      name: \"getCash\",\n    }));\n    multicall({\n      abi: OTOKEN_ABI,\n      calls,\n      options: {},\n      multicallAddress,\n      provider: Ethers.provider(),\n    })\n      .then((res) => {\n        console.log(\"getPoolCash_res:\", res, _cTokensData);\n        oTokens.forEach((oToken, index) => {\n          if (_cTokensData[oToken.address]) {\n            _cTokensData[oToken.address] = {\n              ..._cTokensData[oToken.address],\n              cash: res[index]\n                ? formatUnits(res[index][0], oToken.decimals)\n                : 0,\n            };\n          } else {\n            _cTokensData[oToken.address] = {\n              ...oToken,\n              cash: res[index]\n                ? formatUnits(res[index][0], oToken.decimals)\n                : 0,\n            };\n          }\n        });\n        count++;\n        formatedData(\"oTokens data\");\n      })\n      .catch((err) => {\n        console.log(\"getPoolCash_error:\", err);\n      });\n  };\n  const getTotalBorrows = () => {\n    const calls = oTokens.map((oToken) => ({\n      address: oToken.address,\n      name: \"totalBorrows\",\n    }));\n    multicall({\n      abi: OTOKEN_ABI,\n      calls,\n      options: {},\n      multicallAddress,\n      provider: Ethers.provider(),\n    })\n      .then((res) => {\n        console.log(\"totalBorrows_res:\", res, _cTokensData);\n        oTokens.forEach((oToken, index) => {\n          if (_cTokensData[oToken.address]) {\n            _cTokensData[oToken.address] = {\n              ..._cTokensData[oToken.address],\n              totalBorrows: res[index]\n                ? formatUnits(res[index][0], oToken.decimals)\n                : 0,\n            };\n          } else {\n            _cTokensData[oToken.address] = {\n              ...oToken,\n              totalBorrows: res[index]\n                ? formatUnits(res[index][0], oToken.decimals)\n                : 0,\n            };\n          }\n        });\n        count++;\n        formatedData(\"oTokens data\");\n      })\n      .catch((err) => {\n        console.log(\"totalBorrows_error:\", err);\n      });\n  };\n  const getTotalReserves = () => {\n    const calls = oTokens.map((oToken) => ({\n      address: oToken.address,\n      name: \"totalReserves\",\n    }));\n    multicall({\n      abi: OTOKEN_ABI,\n      calls,\n      options: {},\n      multicallAddress,\n      provider: Ethers.provider(),\n    })\n      .then((res) => {\n        console.log(\"totalReserves_res:\", res, _cTokensData);\n        oTokens.forEach((oToken, index) => {\n          if (_cTokensData[oToken.address]) {\n            _cTokensData[oToken.address] = {\n              ..._cTokensData[oToken.address],\n              totalReserves: res[index]\n                ? formatUnits(res[index][0], oToken.decimals)\n                : 0,\n            };\n          } else {\n            _cTokensData[oToken.address] = {\n              ...oToken,\n              totalReserves: res[index]\n                ? formatUnits(res[index][0], oToken.decimals)\n                : 0,\n            };\n          }\n        });\n        count++;\n        formatedData(\"oTokens data\");\n      })\n      .catch((err) => {\n        console.log(\"totalReserves_error:\", err);\n      });\n  };\n  getUnderlyPrice();\n  // getOTokenLiquidity();\n  getWalletBalance();\n  // getCTokensData();\n  getBorrowRatePerBlock();\n  getSupplyRatePerBlock();\n  getUserSupply();\n  getUserBorrows();\n  getCollateralStatus();\n  getPoolCash();\n  getTotalBorrows();\n  getTotalReserves();\n}, [update, account, orbitTab]);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/bluebiu.near/widget/Lending.Data.Orbit", "fact_widget_deployments_id": "5a4099cc0c826965189c4a89560895f3", "inserted_timestamp": "2024-04-28T17:40:53.419Z", "modified_timestamp": "2024-04-28T17:40:53.419Z", "__row_index": 3}