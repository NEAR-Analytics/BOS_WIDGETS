{"tx_hash": "ByPNXJ7vu31fgm4LsMiPHkrCjVzj2AHGbAeEKdRcpEfr", "action_id_social": "79P8i8HsvAdcJSuQb84haHTYpnBPcgYB2rrjCXgrtfPH-0-widget", "block_id": 116671462, "block_timestamp": "2024-04-12T08:34:08.104Z", "signer_id": "bluebiu.near", "widget_name": "Lending.Data.Benqi", "source_code": "const OTOKEN_ABI = [\n  {\n    inputs: [],\n    name: \"totalSupply\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"totalBorrows\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"exchangeRateCurrent\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"account\", type: \"address\" }],\n    name: \"getAccountSnapshot\",\n    outputs: [\n      { internalType: \"uint256\", name: \"\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"\", type: \"uint256\" },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"supplyRatePerTimestamp\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"borrowRatePerTimestamp\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\nconst UNITROLLER_ABI = [\n  {\n    constant: true,\n    inputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n    name: \"markets\",\n    outputs: [\n      { internalType: \"bool\", name: \"isListed\", type: \"bool\" },\n      {\n        internalType: \"uint256\",\n        name: \"collateralFactorMantissa\",\n        type: \"uint256\",\n      },\n      { internalType: \"bool\", name: \"isQied\", type: \"bool\" },\n    ],\n    payable: false,\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"account\", type: \"address\" },\n      {\n        internalType: \"contract IOToken\",\n        name: \"oToken\",\n        type: \"address\",\n      },\n    ],\n    name: \"checkMembership\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    constant: true,\n    inputs: [\n      { internalType: \"uint8\", name: \"\", type: \"uint8\" },\n      { internalType: \"address\", name: \"\", type: \"address\" },\n    ],\n    name: \"supplyRewardSpeeds\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    payable: false,\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    constant: true,\n    inputs: [\n      { internalType: \"uint8\", name: \"\", type: \"uint8\" },\n      { internalType: \"address\", name: \"\", type: \"address\" },\n    ],\n    name: \"borrowRewardSpeeds\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    payable: false,\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    constant: true,\n    inputs: [\n      { internalType: \"uint8\", name: \"\", type: \"uint8\" },\n      { internalType: \"address\", name: \"\", type: \"address\" },\n    ],\n    name: \"rewardAccrued\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    payable: false,\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\nconst ORACLE_ABI = [\n  {\n    inputs: [\n      {\n        internalType: \"contract IOToken\",\n        name: \"oToken\",\n        type: \"address\",\n      },\n    ],\n    name: \"getUnderlyingPrice\",\n    outputs: [{ internalType: \"uint256\", name: \"price\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\nconst ERC20_ABI = [\n  {\n    constant: true,\n    inputs: [\n      {\n        name: \"_owner\",\n        type: \"address\",\n      },\n    ],\n    name: \"balanceOf\",\n    outputs: [\n      {\n        name: \"balance\",\n        type: \"uint256\",\n      },\n    ],\n    payable: false,\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\n\nconst {\n  multicallAddress,\n  unitrollerAddress,\n  oracleAddress,\n  lensAddress,\n  account,\n  update,\n  name,\n  onLoad,\n  markets,\n  multicall,\n  prices,\n} = props;\n\nuseEffect(() => {\n  if (!multicallAddress || !unitrollerAddress || !update || !account) return \"\";\n\n  console.log(`${name}-update`);\n\n  let _cTokensData = {};\n  let _loanToValue = null;\n  let _underlyPrice = {};\n  let _underlyingBalance = null;\n  let _userMerberShip = null;\n  let _rewardsApy = {};\n  let _accountRewards = {};\n  let count = 0;\n  let oTokensLength = Object.values(markets).length;\n  const AVAX = {\n    icon: \"https://ipfs.near.social/ipfs/bafkreiaxodsgromeeaihu44fazsxdopkrqvinqzhyfxvx5mrbcmduqdfpq\",\n    symbol: \"AVAX\",\n  };\n  const QI = {\n    icon: \"https://ipfs.near.social/ipfs/bafkreiel5ejkjafpw2au4v34muga4im5afzztojy7jedbnd24dtumgtzsi\",\n    symbol: \"QI\",\n  };\n\n  const formatedData = (key) => {\n    console.log(`${name}-${key}`, count);\n    if (count < 5) return;\n    count = 0;\n    oTokensLength = Object.values(markets).length;\n    let totalSupplyUsd = Big(0);\n    let totalBorrowUsd = Big(0);\n    let userTotalSupplyUsd = Big(0);\n    let userTotalBorrowUsd = Big(0);\n    let totalCollateralUsd = Big(0);\n    let totalAccountQiDistributionApy = Big(0);\n    let totalAccountAvaxDistributionApy = Big(0);\n    const markets = {};\n    Object.values(_cTokensData).forEach((market) => {\n      const underlyingPrice = _underlyPrice[market.address] || 1;\n      const marketSupplyUsd = Big(market.totalSupply || 0).mul(underlyingPrice);\n      const marketBorrowUsd = Big(market.totalBorrows || 0).mul(\n        underlyingPrice\n      );\n      totalSupplyUsd = totalSupplyUsd.plus(marketSupplyUsd);\n      totalBorrowUsd = totalBorrowUsd.plus(marketBorrowUsd);\n      userTotalSupplyUsd = userTotalSupplyUsd.plus(\n        Big(market.userSupply).mul(underlyingPrice)\n      );\n      userTotalBorrowUsd = userTotalBorrowUsd.plus(\n        Big(market.userBorrow).mul(underlyingPrice)\n      );\n      if (_userMerberShip[market.address]) {\n        totalCollateralUsd = totalCollateralUsd.plus(\n          Big(market.userSupply)\n            .mul(underlyingPrice)\n            .mul(_loanToValue[market.address])\n            .div(100)\n        );\n      }\n      const rewardsApy = _rewardsApy[market.address];\n      const avaxSupplyDistributionApy = rewardsApy.avax.supply\n        .div(marketSupplyUsd.eq(0) ? 1 : marketSupplyUsd)\n        .mul(100)\n        .toFixed(2);\n      const avaxBorrowDistributionApy = rewardsApy.avax.borrow\n        .div(marketBorrowUsd.eq(0) ? 1 : marketBorrowUsd)\n        .mul(100)\n        .toFixed(2);\n      const qiSupplyDistributionApy = rewardsApy.qi.supply\n        .div(marketSupplyUsd.eq(0) ? 1 : marketSupplyUsd)\n        .mul(100)\n        .toFixed(2);\n      const qiBorrowDistributionApy = rewardsApy.qi.borrow\n        .div(marketBorrowUsd.eq(0) ? 1 : marketBorrowUsd)\n        .mul(100)\n        .toFixed(2);\n      const distributionApy = [\n        {\n          ...AVAX,\n          supply: avaxSupplyDistributionApy + \"%\",\n          borrow: avaxBorrowDistributionApy + \"%\",\n        },\n        {\n          ...QI,\n          supply: qiSupplyDistributionApy + \"%\",\n          borrow: qiBorrowDistributionApy + \"%\",\n        },\n      ];\n      totalAccountQiDistributionApy = totalAccountQiDistributionApy\n        .plus(qiSupplyDistributionApy)\n        .plus(qiBorrowDistributionApy);\n      totalAccountAvaxDistributionApy = totalAccountAvaxDistributionApy\n        .plus(avaxSupplyDistributionApy)\n        .plus(avaxBorrowDistributionApy);\n      const supplyApy = Big(market.supplyRatePerTimestamp)\n        .mul(60 * 60 * 24)\n        .plus(1)\n        .pow(365)\n        .minus(1)\n        .mul(100);\n      const borrowApy = Big(market.borrowRatePerTimestamp)\n        .mul(60 * 60 * 24)\n        .plus(1)\n        .pow(365)\n        .minus(1)\n        .mul(100);\n\n      markets[market.address] = {\n        ...market,\n        loanToValue: _loanToValue[market.address],\n        liquidity: Big(market.totalSupply || 0)\n          .minus(market.totalBorrows || 0)\n          .toString(),\n        underlyingPrice: underlyingPrice,\n        userUnderlyingBalance: _underlyingBalance[market.address],\n        userMerberShip: _userMerberShip[market.address],\n        supplyApy: supplyApy.toFixed(2) + \"%\",\n        borrowApy: borrowApy.toFixed(2) + \"%\",\n        dapp: name,\n        distributionApy,\n      };\n    });\n    let rewards = [];\n\n    if (_accountRewards && Big(_accountRewards.qiReward || 0).gt(0)) {\n      const dailyRewards = totalAccountQiDistributionApy\n        .mul(userTotalSupplyUsd.add(userTotalBorrowUsd))\n        .div(365 * 100)\n        .div(_accountRewards.qiPrice);\n      rewards.push({\n        ...QI,\n        dailyRewards: dailyRewards.toString(),\n        price: _accountRewards.qiPrice,\n        unclaimed: _accountRewards.qiReward,\n      });\n    }\n    if (_accountRewards && Big(_accountRewards.avaxReward || 0).gt(0)) {\n      const dailyRewards = totalAccountAvaxDistributionApy\n        .mul(userTotalSupplyUsd.add(userTotalBorrowUsd))\n        .div(365 * 100)\n        .div(_accountRewards.avaxPrice);\n      rewards.push({\n        ...AVAX,\n        dailyRewards: dailyRewards.toString(),\n        price: _accountRewards.avaxPrice,\n        unclaimed: _accountRewards.avaxReward,\n      });\n    }\n\n    onLoad({\n      markets,\n      rewards,\n      totalSupplyUsd: totalSupplyUsd.toString(),\n      totalBorrowUsd: totalBorrowUsd.toString(),\n      userTotalSupplyUsd: userTotalSupplyUsd.toString(),\n      userTotalBorrowUsd: userTotalBorrowUsd.toString(),\n      totalCollateralUsd: totalCollateralUsd.toString(),\n    });\n  };\n  const getUnitrollerData = () => {\n    const calls = [];\n    const oTokens = Object.values(markets);\n    oTokens.forEach((token) => {\n      calls.push({\n        address: unitrollerAddress,\n        name: \"markets\",\n        params: [token.address],\n      });\n      if (account) {\n        calls.push({\n          address: unitrollerAddress,\n          name: \"checkMembership\",\n          params: [account, token.address],\n        });\n      }\n    });\n    multicall({\n      abi: UNITROLLER_ABI,\n      calls,\n      options: {},\n      multicallAddress,\n      provider: Ethers.provider(),\n    })\n      .then((res) => {\n        _loanToValue = {};\n        _userMerberShip = {};\n        for (let i = 0, len = res.length; i < len; i++) {\n          const index = Math.floor(i / (account ? 2 : 1));\n          const mod = i % (account ? 2 : 1);\n          switch (mod) {\n            case 0:\n              _loanToValue[oTokens[index].address] = ethers.utils.formatUnits(\n                res[i][1]._hex,\n                16\n              );\n              break;\n            case 1:\n              _userMerberShip[oTokens[index].address] = res[i][0] || false;\n              break;\n            default:\n          }\n        }\n        count++;\n        formatedData(\"getUnitrollerData\");\n      })\n      .catch((err) => {\n        console.log(\"error-getUnitrollerData\", err);\n        setTimeout(() => {\n          getUnitrollerData();\n        }, 1000);\n      });\n  };\n  const getUnderlyPrice = () => {\n    if (!oracleAddress) return;\n    const oTokens = Object.keys(markets);\n    const calls = oTokens.map((token) => ({\n      address: oracleAddress,\n      name: \"getUnderlyingPrice\",\n      params: [token],\n    }));\n    multicall({\n      abi: ORACLE_ABI,\n      calls,\n      options: {},\n      multicallAddress,\n      provider: Ethers.provider(),\n    })\n      .then((res) => {\n        _underlyPrice = {};\n        for (let i = 0, len = res.length; i < len; i++) {\n          _underlyPrice[oTokens[i]] = ethers.utils.formatUnits(\n            res[i][0]._hex,\n            36 - markets[oTokens[i]].underlyingToken.decimals\n          );\n        }\n        count++;\n        formatedData(\"getUnderlyPrice\");\n      })\n      .catch((err) => {\n        console.log(\"error-getUnderlyPrice\", err);\n      });\n  };\n  const getWalletBalance = () => {\n    let nativeOToken = \"\";\n    const underlyingTokens = Object.values(markets)\n      .filter((market) => {\n        if (market.underlyingToken.address === \"native\")\n          nativeOToken = market.address;\n        return (\n          market.underlyingToken.address &&\n          market.underlyingToken.address !== \"native\"\n        );\n      })\n      .map((market) => ({\n        ...market.underlyingToken,\n        oTokenAddress: market.address,\n      }));\n    const calls = underlyingTokens.map((token) => ({\n      address: token.address,\n      name: \"balanceOf\",\n      params: [account],\n    }));\n    multicall({\n      abi: ERC20_ABI,\n      calls,\n      options: {},\n      multicallAddress,\n      provider: Ethers.provider(),\n    })\n      .then((res) => {\n        _underlyingBalance = {};\n        for (let i = 0, len = res.length; i < len; i++) {\n          _underlyingBalance[underlyingTokens[i].oTokenAddress] = res[i][0]\n            ? ethers.utils.formatUnits(\n                res[i][0]._hex,\n                underlyingTokens[i].decimals\n              )\n            : \"0\";\n        }\n        if (nativeOToken) {\n          const provider = Ethers.provider();\n          provider.getBalance(account).then((rawBalance) => {\n            _underlyingBalance[nativeOToken] = rawBalance._hex\n              ? ethers.utils.formatUnits(rawBalance._hex, 18)\n              : \"0\";\n            count++;\n            formatedData(\"underlyingTokens\");\n          });\n        } else {\n          count++;\n          formatedData(\"underlyingTokens\");\n        }\n      })\n      .catch((err) => {\n        console.log(\"err getWalletBalance\", err);\n        setTimeout(() => {\n          getWalletBalance();\n        }, 500);\n      });\n  };\n  const getCTokenData = (oToken) => {\n    if (oTokensLength === 0) return;\n    const calls = [\n      {\n        address: oToken.address,\n        name: \"exchangeRateCurrent\",\n      },\n      {\n        address: oToken.address,\n        name: \"totalSupply\",\n      },\n      {\n        address: oToken.address,\n        name: \"totalBorrows\",\n      },\n      {\n        address: oToken.address,\n        name: \"supplyRatePerTimestamp\",\n      },\n      {\n        address: oToken.address,\n        name: \"borrowRatePerTimestamp\",\n      },\n      {\n        address: oToken.address,\n        name: \"getAccountSnapshot\",\n        params: [account],\n      },\n    ];\n    multicall({\n      abi: OTOKEN_ABI,\n      calls,\n      options: {},\n      multicallAddress,\n      provider: Ethers.provider(),\n    })\n      .then((res) => {\n        oTokensLength--;\n        const exchangeRateStored = ethers.utils.formatUnits(\n          res[0][0]._hex,\n          10 + oToken.underlyingToken.decimals\n        );\n        const userSupply = ethers.utils.formatUnits(\n          res[5][1]._hex,\n          oToken.decimals\n        );\n        const totalSupply = ethers.utils.formatUnits(\n          res[1][0]._hex,\n          oToken.decimals\n        );\n        _cTokensData[oToken.address] = {\n          ...oToken,\n          exchangeRateStored,\n          totalSupply: Big(totalSupply).mul(exchangeRateStored).toString(),\n          totalBorrows: ethers.utils.formatUnits(\n            res[2][0]._hex,\n            oToken.underlyingToken.decimals\n          ),\n          supplyRatePerTimestamp: ethers.utils.formatUnits(res[3][0]._hex, 18),\n          borrowRatePerTimestamp: ethers.utils.formatUnits(res[4][0]._hex, 18),\n          userSupply: Big(userSupply).mul(exchangeRateStored).toString(),\n          userBorrow: ethers.utils.formatUnits(\n            res[5][2]._hex,\n            oToken.underlyingToken.decimals\n          ),\n        };\n        if (oTokensLength === 0) {\n          count++;\n          formatedData(\"oTokens data\");\n        }\n      })\n      .catch(() => {\n        setTimeout(() => {\n          getCTokenData(oToken);\n        }, 500);\n      });\n  };\n\n  const getCTokensData = () => {\n    Object.values(markets).forEach((market) => {\n      getCTokenData(market);\n    });\n  };\n\n  const getUserRewards = () => {\n    const calls = [\n      {\n        address: lensAddress,\n        name: \"getClaimableReward\",\n        params: [account, 0],\n      },\n      {\n        address: lensAddress,\n        name: \"getClaimableReward\",\n        params: [account, 1],\n      },\n    ];\n    multicall({\n      abi: [\n        {\n          inputs: [\n            {\n              internalType: \"address\",\n              name: \"user\",\n              type: \"address\",\n            },\n            {\n              internalType: \"uint8\",\n              name: \"rewardType\",\n              type: \"uint8\",\n            },\n          ],\n          name: \"getClaimableReward\",\n          outputs: [\n            {\n              internalType: \"uint256\",\n              name: \"\",\n              type: \"uint256\",\n            },\n            {\n              internalType: \"address[]\",\n              name: \"\",\n              type: \"address[]\",\n            },\n          ],\n          stateMutability: \"view\",\n          type: \"function\",\n        },\n      ],\n      calls,\n      options: {},\n      multicallAddress,\n      provider: Ethers.provider(),\n    }).then((res) => {\n      _accountRewards.qiReward = ethers.utils.formatUnits(res[0][0]._hex, 18);\n      _accountRewards.avaxReward = ethers.utils.formatUnits(res[1][0]._hex, 18);\n      count++;\n      formatedData(\"rewards\");\n    });\n  };\n\n  const getCTokenReward = ({ avaxPrice, qiPrice, cTokens, index }) => {\n    const token = cTokens[index];\n    const calls = [\n      {\n        address: unitrollerAddress,\n        name: \"borrowRewardSpeeds\",\n        params: [0, token],\n      },\n      {\n        address: unitrollerAddress,\n        name: \"borrowRewardSpeeds\",\n        params: [1, token],\n      },\n      {\n        address: unitrollerAddress,\n        name: \"supplyRewardSpeeds\",\n        params: [0, token],\n      },\n      {\n        address: unitrollerAddress,\n        name: \"supplyRewardSpeeds\",\n        params: [1, token],\n      },\n      {\n        address: unitrollerAddress,\n        name: \"rewardAccrued\",\n        params: [0, account],\n      },\n      {\n        address: unitrollerAddress,\n        name: \"rewardAccrued\",\n        params: [1, account],\n      },\n    ];\n    multicall({\n      abi: UNITROLLER_ABI,\n      calls,\n      options: {},\n      multicallAddress,\n      provider: Ethers.provider(),\n    })\n      .then((res) => {\n        const qiBorrow = Big(\n          ethers.utils.formatUnits(res[0][0]._hex || \"0\", 18)\n        ).mul(qiPrice);\n        const avaxBorrow = Big(\n          ethers.utils.formatUnits(res[1][0]._hex || \"0\", 18)\n        ).mul(avaxPrice);\n        const qiSupply = Big(\n          ethers.utils.formatUnits(res[2][0]._hex || \"0\", 18)\n        ).mul(qiPrice);\n        const avaxSupply = Big(\n          ethers.utils.formatUnits(res[3][0]._hex || \"0\", 18)\n        ).mul(avaxPrice);\n        _rewardsApy[token] = {\n          avax: {\n            borrow: avaxBorrow.mul(60 * 60 * 24 * 365),\n            supply: avaxSupply.mul(60 * 60 * 24 * 365),\n          },\n          qi: {\n            borrow: qiBorrow.mul(60 * 60 * 24 * 365),\n            supply: qiSupply.mul(60 * 60 * 24 * 365),\n          },\n        };\n        if (index === cTokens.length - 1) {\n          getUserRewards();\n        } else {\n          getCTokenReward({\n            avaxPrice,\n            qiPrice,\n            cTokens,\n            index: index + 1,\n          });\n        }\n      })\n      .catch((err) => {\n        console.log(\"error-rewards\", err);\n      });\n  };\n\n  const getRewards = () => {\n    const avaxPrice = prices[\"AVAX\"] || 38.64;\n    const qiPrice = prices[\"QI\"] || 0.01918;\n    const cTokens = Object.keys(markets);\n    _accountRewards.avaxPrice = avaxPrice;\n    _accountRewards.qiPrice = qiPrice;\n    getCTokenReward({\n      avaxPrice,\n      qiPrice,\n      cTokens,\n      index: 0,\n    });\n  };\n\n  getUnitrollerData();\n  getUnderlyPrice();\n  getWalletBalance();\n  getCTokensData();\n  getRewards();\n}, [update, account]);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/bluebiu.near/widget/Lending.Data.Benqi", "fact_widget_deployments_id": "b7637236702bf98be0b84c9fdd87281b", "inserted_timestamp": "2024-04-12T10:36:03.279Z", "modified_timestamp": "2024-04-12T10:36:03.279Z", "__row_index": 3}