{"tx_hash": "42F8ECFoovTE1XUT4scNMRfJRev7qvs1Q1p1V5YhSwUC", "action_id_social": "P7ircBjYj43i4yqwZVZKfDH2i6tbR3gMe9U761Tpauu-0-widget", "block_id": 111188832, "block_timestamp": "2024-01-24T08:54:38.154Z", "signer_id": "bluebiu.near", "widget_name": "Lending.Data.LodestarV1", "source_code": "const OTOKEN_ABI = [\n  {\n    inputs: [],\n    name: \"totalSupply\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"totalBorrows\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"exchangeRateCurrent\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"account\", type: \"address\" }],\n    name: \"getAccountSnapshot\",\n    outputs: [\n      { internalType: \"uint256\", name: \"\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"\", type: \"uint256\" },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"supplyRatePerBlock\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"borrowRatePerBlock\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\nconst UNITROLLER_ABI = [\n  {\n    constant: true,\n    inputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n    name: \"markets\",\n    outputs: [\n      { internalType: \"bool\", name: \"isListed\", type: \"bool\" },\n      {\n        internalType: \"uint256\",\n        name: \"collateralFactorMantissa\",\n        type: \"uint256\",\n      },\n      { internalType: \"bool\", name: \"isQied\", type: \"bool\" },\n    ],\n    payable: false,\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"account\", type: \"address\" },\n      {\n        internalType: \"contract IOToken\",\n        name: \"oToken\",\n        type: \"address\",\n      },\n    ],\n    name: \"checkMembership\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    constant: true,\n    inputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n    name: \"compSupplySpeeds\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    payable: false,\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    constant: true,\n    inputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n    name: \"compBorrowSpeeds\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    payable: false,\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\nconst ERC20_ABI = [\n  {\n    constant: true,\n    inputs: [\n      {\n        name: \"_owner\",\n        type: \"address\",\n      },\n    ],\n    name: \"balanceOf\",\n    outputs: [\n      {\n        name: \"balance\",\n        type: \"uint256\",\n      },\n    ],\n    payable: false,\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\nconst LENS_ABI = [\n  {\n    inputs: [\n      { internalType: \"contract Comp\", name: \"comp\", type: \"address\" },\n      { internalType: \"address\", name: \"account\", type: \"address\" },\n    ],\n    name: \"getCompBalanceMetadata\",\n    outputs: [\n      {\n        components: [\n          { internalType: \"uint256\", name: \"balance\", type: \"uint256\" },\n          { internalType: \"uint256\", name: \"votes\", type: \"uint256\" },\n          { internalType: \"address\", name: \"delegate\", type: \"address\" },\n        ],\n        internalType: \"struct CompoundLens.CompBalanceMetadata\",\n        name: \"\",\n        type: \"tuple\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\n\nconst {\n  multicallAddress,\n  unitrollerAddress,\n  lensAddress,\n  oracleAddress,\n  account,\n  update,\n  dapp,\n  onLoad,\n  markets,\n  multicall,\n  prices,\n} = props;\n\nif (!multicallAddress || !unitrollerAddress || !update || !account) return \"\";\n\nlet _cTokensData = {};\nlet _loanToValue = null;\nlet _underlyPrice = {};\nlet _liquidity = null;\nlet _underlyingBalance = null;\nlet _userMerberShip = null;\nlet _rewards = {};\nlet _accountRewards = {};\nlet count = 0;\nlet oTokensLength = Object.values(markets).length;\nconst REWARD_TOKEN = {\n  icon: \"/images/tokens/lode.svg\",\n  symbol: \"LODE\",\n  address: \"0xf19547f9ed24aa66b03c3a552d181ae334fbb8db\",\n  price: prices[\"LODE\"] || \"0.3076\",\n};\nconst formatedData = (key) => {\n  console.log(`${dapp}-${key}`, count);\n  if (count < 6) return;\n  count = 0;\n  oTokensLength = Object.values(markets).length;\n  let totalSupplyUsd = Big(0);\n  let totalBorrowUsd = Big(0);\n  let userTotalSupplyUsd = Big(0);\n  let userTotalBorrowUsd = Big(0);\n  let totalCollateralUsd = Big(0);\n  let totalAccountDistributionApy = Big(0);\n  const markets = {};\n  Object.values(_cTokensData).forEach((market) => {\n    const underlyingPrice = _underlyPrice[market.address] || 1;\n    const marketSupplyUsd = Big(market.totalSupply || 0).mul(underlyingPrice);\n    const marketBorrowUsd = Big(market.totalBorrows || 0).mul(underlyingPrice);\n    totalSupplyUsd = totalSupplyUsd.plus(marketSupplyUsd);\n    totalBorrowUsd = totalBorrowUsd.plus(marketBorrowUsd);\n    userTotalSupplyUsd = userTotalSupplyUsd.plus(\n      Big(market.userSupply).mul(underlyingPrice)\n    );\n    userTotalBorrowUsd = userTotalBorrowUsd.plus(\n      Big(market.userBorrow).mul(underlyingPrice)\n    );\n    if (_userMerberShip[market.address]) {\n      totalCollateralUsd = totalCollateralUsd.plus(\n        Big(market.userSupply)\n          .mul(underlyingPrice)\n          .mul(_loanToValue[market.address])\n          .div(100)\n      );\n    }\n    const distributionSupplyApy = _rewards[market.address].supply\n      .div(marketSupplyUsd.eq(0) ? 1 : marketSupplyUsd)\n      .plus(1)\n      .pow(365)\n      .minus(1)\n      .mul(100)\n      .toFixed(2);\n    const distributionBorrowApy = _rewards[market.address].borrow\n      .div(marketBorrowUsd.eq(0) ? 1 : marketBorrowUsd)\n      .plus(1)\n      .pow(365)\n      .minus(1)\n      .mul(100)\n      .toFixed(2);\n    totalAccountDistributionApy = totalAccountDistributionApy\n      .plus(distributionSupplyApy)\n      .plus(distributionBorrowApy);\n    const supplyApy = Big(market.supplyRatePerBlock)\n      .mul(4 * 60 * 24)\n      .plus(1)\n      .pow(365)\n      .minus(1)\n      .mul(100);\n\n    const borrowApy = Big(market.borrowRatePerBlock)\n      .mul(4 * 60 * 24)\n      .plus(1)\n      .pow(365)\n      .minus(1)\n      .mul(100);\n\n    markets[market.address] = {\n      ...market,\n      loanToValue: _loanToValue[market.address],\n      liquidity: _liquidity[market.address],\n      underlyingPrice: underlyingPrice,\n      userUnderlyingBalance: _underlyingBalance[market.address],\n      userMerberShip: _userMerberShip[market.address],\n      supplyApy: supplyApy.toFixed(2) + \"%\",\n      borrowApy: borrowApy.toFixed(2) + \"%\",\n      distributionApy: [\n        {\n          ...REWARD_TOKEN,\n          supply: distributionSupplyApy + \"%\",\n          borrow: distributionBorrowApy + \"%\",\n        },\n      ],\n      dapp,\n    };\n  });\n\n  // const arbApy = Big(28800 * 52)\n  //   .mul(prices[\"ARB\"] || 1)\n  //   .div(totalSupplyUsd.add(totalBorrowUsd));\n\n  // console.log(\"arbApy\", arbApy.toString());\n\n  let rewards;\n\n  if (_accountRewards && Big(_accountRewards.reward || 0).gt(0)) {\n    const dailyRewards = totalAccountDistributionApy\n      .mul(userTotalSupplyUsd.add(userTotalBorrowUsd))\n      .div(365 * 100)\n      .div(_accountRewards.price);\n    rewards = [\n      {\n        ...REWARD_TOKEN,\n        dailyRewards: dailyRewards.toString(),\n        price: _accountRewards.price,\n        unclaimed: _accountRewards.reward,\n      },\n    ];\n  }\n  onLoad({\n    markets,\n    rewards,\n    totalSupplyUsd: totalSupplyUsd.toString(),\n    totalBorrowUsd: totalBorrowUsd.toString(),\n    userTotalSupplyUsd: userTotalSupplyUsd.toString(),\n    userTotalBorrowUsd: userTotalBorrowUsd.toString(),\n    totalCollateralUsd: totalCollateralUsd.toString(),\n  });\n};\nconst getUnitrollerData = () => {\n  const calls = [];\n  const oTokens = Object.values(markets);\n  oTokens.forEach((token) => {\n    calls.push({\n      address: unitrollerAddress,\n      name: \"markets\",\n      params: [token.address],\n    });\n    if (account) {\n      calls.push({\n        address: unitrollerAddress,\n        name: \"checkMembership\",\n        params: [account, token.address],\n      });\n    }\n  });\n  multicall({\n    abi: UNITROLLER_ABI,\n    calls,\n    options: {},\n    multicallAddress,\n    provider: Ethers.provider(),\n  })\n    .then((res) => {\n      _loanToValue = {};\n      _userMerberShip = {};\n      for (let i = 0, len = res.length; i < len; i++) {\n        const index = Math.floor(i / (account ? 2 : 1));\n        const mod = i % (account ? 2 : 1);\n        switch (mod) {\n          case 0:\n            _loanToValue[oTokens[index].address] = ethers.utils.formatUnits(\n              res[i][1]._hex,\n              16\n            );\n            break;\n          case 1:\n            _userMerberShip[oTokens[index].address] = res[i][0];\n            break;\n          default:\n        }\n      }\n      count++;\n      formatedData(\"getUnitrollerData\");\n    })\n    .catch((err) => {\n      console.log(\"error-getUnitrollerData\", err);\n      setTimeout(() => {\n        getUnitrollerData();\n      }, 1000);\n    });\n};\nconst getUnderlyPrice = () => {\n  Object.values(markets).forEach((market) => {\n    _underlyPrice[market.address] =\n      prices[\n        market.underlyingToken.priceKey || market.underlyingToken.symbol\n      ] || \"1\";\n  });\n  count++;\n  formatedData(\"getUnderlyPrice\");\n};\nconst getOTokenLiquidity = () => {\n  const assets = Object.values(markets);\n  let nativeOToken = \"\";\n  const calls = assets\n    .filter((market) => {\n      if (market.underlyingToken.address === \"native\")\n        nativeOToken = market.address;\n      return (\n        market.underlyingToken.address &&\n        market.underlyingToken.address !== \"native\"\n      );\n    })\n    .map((market) => ({\n      address: market.underlyingToken.address,\n      name: \"balanceOf\",\n      params: [market.address],\n    }));\n  multicall({\n    abi: ERC20_ABI,\n    calls,\n    options: {},\n    multicallAddress,\n    provider: Ethers.provider(),\n  })\n    .then((res) => {\n      _liquidity = {};\n      for (let i = 0, len = res.length; i < len; i++) {\n        const oToken = markets[calls[i].params[0]];\n        _liquidity[oToken.address] = ethers.utils.formatUnits(\n          res[i][0]._hex,\n          oToken.underlyingToken.decimals\n        );\n      }\n      const provider = Ethers.provider();\n      if (nativeOToken) {\n        provider.getBalance(nativeOToken).then((rawBalance) => {\n          _liquidity[nativeOToken] = ethers.utils.formatUnits(\n            rawBalance._hex,\n            18\n          );\n          count++;\n          formatedData(\"getOTokenLiquidity\");\n        });\n      } else {\n        count++;\n        formatedData(\"getOTokenLiquidity\");\n      }\n    })\n    .catch(() => {\n      setTimeout(() => {\n        getOTokenLiquidity();\n      }, 500);\n    });\n};\nconst getWalletBalance = () => {\n  let nativeOToken = \"\";\n  const underlyingTokens = Object.values(markets)\n    .filter((market) => {\n      if (market.underlyingToken.address === \"native\")\n        nativeOToken = market.address;\n      return (\n        market.underlyingToken.address &&\n        market.underlyingToken.address !== \"native\"\n      );\n    })\n    .map((market) => ({\n      ...market.underlyingToken,\n      oTokenAddress: market.address,\n    }));\n  const calls = underlyingTokens.map((token) => ({\n    address: token.address,\n    name: \"balanceOf\",\n    params: [account],\n  }));\n  multicall({\n    abi: ERC20_ABI,\n    calls,\n    options: {},\n    multicallAddress,\n    provider: Ethers.provider(),\n  })\n    .then((res) => {\n      _underlyingBalance = {};\n      for (let i = 0, len = res.length; i < len; i++) {\n        _underlyingBalance[underlyingTokens[i].oTokenAddress] = res[i][0]\n          ? ethers.utils.formatUnits(\n              res[i][0]._hex,\n              underlyingTokens[i].decimals\n            )\n          : \"0\";\n      }\n      const provider = Ethers.provider();\n      if (nativeOToken) {\n        provider.getBalance(account).then((rawBalance) => {\n          _underlyingBalance[nativeOToken] = ethers.utils.formatUnits(\n            rawBalance._hex,\n            18\n          );\n          count++;\n          formatedData(\"underlyingTokens\");\n        });\n      } else {\n        count++;\n        formatedData(\"underlyingTokens\");\n      }\n    })\n    .catch((err) => {\n      console.log(\"getWalletBalance error\", err);\n      setTimeout(() => {\n        getWalletBalance();\n      }, 500);\n    });\n};\nconst getCTokenData = (oToken) => {\n  if (oTokensLength === 0) return;\n  const calls = [\n    {\n      address: oToken.address,\n      name: \"exchangeRateCurrent\",\n    },\n    {\n      address: oToken.address,\n      name: \"totalSupply\",\n    },\n    {\n      address: oToken.address,\n      name: \"totalBorrows\",\n    },\n    {\n      address: oToken.address,\n      name: \"supplyRatePerBlock\",\n    },\n    {\n      address: oToken.address,\n      name: \"borrowRatePerBlock\",\n    },\n    {\n      address: oToken.address,\n      name: \"getAccountSnapshot\",\n      params: [account],\n    },\n  ];\n  multicall({\n    abi: OTOKEN_ABI,\n    calls,\n    options: {},\n    multicallAddress,\n    provider: Ethers.provider(),\n  })\n    .then((res) => {\n      oTokensLength--;\n      const exchangeRateStored = ethers.utils.formatUnits(\n        res[0][0]._hex,\n        10 + oToken.underlyingToken.decimals\n      );\n      const userSupply = ethers.utils.formatUnits(\n        res[5][1]._hex,\n        oToken.decimals\n      );\n      const totalSupply = ethers.utils.formatUnits(\n        res[1][0]._hex,\n        oToken.decimals\n      );\n      _cTokensData[oToken.address] = {\n        ...oToken,\n        exchangeRateStored,\n        totalSupply: Big(totalSupply).mul(exchangeRateStored).toString(),\n        totalBorrows: ethers.utils.formatUnits(\n          res[2][0]._hex,\n          oToken.underlyingToken.decimals\n        ),\n        supplyRatePerBlock: ethers.utils.formatUnits(res[3][0]._hex, 18),\n        borrowRatePerBlock: ethers.utils.formatUnits(res[4][0]._hex, 18),\n        userSupply: Big(userSupply).mul(exchangeRateStored).toString(),\n        userBorrow: ethers.utils.formatUnits(\n          res[5][2]._hex,\n          oToken.underlyingToken.decimals\n        ),\n      };\n      if (oTokensLength === 0) {\n        count++;\n        formatedData(\"oTokens data\");\n      }\n    })\n    .catch(() => {\n      setTimeout(() => {\n        getCTokenData(oToken);\n      }, 500);\n    });\n};\n\nconst getCTokensData = () => {\n  Object.values(markets).forEach((market) => {\n    getCTokenData(market);\n  });\n};\n\nconst getUserRewards = () => {\n  multicall({\n    abi: LENS_ABI,\n    calls: [\n      {\n        address: lensAddress,\n        name: \"getCompBalanceMetadata\",\n        params: [REWARD_TOKEN.address, account],\n      },\n    ],\n    options: {},\n    multicallAddress,\n    provider: Ethers.provider(),\n  })\n    .then((res) => {\n      const price = prices[REWARD_TOKEN.priceKey || REWARD_TOKEN.symbol] || \"1\";\n      _accountRewards = {\n        price,\n        reward: res[0][0][0]\n          ? ethers.utils.formatUnits(res[0][0][0], 18).toString()\n          : \"0\",\n      };\n      count++;\n      formatedData(\"rewards\");\n    })\n    .catch((err) => {\n      console.log(dapp + \" error-user-rewards\", err);\n    });\n};\n\nconst getCTokenReward = ({ cTokens, index }) => {\n  const token = cTokens[index];\n  const calls = [\n    {\n      address: unitrollerAddress,\n      name: \"compBorrowSpeeds\",\n      params: [token],\n    },\n    {\n      address: unitrollerAddress,\n      name: \"compSupplySpeeds\",\n      params: [token],\n    },\n  ];\n  multicall({\n    abi: UNITROLLER_ABI,\n    calls,\n    options: {},\n    multicallAddress,\n    provider: Ethers.provider(),\n  })\n    .then((res) => {\n      const borrow = res[0][0]\n        ? Big(ethers.utils.formatUnits(res[0][0]._hex, 18)).mul(\n            REWARD_TOKEN.price\n          )\n        : Big(0);\n      const supply = res[1][0]\n        ? Big(ethers.utils.formatUnits(res[1][0]._hex, 18)).mul(\n            REWARD_TOKEN.price\n          )\n        : Big(0);\n      _rewards[token] = {\n        borrow: borrow.mul(7200),\n        supply: supply.mul(7200),\n      };\n\n      if (index === cTokens.length - 1) {\n        getUserRewards();\n      } else {\n        getCTokenReward({\n          cTokens,\n          index: index + 1,\n        });\n      }\n    })\n    .catch((err) => {\n      console.log(\"error-rewards\", err);\n    });\n};\n\nconst getRewards = () => {\n  const cTokens = Object.keys(markets);\n  getCTokenReward({\n    cTokens,\n    index: 0,\n  });\n};\n\nuseEffect(() => {\n  getUnitrollerData();\n  getUnderlyPrice();\n  getOTokenLiquidity();\n  getWalletBalance();\n  getCTokensData();\n  getRewards();\n}, []);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/bluebiu.near/widget/Lending.Data.LodestarV1", "fact_widget_deployments_id": "02d88f2c5b9b54bfbb288a426f651412", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 2}