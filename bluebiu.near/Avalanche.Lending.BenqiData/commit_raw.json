{"tx_hash": "zh4zcPYuvBRrPxAVi8rGBDN3XBsuYMpSUuP99F4NWa7", "action_id_social": "7omBDUMxH6JJqyRcKy6uusNkjA4wDUnicxEQiah6Vzdu-0-widget", "block_id": 108401873, "block_timestamp": "2023-12-20T11:36:32.247Z", "signer_id": "bluebiu.near", "widget_name": "Avalanche.Lending.BenqiData", "source_code": "const markets = {\n  // \"0x5C0401e81Bc07Ca70fAD469b451682c0d747Ef1c\": {\n  //   underlyingToken: {\n  //     address: \"native\",\n  //     decimals: 18,\n  //     symbol: \"AVAX\",\n  //   },\n  //   decimals: 8,\n  //   symbol: \"qiAVAX\",\n  //   address: \"0x5C0401e81Bc07Ca70fAD469b451682c0d747Ef1c\",\n  //   icon: \"https://ipfs.near.social/ipfs/bafkreiaxodsgromeeaihu44fazsxdopkrqvinqzhyfxvx5mrbcmduqdfpq\",\n  // },\n  \"0xe194c4c5aC32a3C9ffDb358d9Bfd523a0B6d1568\": {\n    underlyingToken: {\n      address: \"0x50b7545627a5162F82A992c33b87aDc75187B218\",\n      decimals: 8,\n      symbol: \"WBTC.e\",\n    },\n    decimals: 8,\n    symbol: \"qiBTC\",\n    address: \"0xe194c4c5aC32a3C9ffDb358d9Bfd523a0B6d1568\",\n    icon: \"https://ipfs.near.social/ipfs/bafkreigdklwcldjo4w7viyrym54hdb43wgpv23mbicetszygzapttbgo7q\",\n  },\n  \"0x334AD834Cd4481BB02d09615E7c11a00579A7909\": {\n    underlyingToken: {\n      address: \"0x49D5c2BdFfac6CE2BFdB6640F4F80f226bc10bAB\",\n      decimals: 18,\n      symbol: \"WETH.e\",\n    },\n    decimals: 8,\n    symbol: \"qiETH\",\n    address: \"0x334AD834Cd4481BB02d09615E7c11a00579A7909\",\n    icon: \"https://ipfs.near.social/ipfs/bafkreibspnls7q67q25r2ifv2rrfmvzl744pzuh3s5ekigeqkmyycl2auq\",\n  },\n  \"0xc9e5999b8e75C3fEB117F6f73E664b9f3C8ca65C\": {\n    underlyingToken: {\n      address: \"0xc7198437980c041c805A1EDcbA50c1Ce5db95118\",\n      decimals: 6,\n      symbol: \"USDT.e\",\n    },\n    decimals: 8,\n    symbol: \"qiUSDT\",\n    address: \"0xc9e5999b8e75C3fEB117F6f73E664b9f3C8ca65C\",\n    icon: \"https://ipfs.near.social/ipfs/bafkreih45jy7ggj45ck34rf736kb67smsoa52wd7e46c2grh6etd3bhe5i\",\n  },\n  \"0x4e9f683A27a6BdAD3FC2764003759277e93696e6\": {\n    underlyingToken: {\n      address: \"0x5947BB275c521040051D82396192181b413227A3\",\n      decimals: 18,\n      symbol: \"LINK.e\",\n    },\n    decimals: 8,\n    symbol: \"qiLINK\",\n    address: \"0x4e9f683A27a6BdAD3FC2764003759277e93696e6\",\n    icon: \"https://ipfs.near.social/ipfs/bafkreidrq7qk3d6epwaxobq4gk7yowljr5tnslxwrsbd7vnw3srkt7ok3u\",\n  },\n  \"0x835866d37AFB8CB8F8334dCCdaf66cf01832Ff5D\": {\n    underlyingToken: {\n      address: \"0xd586E7F844cEa2F87f50152665BCbc2C279D8d70\",\n      decimals: 18,\n      symbol: \"DAI.e\",\n    },\n    decimals: 8,\n    symbol: \"qiDAI\",\n    address: \"0x835866d37AFB8CB8F8334dCCdaf66cf01832Ff5D\",\n    icon: \"https://ipfs.near.social/ipfs/bafkreieuxntkdzi2mzkzdcbk6kahwxqpftxnipxcwc4oe4p4jm2rhj2xhu\",\n  },\n  \"0xBEb5d47A3f720Ec0a390d04b4d41ED7d9688bC7F\": {\n    underlyingToken: {\n      address: \"0xA7D7079b0FEaD91F3e65f86E8915Cb59c1a4C664\",\n      decimals: 6,\n      symbol: \"USDC.e\",\n    },\n    decimals: 8,\n    symbol: \"qiUSDC\",\n    address: \"0xBEb5d47A3f720Ec0a390d04b4d41ED7d9688bC7F\",\n    icon: \"https://ipfs.near.social/ipfs/bafkreie4jihoa76mgyzxhw2yrapihzu2qhkjz6m7u4opoxjebzg6zc2lla\",\n  },\n  \"0xB715808a78F6041E46d61Cb123C9B4A27056AE9C\": {\n    underlyingToken: {\n      address: \"0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E\",\n      decimals: 6,\n      symbol: \"USDC\",\n    },\n    decimals: 8,\n    symbol: \"qiUSDCn\",\n    address: \"0xB715808a78F6041E46d61Cb123C9B4A27056AE9C\",\n    icon: \"https://ipfs.near.social/ipfs/bafkreie4jihoa76mgyzxhw2yrapihzu2qhkjz6m7u4opoxjebzg6zc2lla\",\n  },\n  \"0xd8fcDa6ec4Bdc547C0827B8804e89aCd817d56EF\": {\n    underlyingToken: {\n      address: \"0x9702230A8Ea53601f5cD2dc00fDBc13d4dF4A8c7\",\n      decimals: 6,\n      symbol: \"USDt\",\n    },\n    decimals: 8,\n    symbol: \"qiUSDTn\",\n    address: \"0xd8fcDa6ec4Bdc547C0827B8804e89aCd817d56EF\",\n    icon: \"https://ipfs.near.social/ipfs/bafkreih45jy7ggj45ck34rf736kb67smsoa52wd7e46c2grh6etd3bhe5i\",\n  },\n  \"0xF362feA9659cf036792c9cb02f8ff8198E21B4cB\": {\n    underlyingToken: {\n      address: \"0x2b2C81e08f1Af8835a78Bb2A90AE924ACE0eA4bE\",\n      decimals: 18,\n      symbol: \"sAVAX\",\n    },\n    decimals: 8,\n    symbol: \"qisAVAX\",\n    address: \"0xF362feA9659cf036792c9cb02f8ff8198E21B4cB\",\n    icon: \"https://ipfs.near.social/ipfs/bafkreia2hefekktykcred4hdkfduh62aeygtdn3r3qzj3ox53val6laosy\",\n  },\n  \"0x89a415b3D20098E6A6C8f7a59001C67BD3129821\": {\n    underlyingToken: {\n      address: \"0x152b9d0FdC40C096757F570A51E494bd4b943E50\",\n      decimals: 8,\n      symbol: \"BTC.b\",\n    },\n    decimals: 8,\n    symbol: \"qiBTC.b\",\n    address: \"0x89a415b3D20098E6A6C8f7a59001C67BD3129821\",\n    icon: \"https://ipfs.near.social/ipfs/bafkreig2h2vpf7u7ukbgomgurcvvfyujl66qdrbsp6u2bcga3wdyxladii\",\n  },\n};\nconst MULTICALL_ABI = [\n  {\n    inputs: [\n      { internalType: \"bool\", name: \"requireSuccess\", type: \"bool\" },\n      {\n        components: [\n          { internalType: \"address\", name: \"target\", type: \"address\" },\n          { internalType: \"bytes\", name: \"callData\", type: \"bytes\" },\n        ],\n        internalType: \"struct Multicall2.Call[]\",\n        name: \"calls\",\n        type: \"tuple[]\",\n      },\n    ],\n    name: \"tryAggregate\",\n    outputs: [\n      {\n        components: [\n          { internalType: \"bool\", name: \"success\", type: \"bool\" },\n          { internalType: \"bytes\", name: \"returnData\", type: \"bytes\" },\n        ],\n        internalType: \"struct Multicall2.Result[]\",\n        name: \"returnData\",\n        type: \"tuple[]\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n];\nconst OTOKEN_ABI = [\n  {\n    inputs: [],\n    name: \"totalSupply\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"totalBorrows\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"exchangeRateStored\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"account\", type: \"address\" }],\n    name: \"getAccountSnapshot\",\n    outputs: [\n      { internalType: \"uint256\", name: \"\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"\", type: \"uint256\" },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"supplyRatePerTimestamp\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"borrowRatePerTimestamp\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\nconst UNITROLLER_ABI = [\n  {\n    constant: true,\n    inputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n    name: \"markets\",\n    outputs: [\n      { internalType: \"bool\", name: \"isListed\", type: \"bool\" },\n      {\n        internalType: \"uint256\",\n        name: \"collateralFactorMantissa\",\n        type: \"uint256\",\n      },\n      { internalType: \"bool\", name: \"isQied\", type: \"bool\" },\n    ],\n    payable: false,\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"account\", type: \"address\" },\n      {\n        internalType: \"contract IOToken\",\n        name: \"oToken\",\n        type: \"address\",\n      },\n    ],\n    name: \"checkMembership\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    constant: true,\n    inputs: [\n      { internalType: \"uint8\", name: \"\", type: \"uint8\" },\n      { internalType: \"address\", name: \"\", type: \"address\" },\n    ],\n    name: \"supplyRewardSpeeds\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    payable: false,\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    constant: true,\n    inputs: [\n      { internalType: \"uint8\", name: \"\", type: \"uint8\" },\n      { internalType: \"address\", name: \"\", type: \"address\" },\n    ],\n    name: \"borrowRewardSpeeds\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    payable: false,\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    constant: true,\n    inputs: [\n      { internalType: \"uint8\", name: \"\", type: \"uint8\" },\n      { internalType: \"address\", name: \"\", type: \"address\" },\n    ],\n    name: \"rewardAccrued\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    payable: false,\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\nconst ORACLE_ABI = [\n  {\n    inputs: [\n      {\n        internalType: \"contract IOToken\",\n        name: \"oToken\",\n        type: \"address\",\n      },\n    ],\n    name: \"getUnderlyingPrice\",\n    outputs: [{ internalType: \"uint256\", name: \"price\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\nconst ERC20_ABI = [\n  {\n    constant: true,\n    inputs: [\n      {\n        name: \"_owner\",\n        type: \"address\",\n      },\n    ],\n    name: \"balanceOf\",\n    outputs: [\n      {\n        name: \"balance\",\n        type: \"uint256\",\n      },\n    ],\n    payable: false,\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\n\nconst {\n  multicallAddress,\n  unitrollerAddress,\n  oracleAddress,\n  lensAddress,\n  account,\n  update,\n  dapp,\n  onLoad,\n} = props;\n\nif (!multicallAddress || !unitrollerAddress || !update || !account) return \"\";\nconst MulticallContract = new ethers.Contract(\n  multicallAddress,\n  MULTICALL_ABI,\n  Ethers.provider().getSigner()\n);\nconsole.log(`${dapp}-update`);\nconst multicallv2 = (abi, calls, options, onSuccess, onError) => {\n  const { requireSuccess, ...overrides } = options || {};\n  const itf = new ethers.utils.Interface(abi);\n  const calldata = calls.map((call) => ({\n    target: call.address.toLowerCase(),\n    callData: itf.encodeFunctionData(call.name, call.params),\n  }));\n  MulticallContract.callStatic\n    .tryAggregate(requireSuccess || true, calldata, overrides)\n    .then((res) => {\n      onSuccess(\n        res.map((call, i) => {\n          const [result, data] = call;\n          return result && data !== \"0x\"\n            ? itf.decodeFunctionResult(calls[i].name, data)\n            : null;\n        })\n      );\n    })\n    .catch((err) => {\n      onError?.(err);\n    });\n};\nlet _cTokensData = {};\nlet _loanToValue = null;\nlet _underlyPrice = {};\nlet _underlyingBalance = null;\nlet _userMerberShip = null;\nlet _rewardsApy = {};\nlet _accountRewards = {};\nlet count = 0;\nlet oTokensLength = Object.values(markets).length;\nconst AVAX = {\n  icon: \"https://ipfs.near.social/ipfs/bafkreiaxodsgromeeaihu44fazsxdopkrqvinqzhyfxvx5mrbcmduqdfpq\",\n  symbol: \"AVAX\",\n};\nconst QI = {\n  icon: \"https://ipfs.near.social/ipfs/bafkreiel5ejkjafpw2au4v34muga4im5afzztojy7jedbnd24dtumgtzsi\",\n  symbol: \"QI\",\n};\n\nconst formatedData = (key) => {\n  console.log(`${dapp}-${key}`, count);\n  if (count < 5) return;\n  count = 0;\n  oTokensLength = Object.values(markets).length;\n  let totalSupplyUsd = Big(0);\n  let totalBorrowUsd = Big(0);\n  let userTotalSupplyUsd = Big(0);\n  let userTotalBorrowUsd = Big(0);\n  let totalCollateralUsd = Big(0);\n  let totalAccountQiDistributionApy = Big(0);\n  let totalAccountAvaxDistributionApy = Big(0);\n  const markets = {};\n  Object.values(_cTokensData).forEach((market) => {\n    const underlyingPrice = _underlyPrice[market.address] || 1;\n    const marketSupplyUsd = Big(market.totalSupply || 0).mul(underlyingPrice);\n    const marketBorrowUsd = Big(market.totalBorrows || 0).mul(underlyingPrice);\n    totalSupplyUsd = totalSupplyUsd.plus(marketSupplyUsd);\n    totalBorrowUsd = totalBorrowUsd.plus(marketBorrowUsd);\n    userTotalSupplyUsd = userTotalSupplyUsd.plus(\n      Big(market.userSupply).mul(underlyingPrice)\n    );\n    userTotalBorrowUsd = userTotalBorrowUsd.plus(\n      Big(market.userBorrow).mul(underlyingPrice)\n    );\n    if (_userMerberShip[market.address]) {\n      totalCollateralUsd = totalCollateralUsd.plus(\n        Big(market.userSupply)\n          .mul(underlyingPrice)\n          .mul(_loanToValue[market.address])\n          .div(100)\n      );\n    }\n    const rewardsApy = _rewardsApy[market.address];\n    const avaxSupplyDistributionApy = rewardsApy.avax.supply\n      .div(marketSupplyUsd.eq(0) ? 1 : marketSupplyUsd)\n      .mul(100)\n      .toFixed(2);\n    const avaxBorrowDistributionApy = rewardsApy.avax.borrow\n      .div(marketBorrowUsd.eq(0) ? 1 : marketBorrowUsd)\n      .mul(100)\n      .toFixed(2);\n    const qiSupplyDistributionApy = rewardsApy.qi.supply\n      .div(marketSupplyUsd.eq(0) ? 1 : marketSupplyUsd)\n      .mul(100)\n      .toFixed(2);\n    const qiBorrowDistributionApy = rewardsApy.qi.borrow\n      .div(marketBorrowUsd.eq(0) ? 1 : marketBorrowUsd)\n      .mul(100)\n      .toFixed(2);\n    const distributionApy = [\n      {\n        ...AVAX,\n        supply: avaxSupplyDistributionApy + \"%\",\n        borrow: avaxBorrowDistributionApy + \"%\",\n      },\n      {\n        ...QI,\n        supply: qiSupplyDistributionApy + \"%\",\n        borrow: qiBorrowDistributionApy + \"%\",\n      },\n    ];\n    totalAccountQiDistributionApy = totalAccountQiDistributionApy\n      .plus(qiSupplyDistributionApy)\n      .plus(qiBorrowDistributionApy);\n    totalAccountAvaxDistributionApy = totalAccountAvaxDistributionApy\n      .plus(avaxSupplyDistributionApy)\n      .plus(avaxBorrowDistributionApy);\n    const supplyApy = Big(market.supplyRatePerTimestamp)\n      .mul(60 * 60 * 24)\n      .plus(1)\n      .pow(365)\n      .minus(1)\n      .mul(100);\n    const borrowApy = Big(market.borrowRatePerTimestamp)\n      .mul(60 * 60 * 24)\n      .plus(1)\n      .pow(365)\n      .minus(1)\n      .mul(100);\n\n    markets[market.address] = {\n      ...market,\n      loanToValue: _loanToValue[market.address],\n      liquidity: Big(market.totalSupply || 0)\n        .minus(market.totalBorrows || 0)\n        .toString(),\n      underlyingPrice: underlyingPrice,\n      userUnderlyingBalance: _underlyingBalance[market.address],\n      userMerberShip: _userMerberShip[market.address],\n      supplyApy: supplyApy.toFixed(2) + \"%\",\n      borrowApy: borrowApy.toFixed(2) + \"%\",\n      dapp,\n      distributionApy,\n    };\n  });\n  let rewards = [];\n\n  if (_accountRewards && Big(_accountRewards.qiReward || 0).gt(0)) {\n    const dailyRewards = totalAccountQiDistributionApy\n      .mul(userTotalSupplyUsd.add(userTotalBorrowUsd))\n      .div(365 * 100)\n      .div(_accountRewards.qiPrice);\n    rewards.push({\n      ...QI,\n      dailyRewards: dailyRewards.lt(0.000001)\n        ? \"0.000001\"\n        : dailyRewards.toString(),\n      price: _accountRewards.qiPrice,\n      unclaimed: _accountRewards.qiReward,\n    });\n  }\n  if (_accountRewards && Big(_accountRewards.avaxReward || 0).gt(0)) {\n    const dailyRewards = totalAccountAvaxDistributionApy\n      .mul(userTotalSupplyUsd.add(userTotalBorrowUsd))\n      .div(365 * 100)\n      .div(_accountRewards.avaxPrice);\n    rewards.push({\n      ...AVAX,\n      dailyRewards: dailyRewards.lt(0.000001)\n        ? \"0.000001\"\n        : dailyRewards.toString(),\n      price: _accountRewards.avaxPrice,\n      unclaimed: _accountRewards.avaxReward,\n    });\n  }\n\n  onLoad({\n    markets,\n    rewards,\n    totalSupplyUsd: totalSupplyUsd.toString(),\n    totalBorrowUsd: totalBorrowUsd.toString(),\n    userTotalSupplyUsd: userTotalSupplyUsd.toString(),\n    userTotalBorrowUsd: userTotalBorrowUsd.toString(),\n    totalCollateralUsd: totalCollateralUsd.toString(),\n  });\n};\nconst getUnitrollerData = () => {\n  const calls = [];\n  const oTokens = Object.values(markets);\n  oTokens.forEach((token) => {\n    calls.push({\n      address: unitrollerAddress,\n      name: \"markets\",\n      params: [token.address],\n    });\n    if (account) {\n      calls.push({\n        address: unitrollerAddress,\n        name: \"checkMembership\",\n        params: [account, token.address],\n      });\n    }\n  });\n  multicallv2(\n    UNITROLLER_ABI,\n    calls,\n    {},\n    (res) => {\n      _loanToValue = {};\n      _userMerberShip = {};\n      for (let i = 0, len = res.length; i < len; i++) {\n        const index = Math.floor(i / (account ? 2 : 1));\n        const mod = i % (account ? 2 : 1);\n        switch (mod) {\n          case 0:\n            _loanToValue[oTokens[index].address] = ethers.utils.formatUnits(\n              res[i][1]._hex,\n              16\n            );\n            break;\n          case 1:\n            _userMerberShip[oTokens[index].address] = res[i][0];\n            break;\n          default:\n        }\n      }\n      count++;\n      formatedData(\"getUnitrollerData\");\n    },\n    (err) => {\n      console.log(\"error-getUnitrollerData\", err);\n      setTimeout(() => {\n        getUnitrollerData();\n      }, 1000);\n    }\n  );\n};\nconst getUnderlyPrice = () => {\n  if (!oracleAddress) return;\n  const oTokens = Object.keys(markets);\n  const calls = oTokens.map((token) => ({\n    address: oracleAddress,\n    name: \"getUnderlyingPrice\",\n    params: [token],\n  }));\n  multicallv2(\n    ORACLE_ABI,\n    calls,\n    {},\n    (res) => {\n      _underlyPrice = {};\n      for (let i = 0, len = res.length; i < len; i++) {\n        _underlyPrice[oTokens[i]] = ethers.utils.formatUnits(\n          res[i][0]._hex,\n          36 - markets[oTokens[i]].underlyingToken.decimals\n        );\n      }\n      count++;\n      formatedData(\"getUnderlyPrice\");\n    },\n    (err) => {\n      console.log(\"error-getUnderlyPrice\", err);\n    }\n  );\n};\nconst getWalletBalance = () => {\n  let nativeOToken = \"\";\n  const underlyingTokens = Object.values(markets)\n    .filter((market) => {\n      if (market.underlyingToken.address === \"native\")\n        nativeOToken = market.address;\n      return (\n        market.underlyingToken.address &&\n        market.underlyingToken.address !== \"native\"\n      );\n    })\n    .map((market) => ({\n      ...market.underlyingToken,\n      oTokenAddress: market.address,\n    }));\n  const calls = underlyingTokens.map((token) => ({\n    address: token.address,\n    name: \"balanceOf\",\n    params: [account],\n  }));\n  multicallv2(\n    ERC20_ABI,\n    calls,\n    {},\n    (res) => {\n      _underlyingBalance = {};\n      for (let i = 0, len = res.length; i < len; i++) {\n        _underlyingBalance[underlyingTokens[i].oTokenAddress] =\n          ethers.utils.formatUnits(\n            res[i][0]._hex,\n            underlyingTokens[i].decimals\n          );\n      }\n      const provider = Ethers.provider();\n      provider.getBalance(account).then((rawBalance) => {\n        _underlyingBalance[nativeOToken] = ethers.utils.formatUnits(\n          rawBalance._hex,\n          18\n        );\n        count++;\n        formatedData(\"underlyingTokens\");\n      });\n    },\n    () => {\n      setTimeout(() => {\n        getWalletBalance();\n      }, 500);\n    }\n  );\n};\nconst getCTokenData = (oToken) => {\n  if (oTokensLength === 0) return;\n  const calls = [\n    {\n      address: oToken.address,\n      name: \"exchangeRateStored\",\n    },\n    {\n      address: oToken.address,\n      name: \"totalSupply\",\n    },\n    {\n      address: oToken.address,\n      name: \"totalBorrows\",\n    },\n    {\n      address: oToken.address,\n      name: \"supplyRatePerTimestamp\",\n    },\n    {\n      address: oToken.address,\n      name: \"borrowRatePerTimestamp\",\n    },\n    {\n      address: oToken.address,\n      name: \"getAccountSnapshot\",\n      params: [account],\n    },\n  ];\n  multicallv2(\n    OTOKEN_ABI,\n    calls,\n    {},\n    (res) => {\n      oTokensLength--;\n      const exchangeRateStored = ethers.utils.formatUnits(\n        res[0][0]._hex,\n        10 + oToken.underlyingToken.decimals\n      );\n      const userSupply = ethers.utils.formatUnits(\n        res[5][1]._hex,\n        oToken.decimals\n      );\n      const totalSupply = ethers.utils.formatUnits(\n        res[1][0]._hex,\n        oToken.decimals\n      );\n      _cTokensData[oToken.address] = {\n        ...oToken,\n        exchangeRateStored,\n        totalSupply: Big(totalSupply).mul(exchangeRateStored).toString(),\n        totalBorrows: ethers.utils.formatUnits(\n          res[2][0]._hex,\n          oToken.underlyingToken.decimals\n        ),\n        supplyRatePerTimestamp: ethers.utils.formatUnits(res[3][0]._hex, 18),\n        borrowRatePerTimestamp: ethers.utils.formatUnits(res[4][0]._hex, 18),\n        userSupply: Big(userSupply).mul(exchangeRateStored).toString(),\n        userBorrow: ethers.utils.formatUnits(\n          res[5][2]._hex,\n          oToken.underlyingToken.decimals\n        ),\n      };\n      if (oTokensLength === 0) {\n        count++;\n        formatedData(\"oTokens data\");\n      }\n    },\n    () => {\n      setTimeout(() => {\n        getCTokenData(oToken);\n      }, 500);\n    }\n  );\n};\n\nconst getCTokensData = () => {\n  Object.values(markets).forEach((market) => {\n    getCTokenData(market);\n  });\n};\n\nconst getUserRewards = () => {\n  const calls = [\n    {\n      address: lensAddress,\n      name: \"getClaimableReward\",\n      params: [account, 0],\n    },\n    {\n      address: lensAddress,\n      name: \"getClaimableReward\",\n      params: [account, 1],\n    },\n  ];\n  multicallv2(\n    [\n      {\n        inputs: [\n          {\n            internalType: \"address\",\n            name: \"user\",\n            type: \"address\",\n          },\n          {\n            internalType: \"uint8\",\n            name: \"rewardType\",\n            type: \"uint8\",\n          },\n        ],\n        name: \"getClaimableReward\",\n        outputs: [\n          {\n            internalType: \"uint256\",\n            name: \"\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"address[]\",\n            name: \"\",\n            type: \"address[]\",\n          },\n        ],\n        stateMutability: \"view\",\n        type: \"function\",\n      },\n    ],\n    calls,\n    {},\n    (res) => {\n      _accountRewards.qiReward = ethers.utils.formatUnits(res[0][0]._hex, 18);\n      _accountRewards.avaxReward = ethers.utils.formatUnits(res[1][0]._hex, 18);\n      count++;\n      formatedData(\"rewards\");\n    }\n  );\n};\n\nconst getCTokenReward = ({ avaxPrice, qiPrice, cTokens, index }) => {\n  const token = cTokens[index];\n  const calls = [\n    {\n      address: unitrollerAddress,\n      name: \"borrowRewardSpeeds\",\n      params: [0, token],\n    },\n    {\n      address: unitrollerAddress,\n      name: \"borrowRewardSpeeds\",\n      params: [1, token],\n    },\n    {\n      address: unitrollerAddress,\n      name: \"supplyRewardSpeeds\",\n      params: [0, token],\n    },\n    {\n      address: unitrollerAddress,\n      name: \"supplyRewardSpeeds\",\n      params: [1, token],\n    },\n    {\n      address: unitrollerAddress,\n      name: \"rewardAccrued\",\n      params: [0, account],\n    },\n    {\n      address: unitrollerAddress,\n      name: \"rewardAccrued\",\n      params: [1, account],\n    },\n  ];\n  multicallv2(\n    UNITROLLER_ABI,\n    calls,\n    {},\n    (res) => {\n      const qiBorrow = Big(ethers.utils.formatUnits(res[0][0]._hex, 18)).mul(\n        qiPrice\n      );\n      const avaxBorrow = Big(ethers.utils.formatUnits(res[1][0]._hex, 18)).mul(\n        avaxPrice\n      );\n      const qiSupply = Big(ethers.utils.formatUnits(res[2][0]._hex, 18)).mul(\n        qiPrice\n      );\n      const avaxSupply = Big(ethers.utils.formatUnits(res[3][0]._hex, 18)).mul(\n        avaxPrice\n      );\n      _rewardsApy[token] = {\n        avax: {\n          borrow: avaxBorrow.mul(60 * 60 * 24 * 365),\n          supply: avaxSupply.mul(60 * 60 * 24 * 365),\n        },\n        qi: {\n          borrow: qiBorrow.mul(60 * 60 * 24 * 365),\n          supply: qiSupply.mul(60 * 60 * 24 * 365),\n        },\n      };\n      if (index === cTokens.length - 1) {\n        getUserRewards();\n      } else {\n        getCTokenReward({\n          avaxPrice,\n          qiPrice,\n          cTokens,\n          index: index + 1,\n        });\n      }\n    },\n    (err) => {\n      console.log(\"error-rewards\", err);\n    }\n  );\n};\n\nconst getRewards = () => {\n  asyncFetch(\n    \"https://api.coingecko.com/api/v3/simple/price?ids=avalanche-2,benqi&vs_currencies=usd\"\n  ).then((response) => {\n    const data = response.body || [];\n    const avaxPrice = data[\"avalanche-2\"].usd;\n    const qiPrice = data[\"benqi\"].usd;\n    const cTokens = Object.keys(markets);\n    _accountRewards.avaxPrice = avaxPrice;\n    _accountRewards.qiPrice = qiPrice;\n    getCTokenReward({\n      avaxPrice,\n      qiPrice,\n      cTokens,\n      index: 0,\n    });\n  });\n};\n\nconst init = () => {\n  getUnitrollerData();\n  getUnderlyPrice();\n  getWalletBalance();\n  getCTokensData();\n  getRewards();\n};\n\nuseEffect(() => {\n  init();\n}, []);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/bluebiu.near/widget/Avalanche.Lending.BenqiData", "fact_widget_deployments_id": "d34330ea9821dc8e453b0f4e32962bfd", "inserted_timestamp": "2023-12-20T13:54:51.837Z", "modified_timestamp": "2023-12-20T14:23:09.625Z", "__row_index": 0}