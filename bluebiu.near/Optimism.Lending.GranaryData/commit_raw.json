{"tx_hash": "5v1BJncZ3ZhhJjcznnYAh3Vnfj2tUp1P34si1NFgPMA3", "action_id_social": "EAT2VSS1Yo55Ux3MvxTC44ZjbJACZaXLSMjVyXzoCDQJ-0-widget", "block_id": 108532014, "block_timestamp": "2023-12-22T06:22:27.497Z", "signer_id": "bluebiu.near", "widget_name": "Optimism.Lending.GranaryData", "source_code": "const native = {\n  address: \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n  decimals: 18,\n  symbol: \"BNB\",\n  name: \"BNB\",\n  description: \"native\",\n  icon: \"https://ipfs.near.social/ipfs/bafkreiaeq6ca67je5ocago6vk2efwxiqurxgemputx7p2nt6n2p3zo65xq\",\n};\n\nconst wethAddress = \"null\";\n\nconst Tokens = {\n  \"0x7F5c764cBc14f9669B88837ca1490cCa17c31607\": {\n    address: \"0x7F5c764cBc14f9669B88837ca1490cCa17c31607\",\n    decimals: 6,\n    symbol: \"USDC\",\n    name: \"USDC\",\n    icon: \"https://ipfs.near.social/ipfs/bafkreie4jihoa76mgyzxhw2yrapihzu2qhkjz6m7u4opoxjebzg6zc2lla\",\n  },\n\n  \"0x94b008aA00579c1307B0EF2c499aD98a8ce58e58\": {\n    address: \"0x94b008aA00579c1307B0EF2c499aD98a8ce58e58\",\n    decimals: 6,\n    symbol: \"USDT\",\n    name: \"USDT\",\n    icon: \"https://ipfs.near.social/ipfs/bafkreih45jy7ggj45ck34rf736kb67smsoa52wd7e46c2grh6etd3bhe5i\",\n  },\n  \"0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1\": {\n    address: \"0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1\",\n    decimals: 18,\n    symbol: \"DAI\",\n    name: \"DAI\",\n    icon: \"https://ipfs.near.social/ipfs/bafkreieuxntkdzi2mzkzdcbk6kahwxqpftxnipxcwc4oe4p4jm2rhj2xhu\",\n  },\n\n  \"0x4200000000000000000000000000000000000042\": {\n    address: \"0x4200000000000000000000000000000000000042\",\n    decimals: 18,\n    symbol: \"OP\",\n    name: \"OP\",\n    icon: \"https://ipfs.near.social/ipfs/bafkreiemkl7qtrrqnk5mexf7r4cr3mkznna6qvxrzhovlmt4djbkx366ae\",\n  },\n\n  \"0x8700dAec35aF8Ff88c16BdF0418774CB3D7599B4\": {\n    address: \"0x8700dAec35aF8Ff88c16BdF0418774CB3D7599B4\",\n    decimals: 18,\n    symbol: \"SNX\",\n    name: \"SNX\",\n    icon: \"https://ipfs.near.social/ipfs/bafkreiblu4utwynt7ajvretbjzqtm2v7e7p2hkyyp7jamb742zkwpdzmu4\",\n  },\n\n  \"0x8c6f28f2F1A3C87F0f938b96d27520d9751ec8d9\": {\n    address: \"0x8c6f28f2F1A3C87F0f938b96d27520d9751ec8d9\",\n    decimals: 18,\n    symbol: \"sUSD\",\n    name: \"sUSD\",\n    icon: \"https://ipfs.near.social/ipfs/bafkreiaum6qcvs7gqjwfmbfoh5dde244fqd6bji4id5wlyn6q5e3vvsorm\",\n  },\n};\n\nconst aaveProtocolDataProviderAbi = [\n  {\n    inputs: [\n      {\n        internalType: \"contract ILendingPoolAddressesProvider\",\n        name: \"addressesProvider\",\n        type: \"address\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"constructor\",\n  },\n  {\n    inputs: [],\n    name: \"ADDRESSES_PROVIDER\",\n    outputs: [\n      {\n        internalType: \"contract ILendingPoolAddressesProvider\",\n        name: \"\",\n        type: \"address\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"getAllATokens\",\n    outputs: [\n      {\n        components: [\n          { internalType: \"string\", name: \"symbol\", type: \"string\" },\n          { internalType: \"address\", name: \"tokenAddress\", type: \"address\" },\n        ],\n        internalType: \"struct AaveProtocolDataProvider.TokenData[]\",\n        name: \"\",\n        type: \"tuple[]\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"getAllReservesTokens\",\n    outputs: [\n      {\n        components: [\n          { internalType: \"string\", name: \"symbol\", type: \"string\" },\n          { internalType: \"address\", name: \"tokenAddress\", type: \"address\" },\n        ],\n        internalType: \"struct AaveProtocolDataProvider.TokenData[]\",\n        name: \"\",\n        type: \"tuple[]\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"asset\", type: \"address\" }],\n    name: \"getReserveConfigurationData\",\n    outputs: [\n      { internalType: \"uint256\", name: \"decimals\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"ltv\", type: \"uint256\" },\n      {\n        internalType: \"uint256\",\n        name: \"liquidationThreshold\",\n        type: \"uint256\",\n      },\n      { internalType: \"uint256\", name: \"liquidationBonus\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"reserveFactor\", type: \"uint256\" },\n      { internalType: \"bool\", name: \"usageAsCollateralEnabled\", type: \"bool\" },\n      { internalType: \"bool\", name: \"borrowingEnabled\", type: \"bool\" },\n      { internalType: \"bool\", name: \"stableBorrowRateEnabled\", type: \"bool\" },\n      { internalType: \"bool\", name: \"isActive\", type: \"bool\" },\n      { internalType: \"bool\", name: \"isFrozen\", type: \"bool\" },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"asset\", type: \"address\" }],\n    name: \"getReserveData\",\n    outputs: [\n      { internalType: \"uint256\", name: \"availableLiquidity\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"totalStableDebt\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"totalVariableDebt\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"liquidityRate\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"variableBorrowRate\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"stableBorrowRate\", type: \"uint256\" },\n      {\n        internalType: \"uint256\",\n        name: \"averageStableBorrowRate\",\n        type: \"uint256\",\n      },\n      { internalType: \"uint256\", name: \"liquidityIndex\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"variableBorrowIndex\", type: \"uint256\" },\n      { internalType: \"uint40\", name: \"lastUpdateTimestamp\", type: \"uint40\" },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"asset\", type: \"address\" }],\n    name: \"getReserveTokensAddresses\",\n    outputs: [\n      { internalType: \"address\", name: \"aTokenAddress\", type: \"address\" },\n      {\n        internalType: \"address\",\n        name: \"stableDebtTokenAddress\",\n        type: \"address\",\n      },\n      {\n        internalType: \"address\",\n        name: \"variableDebtTokenAddress\",\n        type: \"address\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"asset\", type: \"address\" },\n      { internalType: \"address\", name: \"user\", type: \"address\" },\n    ],\n    name: \"getUserReserveData\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"currentATokenBalance\",\n        type: \"uint256\",\n      },\n      { internalType: \"uint256\", name: \"currentStableDebt\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"currentVariableDebt\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"principalStableDebt\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"scaledVariableDebt\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"stableBorrowRate\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"liquidityRate\", type: \"uint256\" },\n      { internalType: \"uint40\", name: \"stableRateLastUpdated\", type: \"uint40\" },\n      { internalType: \"bool\", name: \"usageAsCollateralEnabled\", type: \"bool\" },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\n\nconst ORACLE_ABI = [\n  {\n    inputs: [{ internalType: \"address\", name: \"asset\", type: \"address\" }],\n    name: \"getAssetPrice\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address[]\", name: \"assets\", type: \"address[]\" }],\n    name: \"getAssetsPrices\",\n    outputs: [{ internalType: \"uint256[]\", name: \"\", type: \"uint256[]\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\n\nconst REWARD_ABI = [\n  {\n    inputs: [\n      { internalType: \"address[]\", name: \"assets\", type: \"address[]\" },\n      { internalType: \"address\", name: \"to\", type: \"address\" },\n    ],\n    name: \"claimAllRewards\",\n    outputs: [\n      {\n        internalType: \"address[]\",\n        name: \"rewardTokens\",\n        type: \"address[]\",\n      },\n      {\n        internalType: \"uint256[]\",\n        name: \"claimedAmounts\",\n        type: \"uint256[]\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n];\n\nconst {\n  aaveProtocolDataProviderAddress,\n  oracleAddress,\n  account,\n  update,\n  onLoad,\n  PoolAddressProvider,\n  lendingPoolAddress,\n  wethGateway,\n  initConfig,\n  loaded,\n  multicallAddress,\n  rewardAddress,\n} = props;\n\nif (!aaveProtocolDataProviderAddress || !oracleAddress || !update || !account)\n  return \"\";\n\nconst signer = Ethers.provider().getSigner();\n\nconst MULTICALL_ABI = [\n  {\n    inputs: [\n      { internalType: \"bool\", name: \"requireSuccess\", type: \"bool\" },\n      {\n        components: [\n          { internalType: \"address\", name: \"target\", type: \"address\" },\n          { internalType: \"bytes\", name: \"callData\", type: \"bytes\" },\n        ],\n        internalType: \"struct Multicall2.Call[]\",\n        name: \"calls\",\n        type: \"tuple[]\",\n      },\n    ],\n    name: \"tryAggregate\",\n    outputs: [\n      {\n        components: [\n          { internalType: \"bool\", name: \"success\", type: \"bool\" },\n          { internalType: \"bytes\", name: \"returnData\", type: \"bytes\" },\n        ],\n        internalType: \"struct Multicall2.Result[]\",\n        name: \"returnData\",\n        type: \"tuple[]\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n];\n\nconst multicallv2 = (abi, calls, options, onError) => {\n  const { requireSuccess, ...overrides } = options || {};\n  const itf = new ethers.utils.Interface(abi);\n  const calldata = calls.map((call) => ({\n    target: call.address.toLowerCase(),\n    callData: itf.encodeFunctionData(call.name, call.params),\n  }));\n\n  const MulticallContract = new ethers.Contract(\n    multicallAddress,\n    MULTICALL_ABI,\n    signer\n  );\n  return MulticallContract.callStatic\n    .tryAggregate(requireSuccess || true, calldata, overrides)\n    .then((res) => {\n      return res.map((call, i) => {\n        const [result, data] = call;\n        return result && data !== \"0x\"\n          ? itf.decodeFunctionResult(calls[i].name, data)\n          : null;\n      });\n    })\n    .catch((err) => {\n      onError?.(err);\n    });\n};\n\nconst dataProviderContract = new ethers.Contract(\n  aaveProtocolDataProviderAddress,\n  aaveProtocolDataProviderAbi,\n  signer\n);\n\nconst markets = Object.values(Tokens).map((market) => [\n  market.symbol,\n  market.address,\n]);\n\nconst RewardToken = {\n  \"0xFdb794692724153d1488CcdBE0C56c252596735F\": {\n    symbol: \"LDO\",\n    address: \"0xFdb794692724153d1488CcdBE0C56c252596735F\",\n    decimals: 18,\n    name: \"Lido DAO Token\",\n    icon: \"https://ipfs.near.social/ipfs/bafkreifnahaufauepdznq7qvkkkt5pmchzl4qx3a3orhbusw2lnjvfvecu\",\n    coingeckoId: \"lido-dao\",\n  },\n  \"0x39FdE572a18448F8139b7788099F0a0740f51205\": {\n    symbol: \"OATH\",\n    address: \"0x39FdE572a18448F8139b7788099F0a0740f51205\",\n    decimals: 18,\n    name: \"Oath Token\",\n    icon: \"https://ipfs.near.social/ipfs/bafkreibhxoenia7th5yoecfvb5pcypq44yx2qwtuiigjzobotmpdabfmna\",\n    coingeckoId: \"oath\",\n  },\n  \"0xfD389Dc9533717239856190F42475d3f263a270d\": {\n    symbol: \"GRAIN\",\n    address: \"0xfD389Dc9533717239856190F42475d3f263a270d\",\n    decimals: 18,\n    name: \"Granary Token\",\n    icon: \"https://ipfs.near.social/ipfs/bafkreihovftnvueysjuj7wansa74k3bgtfs4hkip4bgdvguh6nhehkvg5e\",\n    coingeckoId: \"granary\",\n  },\n  \"0x4200000000000000000000000000000000000042\": {\n    symbol: \"OP\",\n    address: \"0x4200000000000000000000000000000000000042\",\n    decimals: 18,\n    name: \"Optimism\",\n    icon: \"https://ipfs.near.social/ipfs/bafkreiemkl7qtrrqnk5mexf7r4cr3mkznna6qvxrzhovlmt4djbkx366ae\",\n    coingeckoId: \"optimism\",\n  },\n};\n\nlet _tokensPrice = {};\nlet _marketsData = {};\nlet _userRewards = {};\n\nconst getTokensPrices = () => {\n  const oracleContract = new ethers.Contract(oracleAddress, ORACLE_ABI, signer);\n  oracleContract.getAssetsPrices(Object.keys(Tokens)).then((res) => {\n    const parsedRes = res.map((price, i) => {\n      return Big(price.toString()).div(100000000).toFixed();\n    });\n\n    Object.keys(Tokens).forEach((address, index) => {\n      _tokensPrice[address] = parsedRes[index];\n    });\n    getMarketsData();\n  });\n};\n\nconst getMarketsData = () => {\n  const userReserveDataCalls = markets.map((market) => {\n    return {\n      address: aaveProtocolDataProviderAddress,\n      name: \"getUserReserveData\",\n      params: [market[1], account],\n    };\n  });\n\n  const tokenReserveDataCals = markets.map((market) => {\n    return {\n      address: aaveProtocolDataProviderAddress,\n      name: \"getReserveData\",\n      params: [market[1]],\n    };\n  });\n\n  const reserveConfigurationDataCalls = markets\n    .map((market) => {\n      return [\n        {\n          address: aaveProtocolDataProviderAddress,\n          name: \"getReserveConfigurationData\",\n          params: [market[1]],\n        },\n\n        {\n          address: aaveProtocolDataProviderAddress,\n          name: \"getReserveTokensAddresses\",\n          params: [market[1]],\n        },\n      ];\n    })\n    .flat();\n\n  // get user reserve data\n  multicallv2(aaveProtocolDataProviderAbi, userReserveDataCalls, {})\n    .then((res) => {\n      const userReserveParsedDataList = res.map((data, i) => {\n        return formatUserReserveData(data, markets[i][1]);\n      });\n      return userReserveParsedDataList;\n    })\n    .then((userReserveParsedDataList) => {\n      //  get configuration data\n      multicallv2(\n        aaveProtocolDataProviderAbi,\n        reserveConfigurationDataCalls,\n        {}\n      )\n        .then((res) => {\n          const loanToValues = [];\n\n          const aTokenAddressList = [];\n\n          const variableDebtTokenAddressList = [];\n\n          res.forEach((data, i) => {\n            if (i % 2 == 0) {\n              const loanToValue = Big(data[1].toString()).div(100).toNumber();\n              loanToValues.push(loanToValue);\n            }\n          });\n\n          res.forEach((data, i) => {\n            if (i % 2 == 1) {\n              const aTokenAddress = data[0];\n              const variableDebtTokenAddress = data[2];\n              aTokenAddressList.push(aTokenAddress);\n              variableDebtTokenAddressList.push(variableDebtTokenAddress);\n            }\n          });\n\n          return loanToValues.map((loanToValue, i) => {\n            return {\n              loanToValue,\n              aTokenAddress: aTokenAddressList[i],\n              variableDebtTokenAddress: variableDebtTokenAddressList[i],\n            };\n          });\n        })\n        .then((configurationList) => {\n          multicallv2(\n            aaveProtocolDataProviderAbi,\n            tokenReserveDataCals,\n            {}\n          ).then((tokenReserveDataList) => {\n            const formattedTokenReserveDataList = tokenReserveDataList.map(\n              (data, index) => {\n                return formateTokenReserveData(\n                  data,\n\n                  markets[index][1],\n                  markets[index][0],\n                  _tokensPrice[markets[index][1]],\n                  configurationList[index].aTokenAddress,\n                  configurationList[index].variableDebtTokenAddress,\n                  configurationList[index].loanToValue,\n                  userReserveParsedDataList[index]\n                );\n              }\n            );\n            getUserRewards();\n          });\n        });\n    });\n};\n\nconst formateTokenReserveData = (\n  data,\n  tokenAddress,\n  symbol,\n  price,\n  aTokenAddress,\n  variableDebtTokenAddress,\n  loanToValue,\n  userReserveParsed\n) => {\n  const [\n    availableLiquidity,\n    totalStableDebt,\n    totalVariableDebt,\n    liquidityRate,\n    variableBorrowRate,\n    stableBorrowRate,\n    averageStableBorrowRate,\n    liquidityIndex,\n    variableBorrowIndex,\n    lastUpdateTimestamp,\n  ] = data;\n\n  const decimalBig = Big(10).pow(Tokens[tokenAddress].decimals);\n\n  const totalDebt = Big(totalStableDebt.toString())\n    .plus(totalVariableDebt.toString())\n    .div(decimalBig)\n    .toFixed();\n\n  const totalDebtRaw = Big(totalStableDebt.toString())\n    .plus(totalVariableDebt.toString())\n    .toFixed();\n\n  const totalDeposit = Big(availableLiquidity.toString())\n    .plus(totalDebtRaw)\n    .div(decimalBig)\n    .toFixed();\n\n  const marketSize = Big(availableLiquidity.toString())\n    .div(decimalBig)\n    .toFixed();\n\n  const Ray = Big(10).pow(27);\n\n  const SECONDS_PER_YEAR = 31536000;\n\n  const depositAPR = Big(liquidityRate).div(Ray);\n\n  const variableBorrowAPR = Big(variableBorrowRate).div(Ray);\n\n  const depositAPY0 = Big(1)\n    .plus(depositAPR.div(Big(SECONDS_PER_YEAR)))\n    .toNumber();\n\n  const depositAPY = Big(\n    100 * (Math.pow(depositAPY0, SECONDS_PER_YEAR) - 1)\n  ).toFixed(2);\n\n  const variableBorrowAPY0 = Big(1)\n    .plus(Big(variableBorrowAPR).div(Big(SECONDS_PER_YEAR)))\n    .toNumber();\n\n  const variableBorrowAPYRaw = Big(\n    100 * (Math.pow(variableBorrowAPY0, SECONDS_PER_YEAR) - 1)\n  );\n\n  const variableBorrowAPY = Big(\n    100 * (Math.pow(variableBorrowAPY0, SECONDS_PER_YEAR) - 1)\n  ).toFixed(2);\n\n  const netApyBig = Big(depositAPY0).minus(variableBorrowAPYRaw);\n  _marketsData[tokenAddress] = {\n    availableLiquidity,\n    totalStableDebt,\n    totalVariableDebt,\n    totalBorrows: !price ? \"-\" : Big(totalDebt).toFixed(4),\n    totalSupply: !price ? \"-\" : Big(totalDeposit).toFixed(4),\n    liquidity: !price ? \"-\" : Big(marketSize).toFixed(4),\n    liquidityRate,\n    variableBorrowRate,\n    stableBorrowRate,\n    averageStableBorrowRate,\n    liquidityIndex,\n    variableBorrowIndex,\n    lastUpdateTimestamp,\n    tokenAddress,\n    depositAPY,\n    loanToValue,\n    supplyApy: depositAPY + \"%\",\n    variableBorrowAPY,\n    borrowApy: variableBorrowAPY + \"%\",\n    underlyingPrice: price,\n    underlyingToken:\n      tokenAddress.toLowerCase() === wethAddress.toLowerCase()\n        ? native\n        : Tokens[tokenAddress],\n    dapp: initConfig.name,\n    dappName: initConfig.name,\n    address: tokenAddress,\n    ...(tokenAddress.toLowerCase() === wethAddress.toLowerCase()\n      ? native\n      : Tokens[tokenAddress]),\n    netApy: netApyBig.toFixed(),\n    aTokenAddress,\n    variableDebtTokenAddress,\n    wethAddress,\n    userReserveParsed,\n  };\n};\n\nconst formatUserReserveData = (data, address) => {\n  const underlyingAsset = Tokens[address];\n\n  const scaledATokenBalance = Big(data[0].toString())\n    .div(Big(10).pow(underlyingAsset.decimals))\n    .toFixed();\n\n  const scaledATokenBalanceUsd = Big(data[0].toString())\n    .div(Big(10).pow(underlyingAsset.decimals))\n    .times(_tokensPrice[address])\n    .toFixed();\n\n  const aTokenBalance = Big(data[0].toString())\n    .div(Big(10).pow(underlyingAsset.decimals))\n    .toFixed();\n\n  const usageAsCollateralEnabledOnUser = data[8];\n\n  const scaledVariableDebt = Big(data[2].toString())\n    .div(Big(10).pow(underlyingAsset.decimals))\n\n    .toFixed();\n\n  const scaledVariableDebtUsd = Big(data[2].toString())\n    .div(Big(10).pow(underlyingAsset.decimals))\n    .times(_tokensPrice[address])\n    .toFixed();\n\n  const userReserveParsed = {\n    address,\n    underlyingAsset,\n    scaledATokenBalanceUsd,\n    scaledATokenBalance,\n    usageAsCollateralEnabledOnUser,\n    scaledVariableDebt,\n    scaledVariableDebtUsd,\n    aTokenBalance,\n    userMerberShip: usageAsCollateralEnabledOnUser,\n  };\n\n  return userReserveParsed;\n};\n\nconst getUserRewards = () => {\n  const aTokens = Object.values(_marketsData).map(\n    (market) => market.aTokenAddress\n  );\n  const RewardContract = new ethers.Contract(rewardAddress, REWARD_ABI, signer);\n  RewardContract.callStatic.claimAllRewards(aTokens, account).then((res) => {\n    const tokens = res[0];\n    const amounts = res[1];\n    const coins = Object.values(RewardToken).map((token) => token.coingeckoId);\n    const pricesUrl = `https://api.coingecko.com/api/v3/simple/price?ids=${coins.join(\n      \",\"\n    )}&vs_currencies=usd`;\n    asyncFetch(pricesUrl).then((res) => {\n      if (!res.ok) return;\n      const prices = {};\n      coins.forEach((coin) => (prices[coin] = res.body[coin].usd));\n      tokens.forEach((token, i) => {\n        _userRewards[token] = {\n          amount: ethers.utils.formatUnits(\n            amounts[i],\n            RewardToken[token].decimals\n          ),\n          price: prices[RewardToken[token].coingeckoId],\n        };\n      });\n      formateData();\n    });\n  });\n};\n\nconst formateData = () => {\n  const parsedData = [];\n\n  Object.keys(_marketsData).forEach((address) => {\n    const market = _marketsData[address];\n\n    parsedData.push(market.userReserveParsed);\n  });\n\n  let userTotalSupplyUsd = Big(0);\n  let userTotalBorrowUsd = Big(0);\n\n  parsedData.forEach((data) => {\n    userTotalSupplyUsd = userTotalSupplyUsd.plus(data.scaledATokenBalanceUsd);\n    userTotalBorrowUsd = userTotalBorrowUsd.plus(data.scaledVariableDebtUsd);\n  });\n\n  const userData = {\n    userTotalSupplyUsd: userTotalSupplyUsd.toString(),\n    userTotalBorrowUsd: userTotalBorrowUsd.toString(),\n    parsedData,\n  };\n\n  userData.parsedData.forEach((d) => {\n    const { address } = d;\n    _marketsData[address].userMerberShip = d.userMerberShip;\n  });\n\n  let netApy = Big(0);\n\n  userData.parsedData.forEach((d) => {\n    const { address } = d;\n    _marketsData[address] = {\n      ..._marketsData[address],\n      ...d,\n      userSupply: d.scaledATokenBalance,\n      userBorrow: d.scaledVariableDebt,\n    };\n  });\n\n  let totalCollateralUsd = Big(0);\n  const aTokenAddress = [];\n  Object.keys(_marketsData).forEach((address, i) => {\n    const market = _marketsData[address];\n\n    const { netApy: netApyRaw } = market;\n    netApy = netApy.plus(netApyRaw);\n\n    market.userUnderlyingBalance = market.aTokenBalance;\n\n    market.lendingPoolAddress = lendingPoolAddress;\n\n    market.wethGateway = wethGateway;\n\n    aTokenAddress.push(market.aTokenAddress);\n\n    market.address = market.aTokenAddress;\n\n    if (userData.parsedData[i]) {\n      const data = userData.parsedData[i];\n      if (data.usageAsCollateralEnabledOnUser) {\n        totalCollateralUsd = totalCollateralUsd\n          .plus(data.scaledATokenBalanceUsd)\n          .times(market.loanToValue / 100);\n      }\n    }\n  });\n\n  userData.totalCollateralUsd = totalCollateralUsd.toFixed();\n\n  userData.netApy = netApy.toFixed(2);\n\n  const parsedMarketData = {};\n\n  Object.entries(_marketsData).map(([address, market]) => {\n    parsedMarketData[market.aTokenAddress] = market;\n  });\n\n  const rewards = [];\n  Object.values(RewardToken).forEach((rewardToken) => {\n    const reward = _userRewards[rewardToken.address];\n    if (Big(reward.amount).gt(0)) {\n      rewards.push({\n        ...rewardToken,\n        price: reward.price,\n        unclaimed: reward.amount,\n        allPools: aTokenAddress,\n      });\n    }\n  });\n  console.log(\"parsedMarketData\", parsedMarketData);\n  onLoad({\n    ...{ ...userData, ...props },\n    markets: parsedMarketData,\n    name: initConfig.name,\n    rewards,\n  });\n};\n\nuseEffect(() => {\n  getTokensPrices();\n}, []);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/bluebiu.near/widget/Optimism.Lending.GranaryData", "fact_widget_deployments_id": "7e772f0529fe09fbcda3cc17a09cafed", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 10}