{"tx_hash": "5NoVPomGtVi6SwJmxjGDbvsQ1BESp8pM4CtaMUeeitME", "action_id_social": "Cx2R6SjJJyFpby4Qai7uxz3MaAahueeCBVgFHA8Bgyah-0-widget", "block_id": 118352027, "block_timestamp": "2024-05-06T07:47:35.586Z", "signer_id": "bluebiu.near", "widget_name": "Liquidity.Bridge.JUICE.Borrowers", "source_code": "const StyledContainer = styled.div`\n  width: 1000px;\n  display: flex;\n  align-items: flex-start;\n  gap: 20px;\n  /* flex-direction: column; */\n`\nconst StyledContainerL = styled.div`\n  /* width: 490px;\n  border-radius: 16px;\n  border: 1px solid #373A53;\n  background: #262836; */\n`\nconst StyledCategory = styled.div`\n  width: 490px;\n  border-radius: 16px;\n  border: 1px solid #373A53;\n  background: #262836;\n`\nconst StyledCategoryTop = styled.div`\n  display: flex;\n  align-items: center;\n  border-bottom: 1px solid #373A53;\n`\nconst StyledCategoryTopButton = styled.div`\n  position: relative;\n  flex: 1;\n  padding: 22px 0;\n  text-align: center;\n  color: #979ABE;\n  font-family: Montserrat;\n  font-size: 16px;\n  font-style: normal;\n  font-weight: 600;\n  line-height: normal;\n  cursor: pointer;\n  &.active {\n    color: #FFF;\n    &:after {\n      content: \"\";\n      position: absolute;\n      left: 0;\n      right: 0;\n      bottom: 0;\n      height: 4px;\n      background: #B968F3;\n    }\n  }\n`\nconst StyledCategoryBottom = styled.div`\n  \n`\nconst StyledDepositContainer = styled.div`\n  padding: 19px 20px 16px;\n`\nconst StyledDepositInput = styled.div`\n  padding: 12px 16px;\n  border-radius: 8px;\n  border: 1px solid #373A53;\n  background: #1B1E27;\n  height: 71px;\n`\nconst StyledDepositInputTop = styled.div`\n  margin-bottom: 6px;\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n`\nconst StyledDepositInputBottom = styled.div`\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  gap: 30px;\n`\nconst StyledDepositInputTopType = styled.div`\n  color: #979ABE;\n  font-family: Gantari;\n  font-size: 14px;\n  font-style: normal;\n  font-weight: 400;\n  line-height: normal;\n`\nconst StyledDepositInputTopBalance = styled.div`\n  color: #979ABE;\n  font-family: Gantari;\n  font-size: 14px;\n  font-style: normal;\n  font-weight: 400;\n  line-height: normal;\n  span {\n    cursor: pointer;\n    color: #FFF;\n    text-decoration-line: underline;\n  }\n`\nconst StyledDepositInputBottomInput = styled.input`\n  padding: 0;\n  border: none;\n  outline: none;\n  background: transparent;\n  \n  flex: 1;\n  color: #FFF;\n  font-family: Gantari;\n  font-size: 20px;\n  font-style: normal;\n  font-weight: 500;\n  line-height: normal;\n\n  &[type=\"number\"]::-webkit-outer-spin-button,\n  &[type=\"number\"]::-webkit-inner-spin-button {\n    -webkit-appearance: none;\n    margin: 0;\n  }\n  &[type=\"number\"] {\n    -moz-appearance: textfield;\n  }\n`\nconst StyledDepositInputBottomSymbol = styled.div`\n  display: flex;\n  align-items: center;\n  gap: 5px;\n`\nconst StyledDepositInputBottomSymbolImageContainer = styled.div`\n  width: 20px;\n  height: 20px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  border-radius: 50%;\n  overflow: hidden;\n`\nconst StyledDepositInputBottomSymbolImage = styled.img`\n  width: 100%;\n  height: 100%;\n`\nconst StyledDepositInputBottomSymbolTxt = styled.div`\n  color: #FFF;\n  font-family: Gantari;\n  font-size: 16px;\n  font-style: normal;\n  font-weight: 400;\n  line-height: normal;\n`\nconst StyledDepositInputBottomInputTxt = styled.div`\n  color: #5E617E;\n  font-family: Gantari;\n  font-size: 20px;\n  font-style: normal;\n  font-weight: 500;\n  line-height: normal;\n`\nconst StyledDepositMessageList = styled.div`\n  padding: 20px 0;\n  display: flex;\n  flex-direction: column;\n  gap: 14px;\n\n`\nconst StyledDepositMessage = styled.div`\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n`\nconst StyledDepositMessageLabel = styled.div`\n  color: #979ABE;\n  font-family: Montserrat;\n  font-size: 14px;\n  font-style: normal;\n  font-weight: 400;\n  line-height: normal;\n`\nconst StyledDepositMessageValue = styled.div`\n  color: #FFF;\n  font-family: Montserrat;\n  font-size: 14px;\n  font-style: normal;\n  font-weight: 400;\n  line-height: normal;\n`\nconst StyledEmptyContainer = styled.div`\n  width: 490px;\n  border-radius: 16px;\n  border: 1px solid #373A53;\n  background: #262836;\n  padding: 55px 16px 15px;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n`\nconst StyledEmptyImage = styled.img`\n  width: 150px;\n`\nconst StyledEmptyTxt = styled.div`\n  margin: 30px 0 24px;\n  color: #FFF;\n  text-align: center;\n  font-family: Montserrat;\n  font-size: 14px;\n  font-style: normal;\n  font-weight: 400;\n  line-height: 150%; /* 21px */\n`\n\nconst StyledOperationButton = styled.button`\n  width: 100%;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  height: 50px;\n  flex-shrink: 0;\n  border-radius: 8px;\n  cursor: pointer;\n  background: var(--button-color);\n\n  color: var(--button-text-color);\n  font-family: Gantari;\n  font-size: 18px;\n  font-style: normal;\n  font-weight: 600;\n  line-height: normal;\n  &[disabled] {\n    cursor: not-allowed;\n    opacity: 0.3;\n  }\n\n`\nconst StyledContainerR = styled.div`\n  width: 490px;\n  border-radius: 16px;\n  border: 1px solid #373A53;\n  background: #262836;\n`\nconst StyledOverviewList = styled.div`\n  display: flex;\n  flex-direction: column;\n  gap: 16px;\n  padding: 20px;\n`\nconst StyledOverview = styled.div`\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n`\nconst StyledOverviewTitle = styled.div`\n  padding: 21px 20px 23px;\n  color: #FFF;\n  font-family: Montserrat;\n  font-size: 16px;\n  font-style: normal;\n  font-weight: 600;\n  line-height: normal;\n  border-bottom: 1px solid #373A53;\n`\nconst StyledOverviewLabel = styled.div`\n  color: #979ABE;\n  font-family: Montserrat;\n  font-size: 14px;\n  font-style: normal;\n  font-weight: 400;\n  line-height: normal;\n`\nconst StyledOverviewValue = styled.div`\n  color: #FFF;\n  font-family: Montserrat;\n  font-size: 14px;\n  font-style: normal;\n  font-weight: 400;\n  line-height: normal;\n`\nconst StyledOverviewButtonContainer = styled.div`\n  padding: 0 16px 16px;\n`\nconst StyledWrapContainer = styled.div`\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  margin-top: 16px;\n  padding: 10px 16px;\n  height: 40px;\n  border-radius: 8px;\n  border: 1px solid #373A53;\n  cursor: pointer;\n`\nconst StyledWrap = styled.div`\n  display: flex;\n  align-items: center;\n  gap: 10px;\n`\nconst StyledWrapChainList = styled.div`\n  display: flex;\n  align-items: center;\n`\nconst StyledChainImage = styled.img`\n  width: 20px;\n`\nconst StyledWrapTxt = styled.div`\n  color: #FFF;\n  font-family: Montserrat;\n  font-size: 14px;\n  font-style: normal;\n  font-weight: 600;\n  line-height: 150%; /* 21px */\n`\nconst StyledIconRight = styled.div`\n  display: flex;\n  align-items: center;\n  justify-content: center;\n`\nState.init({\n  categoryList: [\"Deposit\", \"Withdraw\", \"Borrow\", \"Repay\"],\n  categoryIndex: 0,\n  accountOverview: null,\n  // isDepositOrWithdrawOrBorrowOrRepay: \"Deposit\"\n  inDepositAmount: \"\",\n  inWithdrawAmount: \"\",\n  inBorrowAmount: \"\",\n  inRepayAmount: \"\",\n  depositLoading: false,\n  withdrawLoading: false,\n  borrowLoading: false,\n  repayLoading: false,\n  depositApproved: true,\n  depositApproving: false,\n  repayApproved: true,\n  repayApproving: false,\n  // depositApp\n  withRevert: false,\n  balances: {\n    deposit: 0,\n    withdraw: 0,\n    borrow: 0,\n    repay: 0,\n    firstRepay: 0,\n    secondRepay: 0,\n  },\n  pnl: 0,\n  borrowLeverage: '',\n})\nconst {\n  categoryList,\n  categoryIndex,\n} = state\n\nconst {\n  toast,\n  sender,\n  addAction,\n  multicall,\n  multicallAddress,\n  // checkedVault,\n  isCreatedAccount,\n  createSubAccountLoading,\n  ICON_MAP,\n  PROXY_ADDRESS,\n  SYMBOL_ADDRESS,\n  LENDING_POOL_ADDRESS,\n  smartContractAddress,\n  onCreateSubAccount,\n  onOpenWrap\n} = props\n\nconst isDepositInSufficient = Number(state?.inDepositAmount ?? 0) > Number(state?.balances.deposit ?? 0)\nconst isWithdrawInSufficient = Number(state?.inWithdrawAmount ?? 0) > Number(state?.balances.withdraw ?? 0)\nconst isBorrowInSufficient = Number(state?.inBorrowAmount ?? 0) > Number(state?.balances.borrow ?? 0)\nconst isRepayInSufficient = Number(state?.inRepayAmount ?? 0) > Number(state?.balances.repay ?? 0)\nfunction isNotEmptyArray(value) {\n  return value && value[0]\n}\nfunction getValue(value) {\n  return value ? value : 0\n}\nfunction handleCheckApprove(amount) {\n  const _amount = Big(amount)\n    .mul(Big(10).pow(18))\n    .toFixed(0);\n  const abi = [{\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"owner\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"allowance\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  }];\n  if (categoryIndex === 0) {\n    const contract = new ethers.Contract(\n      SYMBOL_ADDRESS,\n      abi,\n      Ethers.provider()\n    );\n    contract\n      .allowance(sender, PROXY_ADDRESS)\n      .then((allowance) => {\n        State.update({\n          depositApproved: !new Big(allowance.toString()).lt(_amount)\n        })\n      })\n  }\n  if (categoryIndex === 3) {\n    // const contract = new ethers.Contract(\n    //   SYMBOL_ADDRESS,\n    //   abi,\n    //   Ethers.provider()\n    // );\n    // contract\n    //   .allowance(sender, smartContractAddress)\n    //   .then((allowance) => {\n    //     State.update({\n    //       repayApproved: !new Big(allowance.toString()).lt(_amount)\n    //     })\n    //   })\n    State.update({\n      repayApproved: Big(state.accountOverview?.firstBalance ?? 0).gt(amount)\n    })\n  }\n}\nfunction handleInAmountChange(amount) {\n  const keyArray = [\"inDepositAmount\", \"inWithdrawAmount\", \"inBorrowAmount\", \"inRepayAmount\"]\n  if (Number(amount) < 0) {\n    return\n  }\n  if (Number(amount) === 0) {\n    State.update({\n      [keyArray[categoryIndex]]: amount,\n    })\n    if (categoryIndex === 0) {\n      State.update({\n        depositApproved: true,\n        depositApproving: false,\n      })\n    }\n    if (categoryIndex === 3) {\n      State.update({\n        repayApproved: true,\n        repayApproving: false,\n      })\n    }\n    return\n  }\n  State.update({\n    [keyArray[categoryIndex]]: amount\n  })\n\n\n  if (categoryIndex === 0 || categoryIndex === 3) {\n    handleCheckApprove(amount)\n  }\n  if (categoryIndex === 1) {\n    const abi = [{\n      \"inputs\": [\n        {\n          \"internalType\": \"uint256\",\n          \"name\": \"shares\",\n          \"type\": \"uint256\"\n        },\n        {\n          \"internalType\": \"address\",\n          \"name\": \"receiver\",\n          \"type\": \"address\"\n        }\n      ],\n      \"name\": \"withdraw\",\n      \"outputs\": [\n        {\n          \"internalType\": \"uint256\",\n          \"name\": \"updatedAssets\",\n          \"type\": \"uint256\"\n        },\n        {\n          \"internalType\": \"uint256\",\n          \"name\": \"updatedShares\",\n          \"type\": \"uint256\"\n        }\n      ],\n      \"stateMutability\": \"nonpayable\",\n      \"type\": \"function\"\n    }]\n    const contract = new ethers.Contract(\n      ethers.utils.getAddress(PROXY_ADDRESS),\n      abi,\n      Ethers.provider().getSigner()\n    );\n    const _amount = Big(amount)\n      .mul(Big(10).pow(18))\n      .toFixed(0);\n    getShares(_amount)\n      .then((sharesResult) => {\n        const shares = sharesResult[1]\n        contract\n          .callStatic\n          .withdraw(\n            shares,\n            sender,\n          )\n          .then((result) => {\n            console.log('===result', result)\n            State.update({\n              withRevert: false\n            })\n          }).catch((error) => {\n            console.log('===error', error)\n            State.update({\n              withRevert: true\n            })\n          });\n      })\n  }\n}\nfunction doApprove(amount, APPROVE_ADDRESS, onSuccess, onError) {\n  const toastId = toast?.loading({\n    title: `Approve ${amount} WETH`,\n  });\n  const abi = [{\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"approve\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }]\n  const contract = new ethers.Contract(\n    ethers.utils.getAddress(SYMBOL_ADDRESS),\n    abi,\n    Ethers.provider().getSigner()\n  );\n  const _amount = Big(amount)\n    .mul(Big(10).pow(18))\n    .toFixed(0);\n  contract\n    .approve(\n      APPROVE_ADDRESS,\n      _amount,\n    )\n    .then(tx => tx.wait())\n    .then((result) => {\n      const { transactionHash } = result;\n      toast?.dismiss(toastId);\n      toast?.success({\n        title: \"Approve Successfully!\",\n        text: `Approved ${amount} WETH`,\n        tx: transactionHash,\n        chainId,\n      });\n      onSuccess && onSuccess()\n    }).catch(error => {\n      onError && onError()\n      toast?.fail({\n        title: \"Approve Failed!\",\n        text: error?.message?.includes(\"user rejected transaction\")\n          ? \"User rejected transaction\"\n          : `Approved ${amount} WETH`,\n      });\n    });\n}\nfunction handleApprove() {\n  // deposit approve\n  if (categoryIndex === 0) {\n    State.update({\n      depositApproving: true\n    })\n    doApprove(\n      state.inDepositAmount,\n      PROXY_ADDRESS,\n      () => {\n        State.update({\n          depositApproved: true,\n          depositApproving: false\n        })\n        handleRefresh()\n      },\n      () => {\n        State.update({\n          depositApproving: false,\n        })\n      }\n    )\n  }\n  // repay approve \n  if (categoryIndex === 3) {\n    State.update({\n      repayApproving: true\n    })\n    doApprove(\n      Big(state.inRepayAmount).times(2).toFixed(),\n      smartContractAddress,\n      () => {\n        State.update({\n          repayApproved: true,\n          repayApproving: false\n        })\n        handleRefresh()\n      },\n      () => {\n        State.update({\n          repayApproving: false,\n        })\n      }\n    )\n  }\n}\nfunction handleDeposit() {\n  State.update({\n    depositLoading: true\n  })\n  const toastId = toast?.loading({\n    title: `Deposit ${state.inDepositAmount} WETH`,\n  });\n  const abi = [{\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"assets\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"receiver\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"deposit\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"updatedAssets\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"shares\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }]\n  const contract = new ethers.Contract(\n    ethers.utils.getAddress(PROXY_ADDRESS),\n    abi,\n    Ethers.provider().getSigner()\n  );\n  const _amount = Big(state?.inDepositAmount)\n    .mul(Big(10).pow(18))\n    .toFixed(0);\n  contract\n    .deposit(\n      _amount,\n      sender,\n    )\n    .then(tx => tx.wait())\n    .then((result) => {\n      const { status, transactionHash } = result;\n      toast?.dismiss(toastId);\n      if (status !== 1) throw new Error(\"\");\n      State.update({\n        inDepositAmount: \"\",\n        depositLoading: false,\n      })\n      toast?.success({\n        title: \"Deposit Successfully!\",\n        text: `Deposit ${state.inDepositAmount} WETH`,\n        tx: transactionHash,\n        chainId,\n      });\n      if (status === 1) {\n        addAction?.({\n          type: \"Yield\",\n          action: \"Deposit\",\n          token0: \"WETH\",\n          amount: state?.inDepositAmount,\n          template: \"Juice\",\n          add: true,\n          status,\n          transactionHash,\n        });\n        handleRefresh()\n      }\n    }).catch(error => {\n      State.update({\n        depositLoading: false\n      })\n      toast?.fail({\n        title: \"Deposit Failed!\",\n        text: error?.message?.includes(\"user rejected transaction\")\n          ? \"User rejected transaction\"\n          : `Deposited ${state.inDepositAmount} WETH`,\n      });\n    });\n}\nfunction getShares(_amount) {\n  return new Promise((resolve, reject) => {\n    const abi = [{\n      \"inputs\": [\n        {\n          \"internalType\": \"uint256\",\n          \"name\": \"assets\",\n          \"type\": \"uint256\"\n        }\n      ],\n      \"name\": \"previewDeposit\",\n      \"outputs\": [\n        {\n          \"internalType\": \"uint256\",\n          \"name\": \"updatedAssets\",\n          \"type\": \"uint256\"\n        },\n        {\n          \"internalType\": \"uint256\",\n          \"name\": \"shares\",\n          \"type\": \"uint256\"\n        }\n      ],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    }]\n    const contract = new ethers.Contract(\n      ethers.utils.getAddress(PROXY_ADDRESS),\n      abi,\n      Ethers.provider().getSigner()\n    )\n    contract.previewDeposit(_amount)\n      .then(resolve)\n      .catch(reject)\n  })\n\n}\nfunction handleWithdraw() {\n  State.update({\n    withdrawLoading: true\n  })\n  const toastId = toast?.loading({\n    title: `Withdraw ${state.inWithdrawAmount} WETH`,\n  });\n  const abi = [{\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"shares\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"receiver\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"withdraw\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"updatedAssets\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"updatedShares\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }]\n  const contract = new ethers.Contract(\n    ethers.utils.getAddress(PROXY_ADDRESS),\n    abi,\n    Ethers.provider().getSigner()\n  );\n  const _amount = Big(state?.inWithdrawAmount)\n    .mul(Big(10).pow(18))\n    .toFixed(0);\n  getShares(_amount).then(sharesResult => {\n    const shares = sharesResult[1]\n    contract\n      .withdraw(\n        shares,\n        sender,\n      )\n      .then(tx => tx.wait())\n      .then((result) => {\n        const { status, transactionHash } = result;\n        toast?.dismiss(toastId);\n        if (status !== 1) throw new Error(\"\");\n        State.update({\n          inWithdrawAmount: \"\",\n          withdrawLoading: false\n        })\n        toast?.success({\n          title: \"Withdraw Successfully!\",\n          text: `Withdraw ${state.inWithdrawAmount} WETH`,\n          tx: transactionHash,\n          chainId,\n        });\n        if (status === 1) {\n          addAction?.({\n            type: \"Yield\",\n            action: \"Withdraw\",\n            token0: \"WETH\",\n            amount: state?.inWithdrawAmount,\n            template: \"Juice\",\n            add: false,\n            status,\n            transactionHash,\n          });\n          handleRefresh()\n        }\n      }).catch(error => {\n        console.log('=error', error)\n        State.update({\n          withdrawLoading: false\n        })\n        toast?.fail({\n          title: \"Withdraw Failed!\",\n          text: error?.message?.includes(\"user rejected transaction\")\n            ? \"User rejected transaction\"\n            : `Withdraw ${state.inWithdrawAmount} WETH`,\n        });\n      });\n  })\n}\nfunction handleBorrow() {\n  State.update({\n    borrowLoading: true\n  })\n  const toastId = toast?.loading({\n    title: `Borrow ${state.inBorrowAmount} WETH`,\n  });\n  const abi = [{\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"borrow\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"borrowed\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }]\n  const contract = new ethers.Contract(\n    ethers.utils.getAddress(smartContractAddress),\n    abi,\n    Ethers.provider().getSigner()\n  );\n\n  const _amount = Big(state?.inBorrowAmount)\n    .mul(Big(10).pow(18))\n    .toFixed(0);\n  contract\n    .borrow(\n      _amount,\n    )\n    .then(tx => tx.wait())\n    .then((result) => {\n      const { status, transactionHash } = result;\n      toast?.dismiss(toastId);\n      if (status !== 1) throw new Error(\"\");\n      State.update({\n        inBorrowAmount: \"\",\n        borrowLoading: false\n      })\n      toast?.success({\n        title: \"Borrow Successfully!\",\n        text: `Borrow ${state.inBorrowAmount} WETH`,\n        tx: transactionHash,\n        chainId,\n      });\n      if (status === 1) {\n        addAction?.({\n          type: \"Yield\",\n          action: \"Borrow\",\n          token0: \"WETH\",\n          amount: state?.inBorrowAmount,\n          template: \"Juice\",\n          add: true,\n          status,\n          transactionHash,\n        });\n        handleRefresh()\n      }\n    }).catch(error => {\n      console.log('=error', error)\n      State.update({\n        borrowLoading: false\n      })\n      toast?.fail({\n        title: \"Borrow Failed!\",\n        text: error?.message?.includes(\"user rejected transaction\")\n          ? \"User rejected transaction\"\n          : `Borrowed ${state.inBorrowAmount} WETH`,\n      });\n    });\n}\nfunction handleRepay() {\n  State.update({\n    repayLoading: true\n  })\n  const toastId = toast?.loading({\n    title: `Repay ${state.inRepayAmount} WETH`,\n  });\n  const abi = [{\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"repay\",\n    \"outputs\": [],\n    \"stateMutability\": \"payable\",\n    \"type\": \"function\"\n  }, {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amountFrom\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"repayFrom\",\n    \"outputs\": [],\n    \"stateMutability\": \"payable\",\n    \"type\": \"function\"\n  }]\n\n  const contract = new ethers.Contract(\n    ethers.utils.getAddress(smartContractAddress),\n    abi,\n    Ethers.provider().getSigner()\n  );\n  const _amount = Big(state?.inRepayAmount)\n    .mul(Big(10).pow(18))\n    .toFixed(0);\n  const contractMethod = Big(state.balances.repay).gt(state?.accountOverview?.firstBalance ?? 0) ? \"repayFrom\" : \"repay\"\n  console.log('=state.balances.repay', state.balances.repay, '=state?.accountOverview?.firstBalance', state?.accountOverview?.firstBalance)\n  contract[contractMethod](\n    _amount,\n    {\n      gasLimit: 5000000,\n    }\n  )\n    .then(tx => tx.wait())\n    .then((result) => {\n      const { status, transactionHash } = result;\n      toast?.dismiss(toastId);\n      if (status !== 1) throw new Error(\"\");\n      State.update({\n        inRepayAmount: \"\",\n        repayLoading: false\n      })\n      toast?.success({\n        title: \"Repay Successfully!\",\n        text: `Repay ${state.inRepayAmount} WETH`,\n        tx: transactionHash,\n        chainId,\n      });\n      if (status === 1) {\n        addAction?.({\n          type: \"Yield\",\n          action: \"Repay\",\n          token0: \"WETH\",\n          amount: state?.inRepayAmount,\n          template: \"Juice\",\n          add: false,\n          status,\n          transactionHash,\n        });\n        handleRefresh()\n      }\n    }).catch(error => {\n      console.log('=error', error)\n      State.update({\n        repayLoading: false\n      })\n      toast?.fail({\n        title: \"Repay Failed!\",\n        text: error?.message?.includes(\"user rejected transaction\")\n          ? \"User rejected transaction\"\n          : `Repayed ${state.inRepayAmount} WETH`,\n      });\n    });\n}\n// function handleGetCurrentBalance(balances) {\n//   const key = [\"deposit\", \"withdraw\", \"borrow\", \"repay\"][categoryIndex]\n//   return balances[key]\n// }\n// function handleGetDeposit\nfunction handleGetBalances(callback) {\n  const calls = []\n  const abi = [{\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"account\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"balanceOf\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"value\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  }, {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"account\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"getAccountHealth\",\n    \"outputs\": [\n      {\n        \"components\": [\n          {\n            \"internalType\": \"uint256\",\n            \"name\": \"debtAmount\",\n            \"type\": \"uint256\"\n          },\n          {\n            \"internalType\": \"uint256\",\n            \"name\": \"collateralValue\",\n            \"type\": \"uint256\"\n          },\n          {\n            \"internalType\": \"uint256\",\n            \"name\": \"investmentValue\",\n            \"type\": \"uint256\"\n          },\n          {\n            \"internalType\": \"UD60x18\",\n            \"name\": \"healthFactor\",\n            \"type\": \"uint256\"\n          },\n          {\n            \"internalType\": \"bool\",\n            \"name\": \"isLiquidatable\",\n            \"type\": \"bool\"\n          },\n          {\n            \"internalType\": \"bool\",\n            \"name\": \"isRisky\",\n            \"type\": \"bool\"\n          },\n          {\n            \"internalType\": \"bool\",\n            \"name\": \"hasBadDebt\",\n            \"type\": \"bool\"\n          }\n        ],\n        \"internalType\": \"struct AccountLib.Health\",\n        \"name\": \"health\",\n        \"type\": \"tuple\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  }, {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"account\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"getTotalCollateralValue\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"totalValue\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  }, {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"account\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"getDebtAmount\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  }]\n  calls.push({\n    address: SYMBOL_ADDRESS,\n    name: \"balanceOf\",\n    params: [sender]\n  })\n  calls.push({\n    address: PROXY_ADDRESS,\n    name: \"getAccountHealth\",\n    params: [smartContractAddress]\n  })\n  calls.push({\n    address: PROXY_ADDRESS,\n    name: \"getTotalCollateralValue\",\n    params: [smartContractAddress]\n  })\n  calls.push({\n    address: PROXY_ADDRESS,\n    name: \"getDebtAmount\",\n    params: [smartContractAddress]\n  })\n  multicall({\n    abi,\n    calls,\n    options: {},\n    multicallAddress,\n    provider: Ethers.provider(),\n  }).then(result => {\n    const [\n      balanceOfResult,\n      getAccountHealthResult,\n      getTotalCollateralValueResult,\n      getDebtAmountResult\n    ] = result\n    const deposit = Big(isNotEmptyArray(balanceOfResult) ? ethers.utils.formatUnits(balanceOfResult[0]) : 0).toFixed()\n    const withdraw = Big(isNotEmptyArray(getAccountHealthResult) && getAccountHealthResult[0][1] ? ethers.utils.formatUnits(getAccountHealthResult[0][1]) : 0).toFixed()\n    const borrow = Big(isNotEmptyArray(getTotalCollateralValueResult) ? ethers.utils.formatUnits(getTotalCollateralValueResult[0]) : 0).times(2.97).minus(isNotEmptyArray(getDebtAmountResult) ? ethers.utils.formatUnits(getDebtAmountResult[0]) : 0).toFixed()\n    // const firstRepay = Big(isNotEmptyArray(balanceOfResult) ? ethers.utils.formatUnits(balanceOfResult[0]) : 0).toFixed()\n    const firstRepay = deposit\n    const secondRepay = Big(isNotEmptyArray(getDebtAmountResult) ? ethers.utils.formatUnits(getDebtAmountResult[0]) : 0).toFixed()\n    const repay = secondRepay\n    const balances = {\n      deposit,\n      withdraw,\n      borrow: Big(borrow).gt(0) ? borrow : 0,\n      repay,\n      firstRepay,\n      secondRepay\n    }\n    State.update({\n      balances\n    })\n    callback && callback([deposit, withdraw, borrow, repay][categoryIndex])\n  })\n}\nfunction handleGetAccountOverview() {\n  const calls = []\n  const abi = [{\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"account\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"balanceOfAssets\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"assets\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  }, {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"account\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"getDebtAmount\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  }, {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"account\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"getTotalCollateralValue\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"totalValue\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  }, {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"account\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"getAccountHealth\",\n    \"outputs\": [\n      {\n        \"components\": [\n          {\n            \"internalType\": \"uint256\",\n            \"name\": \"debtAmount\",\n            \"type\": \"uint256\"\n          },\n          {\n            \"internalType\": \"uint256\",\n            \"name\": \"collateralValue\",\n            \"type\": \"uint256\"\n          },\n          {\n            \"internalType\": \"uint256\",\n            \"name\": \"investmentValue\",\n            \"type\": \"uint256\"\n          },\n          {\n            \"internalType\": \"UD60x18\",\n            \"name\": \"healthFactor\",\n            \"type\": \"uint256\"\n          },\n          {\n            \"internalType\": \"bool\",\n            \"name\": \"isLiquidatable\",\n            \"type\": \"bool\"\n          },\n          {\n            \"internalType\": \"bool\",\n            \"name\": \"isRisky\",\n            \"type\": \"bool\"\n          },\n          {\n            \"internalType\": \"bool\",\n            \"name\": \"hasBadDebt\",\n            \"type\": \"bool\"\n          }\n        ],\n        \"internalType\": \"struct AccountLib.Health\",\n        \"name\": \"health\",\n        \"type\": \"tuple\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  }, {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"owner\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"balanceOf\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"result\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  }]\n  calls.push({\n    address: PROXY_ADDRESS,\n    name: \"balanceOfAssets\",\n    params: [sender]\n  })\n  calls.push({\n    address: PROXY_ADDRESS,\n    name: \"getDebtAmount\",\n    params: [smartContractAddress]\n  })\n  calls.push({\n    address: PROXY_ADDRESS,\n    name: \"getTotalCollateralValue\",\n    params: [smartContractAddress]\n  })\n  calls.push({\n    address: PROXY_ADDRESS,\n    name: \"getAccountHealth\",\n    params: [smartContractAddress]\n  })\n  calls.push({\n    address: SYMBOL_ADDRESS,\n    name: \"balanceOf\",\n    params: [smartContractAddress]\n  })\n  calls.push({\n    address: SYMBOL_ADDRESS,\n    name: \"balanceOf\",\n    params: [LENDING_POOL_ADDRESS]\n  })\n  multicall({\n    abi,\n    calls,\n    options: {},\n    multicallAddress,\n    provider: Ethers.provider(),\n  }).then(result => {\n    const [\n      balanceOfAssetsResult,\n      getDebtAmountResult,\n      getTotalCollateralValueResult,\n      getAccountHealthResult,\n      firstBalanceResult,\n      secondBalanceResult,\n    ] = result\n    const [A1, A2, A3] = isNotEmptyArray(getAccountHealthResult) ? getAccountHealthResult[0] : [1, 0, 0]\n    State.update({\n      leverage: [\n        isNotEmptyArray(getTotalCollateralValueResult) ? ethers.utils.formatUnits(getTotalCollateralValueResult[0]) : 0,\n        isNotEmptyArray(getDebtAmountResult) ? ethers.utils.formatUnits(getDebtAmountResult[0]) : 0\n      ],\n      accountOverview: {\n        balanceOfAssets: Big(isNotEmptyArray(balanceOfAssetsResult) ? ethers.utils.formatUnits(balanceOfAssetsResult[0]) : 0).toFixed(4),\n        debtAmount: Big(isNotEmptyArray(getDebtAmountResult) ? ethers.utils.formatUnits(getDebtAmountResult[0]) : 0).toFixed(4),\n        totalCollateralValue: Big(isNotEmptyArray(getTotalCollateralValueResult) ? ethers.utils.formatUnits(getTotalCollateralValueResult[0]) : 0).times(2.97).minus(isNotEmptyArray(getDebtAmountResult) ? ethers.utils.formatUnits(getDebtAmountResult[0]) : 0).toFixed(4),\n        accountHealth: Big(A1).gt(0) ? (Big(Big(A2).plus(A3)).div(A1).times(100).toFixed(2) + \"%\") : \"N/A\",\n        firstBalance: Big(isNotEmptyArray(firstBalanceResult) ? ethers.utils.formatUnits(firstBalanceResult[0]) : 0).toFixed(),\n        secondBalance: Big(isNotEmptyArray(secondBalanceResult) ? ethers.utils.formatUnits(secondBalanceResult[0]) : 0).toFixed(),\n      }\n    })\n  })\n}\nfunction doQueryPnl(x, y) {\n  const abi = [\n    {\n      \"inputs\": [\n        {\n          \"internalType\": \"uint256\",\n          \"name\": \"x\",\n          \"type\": \"uint256\"\n        },\n        {\n          \"internalType\": \"uint256\",\n          \"name\": \"y\",\n          \"type\": \"uint256\"\n        }\n      ],\n      \"name\": \"zeroFloorSub\",\n      \"outputs\": [\n        {\n          \"internalType\": \"uint256\",\n          \"name\": \"z\",\n          \"type\": \"uint256\"\n        }\n      ],\n      \"stateMutability\": \"pure\",\n      \"type\": \"function\"\n    }\n  ]\n  const contract = new ethers.Contract(\n    ethers.utils.getAddress(\"0xe1dA6F46d757699f6D783a2876E01937a1eCa9a9\"),\n    abi,\n    Ethers.provider().getSigner()\n  );\n  contract.zeroFloorSub(x, y)\n    .then(result => {\n      State.update({\n        pnl: ethers.utils.formatUnits(result)\n      })\n    })\n}\nfunction handleQueryPnl() {\n  const calls = []\n  const abi = [\n    {\n      \"inputs\": [\n        {\n          \"internalType\": \"address\",\n          \"name\": \"account\",\n          \"type\": \"address\"\n        }\n      ],\n      \"name\": \"getTotalAccountValue\",\n      \"outputs\": [\n        {\n          \"internalType\": \"uint256\",\n          \"name\": \"totalValue\",\n          \"type\": \"uint256\"\n        }\n      ],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        {\n          \"internalType\": \"address\",\n          \"name\": \"account\",\n          \"type\": \"address\"\n        }\n      ],\n      \"name\": \"getDebtAmount\",\n      \"outputs\": [\n        {\n          \"internalType\": \"uint256\",\n          \"name\": \"\",\n          \"type\": \"uint256\"\n        }\n      ],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    }\n  ]\n  calls.push({\n    address: PROXY_ADDRESS,\n    name: \"getTotalAccountValue\",\n    params: [smartContractAddress]\n  })\n  calls.push({\n    address: PROXY_ADDRESS,\n    name: \"getDebtAmount\",\n    params: [smartContractAddress]\n  })\n  multicall({\n    abi,\n    calls,\n    options: {},\n    multicallAddress,\n    provider: Ethers.provider(),\n  }).then(result => {\n    const [getTotalAccountValueResult, getDebtAmountResult] = result\n    doQueryPnl(\n      isNotEmptyArray(getTotalAccountValueResult) ? getTotalAccountValueResult[0] : 0,\n      isNotEmptyArray(getDebtAmountResult) ? getDebtAmountResult[0] : 0\n    )\n  })\n}\nfunction handleClaim() {\n  State.update({\n    claimLoading: true\n  })\n  const abi = [{\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"claim\",\n    \"outputs\": [],\n    \"stateMutability\": \"payable\",\n    \"type\": \"function\"\n  }]\n\n  const contract = new ethers.Contract(\n    ethers.utils.getAddress(smartContractAddress),\n    abi,\n    Ethers.provider().getSigner()\n  );\n  const temAmount = Big(state.balances.repay).eq(0) ? state?.accountOverview?.firstBalance : state?.pnl\n  const _amount = Big(temAmount)\n    .mul(Big(10).pow(18))\n    .toFixed(0);\n  const toastId = toast?.loading({\n    title: `Claim ${Big(state.pnl).toFixed()}`,\n  });\n  contract.claim(_amount)\n    .then(result => {\n      const { transactionHash } = result;\n      toast?.dismiss(toastId);\n      State.update({\n        claimLoading: false\n      })\n      toast?.success({\n        title: \"Claim Successfully!\",\n        text: `Claim ${Big(state.pnl).toFixed()}`,\n        tx: transactionHash,\n        chainId,\n      });\n      handleRefresh()\n    })\n    .catch(error => {\n      console.log('=error', error)\n      State.update({\n        claimLoading: false\n      })\n      toast?.fail({\n        title: \"Claim Failed!\",\n        text: error?.message?.includes(\"user rejected transaction\")\n          ? \"User rejected transaction\"\n          : `Claim ${Big(state.pnl).toFixed()}`,\n      });\n    })\n}\nfunction handleMax() {\n  handleGetBalances(balance => {\n    handleInAmountChange(Big(balance).eq(Big(10).pow(-18)) ? 0 : balance)\n  })\n}\nfunction handleRefresh() {\n  handleGetBalances()\n  handleGetAccountOverview()\n  handleQueryPnl()\n}\nuseEffect(() => {\n  handleGetBalances()\n}, [categoryIndex])\nuseEffect(() => {\n  const [totalCollateralValue, totalBorrowed] = state.leverage\n  if (totalBorrowed && totalCollateralValue) {\n    if (categoryIndex < 3) {\n      State.update({\n        borrowLeverage: Big(Big(totalBorrowed).plus(state?.inBorrowAmount ? state?.inBorrowAmount : 0)).div(totalCollateralValue).times(100).toFixed(2) + '%'\n      })\n    } else {\n      State.update({\n        borrowLeverage: Big(Big(totalBorrowed).minus(state?.inBorrowAmount ? state?.inBorrowAmount : 0)).div(totalCollateralValue).times(100).toFixed(2) + '%'\n      })\n    }\n  } else {\n    State.update({\n      borrowLeverage: '0.00%'\n    })\n  }\n}, [state.categoryIndex, state.leverage, state.inBorrowAmount, state.inRepayAmount])\nuseEffect(() => {\n  handleRefresh()\n}, [])\n\nreturn (\n  <StyledContainer>\n    <StyledContainerL>\n      {\n        isCreatedAccount ? (\n          <StyledCategory>\n            <StyledCategoryTop>\n              {\n                categoryList.map((category, index) => (\n                  <StyledCategoryTopButton\n                    key={index}\n                    className={categoryIndex === index ? \"active\" : \"\"}\n                    onClick={() => {\n                      State.update({\n                        categoryIndex: index\n                      })\n                    }}\n                  >{category}</StyledCategoryTopButton>\n                ))\n              }\n            </StyledCategoryTop>\n            <StyledCategoryBottom>\n              {\n                categoryIndex === 0 && (\n                  <StyledDepositContainer>\n                    <StyledDepositInput>\n                      <StyledDepositInputTop>\n                        <StyledDepositInputTopType>Deposit</StyledDepositInputTopType>\n                        <StyledDepositInputTopBalance>\n                          Balance: <span onClick={handleMax}>{Big(state.balances?.deposit).toFixed(4)}</span>\n                        </StyledDepositInputTopBalance>\n                      </StyledDepositInputTop>\n                      <StyledDepositInputBottom>\n                        <StyledDepositInputBottomInput type=\"number\" placeholder=\"0.0\" value={state.inDepositAmount} onChange={(event) => handleInAmountChange(event.target.value)} />\n                        <StyledDepositInputBottomSymbol>\n                          <StyledDepositInputBottomSymbolImageContainer>\n                            <StyledDepositInputBottomSymbolImage src={ICON_MAP[\"WETH\"]} />\n                          </StyledDepositInputBottomSymbolImageContainer>\n                          <StyledDepositInputBottomSymbolTxt>WETH</StyledDepositInputBottomSymbolTxt>\n                        </StyledDepositInputBottomSymbol>\n                      </StyledDepositInputBottom>\n                    </StyledDepositInput>\n                    <StyledDepositMessageList>\n                      <StyledDepositMessage>\n                        <StyledDepositMessageLabel>Borrow Leverage</StyledDepositMessageLabel>\n                        <StyledDepositMessageValue>{state.borrowLeverage}</StyledDepositMessageValue>\n                      </StyledDepositMessage>\n                      <StyledDepositMessage>\n                        <StyledDepositMessageLabel>New Margin Health Factor</StyledDepositMessageLabel>\n                        <StyledDepositMessageValue>N/A</StyledDepositMessageValue>\n                      </StyledDepositMessage>\n                    </StyledDepositMessageList>\n                    {\n                      isDepositInSufficient ? (\n                        <StyledOperationButton disabled>InSufficient Balance</StyledOperationButton>\n                      ) : !(state.depositApproved || state.depositApproving) ? (\n                        <StyledOperationButton onClick={handleApprove}>Approve</StyledOperationButton>\n                      ) : (state.depositLoading || state.depositApproving) ? (\n                        <StyledOperationButton disabled>\n                          <Widget src={\"bluebiu.near/widget/Liquidity.Bridge.Loading\"} />\n                        </StyledOperationButton>\n                      ) : state.inDepositAmount > 0 ? (\n                        <StyledOperationButton onClick={handleDeposit}>Deposit</StyledOperationButton>\n                      ) : (\n                        <StyledOperationButton disabled>Deposit</StyledOperationButton>\n                      )\n                    }\n                  </StyledDepositContainer>\n                )\n              }\n              {\n                categoryIndex === 1 && (\n                  <StyledDepositContainer>\n                    <StyledDepositInput>\n                      <StyledDepositInputTop>\n                        <StyledDepositInputTopType>Withdraw</StyledDepositInputTopType>\n                        <StyledDepositInputTopBalance>\n                          Available: <span onClick={handleMax}>{Big(state.balances?.withdraw).toFixed(4)}</span>\n                        </StyledDepositInputTopBalance>\n                      </StyledDepositInputTop>\n                      <StyledDepositInputBottom>\n                        <StyledDepositInputBottomInput type=\"number\" placeholder=\"0.0\" value={state.inWithdrawAmount} onChange={(event) => handleInAmountChange(event.target.value)} />\n                        <StyledDepositInputBottomSymbol>\n                          <StyledDepositInputBottomSymbolImageContainer>\n                            <StyledDepositInputBottomSymbolImage src={ICON_MAP[\"WETH\"]} />\n                          </StyledDepositInputBottomSymbolImageContainer>\n                          <StyledDepositInputBottomSymbolTxt>WETH</StyledDepositInputBottomSymbolTxt>\n                        </StyledDepositInputBottomSymbol>\n                      </StyledDepositInputBottom>\n                    </StyledDepositInput>\n                    <StyledDepositMessageList>\n                      <StyledDepositMessage>\n                        <StyledDepositMessageLabel>Borrow Leverage</StyledDepositMessageLabel>\n                        <StyledDepositMessageValue>{state.borrowLeverage}</StyledDepositMessageValue>\n                      </StyledDepositMessage>\n                      <StyledDepositMessage>\n                        <StyledDepositMessageLabel>New Margin Health Factor</StyledDepositMessageLabel>\n                        <StyledDepositMessageValue>N/A</StyledDepositMessageValue>\n                      </StyledDepositMessage>\n                    </StyledDepositMessageList>\n                    {\n                      isWithdrawInSufficient ? (\n                        <StyledOperationButton disabled>InSufficient Balance</StyledOperationButton>\n                      ) : state.withdrawLoading ? (\n                        <StyledOperationButton disabled>\n                          <Widget src={\"bluebiu.near/widget/Liquidity.Bridge.Loading\"} />\n                        </StyledOperationButton>\n                      ) : state.inWithdrawAmount > 0 && !state.withRevert ? (\n                        <StyledOperationButton onClick={handleWithdraw}>Withdraw</StyledOperationButton>\n                      ) : (\n                        <StyledOperationButton disabled>Withdraw</StyledOperationButton>\n                      )\n                    }\n                  </StyledDepositContainer>\n                )\n              }\n              {\n                categoryIndex === 2 && (\n                  <StyledDepositContainer>\n                    <StyledDepositInput>\n                      <StyledDepositInputTop>\n                        <StyledDepositInputTopType>Borrow</StyledDepositInputTopType>\n                        <StyledDepositInputTopBalance>\n                          Available: <span onClick={handleMax}>{Big(state.balances?.borrow).toFixed(4)}</span>\n                        </StyledDepositInputTopBalance>\n                      </StyledDepositInputTop>\n                      <StyledDepositInputBottom>\n                        <StyledDepositInputBottomInput type=\"number\" placeholder=\"0.0\" value={state.inBorrowAmount} onChange={(event) => handleInAmountChange(event.target.value)} />\n                        <StyledDepositInputBottomSymbol>\n                          <StyledDepositInputBottomSymbolImageContainer>\n                            <StyledDepositInputBottomSymbolImage src={ICON_MAP[\"WETH\"]} />\n                          </StyledDepositInputBottomSymbolImageContainer>\n                          <StyledDepositInputBottomSymbolTxt>WETH</StyledDepositInputBottomSymbolTxt>\n                        </StyledDepositInputBottomSymbol>\n                      </StyledDepositInputBottom>\n                    </StyledDepositInput>\n                    <StyledDepositMessageList>\n                      <StyledDepositMessage>\n                        <StyledDepositMessageLabel>Available in Lending Pool</StyledDepositMessageLabel>\n                        <StyledDepositMessageValue>{Big(state?.accountOverview?.secondBalance ?? 0).toFixed(4)}</StyledDepositMessageValue>\n                      </StyledDepositMessage>\n                      <StyledDepositMessage>\n                        <StyledDepositMessageLabel>Variable Borrow Rate</StyledDepositMessageLabel>\n                        <StyledDepositMessageValue>18.84%</StyledDepositMessageValue>\n                      </StyledDepositMessage>\n                      <StyledDepositMessage>\n                        <StyledDepositMessageLabel>Borrow Leverage</StyledDepositMessageLabel>\n                        <StyledDepositMessageValue>{state.borrowLeverage}</StyledDepositMessageValue>\n                      </StyledDepositMessage>\n                      <StyledDepositMessage>\n                        <StyledDepositMessageLabel>New Margin Health Factor</StyledDepositMessageLabel>\n                        <StyledDepositMessageValue>N/A</StyledDepositMessageValue>\n                      </StyledDepositMessage>\n                    </StyledDepositMessageList>\n                    {\n                      isBorrowInSufficient ? (\n                        <StyledOperationButton disabled>InSufficient Balance</StyledOperationButton>\n                      ) : state.borrowLoading ? (\n                        <StyledOperationButton disabled>\n                          <Widget src={\"bluebiu.near/widget/Liquidity.Bridge.Loading\"} />\n                        </StyledOperationButton>\n                      ) : state.inBorrowAmount > 0 ? (\n                        <StyledOperationButton onClick={handleBorrow}>Borrow</StyledOperationButton>\n                      ) : (\n                        <StyledOperationButton disabled>Borrow</StyledOperationButton>\n                      )\n                    }\n                  </StyledDepositContainer>\n                )\n              }\n              {\n                categoryIndex === 3 && (\n                  <StyledDepositContainer>\n                    <StyledDepositInput>\n                      <StyledDepositInputTop>\n                        <StyledDepositInputTopType>Repay</StyledDepositInputTopType>\n                        <StyledDepositInputTopBalance>\n                          Available: <span onClick={handleMax}>{Big(state.balances?.firstRepay ?? 0).plus(state.balances?.repay ?? 0).toFixed(4)}</span>\n                        </StyledDepositInputTopBalance>\n                      </StyledDepositInputTop>\n                      <StyledDepositInputBottom>\n                        <StyledDepositInputBottomInput type=\"number\" placeholder=\"0.0\" value={state.inRepayAmount} onChange={(event) => handleInAmountChange(event.target.value)} />\n                        <StyledDepositInputBottomSymbol>\n                          <StyledDepositInputBottomSymbolImageContainer>\n                            <StyledDepositInputBottomSymbolImage src={ICON_MAP[\"WETH\"]} />\n                          </StyledDepositInputBottomSymbolImageContainer>\n                          <StyledDepositInputBottomSymbolTxt>WETH</StyledDepositInputBottomSymbolTxt>\n                        </StyledDepositInputBottomSymbol>\n                      </StyledDepositInputBottom>\n                    </StyledDepositInput>\n                    <StyledDepositMessageList>\n                      <StyledDepositMessage>\n                        <StyledDepositMessageLabel>Borrow Leverage</StyledDepositMessageLabel>\n                        <StyledDepositMessageValue>{state.borrowLeverage}</StyledDepositMessageValue>\n                      </StyledDepositMessage>\n                      <StyledDepositMessage>\n                        <StyledDepositMessageLabel>New Margin Health Factor</StyledDepositMessageLabel>\n                        <StyledDepositMessageValue>N/A</StyledDepositMessageValue>\n                      </StyledDepositMessage>\n                    </StyledDepositMessageList>\n                    {\n                      isRepayInSufficient ? (\n                        <StyledOperationButton disabled>InSufficient Balance</StyledOperationButton>\n                      ) : !(state.repayApproved || state.repayApproving) ? (\n                        <StyledOperationButton onClick={handleApprove}>Approve</StyledOperationButton>\n                      ) : (state.repayLoading || state.repayApproving) ? (\n                        <StyledOperationButton disabled>\n                          <Widget src={\"bluebiu.near/widget/Liquidity.Bridge.Loading\"} />\n                        </StyledOperationButton>\n                      ) : state.inRepayAmount > 0 ? (\n                        <StyledOperationButton onClick={handleRepay}>Repay</StyledOperationButton>\n                      ) : (\n                        <StyledOperationButton disabled>Repay</StyledOperationButton>\n                      )\n                    }\n                  </StyledDepositContainer>\n                )\n              }\n            </StyledCategoryBottom>\n          </StyledCategory>\n        ) : (\n          <StyledEmptyContainer>\n            <StyledEmptyImage src=\"https://ipfs.near.social/ipfs/bafkreieloy2b3qkgzea7x6oyzth3qnvbs7gaeit7bm4jf66r62hwqugayi\" />\n            <StyledEmptyTxt>Juice creates sub-accounts for users, allowing them to borrow against their deposited collateral. Create your Sub Account to borrow and farm yield.</StyledEmptyTxt>\n            {\n              createSubAccountLoading ? (\n                <StyledOperationButton disabled>\n                  <Widget src={\"bluebiu.near/widget/Liquidity.Bridge.Loading\"} />\n                </StyledOperationButton>\n              ) : (\n                <StyledOperationButton onClick={onCreateSubAccount}>Create Sub Account</StyledOperationButton>\n              )\n            }\n          </StyledEmptyContainer>\n        )\n      }\n      <StyledWrapContainer onClick={onOpenWrap}>\n        <StyledWrap>\n          <StyledWrapChainList>\n            <StyledChainImage src=\"https://ipfs.near.social/ipfs/bafkreib3g5xhs4b3djuvtarhutz5ayogdi7bz7nft6a2zg2e7pi2445uny\" />\n            <StyledChainImage src=\"https://ipfs.near.social/ipfs/bafkreif5jqf6onhhj6aqfjt6zq2lqanw6o3kzmb7exnqjw42p4hpwrojmu\" style={{ marginLeft: -7 }} />\n          </StyledWrapChainList>\n          <StyledWrapTxt>Wrap ETH to WETH</StyledWrapTxt>\n        </StyledWrap>\n        <StyledIconRight>\n          <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" fill=\"none\">\n            <path d=\"M1 7C0.447715 7 4.82823e-08 7.44772 0 8C-4.82823e-08 8.55228 0.447715 9 1 9L1 7ZM15.7071 8.70711C16.0976 8.31658 16.0976 7.68342 15.7071 7.29289L9.34315 0.928933C8.95262 0.538408 8.31946 0.538408 7.92893 0.928933C7.53841 1.31946 7.53841 1.95262 7.92893 2.34315L13.5858 8L7.92893 13.6569C7.53841 14.0474 7.53841 14.6805 7.92893 15.0711C8.31946 15.4616 8.95262 15.4616 9.34314 15.0711L15.7071 8.70711ZM1 9L15 9L15 7L1 7L1 9Z\" fill=\"white\" />\n          </svg>\n        </StyledIconRight>\n      </StyledWrapContainer>\n\n    </StyledContainerL>\n    <StyledContainerR>\n      <StyledOverviewTitle>Juice Account Overview</StyledOverviewTitle>\n      <StyledOverviewList>\n        <StyledOverview>\n          <StyledOverviewLabel>Deposited WETH</StyledOverviewLabel>\n          <StyledOverviewValue>{state.accountOverview?.balanceOfAssets}</StyledOverviewValue>\n        </StyledOverview>\n        <StyledOverview>\n          <StyledOverviewLabel>Total Deposited WETH</StyledOverviewLabel>\n          <StyledOverviewValue>{state.accountOverview?.debtAmount}</StyledOverviewValue>\n        </StyledOverview>\n        <StyledOverview>\n          <StyledOverviewLabel>Remaining WETH to borrow</StyledOverviewLabel>\n          <StyledOverviewValue>{Big(state.balances?.borrow).toFixed(4)}</StyledOverviewValue>\n        </StyledOverview>\n        <StyledOverview>\n          <StyledOverviewLabel>Margin Health Factor</StyledOverviewLabel>\n          <StyledOverviewValue>{state.accountOverview?.accountHealth}</StyledOverviewValue>\n        </StyledOverview>\n        <StyledOverview>\n          <StyledOverviewLabel>Minimum Margin Health Factor</StyledOverviewLabel>\n          <StyledOverviewValue>125.00%</StyledOverviewValue>\n        </StyledOverview>\n        <StyledOverview>\n          <StyledOverviewLabel>Total WETH Balance</StyledOverviewLabel>\n          <StyledOverviewValue>{Big(state?.accountOverview?.firstBalance ?? 0).toFixed(4)}</StyledOverviewValue>\n        </StyledOverview>\n        <StyledOverview>\n          <StyledOverviewLabel>PnL</StyledOverviewLabel>\n          <StyledOverviewValue>{Big(state.pnl).gt(0) ? '' : '-'}{Big(state.pnl).toFixed(4)}</StyledOverviewValue>\n        </StyledOverview>\n      </StyledOverviewList>\n      <StyledOverviewButtonContainer>\n        {\n          Big(state.pnl).gt(0) && Big(state?.accountOverview?.firstBalance ?? 0).gt(0) ? (\n            <StyledOperationButton onClick={handleClaim}>Claim Profit</StyledOperationButton>\n          ) : (\n            <StyledOperationButton disabled>Claim Profit</StyledOperationButton>\n          )\n        }\n      </StyledOverviewButtonContainer>\n    </StyledContainerR>\n  </StyledContainer >\n)", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/bluebiu.near/widget/Liquidity.Bridge.JUICE.Borrowers", "fact_widget_deployments_id": "ef9e75e14e9273db0f89e1595837cf17", "inserted_timestamp": "2024-05-06T09:38:52.108Z", "modified_timestamp": "2024-05-06T09:38:52.108Z", "__row_index": 18}