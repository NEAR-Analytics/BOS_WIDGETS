{"tx_hash": "DBxeAakUEjkKbsG1XJz9UUpm2jsojaMsw52Yv21MepuM", "action_id_social": "CB7ro7yTzXgCk5XvkCLNNAhN7RfAPJHxQbCtrmpsJHj6-0-widget", "block_id": 119032671, "block_timestamp": "2024-05-16T08:26:55.693Z", "signer_id": "bluebiu.near", "widget_name": "Mode.BridgeAuthority.Util", "source_code": "const getETHWithdrawalsFromOp = (account, type, hash, callback) => {\n    const L2_L1_MESSAGE_PASSER_CONTRACT =\n        \"0x4200000000000000000000000000000000000016\";\n    const L1_CROSS_DOMAIN_MESSENGER_CONTRACT =\n        \"0x95bdca6c8edeb69c98bd5bd17660bacef1298a6f\";\n\n    const bridgeAbiWithdrawal = [\n        {\n            \"anonymous\": false,\n            \"inputs\": [\n                {\n                    \"indexed\": true,\n                    \"internalType\": \"address\",\n                    \"name\": \"from\",\n                    \"type\": \"address\"\n                },\n                {\n                    \"indexed\": true,\n                    \"internalType\": \"address\",\n                    \"name\": \"to\",\n                    \"type\": \"address\"\n                },\n                {\n                    \"indexed\": false,\n                    \"internalType\": \"uint256\",\n                    \"name\": \"amount\",\n                    \"type\": \"uint256\"\n                },\n                {\n                    \"indexed\": false,\n                    \"internalType\": \"bytes\",\n                    \"name\": \"extraData\",\n                    \"type\": \"bytes\"\n                }\n            ],\n            \"name\": \"ETHBridgeInitiated\",\n            \"type\": \"event\"\n        },\n        {\n            \"anonymous\": false,\n            \"inputs\": [\n                {\n                    \"indexed\": true,\n                    \"internalType\": \"address\",\n                    \"name\": \"localToken\",\n                    \"type\": \"address\"\n                },\n                {\n                    \"indexed\": true,\n                    \"internalType\": \"address\",\n                    \"name\": \"remoteToken\",\n                    \"type\": \"address\"\n                },\n                {\n                    \"indexed\": true,\n                    \"internalType\": \"address\",\n                    \"name\": \"from\",\n                    \"type\": \"address\"\n                },\n                {\n                    \"indexed\": false,\n                    \"internalType\": \"address\",\n                    \"name\": \"to\",\n                    \"type\": \"address\"\n                },\n                {\n                    \"indexed\": false,\n                    \"internalType\": \"uint256\",\n                    \"name\": \"amount\",\n                    \"type\": \"uint256\"\n                },\n                {\n                    \"indexed\": false,\n                    \"internalType\": \"bytes\",\n                    \"name\": \"extraData\",\n                    \"type\": \"bytes\"\n                }\n            ],\n            \"name\": \"ERC20BridgeInitiated\",\n            \"type\": \"event\"\n        },\n    ];\n\n    const balstProvider = new ethers.providers.JsonRpcProvider(\n        \"https://mainnet.mode.network\"\n    );\n\n    const bridgeContractWithdrawal = new ethers.Contract(\n        '0x4200000000000000000000000000000000000010',\n        bridgeAbiWithdrawal,\n        balstProvider\n    );\n\n    const withdrawals = [];\n\n    const filter = type === 1 ? bridgeContractWithdrawal.filters.ETHBridgeInitiated(\n        account,\n        undefined,\n    ) : bridgeContractWithdrawal.filters.ERC20BridgeInitiated(\n        undefined,\n        undefined,\n        account\n    )\n\n    bridgeContractWithdrawal\n        .queryFilter(\n            filter\n        )\n        .then((events) => {\n\n            const event = events.filter(item => item.transactionHash === hash)[0]\n\n            const { args, blockNumber, transactionHash } = event;\n\n            const messagePasserAbi = [\n                \"event MessagePassed (uint256 indexed nonce, address indexed sender, address indexed target, uint256 value, uint256 gasLimit, bytes data, bytes32 withdrawalHash)\",\n            ];\n\n            const messagePasserContract = new ethers.Contract(\n                L2_L1_MESSAGE_PASSER_CONTRACT,\n                messagePasserAbi,\n                balstProvider\n            );\n\n            messagePasserContract\n                .queryFilter(\n                    messagePasserContract.filters.MessagePassed(\n                        undefined,\n                        undefined,\n                        L1_CROSS_DOMAIN_MESSENGER_CONTRACT,\n                        undefined,\n                        undefined,\n                        undefined,\n                        undefined\n                    ),\n                    blockNumber - 150,\n                    blockNumber\n                )\n                .then((events) => {\n\n                    const event = events.filter(\n                        ({ transactionHash }) => {\n                            return hash === transactionHash\n                        }\n                    )[0];\n\n                    const [\n                        messageNonce,\n                        sender,\n                        target,\n                        value,\n                        minGasLimit,\n                        message,\n                        withdrawalHash,\n                    ] = event.args;\n\n                    let withdrawal = {\n                        blockNumber,\n                        transactionHash,\n                        messageNonce,\n                        sender,\n                        target,\n                        value,\n                        minGasLimit,\n                        message,\n                        withdrawalHash,\n                    };\n\n                    balstProvider.getBlock(blockNumber).then((res) => {\n                        const { timestamp } = res;\n                        callback && callback({\n                            ...withdrawal,\n                            timestamp: timestamp * 1000,\n                        })\n                    });\n                });\n        }).catch((e) => {\n            console.log(e)\n        });\n};\n\nconst opProvider = new ethers.providers.JsonRpcProvider(\n    \"https://mainnet.mode.network\"\n);\nconst opProviderOG = new ethers.providers.JsonRpcProvider(\n    \"https://mainnet.mode.network\"\n);\nconst mainnetProvider = new ethers.providers.JsonRpcProvider(\n    \"https://rpc.ankr.com/eth\"\n);\n\nconst HASH_ZERO =\n    \"0x0000000000000000000000000000000000000000000000000000000000000000\";\nconst L2_OUTPUT_ORACLE_CONTRACT = `0x4317ba146D4933D889518a3e5E11Fe7a53199b04`;\nconst L2_L1_MESSAGE_PASSER_CONTRACT = `0x4200000000000000000000000000000000000016`;\nconst L1_OPTIMISM_PORTAL_CONTRACT = `0x8B34b14c7c7123459Cf3076b8Cb929BE097d0C07`;\n\nconst outputAbi = [\n    {\n        inputs: [\n            {\n                internalType: \"uint256\",\n                name: \"_l2BlockNumber\",\n                type: \"uint256\",\n            },\n        ],\n        name: \"getL2OutputIndexAfter\",\n        outputs: [\n            {\n                internalType: \"uint256\",\n                name: \"\",\n                type: \"uint256\",\n            },\n        ],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        stateMutability: \"view\",\n        type: \"function\",\n        inputs: [\n            {\n                name: \"_l2OutputIndex\",\n                internalType: \"uint256\",\n                type: \"uint256\",\n            },\n        ],\n        name: \"getL2Output\",\n        outputs: [\n            {\n                name: \"\",\n                internalType: \"struct Types.OutputProposal\",\n                type: \"tuple\",\n                components: [\n                    {\n                        name: \"outputRoot\",\n                        internalType: \"bytes32\",\n                        type: \"bytes32\",\n                    },\n                    {\n                        name: \"timestamp\",\n                        internalType: \"uint128\",\n                        type: \"uint128\",\n                    },\n                    {\n                        name: \"l2BlockNumber\",\n                        internalType: \"uint128\",\n                        type: \"uint128\",\n                    },\n                ],\n            },\n        ],\n    },\n];\nconst proofAbi = [\n    {\n        inputs: [\n            {\n                components: [\n                    {\n                        internalType: \"uint256\",\n                        name: \"nonce\",\n                        type: \"uint256\",\n                    },\n                    {\n                        internalType: \"address\",\n                        name: \"sender\",\n                        type: \"address\",\n                    },\n                    {\n                        internalType: \"address\",\n                        name: \"target\",\n                        type: \"address\",\n                    },\n                    {\n                        internalType: \"uint256\",\n                        name: \"value\",\n                        type: \"uint256\",\n                    },\n                    {\n                        internalType: \"uint256\",\n                        name: \"gasLimit\",\n                        type: \"uint256\",\n                    },\n                    {\n                        internalType: \"bytes\",\n                        name: \"data\",\n                        type: \"bytes\",\n                    },\n                ],\n                internalType: \"struct Types.WithdrawalTransaction\",\n                name: \"_tx\",\n                type: \"tuple\",\n            },\n            {\n                internalType: \"uint256\",\n                name: \"_l2OutputIndex\",\n                type: \"uint256\",\n            },\n            {\n                components: [\n                    {\n                        internalType: \"bytes32\",\n                        name: \"version\",\n                        type: \"bytes32\",\n                    },\n                    {\n                        internalType: \"bytes32\",\n                        name: \"stateRoot\",\n                        type: \"bytes32\",\n                    },\n                    {\n                        internalType: \"bytes32\",\n                        name: \"messagePasserStorageRoot\",\n                        type: \"bytes32\",\n                    },\n                    {\n                        internalType: \"bytes32\",\n                        name: \"latestBlockhash\",\n                        type: \"bytes32\",\n                    },\n                ],\n                internalType: \"struct Types.OutputRootProof\",\n                name: \"_outputRootProof\",\n                type: \"tuple\",\n            },\n            {\n                internalType: \"bytes[]\",\n                name: \"_withdrawalProof\",\n                type: \"bytes[]\",\n            },\n        ],\n        name: \"proveWithdrawalTransaction\",\n        outputs: [],\n        stateMutability: \"nonpayable\",\n        type: \"function\",\n    },\n    {\n        stateMutability: \"nonpayable\",\n        type: \"function\",\n        inputs: [\n            {\n                name: \"_tx\",\n                internalType: \"struct Types.WithdrawalTransaction\",\n                type: \"tuple\",\n                components: [\n                    {\n                        name: \"nonce\",\n                        internalType: \"uint256\",\n                        type: \"uint256\",\n                    },\n                    {\n                        name: \"sender\",\n                        internalType: \"address\",\n                        type: \"address\",\n                    },\n                    {\n                        name: \"target\",\n                        internalType: \"address\",\n                        type: \"address\",\n                    },\n                    {\n                        name: \"value\",\n                        internalType: \"uint256\",\n                        type: \"uint256\",\n                    },\n                    {\n                        name: \"gasLimit\",\n                        internalType: \"uint256\",\n                        type: \"uint256\",\n                    },\n                    {\n                        name: \"data\",\n                        internalType: \"bytes\",\n                        type: \"bytes\",\n                    },\n                ],\n            },\n        ],\n        name: \"finalizeWithdrawalTransaction\",\n        outputs: [],\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"uint256\",\n                \"name\": \"_l2OutputIndex\",\n                \"type\": \"uint256\"\n            }\n        ],\n        \"name\": \"isOutputFinalized\",\n        \"outputs\": [\n            {\n                \"internalType\": \"bool\",\n                \"name\": \"\",\n                \"type\": \"bool\"\n            }\n        ],\n        \"stateMutability\": \"view\",\n        \"type\": \"function\"\n    },\n];\nconst outputIface = new ethers.utils.Interface(outputAbi);\n\nconst getMessageBedrockOutput = (l2BlockNumber, callback, onError) => {\n    const contract = new ethers.Contract(\n        L2_OUTPUT_ORACLE_CONTRACT,\n        outputAbi,\n        mainnetProvider\n    );\n\n    contract\n        .getL2OutputIndexAfter(l2BlockNumber)\n        .then((l2OutputIndex) => {\n\n            contract\n                .getL2Output(l2OutputIndex.toString())\n                .then((proposal) => {\n\n                    callback({\n                        outputRoot: proposal[0],\n                        l1Timestamp: proposal[1].toNumber(),\n                        l2BlockNumber: proposal[2].toNumber(),\n                        l2OutputIndex: l2OutputIndex.toNumber(),\n                    });\n                })\n                .catch((e) => {\n                    console.log(\"view error 2:\", e);\n                    onError();\n                });\n        })\n        .catch((e) => {\n            console.log(\"view error 1:\", e);\n            onError();\n        });\n};\n\nconst hashLowLevelMessage = (withdrawal) => {\n    const types = [\n        \"uint256\",\n        \"address\",\n        \"address\",\n        \"uint256\",\n        \"uint256\",\n        \"bytes\",\n    ];\n    const encoded = ethers.utils.defaultAbiCoder.encode(types, [\n        withdrawal.messageNonce,\n        withdrawal.sender,\n        withdrawal.target,\n        withdrawal.value,\n        withdrawal.minGasLimit,\n        withdrawal.message,\n    ]);\n    return ethers.utils.keccak256(encoded);\n};\n\nconst hashMessageHash = (messageHash) => {\n    const data = ethers.utils.defaultAbiCoder.encode(\n        [\"bytes32\", \"uint256\"],\n        [ethers.utils.hexlify(messageHash), HASH_ZERO]\n    );\n    return ethers.utils.keccak256(data);\n};\n\nconst getBedrockMessageProof = (l2BlockNumber, slot, callback) => {\n    opProviderOG\n        .send(\"eth_getProof\", [\n            L2_L1_MESSAGE_PASSER_CONTRACT,\n            [slot],\n            l2BlockNumber,\n        ])\n        .then((proof) => {\n            const stateTrieProof = {\n                accountProof: proof.accountProof,\n                storageProof: proof.storageProof[0].proof,\n                storageValue: Big(parseInt(proof.storageProof[0].value)),\n                storageRoot: proof.storageHash,\n            };\n\n            opProvider\n                .send(\"eth_getBlockByNumber\", [l2BlockNumber, false])\n                .then((block) => {\n\n                    callback({\n                        outputRootProof: {\n                            version: HASH_ZERO,\n                            stateRoot: block.stateRoot,\n                            messagePasserStorageRoot: stateTrieProof.storageRoot,\n                            latestBlockhash: block.hash,\n                        },\n                        withdrawalProof: stateTrieProof.storageProof,\n                    });\n                });\n        })\n        .catch(onError);\n};\n\nconst handleWithdrawalProve = (withdrawal, onSuccess, onError) => {\n\n    getMessageBedrockOutput(withdrawal.blockNumber, (output) => {\n        const hash = hashLowLevelMessage(withdrawal);\n        const messageSlot = hashMessageHash(hash);\n        const l2BlockNumber = ethers.utils.hexlify(output.l2BlockNumber);\n\n        getBedrockMessageProof(l2BlockNumber, messageSlot, (proof) => {\n            const args = [\n                [\n                    withdrawal.messageNonce,\n                    withdrawal.sender,\n                    withdrawal.target,\n                    withdrawal.value,\n                    withdrawal.minGasLimit,\n                    withdrawal.message,\n                ],\n                output.l2OutputIndex,\n                [\n                    proof.outputRootProof.version,\n                    proof.outputRootProof.stateRoot,\n                    proof.outputRootProof.messagePasserStorageRoot,\n                    proof.outputRootProof.latestBlockhash,\n                ],\n                proof.withdrawalProof,\n            ];\n\n            const contract = new ethers.Contract(\n                L1_OPTIMISM_PORTAL_CONTRACT,\n                proofAbi,\n                Ethers.provider().getSigner()\n            );\n\n            contract\n                .proveWithdrawalTransaction(...args)\n                .then((tx) => {\n                    tx.wait().then(onSuccess).catch(onError);\n                })\n                .catch((e) => {\n                    onError();\n                    console.log(\"error\", e);\n                });\n        });\n    }, onError);\n};\n\nfunction checkOutputFinalized(withdrawal, onSuccess, onError) {\n    getMessageBedrockOutput(withdrawal.blockNumber, (output) => {\n        const contract = new ethers.Contract(\n            L1_OPTIMISM_PORTAL_CONTRACT,\n            proofAbi,\n            mainnetProvider\n        );\n\n        contract.isOutputFinalized(output.l2OutputIndex).then(isFinalized => {\n            onSuccess(isFinalized)\n        }).catch(onError)\n\n    }, onError)\n}\n\nconst handleWithdrawalClaim = (withdrawal, onSuccess, onError) => {\n\n    const args = [\n        withdrawal.messageNonce,\n        withdrawal.sender,\n        withdrawal.target,\n        withdrawal.value,\n        withdrawal.minGasLimit,\n        withdrawal.message,\n    ];\n\n    const contract = new ethers.Contract(\n        L1_OPTIMISM_PORTAL_CONTRACT,\n        proofAbi,\n        Ethers.provider().getSigner()\n    );\n\n    contract\n        .finalizeWithdrawalTransaction(args)\n        .then((tx) => {\n            tx.wait().then(onSuccess).catch(onError);\n        })\n        .catch((e) => {\n            console.log(\"error\", e);\n            onError();\n        });\n};\n\nconst checkMessageOutput = (l2BlockNumber, callback) => {\n    const contract = new ethers.Contract(\n        L2_OUTPUT_ORACLE_CONTRACT,\n        outputAbi,\n        mainnetProvider\n    );\n\n    contract\n        .getL2OutputIndexAfter(l2BlockNumber)\n        .then((l2OutputIndex) => {\n            callback(l2OutputIndex)\n        })\n        .catch(e => {\n            callback(null)\n        })\n}\n\nreturn {\n    getETHWithdrawalsFromOp,\n    handleWithdrawalProve,\n    checkOutputFinalized,\n    handleWithdrawalClaim,\n    checkMessageOutput,\n}", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/bluebiu.near/widget/Mode.BridgeAuthority.Util", "fact_widget_deployments_id": "0e5f34b48e1cb2ef90ea6ab2923f09a6", "inserted_timestamp": "2024-05-16T09:49:49.384Z", "modified_timestamp": "2024-05-16T09:49:49.384Z", "__row_index": 0}