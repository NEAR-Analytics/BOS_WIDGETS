{"tx_hash": "AVSw4bUfpythCMCChe12ufhedRgJYPMSdKWUE9gmg71i", "action_id_social": "36QqGB4Rvzfms9gsRydsmDspPhGeVnUSGHKZJRLKhRau-0-widget", "block_id": 117561912, "block_timestamp": "2024-04-25T02:20:10.269Z", "signer_id": "bluebiu.near", "widget_name": "Swap.Data.ThrusterFinance", "source_code": "const ROUTER_ABI = [\n  {\n    inputs: [\n      {\n        components: [\n          { internalType: \"bytes\", name: \"path\", type: \"bytes\" },\n          { internalType: \"address\", name: \"recipient\", type: \"address\" },\n          { internalType: \"uint256\", name: \"deadline\", type: \"uint256\" },\n          { internalType: \"uint256\", name: \"amountIn\", type: \"uint256\" },\n          {\n            internalType: \"uint256\",\n            name: \"amountOutMinimum\",\n            type: \"uint256\",\n          },\n        ],\n        internalType: \"struct ISwapRouter.ExactInputParams\",\n        name: \"params\",\n        type: \"tuple\",\n      },\n    ],\n    name: \"exactInput\",\n    outputs: [{ internalType: \"uint256\", name: \"amountOut\", type: \"uint256\" }],\n    stateMutability: \"payable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"uint256\", name: \"amountMinimum\", type: \"uint256\" },\n      { internalType: \"address\", name: \"recipient\", type: \"address\" },\n    ],\n    name: \"unwrapWETH9\",\n    outputs: [],\n    stateMutability: \"payable\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"bytes[]\", name: \"data\", type: \"bytes[]\" }],\n    name: \"multicall\",\n    outputs: [{ internalType: \"bytes[]\", name: \"results\", type: \"bytes[]\" }],\n    stateMutability: \"payable\",\n    type: \"function\",\n  },\n];\nconst {\n  updater,\n  wethAddress,\n  inputCurrency,\n  outputCurrency,\n  inputCurrencyAmount,\n  onLoad,\n  slippage,\n  account,\n  routerAddress,\n  prices,\n} = props;\n\nuseEffect(() => {\n  if (!updater) return;\n\n  if (\n    (!inputCurrency.address && !inputCurrency.isNative) ||\n    (!outputCurrency.address && !outputCurrency.isNative) ||\n    !inputCurrencyAmount\n  ) {\n    return;\n  }\n\n  const wrapType =\n    inputCurrency.isNative && outputCurrency.address === wethAddress\n      ? 1\n      : inputCurrency.address === wethAddress && outputCurrency.isNative\n      ? 2\n      : 0;\n\n  if (wrapType) {\n    const WethContract = new ethers.Contract(\n      wethAddress,\n      [\n        {\n          constant: false,\n          inputs: [],\n          name: \"deposit\",\n          outputs: [],\n          payable: true,\n          stateMutability: \"payable\",\n          type: \"function\",\n        },\n        {\n          constant: false,\n          inputs: [{ internalType: \"uint256\", name: \"wad\", type: \"uint256\" }],\n          name: \"withdraw\",\n          outputs: [],\n          payable: false,\n          stateMutability: \"nonpayable\",\n          type: \"function\",\n        },\n      ],\n      Ethers.provider().getSigner()\n    );\n    let params = [];\n    let options = {};\n    let method = \"\";\n    if (wrapType === 1) {\n      method = \"deposit\";\n      options.value = ethers.utils.parseEther(\n        Big(inputCurrencyAmount).toFixed(18).toString()\n      );\n    } else {\n      method = \"withdraw\";\n      params = [\n        ethers.utils.parseEther(\n          Big(inputCurrencyAmount).toFixed(18).toString()\n        ),\n      ];\n    }\n    const returnData = {\n      inputCurrency,\n      inputCurrencyAmount,\n      outputCurrency,\n      outputCurrencyAmount: inputCurrencyAmount,\n      noPair: false,\n      routes: null,\n      routerStr: \"\",\n      gas: \"\",\n    };\n    const getTx = (_gas) => {\n      WethContract.populateTransaction[method](...params, {\n        ...options,\n        gasLimit: _gas || 4000000,\n      })\n        .then((res) => {\n          onLoad({\n            ...returnData,\n            gas: _gas,\n            unsignedTx: res,\n          });\n        })\n        .catch((err) => {\n          onLoad({\n            ...returnData,\n          });\n        });\n    };\n    const estimateGas = () => {\n      WethContract.estimateGas[method](...params, options)\n        .then((_gas) => {\n          getTx(_gas);\n        })\n        .catch((err) => {\n          console.log(err);\n          getTx();\n        });\n    };\n    estimateGas();\n    return;\n  }\n\n  const amount = ethers.utils.parseUnits(\n    Big(inputCurrencyAmount || 0).toFixed(inputCurrency.decimals),\n    inputCurrency.decimals\n  );\n\n  const path = [\n    inputCurrency.isNative ? wethAddress : inputCurrency.address,\n    outputCurrency.isNative ? wethAddress : outputCurrency.address,\n  ];\n\n  const getTokenSymbol = (tokens, str, cb) => {\n    if (tokens.length === 0) {\n      cb(str);\n      return;\n    }\n    const TokenContract = new ethers.Contract(\n      tokens.pop(),\n      [\n        {\n          inputs: [],\n          name: \"symbol\",\n          outputs: [{ internalType: \"string\", name: \"\", type: \"string\" }],\n          stateMutability: \"view\",\n          type: \"function\",\n        },\n      ],\n      Ethers.provider().getSigner()\n    );\n    TokenContract.symbol().then((res) => {\n      str += ` > ${res}`;\n      if (tokens.length) {\n        getTokenSymbol(tokens, str);\n      } else {\n        cb(str);\n      }\n    });\n  };\n\n  const getAmountsOut = () => {\n    const params = `amount=${amount}&tokenIn=${path[0].toLowerCase()}&tokenOut=${path[1].toLowerCase()}&type=EXACT_INPUT&chainId=${\n      inputCurrency.chainId\n    }`;\n\n    asyncFetch(`https://api.thruster.finance/quote?${params}`)\n      .then((res) => {\n        const data = res.body?.bestQuote;\n\n        if (!data) {\n          onLoad({\n            inputCurrency,\n            inputCurrencyAmount,\n            outputCurrency,\n            outputCurrencyAmount: \"\",\n            noPair: true,\n          });\n          return;\n        }\n        const tokens = [];\n        for (let i = 0, len = data.route.length; i < len - 1; i++) {\n          tokens.push(data.route[i].tokenOut);\n        }\n\n        let routerStr = \"\";\n        getTokenSymbol(tokens, routerStr, (str) => {\n          const routerStr = `${inputCurrency.symbol} ${str} > ${outputCurrency.symbol}`;\n\n          getTransaction({\n            inputCurrency,\n            inputCurrencyAmount,\n            outputCurrency,\n            priceImpact: data.priceImpact * 100,\n            outputCurrencyAmount: Big(data.quote)\n              .div(Big(10).pow(outputCurrency.decimals))\n              .toFixed(outputCurrency.decimals),\n            noPair: false,\n            routerStr,\n            routes: data.route,\n          });\n        });\n      })\n      .catch((err) => {\n        onLoad({\n          inputCurrency,\n          inputCurrencyAmount,\n          outputCurrency,\n          outputCurrencyAmount: \"\",\n          noPair: true,\n        });\n      });\n  };\n\n  const getTransaction = (params) => {\n    const { routes, ...rest } = params;\n    const RouterContract = new ethers.Contract(\n      routerAddress,\n      ROUTER_ABI,\n      Ethers.provider().getSigner()\n    );\n    let _pathTypes = [\"address\"];\n    let _path = [path[0]];\n    routes.forEach((route, i) => {\n      _pathTypes.push(\"uint24\");\n      _path.push(route.feeTier * 1000000);\n      _pathTypes.push(\"address\");\n      _path.push(route.tokenOut);\n    });\n\n    const deadline = Math.ceil(Date.now() / 1000) + 60;\n    const _amountOut = Big(params.outputCurrencyAmount)\n      .mul(Big(10).pow(outputCurrency.decimals))\n      .mul(1 - (slippage || 0.005))\n      .toFixed(0);\n    const Iface = new ethers.utils.Interface(ROUTER_ABI);\n    const calldatas = [];\n    const options = {\n      value: inputCurrency.isNative ? amount : 0,\n    };\n    calldatas.push(\n      Iface.encodeFunctionData(\"exactInput\", [\n        {\n          path: ethers.utils.solidityPack(_pathTypes, _path),\n          recipient: outputCurrency.isNative ? routerAddress : account,\n          deadline,\n          amountIn: amount,\n          amountOutMinimum: _amountOut,\n        },\n      ])\n    );\n    if (outputCurrency.isNative) {\n      calldatas.push(Iface.encodeFunctionData(\"unwrapWETH9\", [\"0\", account]));\n    }\n\n    const getTx = (_gas) => {\n      RouterContract.populateTransaction\n        .multicall(calldatas, {\n          ...options,\n          gasLimit: _gas,\n        })\n        .then((res) => {\n          onLoad({\n            ...rest,\n            noPair: false,\n            gas: _gas,\n            unsignedTx: res,\n          });\n        })\n        .catch((err) => {\n          onLoad({\n            ...rest,\n            noPair: false,\n            gas: _gas,\n          });\n        });\n    };\n    const estimateGas = () => {\n      RouterContract.estimateGas\n        .multicall(calldatas, options)\n        .then((_gas) => {\n          getTx(_gas);\n        })\n        .catch((err) => {\n          getTx();\n        });\n    };\n\n    estimateGas();\n  };\n  getAmountsOut();\n}, [updater]);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/bluebiu.near/widget/Swap.Data.ThrusterFinance", "fact_widget_deployments_id": "803eebf4bccb3360c7a959f33750c407", "inserted_timestamp": "2024-04-25T04:04:00.243Z", "modified_timestamp": "2024-04-25T04:04:00.243Z", "__row_index": 1}