{"tx_hash": "AJzVXXEr7tAvLDdQJzFPzCvJZer4b7ZqoE5vmKprifS9", "action_id_social": "BmddhkK4D4hYCxxGJjYEy5KiUo3Kqwz42wkFrE3NRSxu-0-widget", "block_id": 109558422, "block_timestamp": "2024-01-04T09:01:49.803Z", "signer_id": "bluebiu.near", "widget_name": "Linea.Swap.IziSwapAmountOut", "source_code": "const QUOTER_ABI = [\n  {\n    inputs: [\n      {\n        internalType: \"bytes[]\",\n        name: \"data\",\n        type: \"bytes[]\",\n      },\n    ],\n    name: \"multicall\",\n    outputs: [\n      {\n        internalType: \"bytes[]\",\n        name: \"results\",\n        type: \"bytes[]\",\n      },\n    ],\n    stateMutability: \"payable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"tokenX\",\n        type: \"address\",\n      },\n      {\n        internalType: \"address\",\n        name: \"tokenY\",\n        type: \"address\",\n      },\n      {\n        internalType: \"uint24\",\n        name: \"fee\",\n        type: \"uint24\",\n      },\n      {\n        internalType: \"uint128\",\n        name: \"amount\",\n        type: \"uint128\",\n      },\n      {\n        internalType: \"int24\",\n        name: \"lowPt\",\n        type: \"int24\",\n      },\n    ],\n    name: \"swapX2Y\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"amountY\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"int24\",\n        name: \"finalPoint\",\n        type: \"int24\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"tokenX\",\n        type: \"address\",\n      },\n      {\n        internalType: \"address\",\n        name: \"tokenY\",\n        type: \"address\",\n      },\n      {\n        internalType: \"uint24\",\n        name: \"fee\",\n        type: \"uint24\",\n      },\n      {\n        internalType: \"uint128\",\n        name: \"amount\",\n        type: \"uint128\",\n      },\n      {\n        internalType: \"int24\",\n        name: \"highPt\",\n        type: \"int24\",\n      },\n    ],\n    name: \"swapY2X\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"amountX\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"int24\",\n        name: \"finalPoint\",\n        type: \"int24\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n];\nconst ROUTER_ABI = [\n  {\n    inputs: [\n      {\n        components: [\n          {\n            internalType: \"address\",\n            name: \"tokenX\",\n            type: \"address\",\n          },\n          {\n            internalType: \"address\",\n            name: \"tokenY\",\n            type: \"address\",\n          },\n          {\n            internalType: \"uint24\",\n            name: \"fee\",\n            type: \"uint24\",\n          },\n          {\n            internalType: \"int24\",\n            name: \"boundaryPt\",\n            type: \"int24\",\n          },\n          {\n            internalType: \"address\",\n            name: \"recipient\",\n            type: \"address\",\n          },\n          {\n            internalType: \"uint128\",\n            name: \"amount\",\n            type: \"uint128\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"maxPayed\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"minAcquired\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"deadline\",\n            type: \"uint256\",\n          },\n        ],\n        internalType: \"struct Swap.SwapParams\",\n        name: \"swapParams\",\n        type: \"tuple\",\n      },\n    ],\n    name: \"swapX2Y\",\n    outputs: [],\n    stateMutability: \"payable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            internalType: \"address\",\n            name: \"tokenX\",\n            type: \"address\",\n          },\n          {\n            internalType: \"address\",\n            name: \"tokenY\",\n            type: \"address\",\n          },\n          {\n            internalType: \"uint24\",\n            name: \"fee\",\n            type: \"uint24\",\n          },\n          {\n            internalType: \"int24\",\n            name: \"boundaryPt\",\n            type: \"int24\",\n          },\n          {\n            internalType: \"address\",\n            name: \"recipient\",\n            type: \"address\",\n          },\n          {\n            internalType: \"uint128\",\n            name: \"amount\",\n            type: \"uint128\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"maxPayed\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"minAcquired\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"deadline\",\n            type: \"uint256\",\n          },\n        ],\n        internalType: \"struct Swap.SwapParams\",\n        name: \"swapParams\",\n        type: \"tuple\",\n      },\n    ],\n    name: \"swapY2X\",\n    outputs: [],\n    stateMutability: \"payable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"uint256\",\n        name: \"minAmount\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"address\",\n        name: \"recipient\",\n        type: \"address\",\n      },\n    ],\n    name: \"unwrapWETH9\",\n    outputs: [],\n    stateMutability: \"payable\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"bytes[]\", name: \"data\", type: \"bytes[]\" }],\n    name: \"multicall\",\n    outputs: [{ internalType: \"bytes[]\", name: \"results\", type: \"bytes[]\" }],\n    stateMutability: \"payable\",\n    type: \"function\",\n  },\n];\n\nconst {\n  updater,\n  routerAddress,\n  quoterAddress,\n  multicallAddress,\n  wethAddress,\n  inputCurrency,\n  outputCurrency,\n  inputCurrencyAmount,\n  onLoad,\n  slippage,\n  account,\n  fees,\n} = props;\n\nconst prices = Storage.get(\n  \"tokensPrice\",\n  \"dapdapbos.near/widget/Linea.Uniswap.Swap.TokensPrice\"\n);\n\nuseEffect(() => {\n  if (!updater || !prices) return;\n\n  if (\n    (!inputCurrency.address && !inputCurrency.isNative) ||\n    (!outputCurrency.address && !outputCurrency.isNative) ||\n    !inputCurrencyAmount\n  ) {\n    return;\n  }\n\n  const wrapType =\n    inputCurrency.address === \"native\" && outputCurrency.address === wethAddress\n      ? 1\n      : inputCurrency.address === wethAddress &&\n        outputCurrency.address === \"native\"\n      ? 2\n      : 0;\n\n  if (wrapType) {\n    onLoad({\n      outputCurrencyAmount: inputCurrencyAmount,\n      noPair: false,\n    });\n    return;\n  }\n\n  const amount = ethers.utils.parseUnits(\n    Big(inputCurrencyAmount || 0).toFixed(inputCurrency.decimals),\n    inputCurrency.decimals\n  );\n\n  const path = [\n    inputCurrency.isNative ? wethAddress : inputCurrency.address,\n    outputCurrency.isNative ? wethAddress : outputCurrency.address,\n  ];\n\n  const isX2Y = path[0].toLowerCase() < path[1].toLowerCase();\n\n  const Iface = new ethers.utils.Interface(QUOTER_ABI);\n\n  const results = [];\n  let _count = 0;\n  const singleQuote = (fee, cb) => {\n    const params = [\n      isX2Y ? path[0] : path[1],\n      isX2Y ? path[1] : path[0],\n      fee,\n      amount,\n      isX2Y ? -799999 : 799999,\n    ];\n    const method = isX2Y ? \"swapX2Y\" : \"swapY2X\";\n\n    const encodedData = Iface.encodeFunctionData(method, params);\n\n    Ethers.provider()\n      .call({\n        to: quoterAddress,\n        data: encodedData,\n      })\n      .then((res) => {\n        const data = Iface.decodeFunctionResult(method, res);\n\n        const amountName = isX2Y ? \"amountY\" : \"amountX\";\n\n        results.push({\n          amountOut: data[amountName],\n          fee,\n        });\n\n        _count++;\n        if (_count === fees.length) {\n          cb();\n        }\n      })\n      .catch((err) => {\n        _count++;\n        if (_count === fees.length) {\n          cb();\n        }\n      });\n  };\n  const getAmountOut = () => {\n    let max = {};\n    results.forEach((result) => {\n      if (\n        Big(Number(result.amountOut._hex)).gt(Number(max.amountOut?._hex) || 0)\n      ) {\n        max = result;\n      }\n    });\n    getTransaction(max);\n  };\n\n  const getTransaction = (result) => {\n    const RouterIface = new ethers.utils.Interface(ROUTER_ABI);\n    const deadline = Math.ceil(Date.now() / 1000) + 60;\n    const options = {\n      value: inputCurrency.isNative ? amount : \"0\",\n    };\n    const _amountOut = Big(result.amountOut)\n      .mul(1 - (slippage || 0.05))\n      .toFixed(0);\n\n    const method = isX2Y ? \"swapX2Y\" : \"swapY2X\";\n\n    const inputs = [\n      {\n        tokenX: isX2Y ? path[0] : path[1],\n        tokenY: isX2Y ? path[1] : path[0],\n        fee: result.fee,\n        boundaryPt: isX2Y ? -799999 : 799999,\n        recipient: outputCurrency.isNative ? routerAddress : account,\n        amount: amount,\n        maxPayed: \"0\",\n        minAcquired: _amountOut,\n        deadline: deadline,\n      },\n    ];\n\n    const multicallParams = [];\n    const encodedDataCallSwap = RouterIface.encodeFunctionData(method, inputs);\n    multicallParams.push(encodedDataCallSwap);\n\n    if (outputCurrency.isNative === \"native\") {\n      multicallParams.push(\n        RouterIface.encodeFunctionData(\"unwrapWETH9\", [\"0\", account])\n      );\n    }\n\n    const multicallContract = new ethers.Contract(\n      routerAddress,\n      ROUTER_ABI,\n      Ethers.provider().getSigner()\n    );\n\n    const _amount = Big(\n      ethers.utils.formatUnits(result.amountOut, outputCurrency.decimals)\n    );\n\n    let priceImpact = null;\n\n    if (prices) {\n      const isReverse =\n        Number(inputCurrency.address) > Number(outputCurrency.address);\n\n      const poolPrice = Big(\n        prices[!isReverse ? inputCurrency.symbol : outputCurrency.symbol] || 0\n      ).div(\n        prices[isReverse ? inputCurrency.symbol : outputCurrency.symbol] || 0\n      );\n      const amountoutPrice = !isReverse\n        ? Big(inputCurrencyAmount).div(_amount)\n        : Big(_amount).div(inputCurrencyAmount);\n\n      priceImpact = poolPrice\n        .minus(amountoutPrice)\n        .div(poolPrice)\n        .mul(100)\n        .toString();\n    }\n\n    const returnData = {\n      outputCurrencyAmount: Big(_amount).gt(0.01)\n        ? Big(_amount).toPrecision(10)\n        : Big(_amount).toFixed(10),\n      priceImpact,\n      noPair: false,\n    };\n\n    multicallContract.estimateGas\n      .multicall(multicallParams, options)\n      .then((gas) => {\n        multicallContract.populateTransaction\n          .multicall(multicallParams, { ...options, gasLimit: gas })\n          .then((res) => {\n            onLoad({\n              ...returnData,\n              gas,\n              unsignedTx: res,\n            });\n          })\n          .catch((err) => {\n            onLoad({\n              ...returnData,\n              gas,\n            });\n          });\n      })\n      .catch((err) => {\n        onLoad({\n          ...returnData,\n        });\n      });\n  };\n\n  (fees || []).forEach((fee) => {\n    singleQuote(fee, getAmountOut);\n  });\n}, [updater, prices]);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/bluebiu.near/widget/Linea.Swap.IziSwapAmountOut", "fact_widget_deployments_id": "498b3d8c30c11f885bb0dd92e7ed2707", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 9}