{"tx_hash": "8dUz2UNzQVAETmQf1VpwHqVxHsjGE5xZfb9CdJRtKaKb", "action_id_social": "ChbS8PSjdy8r8DCy92oBu1PWhEmeAsKHnU8CswE2KuLq-0-widget", "block_id": 120989720, "block_timestamp": "2024-06-12T08:15:07.028Z", "signer_id": "bluebiu.near", "widget_name": "Lending.Data.Liquity", "source_code": "const {\n  multicallAddress,\n  multicall,\n  account,\n  prices,\n  dexConfig,\n  update,\n  onLoad,\n  IS_ETHOS_DAPP,\n  IS_PREON_DAPP,\n  IS_GRAVITA_DAPP,\n} = props;\nconst { borrowTokenAddress, StabilityPool, VesselManagerOperations, markets } =\n  dexConfig;\n\nuseEffect(() => {\n  if (!account || !update || !multicallAddress) return;\n\n  function getDebt() {\n    const _contract = dexConfig.VesselManager;\n\n    let abi;\n    let calls;\n    const tokens = Object.keys(dexConfig.markets);\n    if (IS_ETHOS_DAPP) {\n      abi = [\n        {\n          inputs: [\n            { internalType: \"address\", name: \"_borrower\", type: \"address\" },\n            { internalType: \"address\", name: \"_collateral\", type: \"address\" },\n          ],\n          name: \"getTroveDebt\",\n          outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n          stateMutability: \"view\",\n          type: \"function\",\n        },\n      ];\n      calls = tokens.map((addr) => ({\n        address: _contract,\n        name: \"getTroveDebt\",\n        params: [account, addr],\n      }));\n    }\n    if (IS_PREON_DAPP || IS_GRAVITA_DAPP) {\n      abi = [\n        {\n          inputs: [\n            { internalType: \"address\", name: \"_asset\", type: \"address\" },\n            { internalType: \"address\", name: \"_borrower\", type: \"address\" },\n          ],\n          name: \"getVesselDebt\",\n          outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n          stateMutability: \"view\",\n          type: \"function\",\n        },\n      ];\n      calls = tokens.map((addr) => ({\n        address: _contract,\n        name: \"getVesselDebt\",\n        params: [addr, account],\n      }));\n    }\n\n    multicall({\n      abi,\n      calls,\n      options: {},\n      multicallAddress,\n      provider: Ethers.provider(),\n    })\n      .then((res) => {\n        console.log(\"getDebt_res\", res);\n        for (let i = 0, len = res.length; i < len; i++) {\n          const _vesselStatus = res[i] ? \"ACTIVE\" : \"INACTIVE\";\n          const _vesselDebt =\n            res[i] && res[i][0] ? ethers.utils.formatUnits(res[i][0]) - 20 : 0;\n          markets[tokens[i]].vesselStatus = _vesselStatus;\n          markets[tokens[i]].vesselDebt = _vesselDebt;\n        }\n\n        onLoad({\n          newMarkets: markets,\n        });\n      })\n      .catch((err) => {\n        console.log(\"getDebt_error:\", err);\n      });\n  }\n\n  function getMarketDeposit() {\n    const _contract = dexConfig.VesselManager;\n\n    let abi;\n    let calls;\n    const tokens = Object.keys(dexConfig.markets);\n    if (IS_ETHOS_DAPP) {\n      abi = [\n        {\n          inputs: [\n            { internalType: \"address\", name: \"_borrower\", type: \"address\" },\n            { internalType: \"address\", name: \"_collateral\", type: \"address\" },\n          ],\n          name: \"getTroveColl\",\n          outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n          stateMutability: \"view\",\n          type: \"function\",\n        },\n      ];\n      calls = tokens.map((addr) => ({\n        address: _contract,\n        name: \"getTroveColl\",\n        params: [account, addr],\n      }));\n    }\n    if (IS_PREON_DAPP || IS_GRAVITA_DAPP) {\n      abi = [\n        {\n          inputs: [\n            { internalType: \"address\", name: \"_asset\", type: \"address\" },\n            { internalType: \"address\", name: \"_borrower\", type: \"address\" },\n          ],\n          name: \"getVesselColl\",\n          outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n          stateMutability: \"view\",\n          type: \"function\",\n        },\n      ];\n      calls = tokens.map((addr) => ({\n        address: _contract,\n        name: \"getVesselColl\",\n        params: [addr, account],\n      }));\n    }\n\n    multicall({\n      abi,\n      calls,\n      options: {},\n      multicallAddress,\n      provider: Ethers.provider(),\n    })\n      .then((res) => {\n        console.log(\"getMarketDeposit_res\", res);\n        for (let i = 0, len = res.length; i < len; i++) {\n          const _vesselDeposit =\n            res[i] && res[i][0] ? ethers.utils.formatUnits(res[i][0]._hex) : 0;\n\n          markets[tokens[i]].vesselDeposit = _vesselDeposit;\n        }\n\n        onLoad({\n          newMarkets: markets,\n        });\n      })\n      .catch((err) => {\n        console.log(\"getMarketDeposit_error:\", err);\n      });\n  }\n\n  function getStableDeposit() {\n    const contract = new ethers.Contract(\n      StabilityPool,\n      [\n        {\n          inputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n          name: \"deposits\",\n          outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n          stateMutability: \"view\",\n          type: \"function\",\n        },\n      ],\n      Ethers.provider()\n    );\n    contract\n      .deposits(account)\n      .then((res) => {\n        console.log(\"get_deposits_res:\", res);\n        onLoad({\n          deposits: ethers.utils.formatUnits(res),\n        });\n      })\n      .catch((err) => {\n        console.log(\"getDeposit_error\", err);\n      });\n  }\n\n  function getInfo() {\n    const calls = [\n      {\n        address: borrowTokenAddress,\n        name: \"balanceOf\",\n        params: [StabilityPool],\n      },\n      { address: borrowTokenAddress, name: \"balanceOf\", params: [account] },\n    ];\n    multicall({\n      abi: [\n        {\n          constant: true,\n          inputs: [\n            {\n              name: \"_owner\",\n              type: \"address\",\n            },\n          ],\n          name: \"balanceOf\",\n          outputs: [\n            {\n              name: \"balance\",\n              type: \"uint256\",\n            },\n          ],\n          payable: false,\n          stateMutability: \"view\",\n          type: \"function\",\n        },\n      ],\n      calls,\n      options: {},\n      multicallAddress,\n      provider: Ethers.provider(),\n    })\n      .then((res) => {\n        const [[tvlAmount], [tokenBalAmount]] = res;\n        console.log(\"get_borrow_token_res\", tvlAmount, tokenBalAmount);\n        onLoad({\n          tvl: Big(ethers.utils.formatUnits(tvlAmount || 0)).toFixed(2),\n          tokenBal: Big(ethers.utils.formatUnits(tokenBalAmount || 0)).toFixed(\n            2\n          ),\n        });\n      })\n      .catch((err) => {\n        console.log(\"get_borrow_token_error:\", err);\n      });\n  }\n\n  function getWalletBalance() {\n    if (!markets) return;\n    let nativeOToken = \"\";\n    const underlyingTokens = Object.values(markets)\n      .filter((market) => {\n        if (market.underlyingToken.address === \"native\")\n          nativeOToken = wethAddress;\n        return (\n          market.underlyingToken.address &&\n          market.underlyingToken.address !== \"native\"\n        );\n      })\n      .map((market) => ({\n        ...market.underlyingToken,\n      }));\n    const calls = underlyingTokens.map((token) => ({\n      address: token.address,\n      name: \"balanceOf\",\n      params: [account],\n    }));\n\n    multicall({\n      abi: [\n        {\n          constant: true,\n          inputs: [\n            {\n              name: \"_owner\",\n              type: \"address\",\n            },\n          ],\n          name: \"balanceOf\",\n          outputs: [\n            {\n              name: \"balance\",\n              type: \"uint256\",\n            },\n          ],\n          payable: false,\n          stateMutability: \"view\",\n          type: \"function\",\n        },\n      ],\n      calls,\n      options: {},\n      multicallAddress,\n      provider: Ethers.provider(),\n    })\n      .then((res) => {\n        console.log(\"get_wallet_bal_res:\", res);\n        for (let i = 0, len = res.length; i < len; i++) {\n          markets[underlyingTokens[i].address].userUnderlyingBalance = res[i][0]\n            ? ethers.utils.formatUnits(\n                res[i][0]._hex,\n                underlyingTokens[i].decimals\n              )\n            : \"0\";\n        }\n\n        if (nativeOToken) {\n          const provider = Ethers.provider();\n          provider.getBalance(account).then((rawBalance) => {\n            markets[nativeOToken].userUnderlyingBalance =\n              ethers.utils.formatUnits(rawBalance._hex, 18);\n          });\n        }\n\n        onLoad({\n          newMarkets: markets,\n        });\n      })\n      .catch((err) => {\n        console.log(\"getWalletBalance_error\", err);\n      });\n  }\n\n  function getMinted() {\n    const underlyingTokens = Object.values(markets);\n\n    const calls = underlyingTokens.map((item) => ({\n      address: VesselManagerOperations,\n      name: \"getEntireSystemDebt\",\n      params: [item.underlyingToken.address],\n    }));\n\n    multicall({\n      abi: [\n        {\n          inputs: [\n            { internalType: \"address\", name: \"_asset\", type: \"address\" },\n          ],\n          name: \"getEntireSystemDebt\",\n          outputs: [\n            {\n              internalType: \"uint256\",\n              name: \"entireSystemDebt\",\n              type: \"uint256\",\n            },\n          ],\n          stateMutability: \"view\",\n          type: \"function\",\n        },\n      ],\n      calls,\n      options: {},\n      multicallAddress,\n      provider: Ethers.provider(),\n    })\n      .then((res) => {\n        console.log(\"getMinted_res\", res);\n        for (let i = 0, len = res.length; i < len; i++) {\n          markets[underlyingTokens[i].underlyingToken.address][\"MINTED\"] = res[\n            i\n          ][0]\n            ? ethers.utils.formatUnits(res[i][0]._hex)\n            : \"0\";\n        }\n        onLoad({\n          newMarkets: markets,\n        });\n      })\n      .catch((err) => {\n        console.log(\"getMinted_err\", err);\n      });\n  }\n  function getTotalColl() {\n    const underlyingTokens = Object.values(markets);\n\n    const calls = underlyingTokens.map((item) => ({\n      address: dexConfig.VesselManager,\n      name: \"getEntireSystemColl\",\n      params: [item.underlyingToken.address],\n    }));\n\n    multicall({\n      abi: [\n        {\n          inputs: [\n            { internalType: \"address\", name: \"_asset\", type: \"address\" },\n          ],\n          name: \"getEntireSystemColl\",\n          outputs: [\n            {\n              internalType: \"uint256\",\n              name: \"entireSystemColl\",\n              type: \"uint256\",\n            },\n          ],\n          stateMutability: \"view\",\n          type: \"function\",\n        },\n      ],\n      calls,\n      options: {},\n      multicallAddress,\n      provider: Ethers.provider(),\n    })\n      .then((res) => {\n        console.log(\"getTotalColl_res\", res);\n        for (let i = 0, len = res.length; i < len; i++) {\n          markets[underlyingTokens[i].underlyingToken.address][\n            \"poolTotalColl\"\n          ] = res[i][0] ? ethers.utils.formatUnits(res[i][0]) : \"0\";\n        }\n        onLoad({\n          newMarkets: markets,\n        });\n      })\n      .catch((err) => {\n        console.log(\"getTotalColl_err\", err);\n      });\n  }\n  function getTotalDebt() {\n    const underlyingTokens = Object.values(markets);\n\n    const calls = underlyingTokens.map((item) => ({\n      address: dexConfig.VesselManager,\n      name: \"getEntireSystemDebt\",\n      params: [item.underlyingToken.address],\n    }));\n\n    multicall({\n      abi: [\n        {\n          inputs: [\n            { internalType: \"address\", name: \"_asset\", type: \"address\" },\n          ],\n          name: \"getEntireSystemDebt\",\n          outputs: [\n            {\n              internalType: \"uint256\",\n              name: \"entireSystemDebt\",\n              type: \"uint256\",\n            },\n          ],\n          stateMutability: \"view\",\n          type: \"function\",\n        },\n      ],\n      calls,\n      options: {},\n      multicallAddress,\n      provider: Ethers.provider(),\n    })\n      .then((res) => {\n        console.log(\"getTotalDebt_res\", res);\n        for (let i = 0, len = res.length; i < len; i++) {\n          markets[underlyingTokens[i].underlyingToken.address][\n            \"poolTotalDebt\"\n          ] = res[i][0] ? ethers.utils.formatUnits(res[i][0]) : \"0\";\n        }\n        onLoad({\n          newMarkets: markets,\n        });\n      })\n      .catch((err) => {\n        console.log(\"getTotalDebt_err\", err);\n      });\n  }\n\n  getStableDeposit();\n  getMarketDeposit();\n  getInfo();\n  getDebt();\n  getWalletBalance();\n  getMinted();\n\n  // getTotalColl();\n  // getTotalDebt();\n}, [account, update]);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/bluebiu.near/widget/Lending.Data.Liquity", "fact_widget_deployments_id": "54acbc22b2e85e44491cc20bfcd45bcb", "inserted_timestamp": "2024-06-12T09:04:35.479Z", "modified_timestamp": "2024-06-12T09:04:35.479Z", "__row_index": 0}