{"tx_hash": "Ds9wAaL7d8Wn8PCkZEDjDJC7rS8BtwV7xmDNxUHNngZz", "action_id_social": "HyRNPXwYTEqecpQJvUrdum4MHFHi7fuZocDvDDQdUVdu-0-widget", "block_id": 104535969, "block_timestamp": "2023-10-30T12:16:48.995Z", "signer_id": "bluebiu.near", "widget_name": "Linea.Swap.QuoterV3", "source_code": "const WETH_ADDRESS = props.wethAddress;\n\nconst abi = [\n  {\n    inputs: [{ internalType: \"address\", name: \"_factory\", type: \"address\" }],\n    stateMutability: \"nonpayable\",\n    type: \"constructor\",\n  },\n  {\n    inputs: [],\n    name: \"factory\",\n    outputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"bytes\", name: \"path\", type: \"bytes\" },\n      { internalType: \"uint256\", name: \"amountIn\", type: \"uint256\" },\n    ],\n    name: \"quoteExactInput\",\n    outputs: [\n      { internalType: \"uint256\", name: \"amountOut\", type: \"uint256\" },\n      { internalType: \"uint160[]\", name: \"afterSqrtPList\", type: \"uint160[]\" },\n      {\n        internalType: \"uint32[]\",\n        name: \"initializedTicksCrossedList\",\n        type: \"uint32[]\",\n      },\n      { internalType: \"uint256\", name: \"gasEstimate\", type: \"uint256\" },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { internalType: \"address\", name: \"tokenIn\", type: \"address\" },\n          { internalType: \"address\", name: \"tokenOut\", type: \"address\" },\n          { internalType: \"uint256\", name: \"amountIn\", type: \"uint256\" },\n          { internalType: \"uint24\", name: \"feeUnits\", type: \"uint24\" },\n          { internalType: \"uint160\", name: \"limitSqrtP\", type: \"uint160\" },\n        ],\n        internalType: \"struct IQuoterV2.QuoteExactInputSingleParams\",\n        name: \"params\",\n        type: \"tuple\",\n      },\n    ],\n    name: \"quoteExactInputSingle\",\n    outputs: [\n      {\n        components: [\n          { internalType: \"uint256\", name: \"usedAmount\", type: \"uint256\" },\n          { internalType: \"uint256\", name: \"returnedAmount\", type: \"uint256\" },\n          { internalType: \"uint160\", name: \"afterSqrtP\", type: \"uint160\" },\n          {\n            internalType: \"uint32\",\n            name: \"initializedTicksCrossed\",\n            type: \"uint32\",\n          },\n          { internalType: \"uint256\", name: \"gasEstimate\", type: \"uint256\" },\n        ],\n        internalType: \"struct IQuoterV2.QuoteOutput\",\n        name: \"output\",\n        type: \"tuple\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"bytes\", name: \"path\", type: \"bytes\" },\n      { internalType: \"uint256\", name: \"amountOut\", type: \"uint256\" },\n    ],\n    name: \"quoteExactOutput\",\n    outputs: [\n      { internalType: \"uint256\", name: \"amountIn\", type: \"uint256\" },\n      { internalType: \"uint160[]\", name: \"afterSqrtPList\", type: \"uint160[]\" },\n      {\n        internalType: \"uint32[]\",\n        name: \"initializedTicksCrossedList\",\n        type: \"uint32[]\",\n      },\n      { internalType: \"uint256\", name: \"gasEstimate\", type: \"uint256\" },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { internalType: \"address\", name: \"tokenIn\", type: \"address\" },\n          { internalType: \"address\", name: \"tokenOut\", type: \"address\" },\n          { internalType: \"uint256\", name: \"amount\", type: \"uint256\" },\n          { internalType: \"uint24\", name: \"feeUnits\", type: \"uint24\" },\n          { internalType: \"uint160\", name: \"limitSqrtP\", type: \"uint160\" },\n        ],\n        internalType: \"struct IQuoterV2.QuoteExactOutputSingleParams\",\n        name: \"params\",\n        type: \"tuple\",\n      },\n    ],\n    name: \"quoteExactOutputSingle\",\n    outputs: [\n      {\n        components: [\n          { internalType: \"uint256\", name: \"usedAmount\", type: \"uint256\" },\n          { internalType: \"uint256\", name: \"returnedAmount\", type: \"uint256\" },\n          { internalType: \"uint160\", name: \"afterSqrtP\", type: \"uint160\" },\n          {\n            internalType: \"uint32\",\n            name: \"initializedTicksCrossed\",\n            type: \"uint32\",\n          },\n          { internalType: \"uint256\", name: \"gasEstimate\", type: \"uint256\" },\n        ],\n        internalType: \"struct IQuoterV2.QuoteOutput\",\n        name: \"output\",\n        type: \"tuple\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"int256\", name: \"amount0Delta\", type: \"int256\" },\n      { internalType: \"int256\", name: \"amount1Delta\", type: \"int256\" },\n      { internalType: \"bytes\", name: \"path\", type: \"bytes\" },\n    ],\n    name: \"swapCallback\",\n    outputs: [],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\n\nconst abiIzi = [\n  {\n    inputs: [\n      {\n        internalType: \"bytes[]\",\n        name: \"data\",\n        type: \"bytes[]\",\n      },\n    ],\n    name: \"multicall\",\n    outputs: [\n      {\n        internalType: \"bytes[]\",\n        name: \"results\",\n        type: \"bytes[]\",\n      },\n    ],\n    stateMutability: \"payable\",\n    type: \"function\",\n  },\n\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"tokenX\",\n        type: \"address\",\n      },\n      {\n        internalType: \"address\",\n        name: \"tokenY\",\n        type: \"address\",\n      },\n      {\n        internalType: \"uint24\",\n        name: \"fee\",\n        type: \"uint24\",\n      },\n      {\n        internalType: \"uint128\",\n        name: \"amount\",\n        type: \"uint128\",\n      },\n      {\n        internalType: \"int24\",\n        name: \"lowPt\",\n        type: \"int24\",\n      },\n    ],\n    name: \"swapX2Y\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"amountY\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"int24\",\n        name: \"finalPoint\",\n        type: \"int24\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"tokenX\",\n        type: \"address\",\n      },\n      {\n        internalType: \"address\",\n        name: \"tokenY\",\n        type: \"address\",\n      },\n      {\n        internalType: \"uint24\",\n        name: \"fee\",\n        type: \"uint24\",\n      },\n      {\n        internalType: \"uint128\",\n        name: \"amount\",\n        type: \"uint128\",\n      },\n      {\n        internalType: \"int24\",\n        name: \"highPt\",\n        type: \"int24\",\n      },\n    ],\n    name: \"swapY2X\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"amountX\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"int24\",\n        name: \"finalPoint\",\n        type: \"int24\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n];\n\nconst iziQuoterAddress = \"0xe6805638db944eA605e774e72c6F0D15Fb6a1347\";\n\nconst { amountIn, tokenIn, tokenOut, loadAmountOut, quoterContractId } = props;\n\nconst feeList = [8, 10, 40, 300, 1000];\n\nconst feeListIzi = [100, 500, 3000, 10000];\n\nconst queryString = `${tokenIn.address}-${tokenOut.address}-${amountIn}-${quoterContractId}`;\n\nif (state.cacheString !== queryString) {\n  State.update({\n    cacheString: queryString,\n    quoteDone: false,\n    quoting: false,\n  });\n}\n\nconst quoteSingle = (amountIn, tokenIn, tokenOut, fee, finalList) => {\n  const iface = new ethers.utils.Interface(abi);\n\n  const inputs = [\n    {\n      tokenIn: tokenIn.address === \"native\" ? WETH_ADDRESS : tokenIn.address,\n      tokenOut: tokenOut.address === \"native\" ? WETH_ADDRESS : tokenOut.address,\n      amountIn: ethers.utils.parseUnits(amountIn, tokenIn.decimals),\n      feeUnits: fee,\n      limitSqrtP: 0,\n    },\n  ];\n\n  const encodedData = iface.encodeFunctionData(\"quoteExactInputSingle\", inputs);\n\n  return Ethers.provider()\n    .call({\n      to: quoterContractId,\n      data: encodedData,\n    })\n    .then((data) => {\n      const res = iface.decodeFunctionResult(\"quoteExactInputSingle\", data);\n\n      const rawAmountOut = Big(Number(res[0][1]._hex)).toFixed();\n\n      const parsedAmountOut = new Big(rawAmountOut)\n        .div(Big(10).pow(tokenOut.decimals))\n        .toFixed();\n\n      return [\n        ...finalList,\n        {\n          fee: fee,\n          amountOut: parsedAmountOut,\n          success: true,\n        },\n      ];\n    })\n    .catch((e) => {\n      return [\n        ...finalList,\n        {\n          fee: fee,\n          amountOut: \"0\",\n          success: false,\n        },\n      ];\n    });\n};\n\nconst qouteSingleIzi = (amountIn, tokenIn, tokenOut, fee, finalList) => {\n  const abi = abiIzi;\n\n  const tokenInAddress =\n    tokenIn.address === \"native\" ? WETH_ADDRESS : tokenIn.address;\n\n  const tokenOutAddress =\n    tokenOut.address === \"native\" ? WETH_ADDRESS : tokenOut.address;\n\n  const isX2Y = tokenInAddress.toLowerCase() < tokenOutAddress.toLowerCase();\n\n  const boundaryPt = isX2Y ? -799999 : 799999;\n  const iface = new ethers.utils.Interface(abi);\n\n  const inputs = isX2Y\n    ? [\n        tokenInAddress,\n        tokenOutAddress,\n        fee,\n        ethers.utils.parseUnits(amountIn, tokenIn.decimals),\n        boundaryPt,\n      ]\n    : [\n        tokenOutAddress,\n        tokenInAddress,\n        fee,\n        ethers.utils.parseUnits(amountIn, tokenIn.decimals),\n        boundaryPt,\n      ];\n\n  const method = isX2Y ? \"swapX2Y\" : \"swapY2X\";\n\n  const encodedData = iface.encodeFunctionData(method, inputs);\n  console.log(\"encodedData: \", encodedData);\n\n  return Ethers.provider()\n    .call({\n      to: quoterContractId,\n      data: encodedData,\n    })\n    .then((data) => {\n      const res = iface.decodeFunctionResult(method, data);\n\n      const amountName = isX2Y ? \"amountY\" : \"amountX\";\n\n      const rawAmountOut = Big(Number(res[amountName]._hex)).toFixed();\n      const parsedAmountOut = new Big(rawAmountOut)\n        .div(Big(10).pow(tokenOut.decimals))\n        .toFixed();\n\n      return [\n        ...finalList,\n        {\n          fee: fee,\n          amountOut: parsedAmountOut,\n          success: true,\n        },\n      ];\n    })\n    .catch((e) => {\n      console.log(\"e1111: \", e);\n      return [\n        ...finalList,\n        {\n          fee: fee,\n          amountOut: \"0\",\n          success: false,\n        },\n      ];\n    });\n};\n\nconst quoteAll = () => {\n  State.update({\n    quoting: true,\n  });\n\n  quoteSingle(amountIn, tokenIn, tokenOut, feeList[0], [])\n    .then((finalList0) => {\n      return quoteSingle(amountIn, tokenIn, tokenOut, feeList[1], finalList0);\n    })\n    .then((finalList1) => {\n      return quoteSingle(amountIn, tokenIn, tokenOut, feeList[2], finalList1);\n    })\n    .then((finalList2) => {\n      return quoteSingle(amountIn, tokenIn, tokenOut, feeList[3], finalList2);\n    })\n    .then((finalList3) => {\n      return quoteSingle(amountIn, tokenIn, tokenOut, feeList[4], finalList3);\n    })\n    .then((finalList4) => {\n      const maxAmountOutEstimate = finalList4.reduce((prev, current) => {\n        if (Number(prev.amountOut) > Number(current.amountOut)) {\n          return prev;\n        } else {\n          return current;\n        }\n      }, finalList4[0]);\n\n      State.update({ quoteDone: true, quoting: false });\n      loadAmountOut({\n        ...maxAmountOutEstimate,\n        quoteDone,\n        quoting,\n        noPair: !Big(maxAmountOutEstimate.amountOut).gt(0),\n      });\n    });\n};\n\nconst quoteAllIzi = () => {\n  State.update({\n    quoting: true,\n  });\n\n  qouteSingleIzi(amountIn, tokenIn, tokenOut, feeListIzi[0], [])\n    .then((finalList0) => {\n      return qouteSingleIzi(\n        amountIn,\n        tokenIn,\n        tokenOut,\n        feeListIzi[1],\n        finalList0\n      );\n    })\n    .then((finalList1) => {\n      return qouteSingleIzi(\n        amountIn,\n        tokenIn,\n        tokenOut,\n        feeListIzi[2],\n        finalList1\n      );\n    })\n    .then((finalList2) => {\n      return qouteSingleIzi(\n        amountIn,\n        tokenIn,\n        tokenOut,\n        feeListIzi[3],\n        finalList2\n      );\n    })\n    .then((finalList3) => {\n      const maxAmountOutEstimate = finalList3.reduce((prev, current) => {\n        if (Number(prev.amountOut) > Number(current.amountOut)) {\n          return prev;\n        } else {\n          return current;\n        }\n      }, finalList3[0]);\n\n      State.update({ quoteDone: true, quoting: false });\n      loadAmountOut({\n        ...maxAmountOutEstimate,\n        quoteDone,\n        quoting,\n      });\n    });\n};\n\nconst wrapType =\n  tokenIn.address === \"native\" && tokenOut.symbol === \"WETH\"\n    ? 1\n    : tokenIn.symbol === \"WETH\" && tokenOut.address === \"native\"\n    ? 2\n    : 0;\n\nif (Number(amountIn) > 0 && !state.quoteDone && !state.quoting) {\n  if (wrapType > 0) {\n    loadAmountOut({\n      amountOut: amountIn,\n      fee: 0,\n      success: true,\n      quoteDone: true,\n      quoting: false,\n    });\n  } else {\n    if (quoterContractId === iziQuoterAddress) {\n      quoteAllIzi();\n    } else {\n      quoteAll();\n    }\n  }\n}\nreturn <div></div>;\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/bluebiu.near/widget/Linea.Swap.QuoterV3", "fact_widget_deployments_id": "490e7c1767ada83f9e2bef99d12e9afe", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 0}