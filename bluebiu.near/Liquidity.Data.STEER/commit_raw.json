{"tx_hash": "5MfPLVCdJ9972gtxp4QnL9qp8XC2pX25AeaeewBfVepi", "action_id_social": "CUV3Eh7HWGDnwbbvTQZqedU6s1cLHNpg1sfwr3AmooRV-0-widget", "block_id": 117506357, "block_timestamp": "2024-04-24T07:26:34.122Z", "signer_id": "bluebiu.near", "widget_name": "Liquidity.Data.STEER", "source_code": "const {\n  pairs,\n  addresses,\n  allData,\n  stakingPoolsData,\n  onLoad,\n  // chainType,\n  curChain,\n  FEE_APR_URL,\n  multicallAddress,\n  prices\n} = props\n\nconst MULTICALL_ABI = [\n  {\n    inputs: [\n      { internalType: \"bool\", name: \"requireSuccess\", type: \"bool\" },\n      {\n        components: [\n          { internalType: \"address\", name: \"target\", type: \"address\" },\n          { internalType: \"bytes\", name: \"callData\", type: \"bytes\" },\n        ],\n        internalType: \"struct Multicall2.Call[]\",\n        name: \"calls\",\n        type: \"tuple[]\",\n      },\n    ],\n    name: \"tryAggregate\",\n    outputs: [\n      {\n        components: [\n          { internalType: \"bool\", name: \"success\", type: \"bool\" },\n          { internalType: \"bytes\", name: \"returnData\", type: \"bytes\" },\n        ],\n        internalType: \"struct Multicall2.Result[]\",\n        name: \"returnData\",\n        type: \"tuple[]\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n];\nconst ERC20_ABI = [\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_shares\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"getUnderlyingAssets\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"totalX\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"totalY\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  \"function balanceOf(address) view returns (uint256)\",\n  {\n    \"inputs\": [],\n    \"name\": \"totalSupply\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  \"function getTotalAmounts() external view returns (uint256 total0, uint256 total1)\"\n];\n\nconst MulticallContract = new ethers.Contract(\n  multicallAddress,\n  MULTICALL_ABI,\n  Ethers.provider().getSigner()\n);\n\nconst multicallv2 = (abi, calls, options, onSuccess, onError) => {\n  const { requireSuccess, ...overrides } = options || {};\n  const itf = new ethers.utils.Interface(abi);\n  const calldata = calls.map((call) => ({\n    target: call.address.toLowerCase(),\n    callData: itf.encodeFunctionData(call.name, call.params),\n  }));\n  MulticallContract.callStatic\n    .tryAggregate(requireSuccess || true, calldata, overrides)\n    .then((res) => {\n      onSuccess(\n        res.map((call, i) => {\n          const [result, data] = call;\n          return result && data !== \"0x\"\n            ? itf.decodeFunctionResult(calls[i].name, data)\n            : null;\n        })\n      );\n    })\n    .catch((err) => {\n      onError?.(err);\n    });\n};\n\nfunction multicallv2WithPromise(abi, calls, options) {\n  return new Promise((resolve, reject) => {\n    multicallv2(\n      abi,\n      calls,\n      options,\n      resolve,\n      reject)\n  })\n}\nfunction asyncFetchWithPromise(url, options) {\n  return new Promise((resolve, reject) => {\n    asyncFetch(url, options || {}).then(result => {\n      try {\n        if (result.ok) {\n          resolve(JSON.parse(result.body))\n        } else {\n          reject(result.status)\n        }\n      } catch (error) {\n        reject(error)\n      }\n    }).catch(reject)\n  })\n\n}\n\nconst formatPercent = (value) => {\n  return `${Number(value * 100).toLocaleString(\"en\", {\n    maximumFractionDigits: 2,\n  })}%`;\n};\n\n\nlet loading = false\nlet dataList = []\nfunction formatedData() {\n  onLoad({\n    loading,\n    dataList\n  })\n}\nfunction getDataList() {\n  pairs.forEach(pair => {\n    const findIndex = allData.findIndex(data => addresses[pair.id].toLowerCase() === data.id)\n    if (findIndex > -1) {\n      dataList.push({\n        initialData: allData[findIndex],\n        ...pair,\n      })\n    }\n  })\n  formatedData('getDataList')\n}\nfunction getFee() {\n  for (let i = 0; i < dataList.length; i++) {\n    const data = dataList[i];\n    dataList[i].fee = Big(data?.initialData?.feeTier).div(10000).toFixed(2)\n  }\n  formatedData('getFee')\n}\n\nfunction getTvlUSD() {\n  for (let i = 0; i < dataList.length; i++) {\n    const data = dataList[i]\n    const {\n      token0Balance,\n      token1Balance,\n    } = data.initialData\n    dataList[i].tvlUSD = Big(ethers.utils.formatUnits(token0Balance, data.decimals0)).times(prices[data.token0]).plus(Big(ethers.utils.formatUnits(token1Balance, data.decimals1)).times(prices[data.token1])).toFixed(2)\n  }\n  formatedData('getTvlUSD')\n}\nfunction handleGetBaseApr(baseAprUrl) {\n  const baseAprPromiseArray = []\n  baseAprUrl.forEach(url => {\n    baseAprPromiseArray.push(asyncFetchWithPromise(url))\n  })\n  return new Promise((resolve, reject) => {\n    Promise.all(baseAprPromiseArray).then(resolve).catch(reject)\n  })\n}\nfunction getFeeApr() {\n\n  const totalSupplyCalls = []\n  const getTotalAmountsColls = []\n  const balanceOfColls = []\n  const baseAprUrl = []\n  dataList.forEach(data => {\n    totalSupplyCalls.push({\n      address: addresses[data.id],\n      name: 'totalSupply'\n    })\n    getTotalAmountsColls.push({\n      address: addresses[data.id],\n      name: \"getTotalAmounts\",\n    })\n    balanceOfColls.push({\n      address: addresses[data.id],\n      name: \"balanceOf\",\n      params: [data.stakingAddress]\n    })\n    baseAprUrl.push(`${FEE_APR_URL}?address=${addresses[data.id]}&chain=${curChain.chain_id}&interval=604800`)\n  })\n  const promiseArray = []\n  if (curChain.chain_id === 169) {\n    promiseArray.push(multicallv2WithPromise(ERC20_ABI, totalSupplyCalls, {}))\n    promiseArray.push(multicallv2WithPromise(ERC20_ABI, getTotalAmountsColls, {}))\n    promiseArray.push(multicallv2WithPromise(ERC20_ABI, balanceOfColls, {}))\n  }\n  promiseArray.push(handleGetBaseApr(baseAprUrl))\n  Promise.all(promiseArray).then(result => {\n    for (let i = 0; i < dataList.length; i++) {\n      const data = dataList[i]\n      if (curChain.chain_id === 169) {\n        // first value\n        const staking = stakingPoolsData.find(pool => pool.stakingPool.toLowerCase() === data.stakingAddress.toLowerCase())\n        const {\n          dailyEmissionRewardA, dailyEmissionRewardB, rewardTokenADetail, rewardTokenBDetail\n        } = staking\n        const firstValue = Big(Big(dailyEmissionRewardA).times(prices[rewardTokenADetail.symbol])\n          .plus(Big(dailyEmissionRewardB).times(prices[rewardTokenBDetail.symbol]))).times(365)\n        // second value\n        const [totalSupplyResult, getTotalAmountsResult, balanceOfResult, baseAprResult] = result\n        const total0 = ethers.utils.formatUnits(getTotalAmountsResult[i][0], data.decimals0)\n        const total1 = ethers.utils.formatUnits(getTotalAmountsResult[i][1], data.decimals1)\n        const totalSupply = ethers.utils.formatUnits(totalSupplyResult[i][0], 18)\n        const priceLp = Big(Big(total0)\n          .times(prices[data.token0])\n          .plus(Big(total1).times(prices[data.token1]))\n        ).div(totalSupply)\n        const amountLp = ethers.utils.formatUnits(balanceOfResult[i][0], 18)\n        const secondValue = Big(priceLp).times(amountLp)\n        const stakingAPR = Big(firstValue).div(secondValue).times(100)\n        console.log('=stakingAPR', stakingAPR.toString(), '=baseAprResult[i]?.apr', baseAprResult[i]?.apr)\n        dataList[i].feeApr = Big(stakingAPR).plus(baseAprResult[i]?.apr ?? 0).toFixed(2) + '%'\n      } else {\n        const [baseAprResult] = result\n        dataList[i].feeApr = Big(baseAprResult[i]?.apr ?? 0).toFixed(2) + '%'\n      }\n    }\n    formatedData(\"getFeeApr\")\n  }).catch(error => {\n    console.log('error', error)\n  })\n}\nfunction getLiquidity() {\n  const totalSupplyCalls = []\n  const getTotalAmountsColls = []\n  dataList.forEach(data => {\n    totalSupplyCalls.push({\n      address: addresses[data.id],\n      name: 'totalSupply'\n    })\n    getTotalAmountsColls.push({\n      address: addresses[data.id],\n      name: \"getTotalAmounts\",\n    })\n  })\n  const promiseArray = []\n  promiseArray.push(multicallv2WithPromise(ERC20_ABI, totalSupplyCalls, {}))\n  promiseArray.push(multicallv2WithPromise(ERC20_ABI, getTotalAmountsColls, {}))\n  Promise.all(promiseArray).then(result => {\n    for (let i = 0; i < dataList.length; i++) {\n      const data = dataList[i]\n      const [totalSupplyResult, getTotalAmountsResult] = result\n      const total0 = ethers.utils.formatUnits(getTotalAmountsResult[i][0], data.decimals0)\n      const total1 = ethers.utils.formatUnits(getTotalAmountsResult[i][1], data.decimals1)\n      const totalSupply = ethers.utils.formatUnits(totalSupplyResult[i][0], 18)\n      const priceLp = Big(Big(total0)\n        .times(prices[data.token0])\n        .plus(Big(total1).times(prices[data.token1]))\n      ).div(totalSupply)\n      const amountLp = data.balance\n      dataList[i].liquidity = Big(priceLp).times(amountLp).toFixed(2)\n    }\n    formatedData(\"getLiquidity\")\n  }).catch(error => {\n    console.log('error', error)\n  })\n}\nfunction getBalance() {\n  const calls = [];\n  const sender = Ethers.send(\"eth_requestAccounts\", [])[0];\n  dataList.forEach(data => {\n    calls.push({\n      address: ethers.utils.getAddress(addresses[data.id]),\n      name: \"balanceOf\",\n      params: [sender],\n    });\n  })\n  multicallv2(\n    ERC20_ABI,\n    calls,\n    {},\n    (result) => {\n      for (let i = 0; i < result.length; i++) {\n        const element = result[i];\n        dataList[i].balance = Big(ethers.utils.formatUnits(element[0], 18)).toFixed(4)\n      }\n      formatedData('getBalance')\n      getLiquidity()\n    },\n    (error) => {\n      setTimeout(() => {\n        getBalance();\n      }, 500);\n    }\n  )\n}\nuseEffect(() => {\n  getDataList()\n  getFee()\n  getTvlUSD()\n  getFeeApr()\n  getBalance()\n}, [])", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/bluebiu.near/widget/Liquidity.Data.STEER", "fact_widget_deployments_id": "c4f789a7091a4ee0476b3eea0c9e1f2c", "inserted_timestamp": "2024-04-24T10:37:40.129Z", "modified_timestamp": "2024-04-24T10:37:40.129Z", "__row_index": 2}