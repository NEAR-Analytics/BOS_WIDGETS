{"tx_hash": "GYaeHu1Tw8RYKwN62EZjPo3vjXGR9Rfbiv1D4j4F4qnM", "action_id_social": "HXpEvy58wLRTtcyvGjLQTgCRRPRZ1b1vmm2aUWSfifZt-0-widget", "block_id": 116378635, "block_timestamp": "2024-04-08T07:42:24.486Z", "signer_id": "bluebiu.near", "widget_name": "Liquidity.Bridge.METAVAULT.Detail", "source_code": "\nconst {\n  data,\n  toast,\n  prices,\n  refetch,\n  addresses,\n  addAction,\n  storeAddress,\n  ICON_VAULT_MAP\n} = props;\n\nconst {\n  StyledFont,\n  StyledFlex,\n  Row,\n  Column,\n  DetailWrapper,\n  FilterButtonList,\n  FilterButton,\n  InputWrapList,\n  InputWrap,\n  Input,\n  InputSuffix,\n  StyledImageList,\n  PriceWrap,\n  TotalPrice,\n  BalancePrice,\n  StyledButtonList,\n  StyledButton,\n  StyledLoading\n} = VM.require('bluebiu.near/widget/Liquidity.Handler.Styles')\n\n\nconst iconCircle = (\n  <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" fill=\"none\">\n    <path d=\"M8 15C11.866 15 15 11.866 15 8C15 4.13401 11.866 1 8 1C4.13401 1 1 4.13401 1 8\" stroke=\"#1E2028\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" />\n  </svg>\n\n)\nconst defaultDeposit = props.tab === \"deposit\" || !props.tab;\n\n// const curPositionUSD = userPositions[data.vaultAddress]?.balanceUSD;\n\nState.init({\n  isDeposit: defaultDeposit,\n  lpBalance: \"\",\n  balances: [],\n  amount: \"\",\n  lpAmount: \"\",\n  isError: false,\n  isLoading: false,\n  isTokenApproved: true,\n  isTokenApproving: false,\n  loadingMsg: \"\",\n  isPostTx: false,\n  showPairs: false,\n});\n\nconst sender = Ethers.send(\"eth_requestAccounts\", [])[0];\nconst { token, decimals, id, poolAddress } = data || defaultPair;\n\nconst vaultAddress = addresses[id];\n\nconst updateLPBalance = () => {\n  const sender = Ethers.send(\"eth_requestAccounts\", [])[0];\n  const abi = [{\n    \"inputs\": [\n      {\n        \"internalType\": \"address[]\",\n        \"name\": \"_assets\",\n        \"type\": \"address[]\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"account\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"getUserBalances\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256[]\",\n        \"name\": \"\",\n        \"type\": \"uint256[]\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  }]\n  const contract = new ethers.Contract(\n    ethers.utils.getAddress(storeAddress),\n    abi,\n    Ethers.provider()\n  );\n  contract\n    .getUserBalances([vaultAddress], sender)\n    .then((result) => {\n      State.update({\n        lpBalance: Big(ethers.utils.formatUnits(result[0], decimals)).toFixed(6),\n      });\n    })\n};\nconst updateBalance = () => {\n  const symbol = token\n  const address = addresses[token]\n  if (symbol === \"ETH\") {\n    Ethers.provider()\n      .getBalance(sender)\n      .then((balanceBig) => {\n        const adjustedBalance = ethers.utils.formatEther(balanceBig);\n        State.update({\n          balances: {\n            ...state.balances,\n            [symbol]: adjustedBalance,\n          },\n        });\n      });\n  } else {\n    const abi = [\"function balanceOf(address) view returns (uint256)\"];\n    const contract = new ethers.Contract(\n      address,\n      abi,\n      Ethers.provider()\n    );\n    contract.balanceOf(sender).then((balanceBig) => {\n      const adjustedBalance = Big(\n        ethers.utils.formatUnits(balanceBig, decimals)\n      ).toString();\n      State.update({\n        balances: {\n          ...state.balances,\n          [symbol]: adjustedBalance,\n        },\n      });\n    });\n  }\n};\n\nconst {\n  isDeposit,\n  balances,\n  amount,\n  isLoading,\n  isError,\n  isTokenApproved,\n  isTokenApproving,\n  loadingMsg,\n  lpBalance,\n  lpAmount,\n  isPostTx,\n} = state;\n\nconst changeMode = (isDeposit) => {\n  State.update({ isDeposit });\n};\n\nconst handleMax = () => {\n  handleTokenChange(balances[token], token);\n};\n\nconst handleTokenChange = (value, symbol) => {\n  State.update({\n    amount: value\n  })\n  if (Number(value) === 0) {\n    State.update({\n      isTokenApproved: true,\n    })\n    return;\n  }\n};\n\nconst handleLPChange = (amount) => {\n  State.update({\n    lpAmount: amount,\n  });\n};\n\nconst handleDeposit = () => {\n  const toastId = toast?.loading({\n    title: `Depositing...`,\n  });\n  State.update({\n    isLoading: true,\n    isError: false,\n    loadingMsg: \"Depositing...\",\n  });\n  const _amount = Big(amount)\n    .mul(Big(10).pow(decimals))\n    .toFixed(0);\n\n\n  const abi = [{\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_asset\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"deposit\",\n    \"outputs\": [],\n    \"stateMutability\": \"payable\",\n    \"type\": \"function\"\n  }];\n  const contract = new ethers.Contract(\n    ethers.utils.getAddress(storeAddress),\n    abi,\n    Ethers.provider().getSigner()\n  );\n  contract\n    .deposit(vaultAddress, _amount, {\n      value: _amount\n    })\n    .then((tx) => {\n      return tx.wait();\n    })\n    .then((receipt) => {\n      const { status, transactionHash } = receipt;\n      // addAction?.({\n      //   type: \"Liquidity\",\n      //   action: \"Deposit\",\n      //   token,\n      //   amount,\n      //   template: \"Metavault\",\n      //   status: status,\n      //   transactionHash,\n      //   chain_id: props.chainId,\n      // });\n\n      State.update({\n        isLoading: false,\n        isPostTx: true,\n      });\n\n      setTimeout(() => State.update({ isPostTx: false }), 10_000);\n\n      if (refetch) refetch();\n\n      toast?.dismiss(toastId);\n      toast?.success({\n        title: \"Deposit Successfully!\",\n      });\n    })\n    .catch((error) => {\n      State.update({\n        isError: true,\n        isLoading: false,\n        loadingMsg: error,\n      });\n      toast?.dismiss(toastId);\n      toast?.fail({\n        title: \"Deposit Failed!\",\n        text: error?.message?.includes(\"user rejected transaction\")\n          ? \"User rejected transaction\"\n          : \"\",\n      });\n    });\n\n\n};\n\nconst handleWithdraw = () => {\n  const toastId = toast?.loading({\n    title: `Withdrawing...`,\n  });\n  State.update({\n    isLoading: true,\n    isError: false,\n    loadingMsg: \"Withdrawing...\",\n  });\n  const _amount = Big(lpAmount)\n    .mul(Big(10).pow(18))\n    .toFixed(0)\n\n  const abi = [{\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_asset\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"withdraw\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }];\n\n  const contract = new ethers.Contract(\n    ethers.utils.getAddress(storeAddress),\n    abi,\n    Ethers.provider().getSigner()\n  );\n  contract\n    .withdraw(vaultAddress, _amount)\n    .then((tx) => {\n      return tx.wait();\n    })\n    .then((receipt) => {\n      State.update({\n        isLoading: false,\n        isPostTx: true,\n      });\n\n      const { status, transactionHash } = receipt;\n\n      // addAction?.({\n      //   type: \"Liquidity\",\n      //   action: \"Withdraw\",\n      //   token,\n      //   amount: lpAmount,\n      //   template: \"Metavault\",\n      //   status: status,\n      //   transactionHash,\n      //   chain_id: state.chainId,\n      // });\n\n      setTimeout(() => State.update({ isPostTx: false }), 10_000);\n\n      if (refetch) refetch();\n\n      toast?.dismiss(toastId);\n      toast?.success({\n        title: \"Withdraw Successfully!\",\n      });\n    })\n    .catch((error) => {\n      console.log('error', error)\n      State.update({\n        isError: true,\n        isLoading: false,\n        loadingMsg: error,\n      });\n      toast?.dismiss(toastId);\n      toast?.fail({\n        title: \"Withdraw Failed!\",\n        text: error?.message?.includes(\"user rejected transaction\")\n          ? \"User rejected transaction\"\n          : \"\",\n      });\n    });\n};\n\nconst tokensPrice = prices;\n\nconst isInSufficient =\n  Number(amount) > Number(balances[token])\n\nconst isWithdrawInsufficient = Number(lpAmount) > Number(lpBalance);\n\nconst balance =\n  !amount || !tokensPrice?.[token]\n    ? \"-\"\n    : parseFloat(Big(amount).times(tokensPrice[token]).toFixed(4));\n\n\n\nconst balanceLp =\n  !lpAmount || !tokensPrice?.[token]\n    ? \"-\"\n    : parseFloat(\n      parseFloat(Big(lpAmount).times(tokensPrice[token]).toFixed(4))\n    );\n\nconst onUpdateLpPercent = (percent) => {\n  State.update({\n    lpPercent: percent,\n  });\n};\n\nconst onChangeSlider = (percent) => {\n  const newLpValue = Big(percent)\n    .div(100)\n    .times(lpBalance || 0)\n    .toFixed(6);\n\n  handleLPChange(newLpValue);\n};\n\nuseEffect(() => {\n  if (!sender || !token) return;\n  updateBalance()\n  updateLPBalance();\n}, [sender, token]);\n\nuseEffect(() => {\n  if (amount) {\n    handleTokenChange(amount, token);\n  }\n}, [data]);\n\nreturn (\n  <DetailWrapper>\n    <FilterButtonList>\n      <FilterButton className={isDeposit ? 'isActive' : ''} onClick={() => changeMode(true)}>Deposit</FilterButton>\n      <FilterButton className={!isDeposit ? 'isActive' : ''} onClick={() => changeMode(false)}>Withdraw</FilterButton>\n    </FilterButtonList>\n    {\n      isDeposit ? <>\n        <Row className=\"price-input\">\n          <Column>\n            <InputWrap className={Number(amount) > Number(balances[token]) ? \"inSufficient\" : \"\"}>\n              <Input value={amount} type=\"number\" onChange={(e) => handleTokenChange(e.target.value, token)} />\n              <InputSuffix>\n                <img src={ICON_VAULT_MAP[token]} alt={token} />\n                <span>{token}</span>\n              </InputSuffix>\n            </InputWrap>\n            <PriceWrap>\n              <TotalPrice>${balance}</TotalPrice>\n              <BalancePrice>Balance:<span onClick={() => handleMax(true)}>{Big(balances[token] ?? 0).toFixed(6)}</span> {token}</BalancePrice>\n            </PriceWrap>\n          </Column>\n        </Row>\n        <StyledButtonList>\n          {isInSufficient && <StyledButton disabled>InSufficient Balance</StyledButton>}\n          {\n            !isInSufficient &&\n            (isTokenApproved &&\n              !isTokenApproving ? (\n\n              <StyledButton disabled={isLoading || !amount} onClick={handleDeposit}>\n                {\n                  isLoading ? (\n                    <StyledLoading>{iconCircle}</StyledLoading>\n                  ) : (\n                    \"Deposit\"\n                  )\n                }\n              </StyledButton>\n            ) : (\n              <>\n                <StyledButton disabled={isTokenApproved || isTokenApproving} onClick={() => handleApprove(true)}>{\n                  isTokenApproving ? (\n                    <StyledLoading>{iconCircle}</StyledLoading>\n                  ) : (\n                    <>\n                      {isTokenApproved ? \"Approved\" : \"Approve\"} {token}\n                    </>\n                  )}\n                </StyledButton>\n              </>\n            ))\n          }\n        </StyledButtonList>\n      </> : <>\n        <Row className=\"price-input\">\n          <Column>\n            <InputWrap>\n              <Input value={lpAmount} type=\"number\" onChange={(e) => {\n                handleLPChange(e.target.value);\n\n                const value = e.target.value;\n\n                if (!value) {\n                  onUpdateLpPercent(0);\n                }\n\n                if (value && Big(value).gt(0)) {\n                  const newSliderPercent = Big(value || 0)\n                    .div(Big(lpBalance).gt(0) ? lpBalance : 1)\n                    .times(100)\n                    .toFixed(0);\n                  onUpdateLpPercent(newSliderPercent);\n                }\n              }} />\n\n              <InputSuffix>\n                <StyledImageList>\n                  <img src={ICON_VAULT_MAP[token]} alt={token} />\n                </StyledImageList>\n                <span>{token}</span>\n              </InputSuffix>\n            </InputWrap>\n            <PriceWrap>\n              <TotalPrice>${balanceLp}</TotalPrice>\n              <BalancePrice>Balance: <span\n                onClick={() => {\n                  const newSliderPercent = Big(lpBalance || 0)\n                    .div(Big(lpBalance).gt(0) ? lpBalance : 1)\n                    .times(100)\n                    .toFixed(0);\n\n                  onUpdateLpPercent(newSliderPercent);\n\n                  handleLPChange(lpBalance);\n                }}\n              >\n                {lpBalance}\n              </span></BalancePrice>\n            </PriceWrap>\n          </Column>\n        </Row>\n        <StyledButtonList>\n          <StyledButton\n            disabled={isWithdrawInsufficient || isLoading || !lpAmount}\n            onClick={handleWithdraw}\n          >\n            {isLoading ? (\n              <StyledLoading>{iconCircle}</StyledLoading>\n            ) : (\n              <>\n                {isWithdrawInsufficient ? \"InSufficient Balance\" : \"Withdraw\"}\n              </>\n            )}\n          </StyledButton>\n        </StyledButtonList>\n      </>\n    }\n\n  </DetailWrapper>\n)", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/bluebiu.near/widget/Liquidity.Bridge.METAVAULT.Detail", "fact_widget_deployments_id": "2e66d356541b5072474c9bd8e400cd58", "inserted_timestamp": "2024-04-08T09:30:33.775Z", "modified_timestamp": "2024-04-08T09:30:33.775Z", "__row_index": 0}