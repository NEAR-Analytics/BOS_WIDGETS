{"tx_hash": "9jfL1Kr5fwMMi99vzAdWqNipea8GqCnFn2iSHZkdDyYE", "action_id_social": "7bqe7gdXNM8uWETzYCjNqU7FSNs41gTvt3ZkuvFHTb6b-0-widget", "block_id": 104032422, "block_timestamp": "2023-10-23T12:53:00.829Z", "signer_id": "bluebiu.near", "widget_name": "Bsc.Lending.RadiantData", "source_code": "const native = {\n  address: \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n  decimals: 18,\n  symbol: \"BNB\",\n  name: \"BNB\",\n  description: \"native\",\n  icon: \"https://ipfs.near.social/ipfs/bafkreiaeq6ca67je5ocago6vk2efwxiqurxgemputx7p2nt6n2p3zo65xq\",\n};\n\nconst wethAddress = \"0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c\";\n\nconst Tokens = {\n  \"0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c\": {\n    address: \"0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c\",\n    decimals: 18,\n    symbol: \"BTCB\",\n    name: \"BTCB\",\n    icon: \"https://ipfs.near.social/ipfs/bafkreigdklwcldjo4w7viyrym54hdb43wgpv23mbicetszygzapttbgo7q\",\n  },\n\n  \"0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c\": {\n    address: \"0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c\",\n    decimals: 18,\n    symbol: \"WBNB\",\n    name: \"WBNB\",\n    icon: \"https://ipfs.near.social/ipfs/bafkreiev2yrk7g4ugo3aytnqydxvtwlfw7ycxrxhk7ph6k2334z7djqd3e\",\n  },\n  \"0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56\": {\n    address: \"0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56\",\n    decimals: 18,\n    symbol: \"BUSD\",\n    name: \"BUSD\",\n    icon: \"https://ipfs.near.social/ipfs/bafkreibp36dfkfjzgnnbb7u4jxh57gpjmfjerc6pefmyzhueulz5ovd5xy\",\n  },\n  \"0x55d398326f99059fF775485246999027B3197955\": {\n    address: \"0x55d398326f99059fF775485246999027B3197955\",\n    decimals: 18,\n    symbol: \"USDT\",\n    name: \"USDT\",\n    icon: \"https://ipfs.near.social/ipfs/bafkreih45jy7ggj45ck34rf736kb67smsoa52wd7e46c2grh6etd3bhe5i\",\n  },\n\n  \"0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d\": {\n    address: \"0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d\",\n    decimals: 18,\n    symbol: \"USDC\",\n    name: \"USDC\",\n    icon: \"https://ipfs.near.social/ipfs/bafkreie4jihoa76mgyzxhw2yrapihzu2qhkjz6m7u4opoxjebzg6zc2lla\",\n  },\n\n  \"0x2170Ed0880ac9A755fd29B2688956BD959F933F8\": {\n    address: \"0x2170Ed0880ac9A755fd29B2688956BD959F933F8\",\n    decimals: 18,\n    symbol: \"ETH\",\n    name: \"ETH\",\n    icon: \"https://ipfs.near.social/ipfs/bafkreibspnls7q67q25r2ifv2rrfmvzl744pzuh3s5ekigeqkmyycl2auq\",\n  },\n};\n\nconst RewardToken = {\n  symbol: \"RDNT\",\n  address: \"0x3082CC23568eA640225c2467653dB90e9250AaA0\",\n  decimals: 18,\n  name: \"Radiant\",\n  icon: \"https://ipfs.near.social/ipfs/bafkreiboaplfrmdlyxumajlxnipkk4viu6pxqow7ue2ixlimgkenre2gru\",\n};\n\nconst aaveProtocolDataProviderAbi = [\n  {\n    inputs: [\n      {\n        internalType: \"contract ILendingPoolAddressesProvider\",\n        name: \"addressesProvider\",\n        type: \"address\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"constructor\",\n  },\n  {\n    inputs: [],\n    name: \"ADDRESSES_PROVIDER\",\n    outputs: [\n      {\n        internalType: \"contract ILendingPoolAddressesProvider\",\n        name: \"\",\n        type: \"address\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"getAllATokens\",\n    outputs: [\n      {\n        components: [\n          { internalType: \"string\", name: \"symbol\", type: \"string\" },\n          { internalType: \"address\", name: \"tokenAddress\", type: \"address\" },\n        ],\n        internalType: \"struct AaveProtocolDataProvider.TokenData[]\",\n        name: \"\",\n        type: \"tuple[]\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"getAllReservesTokens\",\n    outputs: [\n      {\n        components: [\n          { internalType: \"string\", name: \"symbol\", type: \"string\" },\n          { internalType: \"address\", name: \"tokenAddress\", type: \"address\" },\n        ],\n        internalType: \"struct AaveProtocolDataProvider.TokenData[]\",\n        name: \"\",\n        type: \"tuple[]\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"asset\", type: \"address\" }],\n    name: \"getReserveConfigurationData\",\n    outputs: [\n      { internalType: \"uint256\", name: \"decimals\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"ltv\", type: \"uint256\" },\n      {\n        internalType: \"uint256\",\n        name: \"liquidationThreshold\",\n        type: \"uint256\",\n      },\n      { internalType: \"uint256\", name: \"liquidationBonus\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"reserveFactor\", type: \"uint256\" },\n      { internalType: \"bool\", name: \"usageAsCollateralEnabled\", type: \"bool\" },\n      { internalType: \"bool\", name: \"borrowingEnabled\", type: \"bool\" },\n      { internalType: \"bool\", name: \"stableBorrowRateEnabled\", type: \"bool\" },\n      { internalType: \"bool\", name: \"isActive\", type: \"bool\" },\n      { internalType: \"bool\", name: \"isFrozen\", type: \"bool\" },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"asset\", type: \"address\" }],\n    name: \"getReserveData\",\n    outputs: [\n      { internalType: \"uint256\", name: \"availableLiquidity\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"totalStableDebt\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"totalVariableDebt\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"liquidityRate\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"variableBorrowRate\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"stableBorrowRate\", type: \"uint256\" },\n      {\n        internalType: \"uint256\",\n        name: \"averageStableBorrowRate\",\n        type: \"uint256\",\n      },\n      { internalType: \"uint256\", name: \"liquidityIndex\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"variableBorrowIndex\", type: \"uint256\" },\n      { internalType: \"uint40\", name: \"lastUpdateTimestamp\", type: \"uint40\" },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"asset\", type: \"address\" }],\n    name: \"getReserveTokensAddresses\",\n    outputs: [\n      { internalType: \"address\", name: \"aTokenAddress\", type: \"address\" },\n      {\n        internalType: \"address\",\n        name: \"stableDebtTokenAddress\",\n        type: \"address\",\n      },\n      {\n        internalType: \"address\",\n        name: \"variableDebtTokenAddress\",\n        type: \"address\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"asset\", type: \"address\" },\n      { internalType: \"address\", name: \"user\", type: \"address\" },\n    ],\n    name: \"getUserReserveData\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"currentATokenBalance\",\n        type: \"uint256\",\n      },\n      { internalType: \"uint256\", name: \"currentStableDebt\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"currentVariableDebt\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"principalStableDebt\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"scaledVariableDebt\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"stableBorrowRate\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"liquidityRate\", type: \"uint256\" },\n      { internalType: \"uint40\", name: \"stableRateLastUpdated\", type: \"uint40\" },\n      { internalType: \"bool\", name: \"usageAsCollateralEnabled\", type: \"bool\" },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\n\nconst ORACLE_ABI = [\n  {\n    inputs: [{ internalType: \"address\", name: \"asset\", type: \"address\" }],\n    name: \"getAssetPrice\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address[]\", name: \"assets\", type: \"address[]\" }],\n    name: \"getAssetsPrices\",\n    outputs: [{ internalType: \"uint256[]\", name: \"\", type: \"uint256[]\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\n\nconst {\n  aaveProtocolDataProviderAddress,\n  oracleAddress,\n  uiPoolDataProviderAddress,\n  account,\n  update,\n  onLoad,\n  PoolAddressProvider,\n  walletBalanceProvider,\n  lendingPoolAddress,\n  wethGateway,\n  initConfig,\n  loaded,\n  multicallAddress,\n} = props;\n\nconst MULTICALL_ABI = [\n  {\n    inputs: [\n      { internalType: \"bool\", name: \"requireSuccess\", type: \"bool\" },\n      {\n        components: [\n          { internalType: \"address\", name: \"target\", type: \"address\" },\n          { internalType: \"bytes\", name: \"callData\", type: \"bytes\" },\n        ],\n        internalType: \"struct Multicall2.Call[]\",\n        name: \"calls\",\n        type: \"tuple[]\",\n      },\n    ],\n    name: \"tryAggregate\",\n    outputs: [\n      {\n        components: [\n          { internalType: \"bool\", name: \"success\", type: \"bool\" },\n          { internalType: \"bytes\", name: \"returnData\", type: \"bytes\" },\n        ],\n        internalType: \"struct Multicall2.Result[]\",\n        name: \"returnData\",\n        type: \"tuple[]\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n];\n\nconst { incentiveController } = initConfig;\n\nif (\n  !aaveProtocolDataProviderAddress ||\n  !oracleAddress ||\n  !update ||\n  !account ||\n  !uiPoolDataProviderAddress\n)\n  return \"\";\n\nconst signer = Ethers.provider().getSigner();\n\nconst multicallv2 = (abi, calls, options, onError) => {\n  const { requireSuccess, ...overrides } = options || {};\n  const itf = new ethers.utils.Interface(abi);\n  const calldata = calls.map((call) => ({\n    target: call.address.toLowerCase(),\n    callData: itf.encodeFunctionData(call.name, call.params),\n  }));\n\n  const MulticallContract = new ethers.Contract(\n    multicallAddress,\n    MULTICALL_ABI,\n    signer\n  );\n  return MulticallContract.callStatic\n    .tryAggregate(requireSuccess || true, calldata, overrides)\n    .then((res) => {\n      return res.map((call, i) => {\n        const [result, data] = call;\n        return result && data !== \"0x\"\n          ? itf.decodeFunctionResult(calls[i].name, data)\n          : null;\n      });\n    })\n    .catch((err) => {\n      console.log(\"err: \", err);\n      onError?.(err);\n    });\n};\n\nlet rewardPrice = \"0\";\n\nconst rndtPriceData = fetch(\n  \"https://api.coingecko.com/api/v3/simple/price?ids=radiant-capital&vs_currencies=usd\"\n);\n\nif (rndtPriceData) {\n  const data = rndtPriceData.body || [];\n\n  rewardPrice = data[\"radiant-capital\"].usd;\n}\n\nconst getTokensPrices = () => {\n  const oracleContract = new ethers.Contract(oracleAddress, ORACLE_ABI, signer);\n  oracleContract.getAssetsPrices(Object.keys(Tokens)).then((res) => {\n    const parsedRes = res.map((price, i) => {\n      return Big(price.toString()).div(100000000).toFixed();\n    });\n\n    const tokensPrice = {};\n    Object.keys(Tokens).forEach((address, index) => {\n      tokensPrice[address] = parsedRes[index];\n    });\n    State.update({\n      tokensPrice,\n    });\n  });\n};\n\nconst getUserWalletBalances = () => {\n  const walletBalanceProviderContract = new ethers.Contract(\n    walletBalanceProvider,\n    [\n      {\n        inputs: [\n          { internalType: \"address\", name: \"provider\", type: \"address\" },\n          { internalType: \"address\", name: \"user\", type: \"address\" },\n        ],\n        name: \"getUserWalletBalances\",\n        outputs: [\n          { internalType: \"address[]\", name: \"\", type: \"address[]\" },\n          { internalType: \"uint256[]\", name: \"\", type: \"uint256[]\" },\n        ],\n        stateMutability: \"view\",\n        type: \"function\",\n      },\n    ],\n    signer\n  );\n\n  const balances = {};\n\n  walletBalanceProviderContract\n    .getUserWalletBalances(PoolAddressProvider, account)\n    .then((res) => {\n      const addresses = res[0];\n      const values = res[1];\n\n      values.forEach((value, index) => {\n        const parsedValue = Big(value.toString())\n          .div(Big(10).pow(Tokens[addresses[index]]?.decimals || 18))\n          .toFixed();\n\n        balances[addresses[index]] = parsedValue;\n      });\n\n      State.update({\n        balances,\n      });\n    });\n};\n\nif (!state.balances) {\n  getUserWalletBalances();\n}\n\nconst getUserRewards = (aTokenAddress, variableDebtTokenAddress, address) => {\n  const incentiveControllerAbi = [\n    {\n      inputs: [\n        { internalType: \"address\", name: \"\", type: \"address\" },\n        { internalType: \"address\", name: \"\", type: \"address\" },\n      ],\n      name: \"userInfo\",\n      outputs: [\n        { internalType: \"uint256\", name: \"amount\", type: \"uint256\" },\n        { internalType: \"uint256\", name: \"rewardDebt\", type: \"uint256\" },\n        { internalType: \"uint256\", name: \"enterTime\", type: \"uint256\" },\n        { internalType: \"uint256\", name: \"lastClaimTime\", type: \"uint256\" },\n      ],\n      stateMutability: \"view\",\n      type: \"function\",\n    },\n    {\n      inputs: [\n        { internalType: \"address\", name: \"_user\", type: \"address\" },\n        { internalType: \"address[]\", name: \"_tokens\", type: \"address[]\" },\n      ],\n      name: \"pendingRewards\",\n      outputs: [{ internalType: \"uint256[]\", name: \"\", type: \"uint256[]\" }],\n      stateMutability: \"view\",\n      type: \"function\",\n    },\n    {\n      inputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n      name: \"poolInfo\",\n      outputs: [\n        { internalType: \"uint256\", name: \"totalSupply\", type: \"uint256\" },\n        { internalType: \"uint256\", name: \"allocPoint\", type: \"uint256\" },\n        { internalType: \"uint256\", name: \"lastRewardTime\", type: \"uint256\" },\n        { internalType: \"uint256\", name: \"accRewardPerShare\", type: \"uint256\" },\n        {\n          internalType: \"contract IOnwardIncentivesController\",\n          name: \"onwardIncentives\",\n          type: \"address\",\n        },\n      ],\n      stateMutability: \"view\",\n      type: \"function\",\n    },\n    {\n      inputs: [],\n      name: \"totalAllocPoint\",\n      outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n      stateMutability: \"view\",\n      type: \"function\",\n    },\n    {\n      inputs: [],\n      name: \"rewardsPerSecond\",\n      outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n      stateMutability: \"view\",\n      type: \"function\",\n    },\n  ];\n\n  const calls = [\n    {\n      address: incentiveController,\n      name: \"totalAllocPoint\",\n      params: [],\n    },\n    {\n      address: incentiveController,\n      name: \"rewardsPerSecond\",\n      params: [],\n    },\n    {\n      address: incentiveController,\n      name: \"poolInfo\",\n      params: [aTokenAddress],\n    },\n    {\n      address: incentiveController,\n      name: \"userInfo\",\n      params: [aTokenAddress, account],\n    },\n    {\n      address: incentiveController,\n      name: \"pendingRewards\",\n      params: [account, [aTokenAddress]],\n    },\n\n    {\n      address: incentiveController,\n      name: \"poolInfo\",\n      params: [variableDebtTokenAddress],\n    },\n    {\n      address: incentiveController,\n      name: \"userInfo\",\n      params: [variableDebtTokenAddress, account],\n    },\n    {\n      address: incentiveController,\n      name: \"pendingRewards\",\n      params: [account, [variableDebtTokenAddress]],\n    },\n  ];\n  return multicallv2(incentiveControllerAbi, calls, {})\n    .then((res) => {\n      const ACC_REWARD_PRECISION = Big(10).pow(12);\n      console.log(\"ACC_REWARD_PRECISION: \", ACC_REWARD_PRECISION, res);\n\n      const totalAllocPoint = res[0].toString();\n      const rewardsPerSecond = res[1].toString();\n\n      const poolInfo = res[2];\n      const poolInfoDebt = res[5];\n      console.log(\"poolInfoDebt: \", poolInfoDebt);\n\n      const totalSupply = poolInfo[0].toString();\n      const totalSupplyDebt = poolInfoDebt[0].toString();\n\n      const allocPoint = poolInfo[1].toString();\n      const allocPointDebt = poolInfoDebt[1].toString();\n\n      const dailyRewardToThisPool = Big(60 * 60 * 24)\n        .times(rewardsPerSecond)\n        .times(allocPoint)\n        .div(totalAllocPoint);\n\n      const yearlyRewardToThisPool = dailyRewardToThisPool\n        .mul(365)\n        .div(Big(10).pow(RewardToken.decimals));\n\n      console.log(\"yearlyRewardToThisPool: \", yearlyRewardToThisPool);\n\n      const yearlyRewardToThisPoolUsd = Big(yearlyRewardToThisPool).times(\n        rewardPrice\n      );\n      const totalSupplyUsd = Big(state.tokensPrice[address]).mul(\n        ethers.utils.formatUnits(poolInfo[0]._hex, Tokens[address].decimals)\n      );\n      const supplyApy = yearlyRewardToThisPoolUsd\n        .div(totalSupplyUsd)\n        .mul(100)\n        .toFixed(2, 0);\n\n      console.log(\"supplyApy: \", supplyApy);\n\n      const dailyRewardToThisPoolDebt = Big(60 * 60 * 24)\n        .times(rewardsPerSecond)\n        .times(allocPointDebt)\n        .div(totalAllocPoint);\n\n      const yearlyRewardToThisPoolDebt = dailyRewardToThisPoolDebt\n        .mul(365)\n        .div(Big(10).pow(RewardToken.decimals));\n\n      const yearlyRewardToThisPoolDebtUsd = Big(\n        yearlyRewardToThisPoolDebt\n      ).times(rewardPrice);\n\n      const totalBorrowUsd = Big(state.tokensPrice[address]).mul(\n        ethers.utils.formatUnits(poolInfoDebt[0]._hex, Tokens[address].decimals)\n      );\n      const borrowApy = yearlyRewardToThisPoolDebtUsd\n        .div(totalBorrowUsd)\n        .mul(100)\n        .toFixed(2, 0);\n\n      console.log(\"borrowApy: \", borrowApy);\n\n      const rewardPerShareThisPool = dailyRewardToThisPool\n        .mul(ACC_REWARD_PRECISION)\n        .div(totalSupply)\n        .toFixed(0);\n\n      const rewardPerShareThisPoolDebt = dailyRewardToThisPoolDebt\n        .mul(ACC_REWARD_PRECISION)\n        .div(totalSupplyDebt)\n        .toFixed(0);\n\n      const userInfo = res[3];\n      const userInfoDebt = res[6];\n\n      const amount = userInfo[0].toString();\n      const amountDebt = userInfoDebt[0].toString();\n\n      const userDailyReward = Big(rewardPerShareThisPool)\n        .times(Big(amount))\n        .div(ACC_REWARD_PRECISION)\n        .toFixed();\n\n      const userDailyRewardDebt = Big(rewardPerShareThisPoolDebt)\n        .times(Big(amountDebt))\n        .div(ACC_REWARD_PRECISION)\n        .toFixed();\n\n      const pendingRewards = res[4];\n      const pendingRewardsDebt = res[7];\n\n      const unclaimed = pendingRewards[0].toString();\n      const unclaimedDebt = pendingRewardsDebt[0].toString();\n\n      const dailyRewards = Big(userDailyReward).toFixed();\n\n      const dailyRewardsDebt = Big(userDailyRewardDebt).toFixed();\n\n      const rewards = {\n        ...RewardToken,\n        unclaimed,\n        price: rewardPrice,\n        dailyRewards,\n        rewardAddress: aTokenAddress,\n      };\n\n      const rewardsDebt = {\n        ...RewardToken,\n        unclaimed: unclaimedDebt,\n        price: rewardPrice,\n        dailyRewards: dailyRewardsDebt,\n        rewardAddress: variableDebtTokenAddress,\n      };\n\n      return {\n        ...rewards,\n        unclaimed: Big(rewards.unclaimed).plus(rewardsDebt.unclaimed).toFixed(),\n        supplyApy,\n        borrowApy,\n        dailyRewards: Big(rewards.dailyRewards)\n          .plus(rewardsDebt.dailyRewards)\n          .toFixed(),\n      };\n    })\n    .catch((e) => {\n      return undefined;\n    });\n};\n\nconst getRewardApy = (aTokenAddress, variableDebtTokenAddress, address) => {\n  const incentiveControllerAbi = [\n    {\n      inputs: [\n        { internalType: \"address\", name: \"\", type: \"address\" },\n        { internalType: \"address\", name: \"\", type: \"address\" },\n      ],\n      name: \"userInfo\",\n      outputs: [\n        { internalType: \"uint256\", name: \"amount\", type: \"uint256\" },\n        { internalType: \"uint256\", name: \"rewardDebt\", type: \"uint256\" },\n        { internalType: \"uint256\", name: \"enterTime\", type: \"uint256\" },\n        { internalType: \"uint256\", name: \"lastClaimTime\", type: \"uint256\" },\n      ],\n      stateMutability: \"view\",\n      type: \"function\",\n    },\n    {\n      inputs: [\n        { internalType: \"address\", name: \"_user\", type: \"address\" },\n        { internalType: \"address[]\", name: \"_tokens\", type: \"address[]\" },\n      ],\n      name: \"pendingRewards\",\n      outputs: [{ internalType: \"uint256[]\", name: \"\", type: \"uint256[]\" }],\n      stateMutability: \"view\",\n      type: \"function\",\n    },\n    {\n      inputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n      name: \"poolInfo\",\n      outputs: [\n        { internalType: \"uint256\", name: \"totalSupply\", type: \"uint256\" },\n        { internalType: \"uint256\", name: \"allocPoint\", type: \"uint256\" },\n        { internalType: \"uint256\", name: \"lastRewardTime\", type: \"uint256\" },\n        { internalType: \"uint256\", name: \"accRewardPerShare\", type: \"uint256\" },\n        {\n          internalType: \"contract IOnwardIncentivesController\",\n          name: \"onwardIncentives\",\n          type: \"address\",\n        },\n      ],\n      stateMutability: \"view\",\n      type: \"function\",\n    },\n    {\n      inputs: [],\n      name: \"totalAllocPoint\",\n      outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n      stateMutability: \"view\",\n      type: \"function\",\n    },\n    {\n      inputs: [],\n      name: \"rewardsPerSecond\",\n      outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n      stateMutability: \"view\",\n      type: \"function\",\n    },\n  ];\n\n  const calls = [\n    {\n      address: incentiveController,\n      name: \"totalAllocPoint\",\n      params: [],\n    },\n    {\n      address: incentiveController,\n      name: \"rewardsPerSecond\",\n      params: [],\n    },\n    {\n      address: incentiveController,\n      name: \"poolInfo\",\n      params: [aTokenAddress],\n    },\n    {\n      address: incentiveController,\n      name: \"poolInfo\",\n      params: [variableDebtTokenAddress],\n    },\n  ];\n  return multicallv2(incentiveControllerAbi, calls, {})\n    .then((res) => {\n      console.log(\"res: \", res);\n      const totalAllocPoint = res[0].toString();\n      const rewardsPerSecond = res[1].toString();\n\n      const poolInfo = res[2];\n      const poolInfoDebt = res[3];\n\n      const allocPoint = poolInfo[1].toString();\n      const allocPointDebt = poolInfoDebt[1].toString();\n\n      const dailyRewardToThisPool = Big(60 * 60 * 24)\n        .times(rewardsPerSecond)\n        .times(allocPoint)\n        .div(totalAllocPoint);\n\n      const yearlyRewardToThisPool = dailyRewardToThisPool\n        .mul(365)\n        .div(Big(10).pow(RewardToken.decimals));\n\n      const yearlyRewardToThisPoolUsd = Big(yearlyRewardToThisPool).times(\n        rewardPrice\n      );\n      const totalSupplyUsd = Big(state.tokensPrice[address]).mul(\n        ethers.utils.formatUnits(poolInfo[0]._hex, Tokens[address].decimals)\n      );\n      const supplyApy = yearlyRewardToThisPoolUsd\n        .div(totalSupplyUsd)\n        .mul(100)\n        .toFixed(2, 0);\n\n      const dailyRewardToThisPoolDebt = Big(60 * 60 * 24)\n        .times(rewardsPerSecond)\n        .times(allocPointDebt)\n        .div(totalAllocPoint);\n\n      const yearlyRewardToThisPoolDebt = dailyRewardToThisPoolDebt\n        .mul(365)\n        .div(Big(10).pow(RewardToken.decimals));\n\n      const yearlyRewardToThisPoolDebtUsd = Big(\n        yearlyRewardToThisPoolDebt\n      ).times(rewardPrice);\n\n      const totalBorrowUsd = Big(state.tokensPrice[address]).mul(\n        ethers.utils.formatUnits(poolInfoDebt[0]._hex, Tokens[address].decimals)\n      );\n      const borrowApy = yearlyRewardToThisPoolDebtUsd\n        .div(totalBorrowUsd)\n        .mul(100)\n        .toFixed(2, 0);\n\n      console.log(\"borrowApy: \", borrowApy);\n\n      return {\n        supplyApy,\n        borrowApy,\n      };\n    })\n    .catch((e) => {\n      return undefined;\n    });\n};\n\nconst getMarkets = () => {\n  const dataProviderContract = new ethers.Contract(\n    aaveProtocolDataProviderAddress,\n    aaveProtocolDataProviderAbi,\n    signer\n  );\n\n  dataProviderContract.getAllReservesTokens().then((markets) => {\n    State.update({\n      markets,\n    });\n\n    markets.forEach((token) => {\n      const [symbol, address] = token;\n\n      const tokensPrice = state.tokensPrice;\n\n      const calls = [\n        {\n          address: aaveProtocolDataProviderAddress,\n          name: \"getReserveConfigurationData\",\n          params: [address],\n        },\n        {\n          address: aaveProtocolDataProviderAddress,\n          name: \"getReserveTokensAddresses\",\n          params: [address],\n        },\n      ];\n\n      return multicallv2(aaveProtocolDataProviderAbi, calls, {}).then((res) => {\n        const loanToValue = Big(res[0][1].toString()).div(100).toNumber();\n\n        const aTokenAddress = res[1][0];\n        const variableDebtTokenAddress = res[1][2];\n        console.log(\n          \"variableDebtTokenAddress: \",\n          variableDebtTokenAddress,\n          aTokenAddress\n        );\n\n        getRewardApy(aTokenAddress, variableDebtTokenAddress, address).then(\n          ({\n            supplyApy: incentiveSupplyApy,\n            borrowApy: incentiveBorrowApy,\n          }) => {\n            getUserRewards(\n              aTokenAddress,\n              variableDebtTokenAddress,\n              address\n            ).then((rawRewards) => {\n              const rewards = !rawRewards ? undefined : [rawRewards];\n              getTokenReserveData(\n                address,\n                symbol,\n                tokensPrice[address],\n                aTokenAddress,\n                variableDebtTokenAddress,\n                loanToValue,\n                rewards,\n                incentiveSupplyApy,\n                incentiveBorrowApy\n              );\n            });\n          }\n        );\n      });\n    });\n  });\n};\n\nconst getTokenReserveData = (\n  tokenAddress,\n  symbol,\n  price,\n  aTokenAddress,\n  variableDebtTokenAddress,\n  loanToValue,\n  rewards,\n  incentiveSupplyApy,\n  incentiveBorrowApy\n) => {\n  const dataProviderContract = new ethers.Contract(\n    aaveProtocolDataProviderAddress,\n    aaveProtocolDataProviderAbi,\n    signer\n  );\n\n  dataProviderContract.getReserveData(tokenAddress).then((data) => {\n    const [\n      availableLiquidity,\n      totalStableDebt,\n      totalVariableDebt,\n      liquidityRate,\n      variableBorrowRate,\n      stableBorrowRate,\n      averageStableBorrowRate,\n      liquidityIndex,\n      variableBorrowIndex,\n      lastUpdateTimestamp,\n    ] = data;\n\n    const decimalBig = Big(10).pow(Tokens[tokenAddress].decimals);\n\n    const totalDebt = Big(totalStableDebt.toString())\n      .plus(totalVariableDebt.toString())\n      .div(decimalBig)\n      .toFixed();\n    const totalDebtUsd = Big(totalDebt).times(price).toFixed();\n    const totalDebtRaw = Big(totalStableDebt.toString())\n      .plus(totalVariableDebt.toString())\n      .toFixed();\n    const totalDeposit = Big(availableLiquidity.toString())\n      .plus(totalDebtRaw)\n      .div(decimalBig)\n      .toFixed();\n\n    const totalDepositUsd = Big(totalDeposit).times(price).toFixed();\n\n    const marketSize = Big(availableLiquidity.toString())\n      .div(decimalBig)\n      .toFixed();\n\n    const Ray = Big(10).pow(27);\n\n    const SECONDS_PER_YEAR = 31536000;\n\n    const depositAPR = Big(liquidityRate).div(Ray);\n\n    const variableBorrowAPR = Big(variableBorrowRate).div(Ray);\n\n    const depositAPY0 = Big(1)\n      .plus(depositAPR.div(Big(SECONDS_PER_YEAR)))\n      .toNumber();\n\n    const depositAPY = Big(\n      100 * (Math.pow(depositAPY0, SECONDS_PER_YEAR) - 1)\n    ).toFixed(2);\n\n    const variableBorrowAPY0 = Big(1)\n      .plus(Big(variableBorrowAPR).div(Big(SECONDS_PER_YEAR)))\n      .toNumber();\n\n    const variableBorrowAPYRaw = Big(\n      100 * (Math.pow(variableBorrowAPY0, SECONDS_PER_YEAR) - 1)\n    );\n\n    const variableBorrowAPY = Big(\n      100 * (Math.pow(variableBorrowAPY0, SECONDS_PER_YEAR) - 1)\n    ).toFixed(2);\n\n    const netApyBig = Big(depositAPY0).minus(variableBorrowAPYRaw);\n\n    console.log(\"incentiveSupplyApy: \", incentiveSupplyApy, incentiveBorrowApy);\n\n    State.update({\n      [tokenAddress]: {\n        availableLiquidity,\n        totalStableDebt,\n        totalVariableDebt,\n        totalBorrows: !price ? \"-\" : Big(totalDebt).toFixed(4),\n        totalSupply: !price ? \"-\" : Big(totalDeposit).toFixed(4),\n        liquidity: !price ? \"-\" : Big(marketSize).toFixed(4),\n        totalDebtUsd,\n        totalDepositUsd,\n        liquidityRate,\n        variableBorrowRate,\n        stableBorrowRate,\n        averageStableBorrowRate,\n        liquidityIndex,\n        variableBorrowIndex,\n        lastUpdateTimestamp,\n        tokenAddress,\n        depositAPY,\n        loanToValue,\n        supplyApy: depositAPY + \"%\",\n        variableBorrowAPY,\n        borrowApy: variableBorrowAPY + \"%\",\n        underlyingPrice: price,\n        underlyingToken:\n          tokenAddress.toLowerCase() === wethAddress.toLowerCase()\n            ? native\n            : Tokens[tokenAddress],\n        dapp: \"Radiant\",\n        dappName: \"Radiant\",\n        address: tokenAddress,\n        ...(tokenAddress.toLowerCase() === wethAddress.toLowerCase()\n          ? native\n          : Tokens[tokenAddress]),\n        userUnderlyingBalance: state.balances[tokenAddress],\n        netApy: netApyBig.toFixed(),\n        aTokenAddress,\n        variableDebtTokenAddress,\n        wethAddress,\n        rewards,\n        distributionApy: [\n          {\n            ...RewardToken,\n            supply: incentiveSupplyApy + \"%\",\n            borrow: incentiveBorrowApy + \"%\",\n          },\n        ],\n      },\n    });\n  });\n};\n\nconst getUserRevervesData = (addresses) => {\n  const calls = addresses.map((address) => {\n    return {\n      address: aaveProtocolDataProviderAddress,\n      name: \"getUserReserveData\",\n      params: [address, account],\n    };\n  });\n\n  multicallv2(aaveProtocolDataProviderAbi, calls, {}).then((res) => {\n    const parsedData = res.map((data, index) => {\n      const address = addresses[index];\n\n      const underlyingAsset = Tokens[address];\n\n      const scaledATokenBalance = Big(data[0].toString())\n        .div(Big(10).pow(underlyingAsset.decimals))\n        // .times(state.tokensPrice[address])\n        .toFixed();\n\n      const scaledATokenBalanceUsd = Big(data[0].toString())\n        .div(Big(10).pow(underlyingAsset.decimals))\n        .times(state.tokensPrice[address])\n        .toFixed();\n\n      const aTokenBalance = Big(data[0].toString())\n        .div(Big(10).pow(underlyingAsset.decimals))\n        .toFixed();\n\n      const usageAsCollateralEnabledOnUser = data[8];\n\n      const scaledVariableDebt = Big(data[2].toString())\n        .div(Big(10).pow(underlyingAsset.decimals))\n        .toFixed();\n\n      const scaledVariableDebtUsd = Big(data[2].toString())\n        .div(Big(10).pow(underlyingAsset.decimals))\n        .times(state.tokensPrice[address])\n        .toFixed();\n\n      return {\n        address,\n        underlyingAsset,\n        scaledATokenBalanceUsd,\n        scaledATokenBalance,\n        usageAsCollateralEnabledOnUser,\n        scaledVariableDebt,\n        scaledVariableDebtUsd,\n        aTokenBalance,\n        userMerberShip: usageAsCollateralEnabledOnUser,\n      };\n    });\n\n    let userTotalSupplyUsd = Big(0);\n    let userTotalBorrowUsd = Big(0);\n\n    parsedData.forEach((data, i) => {\n      userTotalSupplyUsd = userTotalSupplyUsd.plus(data.scaledATokenBalanceUsd);\n\n      userTotalBorrowUsd = userTotalBorrowUsd.plus(data.scaledVariableDebtUsd);\n    });\n\n    State.update({\n      userData: {\n        userTotalSupplyUsd: userTotalSupplyUsd.toString(),\n        userTotalBorrowUsd: userTotalBorrowUsd.toString(),\n        parsedData,\n      },\n    });\n  });\n};\n\nif (!state.tokensPrice) {\n  getTokensPrices();\n}\n\nif (\n  !state.markets &&\n  state.tokensPrice &&\n  state.balances &&\n  !state.userLoading\n) {\n  State.update({ userLoading: true });\n\n  getMarkets();\n}\n\nif (state.markets && !state.userData) {\n  const addresses = state.markets.map((market) => market[1]);\n\n  getUserRevervesData(addresses);\n}\n\nif (\n  state.userData &&\n  state.markets &&\n  Object.keys(state).length === state.markets.length + 5\n) {\n  const {\n    markets,\n    tokensPrice,\n    balances,\n    userData,\n    userLoading,\n    ...marketData\n  } = state;\n\n  userData.parsedData.forEach((d) => {\n    const { address } = d;\n    marketData[address].userMerberShip = d.userMerberShip;\n  });\n\n  let netApy = Big(0);\n\n  userData.parsedData.forEach((d) => {\n    const { address } = d;\n    marketData[address] = {\n      ...d,\n      ...marketData[address],\n      userSupply: d.scaledATokenBalance,\n      userBorrow: d.scaledVariableDebt,\n    };\n  });\n\n  let reduceUnclaimed = Big(0);\n\n  let reduceDailyRewards = Big(0);\n\n  let totalCollateralUsd = Big(0);\n\n  Object.keys(marketData).forEach((address, i) => {\n    const market = marketData[address];\n    if (market.rewards) {\n      const unclaimed = market.rewards[0].unclaimed;\n      const dailyRewards = market.rewards[0].dailyRewards;\n\n      reduceUnclaimed = reduceUnclaimed.plus(Big(unclaimed));\n\n      reduceDailyRewards = reduceDailyRewards.plus(Big(dailyRewards));\n    }\n\n    if (userData.parsedData[i]) {\n      const data = userData.parsedData[i];\n      if (data.usageAsCollateralEnabledOnUser) {\n        totalCollateralUsd = totalCollateralUsd\n          .plus(data.scaledATokenBalanceUsd)\n          .times(market.loanToValue / 100);\n      }\n    }\n\n    const { netApy: netApyRaw } = market;\n    netApy = netApy.plus(netApyRaw);\n    console.log(\"netApy: \", netApy);\n\n    market.userUnderlyingBalance = market.aTokenBalance;\n\n    market.lendingPoolAddress = lendingPoolAddress;\n\n    market.wethGateway = wethGateway;\n\n    market.address = market.aTokenAddress;\n  });\n\n  userData.totalCollateralUsd = totalCollateralUsd.toFixed();\n\n  userData.netApy = netApy.toFixed(2);\n\n  const parsedMarketData = {};\n\n  Object.entries(marketData).map(([address, market], index) => {\n    parsedMarketData[market.aTokenAddress] = market;\n  });\n\n  userData.rewards = [\n    {\n      ...RewardToken,\n      unclaimed: reduceUnclaimed\n        .div(Big(10).pow(RewardToken.decimals))\n        .toFixed(),\n      dailyRewards: reduceDailyRewards\n        .div(Big(10).pow(RewardToken.decimals))\n        .toFixed(),\n      price: rewardPrice,\n    },\n  ];\n\n  onLoad({\n    ...{ ...userData, ...props },\n    markets: parsedMarketData,\n    name: initConfig.name,\n  });\n}\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/bluebiu.near/widget/Bsc.Lending.RadiantData", "fact_widget_deployments_id": "18c3bf033b2c205cace2e624134542cf", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 0}