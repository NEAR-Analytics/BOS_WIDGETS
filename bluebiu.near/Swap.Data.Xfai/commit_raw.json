{"tx_hash": "7H8S4twWGgzq2djRJRc9o6wxHTySrnRHMeANBfnn6x33", "action_id_social": "4vuNGwgCtwb1rpbkhpn6QeA4cEuLP7CmPw4xx1u5BeWF-0-widget", "block_id": 111338498, "block_timestamp": "2024-01-26T06:05:36.643Z", "signer_id": "bluebiu.near", "widget_name": "Swap.Data.Xfai", "source_code": "const ROUTER_ABI = [\n  {\n    inputs: [\n      { internalType: \"address\", name: \"_to\", type: \"address\" },\n      { internalType: \"address\", name: \"_token0\", type: \"address\" },\n      { internalType: \"address\", name: \"_token1\", type: \"address\" },\n      { internalType: \"uint256\", name: \"_amount0In\", type: \"uint256\" },\n      {\n        internalType: \"uint256\",\n        name: \"_amount1OutMin\",\n        type: \"uint256\",\n      },\n      { internalType: \"uint256\", name: \"_deadline\", type: \"uint256\" },\n    ],\n    name: \"swapExactTokensForTokens\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"_to\", type: \"address\" },\n      { internalType: \"address\", name: \"_token1\", type: \"address\" },\n      {\n        internalType: \"uint256\",\n        name: \"_amount1OutMin\",\n        type: \"uint256\",\n      },\n      { internalType: \"uint256\", name: \"_deadline\", type: \"uint256\" },\n    ],\n    name: \"swapExactETHForTokens\",\n    outputs: [{ internalType: \"uint256\", name: \"amount1Out\", type: \"uint256\" }],\n    stateMutability: \"payable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"_to\", type: \"address\" },\n      { internalType: \"address\", name: \"_token0\", type: \"address\" },\n      { internalType: \"uint256\", name: \"_amount0In\", type: \"uint256\" },\n      {\n        internalType: \"uint256\",\n        name: \"_amount1OutMin\",\n        type: \"uint256\",\n      },\n      { internalType: \"uint256\", name: \"_deadline\", type: \"uint256\" },\n    ],\n    name: \"swapExactTokensForETH\",\n    outputs: [{ internalType: \"uint256\", name: \"amount1Out\", type: \"uint256\" }],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n];\nconst PAIR_ABI = [\n  {\n    inputs: [],\n    name: \"getStates\",\n    outputs: [\n      { internalType: \"uint256\", name: \"\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"\", type: \"uint256\" },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\nconst FACTORY_ABI = [\n  {\n    inputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n    name: \"getPool\",\n    outputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\n\nconst {\n  updater,\n  routerAddress,\n  factoryAddress,\n  multicallAddress,\n  wethAddress,\n  inputCurrency,\n  outputCurrency,\n  inputCurrencyAmount,\n  onLoad,\n  multicall,\n  slippage,\n  account,\n  prices,\n} = props;\n\nuseEffect(() => {\n  if (!updater) return;\n\n  if (\n    (!inputCurrency.address && !inputCurrency.isNative) ||\n    (!outputCurrency.address && !outputCurrency.isNative) ||\n    !inputCurrencyAmount\n  ) {\n    return;\n  }\n\n  const wrapType =\n    inputCurrency.isNative && outputCurrency.address === wethAddress\n      ? 1\n      : inputCurrency.address === wethAddress && outputCurrency.isNative\n      ? 2\n      : 0;\n\n  if (wrapType) {\n    onLoad({\n      outputCurrencyAmount: inputCurrencyAmount,\n      noPair: false,\n    });\n    return;\n  }\n\n  const amount = ethers.utils.parseUnits(\n    Big(inputCurrencyAmount || 0).toFixed(inputCurrency.decimals),\n    inputCurrency.decimals\n  );\n\n  const path = [\n    inputCurrency.isNative ? wethAddress : inputCurrency.address,\n    outputCurrency.isNative ? wethAddress : outputCurrency.address,\n  ];\n\n  const RouterContract = new ethers.Contract(\n    routerAddress,\n    ROUTER_ABI,\n    Ethers.provider().getSigner()\n  );\n\n  const getAmountOut = () => {\n    const factoryCalls = path.map((_path) => ({\n      address: factoryAddress,\n      name: \"getPool\",\n      params: [_path],\n    }));\n    multicall({\n      abi: FACTORY_ABI,\n      calls: factoryCalls,\n      options: {},\n      multicallAddress,\n      provider: Ethers.provider(),\n    })\n      .then((res) => {\n        const pool0 = inputCurrency.isNative ? null : res[0][0];\n        const pool1 = outputCurrency.isNative ? null : res[1][0];\n        const poolCalls = [];\n        if (pool0) {\n          poolCalls.push({\n            address: pool0,\n            name: \"getStates\",\n          });\n        }\n        if (pool1) {\n          poolCalls.push({\n            address: pool1,\n            name: \"getStates\",\n          });\n        }\n        multicall({\n          abi: PAIR_ABI,\n          calls: poolCalls,\n          options: {},\n          multicallAddress,\n          provider: Ethers.provider(),\n        })\n          .then((poolsRes) => {\n            let pool0Reverse = 0;\n            let pool0EthReverse = 0;\n            let pool1Reverse = 0;\n            let pool1EthReverse = 0;\n\n            if (pool0) {\n              pool0Reverse = ethers.utils.formatUnits(\n                poolsRes[0][0],\n                inputCurrency.decimals\n              );\n              pool0EthReverse = ethers.utils.formatUnits(poolsRes[0][1], 18);\n            }\n            if (!pool0 && pool1) {\n              pool0Reverse = ethers.utils.formatUnits(\n                poolsRes[0][0],\n                outputCurrency.decimals\n              );\n              pool0EthReverse = ethers.utils.formatUnits(poolsRes[0][1], 18);\n            }\n\n            if (pool0 && pool1) {\n              pool1Reverse = poolsRes[1]\n                ? ethers.utils.formatUnits(\n                    poolsRes[1][0],\n                    outputCurrency.decimals\n                  )\n                : 0;\n              pool1EthReverse = poolsRes[1]\n                ? ethers.utils.formatUnits(poolsRes[1][1], 18)\n                : 0;\n            }\n\n            let amountOut = 0;\n\n            if (!pool0) {\n              amountOut = Big(pool0Reverse)\n                .div(pool0EthReverse)\n                .mul(inputCurrencyAmount)\n                .toString();\n            } else if (!pool1) {\n              amountOut = Big(pool0EthReverse)\n                .div(pool0Reverse)\n                .mul(inputCurrencyAmount)\n                .toString();\n            } else {\n              const token0Price = Big(pool0Reverse).div(pool0EthReverse);\n              const token1Price = Big(pool1Reverse).div(pool1EthReverse);\n              amountOut = token0Price\n                .div(token1Price)\n                .mul(inputCurrencyAmount)\n                .toString();\n            }\n            getTransaction(amountOut);\n          })\n          .catch((err) => {\n            onLoad({\n              noPair: true,\n              outputCurrencyAmount: \"\",\n            });\n          });\n      })\n      .catch((err) => {\n        onLoad({\n          noPair: true,\n          outputCurrencyAmount: \"\",\n        });\n      });\n  };\n\n  const getTransaction = (amountOut) => {\n    let method = \"\";\n    const deadline = Math.ceil(Date.now() / 1000) + 60;\n\n    const _amountOut = Big(amountOut)\n      .mul(Big(10).pow(outputCurrency.decimals))\n      .mul(1 - (slippage || 0.05))\n      .toFixed(0);\n\n    let priceImpact = null;\n    if (prices) {\n      const isReverse = Number(path[0]) > Number(path[1]);\n\n      const poolPrice = Big(\n        prices[isReverse ? inputCurrency.symbol : outputCurrency.symbol] || 0\n      ).div(\n        prices[!isReverse ? inputCurrency.symbol : outputCurrency.symbol] || 0\n      );\n\n      const amountoutPrice = !isReverse\n        ? Big(inputCurrencyAmount).div(amountOut)\n        : Big(amountOut).div(inputCurrencyAmount);\n\n      priceImpact = poolPrice\n        .minus(amountoutPrice)\n        .div(poolPrice)\n        .mul(100)\n        .toString();\n    }\n\n    const options = {};\n    let params = [];\n    if (inputCurrency.isNative) {\n      method = \"swapExactETHForTokens\";\n      params = [account, path[1], _amountOut, deadline];\n      options.value = amount;\n    } else if (outputCurrency.isNative) {\n      params = [account, path[0], amount, _amountOut, deadline];\n      method = \"swapExactTokensForETH\";\n    } else {\n      params = [account, path[0], path[1], amount, _amountOut, deadline];\n      method = \"swapExactTokensForTokens\";\n    }\n    const returnData = {\n      outputCurrencyAmount: Big(amountOut).gt(0.01)\n        ? Big(amountOut).toPrecision(10)\n        : Big(amountOut).toFixed(10),\n      priceImpact,\n    };\n\n    const getTx = (_gas) => {\n      RouterContract.populateTransaction[method](...params, {\n        ...options,\n        gasLimit: _gas,\n      })\n        .then((res) => {\n          onLoad({\n            ...returnData,\n            noPair: false,\n            gas: _gas,\n            unsignedTx: res,\n          });\n        })\n        .catch((err) => {\n          onLoad({\n            ...returnData,\n            noPair: false,\n            gas: _gas,\n          });\n        });\n    };\n\n    const estimateGas = () => {\n      RouterContract.estimateGas[method](...params, options)\n        .then((_gas) => {\n          getTx(_gas);\n        })\n        .catch((err) => {\n          onLoad({\n            ...returnData,\n            noPair: false,\n          });\n        });\n    };\n\n    estimateGas();\n  };\n  getAmountOut();\n}, [updater]);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/bluebiu.near/widget/Swap.Data.Xfai", "fact_widget_deployments_id": "d1948f8ef328b93248362b8259cb85bc", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 2}