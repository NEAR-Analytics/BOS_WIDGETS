{"tx_hash": "Am12N9dQwP49YzjvQBmmFQ5WEr1S56CtU85vS5bHpain", "action_id_social": "DZMUczn46cbkbR6dfJQ7TtKoip3q4aJAJ3Sji3kNijwv-0-widget", "block_id": 119325600, "block_timestamp": "2024-05-20T06:25:41.853Z", "signer_id": "bluebiu.near", "widget_name": "Staking.Data.Kelp", "source_code": "const OTOKEN_ABI = [\n  {\n    inputs: [],\n    name: \"totalSupply\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"totalBorrows\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"exchangeRateCurrent\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    constant: true,\n    inputs: [{ internalType: \"address\", name: \"owner\", type: \"address\" }],\n    name: \"balanceOf\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    payable: false,\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    constant: true,\n    inputs: [{ internalType: \"address\", name: \"account\", type: \"address\" }],\n    name: \"borrowBalanceCurrent\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    payable: false,\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"supplyRatePerBlock\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"borrowRatePerBlock\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\nconst UNITROLLER_ABI = [\n  {\n    inputs: [{ internalType: \"address\", name: \"account\", type: \"address\" }],\n    name: \"getAssetsIn\",\n    outputs: [\n      { internalType: \"contract OToken[]\", name: \"\", type: \"address[]\" },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    constant: true,\n    inputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n    name: \"markets\",\n    outputs: [\n      { internalType: \"bool\", name: \"isListed\", type: \"bool\" },\n      {\n        internalType: \"uint256\",\n        name: \"collateralFactorMantissa\",\n        type: \"uint256\",\n      },\n      { internalType: \"bool\", name: \"isQied\", type: \"bool\" },\n    ],\n    payable: false,\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"account\", type: \"address\" },\n      {\n        internalType: \"contract IOToken\",\n        name: \"oToken\",\n        type: \"address\",\n      },\n    ],\n    name: \"checkMembership\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\nconst ORACLE_ABI = [\n  {\n    inputs: [\n      {\n        internalType: \"contract IOToken\",\n        name: \"oToken\",\n        type: \"address\",\n      },\n    ],\n    name: \"getUnderlyingPrice\",\n    outputs: [{ internalType: \"uint256\", name: \"price\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\nconst ERC20_ABI = [\n  {\n    constant: true,\n    inputs: [\n      {\n        name: \"_owner\",\n        type: \"address\",\n      },\n    ],\n    name: \"balanceOf\",\n    outputs: [\n      {\n        name: \"balance\",\n        type: \"uint256\",\n      },\n    ],\n    payable: false,\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\n\nconst {\n  multicallAddress,\n  account,\n  update,\n  name,\n  onLoad,\n  markets,\n  multicall,\n  prices,\n} = props;\n\nconst { formatUnits, parseUnits } = ethers.utils;\n\nuseEffect(() => {\n  if (!multicallAddress || !update || !account) return \"\";\n\n  console.log(`${name}-update`);\n\n  let _cTokensData = {};\n\n  let _underlyPrice = {};\n  let _liquidity = null;\n  let _underlyingBalance = null;\n  let _userMerberShip = null;\n  let _collateralMap = {};\n  let _minBorrowMap = {};\n  let count = 0;\n  let oTokensLength = Object.values(markets).length;\n\n  const calcApy = (rateAsNumber) => {\n    const blocksPerMin = 30;\n    const daysPerYear = 365;\n    const blocksPerDay = blocksPerMin * 60 * 24;\n    const dailyGrowthRate = Big(rateAsNumber || 0)\n      .mul(blocksPerDay)\n      .toString();\n    const annualGrowth =\n      Math.exp(daysPerYear * Math.log1p(dailyGrowthRate)) - 1;\n    const apy = Big(annualGrowth).mul(100);\n    return apy;\n  };\n\n  const formatedData = (key) => {\n    console.log(`${name}-${key}`, count);\n    if (count < 6) return;\n    count = 0;\n    oTokensLength = Object.values(markets).length;\n    let totalSupplyUsd = Big(0);\n    let totalBorrowUsd = Big(0);\n    let userTotalSupplyUsd = Big(0);\n    let userTotalBorrowUsd = Big(0);\n    let totalCollateralUsd = Big(0);\n    const markets = {};\n\n    Object.values(_cTokensData).forEach((market) => {\n      // // const underlyingPrice = _underlyPrice[market.address] || 1;\n\n      // let underlyingPrice =\n      //   market.underlyingToken.symbol === \"weETH.mode\"\n      //     ? prices[\"weETH\"]\n      //     : prices[market.underlyingToken.symbol];\n      // underlyingPrice = underlyingPrice || 1;\n\n      // const marketSupplyUsd = Big(market.totalSupply || 0).mul(underlyingPrice);\n      // const marketBorrowUsd = Big(market.totalBorrows || 0).mul(\n      //   underlyingPrice\n      // );\n      // totalSupplyUsd = totalSupplyUsd.plus(marketSupplyUsd);\n      // totalBorrowUsd = totalBorrowUsd.plus(marketBorrowUsd);\n      // userTotalSupplyUsd = userTotalSupplyUsd.plus(\n      //   Big(market.userSupply).mul(underlyingPrice)\n      // );\n      // userTotalBorrowUsd = userTotalBorrowUsd.plus(\n      //   Big(market.userBorrow).mul(underlyingPrice)\n      // );\n\n      // // if (_userMerberShip[market.address]) {\n      // totalCollateralUsd = totalCollateralUsd.plus(\n      //   Big(market.userSupply)\n      //     .mul(underlyingPrice)\n      //     .mul(market[\"COLLATERAL_FACTOR\"])\n      // );\n      // // }\n      // // for ionic, every token's collateral usd\n      // const _userCollateralUSD = Big(market.userSupply)\n      //   .mul(underlyingPrice)\n      //   .toString();\n      // const supplyApy = calcApy(market.supplyRatePerBlock);\n\n      // const borrowApy = calcApy(market.borrowRatePerBlock);\n\n      // const _minBorrowAmount = Big(\n      //   formatUnits(_minBorrowMap[market.address][0])\n      // )\n      //   .times(Big(prices[\"ETH\"] || 0))\n      //   .div(underlyingPrice)\n      //   .toFixed(6, 0);\n\n      markets[market.address] = {\n        ...market,\n\n        // liquidity: _liquidity[market.address],\n        // underlyingPrice: underlyingPrice,\n        // userCollateralUSD: _userCollateralUSD,\n        // userUnderlyingBalance: _underlyingBalance[market.address],\n        // userMerberShip: _collateralMap[market.address] ? true : false,\n        // // userMerberShip: _userMerberShip[market.address],\n        // supplyApy: supplyApy.toFixed(2) + \"%\",\n        // borrowApy: borrowApy.toFixed(2) + \"%\",\n        // minBorrowAmount: _minBorrowAmount,\n        // dapp: name,\n      };\n    });\n\n    onLoad({\n      markets,\n      totalSupplyUsd: totalSupplyUsd.toString(),\n      totalBorrowUsd: totalBorrowUsd.toString(),\n      userTotalSupplyUsd: userTotalSupplyUsd.toString(),\n      userTotalBorrowUsd: userTotalBorrowUsd.toString(),\n      totalCollateralUsd: totalCollateralUsd.toString(),\n    });\n  };\n\n  const getWalletBalance = () => {\n    let nativeOToken = \"\";\n    const underlyingTokens = Object.values(markets)\n      .filter((market) => {\n        if (market.underlyingToken.address === \"native\")\n          nativeOToken = market.address;\n        return (\n          market.underlyingToken.address &&\n          market.underlyingToken.address !== \"native\"\n        );\n      })\n      .map((market) => ({\n        ...market.underlyingToken,\n        oTokenAddress: market.address,\n      }));\n    const calls = underlyingTokens.map((token) => ({\n      address: token.address,\n      name: \"balanceOf\",\n      params: [account],\n    }));\n    multicall({\n      abi: ERC20_ABI,\n      calls,\n      options: {},\n      multicallAddress,\n      provider: Ethers.provider(),\n    })\n      .then((res) => {\n        _underlyingBalance = {};\n        for (let i = 0, len = res.length; i < len; i++) {\n          _underlyingBalance[underlyingTokens[i].oTokenAddress] = res[i][0]\n            ? ethers.utils.formatUnits(\n                res[i][0]._hex,\n                underlyingTokens[i].decimals\n              )\n            : \"0\";\n        }\n        if (nativeOToken) {\n          const provider = Ethers.provider();\n          provider.getBalance(account).then((rawBalance) => {\n            _underlyingBalance[nativeOToken] = ethers.utils.formatUnits(\n              rawBalance._hex,\n              18\n            );\n            count++;\n            formatedData(\"underlyingTokens\");\n          });\n        } else {\n          count++;\n          formatedData(\"underlyingTokens\");\n        }\n      })\n      .catch(() => {\n        setTimeout(() => {\n          getWalletBalance();\n        }, 500);\n      });\n  };\n\n  const getMinBorrow = () => {\n    const cTokens = Object.keys(markets);\n\n    const calls = cTokens.map((_cToken) => ({\n      address: \"0x8ea3fc79D9E463464C5159578d38870b770f6E57\",\n      name: \"getMinBorrowEth\",\n      params: [_cToken],\n    }));\n    multicall({\n      abi: [\n        {\n          inputs: [\n            {\n              internalType: \"contract ICErc20\",\n              name: \"_ctoken\",\n              type: \"address\",\n            },\n          ],\n          name: \"getMinBorrowEth\",\n          outputs: [\n            {\n              internalType: \"uint256\",\n              name: \"\",\n              type: \"uint256\",\n            },\n          ],\n          stateMutability: \"view\",\n          type: \"function\",\n        },\n      ],\n      calls,\n      options: {},\n      multicallAddress,\n      provider: Ethers.provider(),\n    })\n      .then((res) => {\n        console.log(\"getMinBorrow-res:\", res);\n\n        if (Array.isArray(res) && res.length) {\n          _minBorrowMap = {};\n          res.forEach((_rawMinAmount, index) => {\n            _minBorrowMap[cTokens[index]] = _rawMinAmount;\n          });\n        }\n\n        count++;\n        formatedData(\"getMinBorrow\");\n      })\n      .catch((err) => {\n        console.log(\"CATCH_getMinBorrow_ERROR:\", err);\n      });\n  };\n\n  getUnderlyPrice();\n  getWalletBalance();\n  getMinBorrow();\n}, [update, account]);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/bluebiu.near/widget/Staking.Data.Kelp", "fact_widget_deployments_id": "2a82fbd7bebfa0b92be3924731285144", "inserted_timestamp": "2024-05-20T07:51:07.344Z", "modified_timestamp": "2024-05-20T07:51:07.344Z", "__row_index": 0}