{"tx_hash": "5JBNazipzAN6jfGvjizYHX5TcJ2chkdiai2ttBcidUur", "action_id_social": "9PrXF5JcAMEhJsvoSw6WwbGANv5Ek5PyFx3mgLqtbxTT-0-widget", "block_id": 110209360, "block_timestamp": "2024-01-12T08:08:33.065Z", "signer_id": "bluebiu.near", "widget_name": "Lending.Data.Lendle", "source_code": "const ORACLE_ABI = [\n  {\n    inputs: [{ internalType: \"address[]\", name: \"assets\", type: \"address[]\" }],\n    name: \"getAssetsPrices\",\n    outputs: [{ internalType: \"uint256[]\", name: \"\", type: \"uint256[]\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\nconst DATA_ABI = [\n  {\n    inputs: [{ internalType: \"address\", name: \"asset\", type: \"address\" }],\n    name: \"getReserveConfigurationData\",\n    outputs: [\n      { internalType: \"uint256\", name: \"decimals\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"ltv\", type: \"uint256\" },\n      {\n        internalType: \"uint256\",\n        name: \"liquidationThreshold\",\n        type: \"uint256\",\n      },\n      { internalType: \"uint256\", name: \"liquidationBonus\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"reserveFactor\", type: \"uint256\" },\n      { internalType: \"bool\", name: \"usageAsCollateralEnabled\", type: \"bool\" },\n      { internalType: \"bool\", name: \"borrowingEnabled\", type: \"bool\" },\n      { internalType: \"bool\", name: \"stableBorrowRateEnabled\", type: \"bool\" },\n      { internalType: \"bool\", name: \"isActive\", type: \"bool\" },\n      { internalType: \"bool\", name: \"isFrozen\", type: \"bool\" },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"asset\", type: \"address\" },\n      { internalType: \"address\", name: \"user\", type: \"address\" },\n    ],\n    name: \"getUserReserveData\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"currentATokenBalance\",\n        type: \"uint256\",\n      },\n      { internalType: \"uint256\", name: \"currentStableDebt\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"currentVariableDebt\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"principalStableDebt\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"scaledVariableDebt\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"stableBorrowRate\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"liquidityRate\", type: \"uint256\" },\n      { internalType: \"uint40\", name: \"stableRateLastUpdated\", type: \"uint40\" },\n      { internalType: \"bool\", name: \"usageAsCollateralEnabled\", type: \"bool\" },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"asset\", type: \"address\" }],\n    name: \"getReserveData\",\n    outputs: [\n      { internalType: \"uint256\", name: \"availableLiquidity\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"totalStableDebt\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"totalVariableDebt\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"liquidityRate\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"variableBorrowRate\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"stableBorrowRate\", type: \"uint256\" },\n      {\n        internalType: \"uint256\",\n        name: \"averageStableBorrowRate\",\n        type: \"uint256\",\n      },\n      { internalType: \"uint256\", name: \"liquidityIndex\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"variableBorrowIndex\", type: \"uint256\" },\n      { internalType: \"uint40\", name: \"lastUpdateTimestamp\", type: \"uint40\" },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\nconst INCENTIVE_ABI = [\n  {\n    inputs: [],\n    name: \"totalAllocPoint\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"rewardsPerSecond\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n    name: \"poolInfo\",\n    outputs: [\n      { internalType: \"uint256\", name: \"totalSupply\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"allocPoint\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"lastRewardTime\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"accRewardPerShare\", type: \"uint256\" },\n      {\n        internalType: \"contract IOnwardIncentivesController\",\n        name: \"onwardIncentives\",\n        type: \"address\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"\", type: \"address\" },\n      { internalType: \"address\", name: \"user\", type: \"address\" },\n    ],\n    name: \"userInfo\",\n    outputs: [\n      { type: \"uint256\", name: \"amount\", internalType: \"uint256\" },\n      { type: \"uint256\", name: \"rewardDebt\", internalType: \"uint256\" },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"_user\", type: \"address\" },\n      { internalType: \"address[]\", name: \"_tokens\", type: \"address[]\" },\n    ],\n    name: \"claimableReward\",\n    outputs: [{ internalType: \"uint256[]\", name: \"\", type: \"uint256[]\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\n\nconst {\n  oracleAddress,\n  walletBalanceProvider,\n  aaveProtocolDataProviderAddress,\n  poolAddressProvider,\n  incentiveController,\n  multicallAddress,\n  wethAddress,\n  multicall,\n  markets,\n  rewardToken,\n  account,\n  prices,\n  name: dappName,\n  update,\n  onLoad,\n} = props;\n\nuseEffect(() => {\n  if (!account || !update || !oracleAddress || !multicallAddress) return;\n  let info = {};\n  let count = 0;\n  const marketList = Object.values(markets);\n  const underlyingTokensAddress = Object.keys(markets);\n\n  const getRewardPrice = () => {\n    if (!rewardToken) {\n      getTokensPrice();\n      return;\n    }\n\n    rewardToken.price = prices[rewardToken.symbol] || 0.3002;\n    if (rewardToken.price) {\n      getTokensPrice();\n    }\n  };\n\n  const getTokensPrice = () => {\n    const oracleContract = new ethers.Contract(\n      oracleAddress,\n      ORACLE_ABI,\n      Ethers.provider().getSigner()\n    );\n    oracleContract\n      .getAssetsPrices(underlyingTokensAddress)\n      .then((res) => {\n        const scale = [\"Agave\", \"Lendle\"].includes(dappName)\n          ? 1000000000000000000\n          : 100000000;\n        const parsedRes = res.map((price, i) => {\n          return Big(price.toString()).div(scale).toFixed();\n        });\n\n        underlyingTokensAddress.forEach((address, index) => {\n          markets[address].underlyingPrice = parsedRes[index];\n        });\n        if (incentiveController) {\n          getIncentiveData();\n        } else {\n          count++;\n          formatedData(\"getTokensPrice\");\n        }\n      })\n      .catch((err) => {\n        console.log(\"getTokensPrice error\", err);\n      });\n  };\n\n  const getUserWalletBalances = () => {\n    if (!walletBalanceProvider) {\n      getWalletBalance();\n      return;\n    }\n    const walletBalanceProviderContract = new ethers.Contract(\n      walletBalanceProvider,\n      [\n        {\n          inputs: [\n            { internalType: \"address\", name: \"provider\", type: \"address\" },\n            { internalType: \"address\", name: \"user\", type: \"address\" },\n          ],\n          name: \"getUserWalletBalances\",\n          outputs: [\n            { internalType: \"address[]\", name: \"\", type: \"address[]\" },\n            { internalType: \"uint256[]\", name: \"\", type: \"uint256[]\" },\n          ],\n          stateMutability: \"view\",\n          type: \"function\",\n        },\n      ],\n      Ethers.provider().getSigner()\n    );\n    walletBalanceProviderContract\n      .getUserWalletBalances(poolAddressProvider, account)\n      .then((res) => {\n        const addresses = res[0];\n        const values = res[1];\n\n        addresses.forEach((address, index) => {\n          const value = values[index];\n\n          if (markets[address]) {\n            const parsedValue = Big(value.toString())\n              .div(Big(10).pow(markets[address].underlyingToken.decimals))\n              .toFixed();\n            markets[address].userUnderlyingBalance = parsedValue;\n          }\n        });\n\n        count++;\n        formatedData(\"getUserWalletBalances\");\n      })\n      .catch((err) => {\n        console.log(\"getUserWalletBalances error\");\n      });\n  };\n\n  const getWalletBalance = () => {\n    let nativeOToken = \"\";\n    const underlyingTokens = Object.values(markets)\n      .filter((market) => {\n        if (market.underlyingToken.address === \"native\")\n          nativeOToken = wethAddress;\n        return (\n          market.underlyingToken.address &&\n          market.underlyingToken.address !== \"native\"\n        );\n      })\n      .map((market) => ({\n        ...market.underlyingToken,\n      }));\n    const calls = underlyingTokens.map((token) => ({\n      address: token.address,\n      name: \"balanceOf\",\n      params: [account],\n    }));\n\n    multicall({\n      abi: [\n        {\n          constant: true,\n          inputs: [\n            {\n              name: \"_owner\",\n              type: \"address\",\n            },\n          ],\n          name: \"balanceOf\",\n          outputs: [\n            {\n              name: \"balance\",\n              type: \"uint256\",\n            },\n          ],\n          payable: false,\n          stateMutability: \"view\",\n          type: \"function\",\n        },\n      ],\n      calls,\n      options: {},\n      multicallAddress,\n      provider: Ethers.provider(),\n    })\n      .then((res) => {\n        for (let i = 0, len = res.length; i < len; i++) {\n          markets[underlyingTokens[i].address].userUnderlyingBalance = res[i][0]\n            ? ethers.utils.formatUnits(\n                res[i][0]._hex,\n                underlyingTokens[i].decimals\n              )\n            : \"0\";\n        }\n\n        if (nativeOToken) {\n          const provider = Ethers.provider();\n          provider.getBalance(account).then((rawBalance) => {\n            markets[nativeOToken].userUnderlyingBalance =\n              ethers.utils.formatUnits(rawBalance._hex, 18);\n\n            count++;\n            formatedData(\"getWalletBalance\");\n          });\n        } else {\n          count++;\n          formatedData(\"getWalletBalance\");\n        }\n      })\n      .catch((err) => {\n        console.log(\"getWalletBalance error\", err);\n      });\n  };\n\n  const getConfigurationData = () => {\n    const calls = underlyingTokensAddress.map((address) => ({\n      address: aaveProtocolDataProviderAddress,\n      name: \"getReserveConfigurationData\",\n      params: [address],\n    }));\n    multicall({\n      abi: DATA_ABI,\n      calls,\n      options: {},\n      multicallAddress,\n      provider: Ethers.provider(),\n    })\n      .then((res) => {\n        res.forEach((item, i) => {\n          const _address = underlyingTokensAddress[i];\n          markets[_address].loanToValue = Big(item[1].toString())\n            .div(100)\n            .toNumber();\n        });\n        count++;\n        formatedData(\"getConfigurationData\");\n      })\n      .catch((err) => {\n        console.log(\"getConfigurationData error\");\n      });\n  };\n\n  const getReverseData = () => {\n    const calls = underlyingTokensAddress.map((address) => ({\n      address: aaveProtocolDataProviderAddress,\n      name: \"getReserveData\",\n      params: [address],\n    }));\n    multicall({\n      abi: DATA_ABI,\n      calls,\n      options: {},\n      multicallAddress,\n      provider: Ethers.provider(),\n    })\n      .then((res) => {\n        res.forEach((item, i) => {\n          const _address = underlyingTokensAddress[i];\n\n          const [\n            availableLiquidity,\n            totalStableDebt,\n            totalVariableDebt,\n            liquidityRate,\n            variableBorrowRate,\n          ] = item;\n          const decimals = Big(10).pow(\n            markets[_address].underlyingToken.decimals\n          );\n          const totalDebt = Big(totalStableDebt.toString())\n            .plus(totalVariableDebt.toString())\n            .div(decimals)\n            .toFixed();\n          const totalDebtRaw = Big(totalStableDebt.toString())\n            .plus(totalVariableDebt.toString())\n            .toFixed();\n          const totalDeposit = Big(availableLiquidity.toString())\n            .plus(totalDebtRaw)\n            .div(decimals)\n            .toFixed();\n          const marketSize = Big(availableLiquidity.toString())\n            .div(decimals)\n            .toFixed();\n\n          const RAY = Big(10).pow(27);\n\n          const SECONDS_PER_YEAR = 31536000;\n\n          const depositAPR = Big(liquidityRate).div(RAY);\n\n          const variableBorrowAPR = Big(variableBorrowRate).div(RAY);\n\n          const depositAPY0 = Big(1)\n            .plus(depositAPR.div(Big(SECONDS_PER_YEAR)))\n            .toNumber();\n\n          const depositAPY = Big(\n            100 * (Math.pow(depositAPY0, SECONDS_PER_YEAR) - 1)\n          ).toFixed(2);\n\n          const variableBorrowAPY0 = Big(1)\n            .plus(Big(variableBorrowAPR).div(Big(SECONDS_PER_YEAR)))\n            .toNumber();\n\n          const variableBorrowAPYRaw = Big(\n            100 * (Math.pow(variableBorrowAPY0, SECONDS_PER_YEAR) - 1)\n          );\n\n          const variableBorrowAPY = Big(\n            100 * (Math.pow(variableBorrowAPY0, SECONDS_PER_YEAR) - 1)\n          ).toFixed(2);\n\n          const netApyBig = Big(depositAPY0).minus(variableBorrowAPYRaw);\n          markets[_address].supplyApy = depositAPY + \"%\";\n          markets[_address].borrowApy = variableBorrowAPY + \"%\";\n          markets[_address].totalBorrows = Big(totalDebt).toFixed(4);\n          markets[_address].totalSupply = Big(totalDeposit).toFixed(4);\n          markets[_address].liquidity = Big(marketSize).toFixed(4);\n          markets[_address].netApy = Big(netApyBig).toFixed();\n        });\n        count++;\n        formatedData(\"getReverseData\");\n      })\n      .catch((err) => {\n        console.log(\"getReverseData error\");\n      });\n  };\n\n  const getUserReserveData = () => {\n    const calls = underlyingTokensAddress.map((address) => ({\n      address: aaveProtocolDataProviderAddress,\n      name: \"getUserReserveData\",\n      params: [address, account],\n    }));\n    multicall({\n      abi: DATA_ABI,\n      calls,\n      options: {},\n      multicallAddress,\n      provider: Ethers.provider(),\n    })\n      .then((res) => {\n        res.forEach((item, i) => {\n          const _address = underlyingTokensAddress[i];\n          const decimals = Big(10).pow(\n            markets[_address].underlyingToken.decimals\n          );\n\n          markets[_address].userMerberShip = item[8];\n          markets[_address].userSupply = Big(item[0].toString())\n            .div(decimals)\n            .toFixed();\n          markets[_address].userBorrow = Big(item[1].toString())\n            .add(item[2].toString())\n            .div(decimals)\n            .toFixed();\n        });\n        count++;\n        formatedData(\"getUserReserveData\");\n      })\n      .catch((err) => {\n        console.log(\"getUserReserveData error\");\n      });\n  };\n  let fetchedTokenLen = 0;\n  const getIncentiveData = () => {\n    const calls = [\n      {\n        address: incentiveController,\n        name: \"totalAllocPoint\",\n        params: [],\n      },\n      {\n        address: incentiveController,\n        name: \"rewardsPerSecond\",\n        params: [],\n      },\n    ];\n    multicall({\n      abi: INCENTIVE_ABI,\n      calls,\n      options: {},\n      multicallAddress,\n      provider: Ethers.provider(),\n    })\n      .then((res) => {\n        info.totalAllocPoint = res[0].toString();\n        info.rewardsPerSecond = res[1].toString();\n\n        getIncentiveDataForToken({\n          aTokenAddress: marketList[fetchedTokenLen].address,\n          variableDebtTokenAddress:\n            marketList[fetchedTokenLen].variableDebtTokenAddress,\n          address:\n            marketList[fetchedTokenLen].underlyingToken.address === \"native\"\n              ? wethAddress\n              : marketList[fetchedTokenLen].underlyingToken.address,\n        });\n      })\n      .catch((err) => {\n        console.log(\"getIncentiveData error\");\n      });\n  };\n\n  const getIncentiveDataForToken = ({\n    aTokenAddress,\n    variableDebtTokenAddress,\n    address,\n  }) => {\n    const calls = [\n      {\n        address: incentiveController,\n        name: \"poolInfo\",\n        params: [aTokenAddress],\n      },\n      {\n        address: incentiveController,\n        name: \"userInfo\",\n        params: [aTokenAddress, account],\n      },\n      {\n        address: incentiveController,\n        name: \"claimableReward\",\n        params: [account, [aTokenAddress]],\n      },\n      {\n        address: incentiveController,\n        name: \"poolInfo\",\n        params: [variableDebtTokenAddress],\n      },\n      {\n        address: incentiveController,\n        name: \"userInfo\",\n        params: [variableDebtTokenAddress, account],\n      },\n      {\n        address: incentiveController,\n        name: \"claimableReward\",\n        params: [account, [variableDebtTokenAddress]],\n      },\n    ];\n    multicall({\n      abi: INCENTIVE_ABI,\n      calls,\n      options: {},\n      multicallAddress,\n      provider: Ethers.provider(),\n    })\n      .then((res) => {\n        const ACC_REWARD_PRECISION = Big(10).pow(12);\n\n        const poolInfo = res[0];\n        const poolInfoDebt = res[3];\n\n        const totalSupply = poolInfo[0].toString();\n        const totalSupplyDebt = poolInfoDebt[0].toString();\n\n        const allocPoint = poolInfo[1].toString();\n        const allocPointDebt = poolInfoDebt[1].toString();\n\n        const dailyRewardToThisPool = Big(60 * 60 * 24)\n          .times(info.rewardsPerSecond)\n          .times(allocPoint)\n          .div(info.totalAllocPoint);\n\n        let yearlyRewardToThisPool = Big(0);\n        let yearlyRewardToThisPoolUsd = Big(0);\n        let yearlyRewardToThisPoolDebt = Big(0);\n        let yearlyRewardToThisPoolDebtUsd = Big(0);\n\n        const dailyRewardToThisPoolDebt = Big(60 * 60 * 24)\n          .times(info.rewardsPerSecond)\n          .times(allocPointDebt)\n          .div(info.totalAllocPoint);\n\n        if (rewardToken) {\n          yearlyRewardToThisPool = dailyRewardToThisPool\n            .mul(365)\n            .div(Big(10).pow(rewardToken.decimals));\n\n          yearlyRewardToThisPoolUsd = Big(yearlyRewardToThisPool).times(\n            rewardToken.price\n          );\n\n          yearlyRewardToThisPoolDebt = dailyRewardToThisPoolDebt\n            .mul(365)\n            .div(Big(10).pow(rewardToken.decimals));\n\n          yearlyRewardToThisPoolDebtUsd = Big(yearlyRewardToThisPoolDebt).times(\n            rewardToken.price\n          );\n        }\n\n        const totalSupplyUsd = Big(markets[address].underlyingPrice).mul(\n          ethers.utils.formatUnits(\n            poolInfo[0]._hex,\n            markets[address].underlyingToken.decimals\n          )\n        );\n\n        markets[address].rewardSupplyApy = yearlyRewardToThisPoolUsd\n          .div(totalSupplyUsd)\n          .mul(100)\n          .toFixed(2, 0);\n\n        const totalBorrowUsd = Big(markets[address].underlyingPrice).mul(\n          ethers.utils.formatUnits(\n            poolInfoDebt[0]._hex,\n            markets[address].underlyingToken.decimals\n          )\n        );\n\n        markets[address].rewardBorrowApy = yearlyRewardToThisPoolDebtUsd\n          .div(totalBorrowUsd)\n          .mul(100)\n          .toFixed(2, 0);\n\n        const rewardPerShareThisPool = dailyRewardToThisPool\n          .mul(ACC_REWARD_PRECISION)\n          .div(totalSupply)\n          .toFixed(0);\n\n        const rewardPerShareThisPoolDebt = dailyRewardToThisPoolDebt\n          .mul(ACC_REWARD_PRECISION)\n          .div(totalSupplyDebt)\n          .toFixed(0);\n\n        const userInfo = res[1] || [0];\n        const userInfoDebt = res[4] || [0];\n\n        const amount = userInfo[0].toString();\n        const amountDebt = userInfoDebt[0].toString();\n\n        const userDailyReward = Big(rewardPerShareThisPool)\n          .times(Big(amount))\n          .div(ACC_REWARD_PRECISION)\n          .div(Big(10).pow(rewardToken.decimals))\n          .toFixed();\n\n        const userDailyRewardDebt = Big(rewardPerShareThisPoolDebt)\n          .times(Big(amountDebt))\n          .div(ACC_REWARD_PRECISION)\n          .div(Big(10).pow(rewardToken.decimals))\n          .toFixed();\n\n        const pendingRewards = res[2];\n        const pendingRewardsDebt = res[5];\n\n        const unclaimed = pendingRewards[0].toString();\n        const unclaimedDebt = pendingRewardsDebt[0].toString();\n\n        const dailyRewards = Big(userDailyReward).toFixed();\n\n        const dailyRewardsDebt = Big(userDailyRewardDebt).toFixed();\n\n        markets[address].unclaimed = Big(unclaimed)\n          .plus(unclaimedDebt)\n          .div(Big(10).pow(rewardToken.decimals))\n          .toFixed();\n\n        markets[address].dailyRewards = Big(dailyRewards)\n          .plus(dailyRewardsDebt)\n          .toFixed();\n        fetchedTokenLen++;\n        if (fetchedTokenLen === underlyingTokensAddress.length) {\n          count++;\n          formatedData(\"getIncentiveDataForToken\");\n        } else {\n          getIncentiveDataForToken({\n            aTokenAddress: marketList[fetchedTokenLen].address,\n            variableDebtTokenAddress:\n              marketList[fetchedTokenLen].variableDebtTokenAddress,\n            address:\n              marketList[fetchedTokenLen].underlyingToken.address === \"native\"\n                ? wethAddress\n                : marketList[fetchedTokenLen].underlyingToken.address,\n          });\n        }\n      })\n      .catch((err) => {\n        console.log(\"getIncentiveDataForToken error\", err);\n      });\n  };\n\n  const formatedData = (key) => {\n    console.log(key);\n    if (count < 5) return;\n    let totalSupplyUsd = Big(0);\n    let totalBorrowUsd = Big(0);\n    let userTotalSupplyUsd = Big(0);\n    let userTotalBorrowUsd = Big(0);\n    let totalCollateralUsd = Big(0);\n    let totalUnclaimed = Big(0);\n    let totalDailyRewards = Big(0);\n    const _markets = {};\n\n    Object.values(markets).forEach((market, i) => {\n      const underlyingPrice = market.underlyingPrice;\n      const marketSupplyUsd = Big(market.totalSupply || 0).mul(underlyingPrice);\n      const marketBorrowUsd = Big(market.totalBorrows || 0).mul(\n        underlyingPrice\n      );\n\n      totalSupplyUsd = totalSupplyUsd.plus(marketSupplyUsd);\n      totalBorrowUsd = totalBorrowUsd.plus(marketBorrowUsd);\n      userTotalSupplyUsd = userTotalSupplyUsd.plus(\n        Big(market.userSupply).mul(underlyingPrice)\n      );\n      userTotalBorrowUsd = userTotalBorrowUsd.plus(\n        Big(market.userBorrow).mul(underlyingPrice)\n      );\n\n      if (market.userMerberShip) {\n        totalCollateralUsd = totalCollateralUsd.plus(\n          Big(market.userSupply)\n            .mul(underlyingPrice)\n            .mul(market.loanToValue)\n            .div(100)\n        );\n      }\n\n      let distributionApy = [];\n      if (rewardToken) {\n        distributionApy = [\n          {\n            ...rewardToken,\n            supply: market.rewardSupplyApy + \"%\",\n            borrow: market.rewardBorrowApy + \"%\",\n          },\n        ];\n        totalUnclaimed = totalUnclaimed.plus(market.unclaimed);\n        totalDailyRewards = totalDailyRewards.plus(market.dailyRewards);\n      }\n\n      _markets[market.address] = {\n        ...market,\n        distributionApy,\n        dapp: dappName,\n      };\n    });\n    let rewards = [];\n    if (rewardToken) {\n      rewards = [\n        {\n          ...rewardToken,\n          dailyRewards: totalDailyRewards.toString(),\n          unclaimed: totalUnclaimed.toString(),\n        },\n      ];\n    }\n    onLoad({\n      markets: _markets,\n      rewards,\n      totalSupplyUsd: totalSupplyUsd.toString(),\n      totalBorrowUsd: totalBorrowUsd.toString(),\n      userTotalSupplyUsd: userTotalSupplyUsd.toString(),\n      userTotalBorrowUsd: userTotalBorrowUsd.toString(),\n      totalCollateralUsd: totalCollateralUsd.toString(),\n    });\n  };\n\n  getUserReserveData();\n  getReverseData();\n  getConfigurationData();\n  getUserWalletBalances();\n  getRewardPrice();\n}, [account, update]);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/bluebiu.near/widget/Lending.Data.Lendle", "fact_widget_deployments_id": "b7aa23bf4a3322ed05c49c1d6bc69032", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 0}