{"tx_hash": "4hiYYpAdeL2Won9bYEwtVM2FfSqeiw14gDm2VsP6Vh5p", "action_id_social": "7aea7oM22L5C21TXs366CEpiwR56V53BS6NrHyDSpDdP-0-widget", "block_id": 115010053, "block_timestamp": "2024-03-19T08:01:59.499Z", "signer_id": "bluebiu.near", "widget_name": "Swap.Data.VelocoreV2AmountOut", "source_code": "const VAULT_ABI = [\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"user\",\n        type: \"address\",\n      },\n      {\n        internalType: \"Token[]\",\n        name: \"tokenRef\",\n        type: \"bytes32[]\",\n      },\n      {\n        internalType: \"int128[]\",\n        name: \"deposit\",\n        type: \"int128[]\",\n      },\n      {\n        components: [\n          {\n            internalType: \"bytes32\",\n            name: \"poolId\",\n            type: \"bytes32\",\n          },\n          {\n            internalType: \"bytes32[]\",\n            name: \"tokenInformations\",\n            type: \"bytes32[]\",\n          },\n          {\n            internalType: \"bytes\",\n            name: \"data\",\n            type: \"bytes\",\n          },\n        ],\n        internalType: \"struct VelocoreOperation[]\",\n        name: \"ops\",\n        type: \"tuple[]\",\n      },\n    ],\n    name: \"query\",\n    outputs: [\n      {\n        internalType: \"int128[]\",\n        name: \"\",\n        type: \"int128[]\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"Token[]\",\n        name: \"tokenRef\",\n        type: \"bytes32[]\",\n      },\n      {\n        internalType: \"int128[]\",\n        name: \"deposit\",\n        type: \"int128[]\",\n      },\n      {\n        components: [\n          {\n            internalType: \"bytes32\",\n            name: \"poolId\",\n            type: \"bytes32\",\n          },\n          {\n            internalType: \"bytes32[]\",\n            name: \"tokenInformations\",\n            type: \"bytes32[]\",\n          },\n          {\n            internalType: \"bytes\",\n            name: \"data\",\n            type: \"bytes\",\n          },\n        ],\n        internalType: \"struct VelocoreOperation[]\",\n        name: \"ops\",\n        type: \"tuple[]\",\n      },\n    ],\n    name: \"execute\",\n    outputs: [],\n    stateMutability: \"payable\",\n    type: \"function\",\n  },\n];\nconst FACTORY_ABI = [\n  {\n    inputs: [\n      { internalType: \"Token\", name: \"\", type: \"bytes32\" },\n      { internalType: \"Token\", name: \"\", type: \"bytes32\" },\n    ],\n    name: \"pools\",\n    outputs: [\n      {\n        internalType: \"contract ConstantProductPool\",\n        name: \"\",\n        type: \"address\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\n\nconst {\n  updater,\n  routerAddress,\n  factoryAddress,\n  wethAddress,\n  inputCurrency,\n  outputCurrency,\n  inputCurrencyAmount,\n  prices,\n  onLoad,\n  slippage,\n  account,\n} = props;\n\nuseEffect(() => {\n  if (!updater) return;\n\n  if (\n    (!inputCurrency.address && !inputCurrency.isNative) ||\n    (!outputCurrency.address && !outputCurrency.isNative) ||\n    !inputCurrencyAmount\n  ) {\n    return;\n  }\n  const wrapType =\n    inputCurrency.isNative && outputCurrency.address === wethAddress\n      ? 1\n      : inputCurrency.address === wethAddress && outputCurrency.isNative\n      ? 2\n      : 0;\n\n  if (wrapType) {\n    onLoad({\n      outputCurrencyAmount: inputCurrencyAmount,\n      noPair: false,\n    });\n    return;\n  }\n\n  const solidityPack = ethers.utils.solidityPack;\n  const toToken = (spec, id, addr) =>\n    solidityPack(\n      [\"uint8\", \"uint88\", \"address\"],\n      [[\"erc20\", \"erc721\", \"erc1155\"].indexOf(spec), id, addr]\n    );\n  const poolId = (i, poolAddress) =>\n    solidityPack([\"bytes1\", \"uint88\", \"address\"], [i, 0, poolAddress]);\n\n  const tokenInformation = (index, amountType, amount) =>\n    solidityPack(\n      [\"uint8\", \"uint8\", \"uint112\", \"int128\"],\n      [\n        index,\n        [\"exactly\", \"at most\", \"all\", \"flashloan\"].indexOf(amountType),\n        0,\n        amount,\n      ]\n    );\n\n  const amount = ethers.utils.parseUnits(\n    Big(inputCurrencyAmount || 0).toFixed(inputCurrency.decimals),\n    inputCurrency.decimals\n  );\n\n  const path = [\n    inputCurrency.isNative\n      ? \"0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee\"\n      : toToken(\"erc20\", 0, inputCurrency.address),\n    outputCurrency.isNative\n      ? \"0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee\"\n      : toToken(\"erc20\", 0, outputCurrency.address),\n  ];\n\n  const isReverse = Number(path[0]) > Number(path[1]);\n\n  const options = {\n    value: inputCurrency.isNative ? amount : 0,\n  };\n\n  const getTokenRef = (ops) => {\n    return [...new Set(ops.flatMap((x) => x[1].map((i) => i[0])))].sort();\n  };\n\n  const VaultContract = new ethers.Contract(\n    routerAddress,\n    VAULT_ABI,\n    Ethers.provider().getSigner()\n  );\n\n  const getAmountout = () => {\n    const FactoryContract = new ethers.Contract(\n      factoryAddress,\n      FACTORY_ABI,\n      Ethers.provider().getSigner()\n    );\n    FactoryContract.pools(...path)\n      .then((pool) => {\n        const opts = [\n          [\n            poolId(0, pool),\n            [\n              [path[0], \"exactly\", amount],\n              [path[1], \"at most\", \"0\"],\n            ],\n          ],\n        ];\n        const tokenRef = getTokenRef(opts);\n        const params = [\n          account,\n          tokenRef,\n          new Array(tokenRef.length).fill(0),\n          opts.map((op) => ({\n            poolId: op[0],\n            tokenInformations: op[1]\n              .map((i) => tokenInformation(tokenRef.indexOf(i[0]), i[1], i[2]))\n              .sort(),\n            data: [],\n          })),\n        ];\n        VaultContract.callStatic\n          .query(...params)\n          .then((res) => {\n            getTransaction(isReverse ? res[0] : res[1], pool);\n          })\n          .catch((err) => {\n            onLoad({\n              noPair: true,\n              outputCurrencyAmount: \"\",\n            });\n          });\n      })\n      .catch((err) => {\n        onLoad({\n          noPair: true,\n          outputCurrencyAmount: \"\",\n        });\n      });\n  };\n\n  const getTransaction = (amountOut, pool) => {\n    let priceImpact = null;\n\n    const _amountOutWithoutDecimal = Big(\n      ethers.utils.formatUnits(amountOut, outputCurrency.decimals)\n    );\n    if (prices) {\n      const poolPrice = Big(prices[inputCurrency.symbol] || 1).div(\n        prices[outputCurrency.symbol] || 1\n      );\n      const amountoutPrice = Big(_amountOutWithoutDecimal).div(\n        inputCurrencyAmount\n      );\n\n      priceImpact = poolPrice\n        .minus(amountoutPrice)\n        .div(poolPrice)\n        .mul(100)\n        .toString();\n    }\n    const _amountOut = Big(amountOut)\n      .mul(1 - (slippage || 0.05))\n      .toFixed(0);\n\n    const returnData = {\n      inputCurrency,\n      inputCurrencyAmount,\n      outputCurrency,\n      outputCurrencyAmount: Big(_amountOutWithoutDecimal).gt(0.01)\n        ? Big(_amountOutWithoutDecimal).toPrecision(10)\n        : Big(_amountOutWithoutDecimal).toFixed(10),\n      priceImpact,\n      noPair: false,\n    };\n    const opts = [\n      [\n        poolId(0, pool),\n        [\n          [path[0], \"exactly\", amount],\n          [path[1], \"at most\", _amountOut],\n        ],\n      ],\n    ];\n\n    const tokenRef = getTokenRef(opts);\n    const params = [\n      tokenRef,\n      new Array(tokenRef.length).fill(0),\n      opts.map((op) => ({\n        poolId: op[0],\n        tokenInformations: op[1]\n          .map((i) => tokenInformation(tokenRef.indexOf(i[0]), i[1], i[2]))\n          .sort(),\n        data: [],\n      })),\n    ];\n\n    const getTx = (_gas) => {\n      VaultContract.populateTransaction\n        .execute(...params, {\n          ...options,\n          gasLimit: _gas,\n        })\n        .then((res) => {\n          onLoad({\n            ...returnData,\n            noPair: false,\n            gas: _gas,\n            unsignedTx: res,\n          });\n        })\n        .catch((err) => {\n          onLoad({\n            ...returnData,\n            noPair: false,\n            gas: _gas,\n          });\n        });\n    };\n\n    const estimateGas = () => {\n      VaultContract.estimateGas\n        .execute(...params, options)\n        .then((_gas) => {\n          getTx(_gas);\n        })\n        .catch((err) => {\n          onLoad({\n            ...returnData,\n            noPair: false,\n          });\n        });\n    };\n\n    estimateGas();\n  };\n\n  getAmountout();\n}, [updater]);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/bluebiu.near/widget/Swap.Data.VelocoreV2AmountOut", "fact_widget_deployments_id": "4c245237296b1ceb79bd44ad7aa8fec4", "inserted_timestamp": "2024-03-19T09:34:29.241Z", "modified_timestamp": "2024-03-19T09:34:29.241Z", "__row_index": 1}