{"tx_hash": "FzrCH6xUB9AG4qhduJ9D5bz5y4sUwMGDNhojpbiMTz4v", "action_id_social": "9A4RfMaPWRZqYMaab5ZYrNzQSp9FKX3U1vMaVCeottPc-0-widget", "block_id": 103603753, "block_timestamp": "2023-10-17T19:12:35.751Z", "signer_id": "zavodil.near", "widget_name": "DexData3", "source_code": "const dexlistData = Social.get(`zavodil.near/dexlist/chains/**`, \"final\");\nconsole.log(\"All DexlistData\", dexlistData);\n\n// PancakeZKEVM added\nconst {\n  NETWORK_NEAR,\n  NETWORK_ETH,\n  NETWORK_ZKSYNC,\n  NETWORK_ZKEVM,\n  NETWORK_AURORA,\n  NETWORK_POLYGON,\n  NETWORK_MANTLE,\n  DEX,\n  debug,\n} = props;\nconsole.log(\"DexData3\", DEX);\n\nlet onLoad = props.onLoad;\nconst forceReload = props.forceReload ?? false;\n\nState.init({ loadComplete: false });\n\nif (forceReload) {\n  State.update({\n    forceReload: false,\n    factoryAbi: undefined,\n    erc20Abi: undefined,\n    routerAbi: undefined,\n  });\n}\n\nif (state.loadComplete && !forceReload) {\n  return state.debugOutput ?? <div />;\n}\n\nif (debug) {\n  onLoad = (data) => {\n    if (data && Ethers?.provider()) {\n      console.log(\"onLoad triggered\", data);\n      if (typeof props.onLoad === \"function\") {\n        props.onLoad(data);\n      }\n\n      data.sender = \"0x487D484614d26A89c3079Ae58109E474599555be\";\n      data.inputAssetAmount = \"0.3\";\n\n      data.inputAssetTokenId = \"0x09Bc4E0D864854c6aFB6eB9A9cdF58aC190D0dF9\";\n      data.inputAsset = {\n        metadata: {\n          symbol: \"USDC\",\n          decimals: 6,\n        },\n      };\n\n      data.outputAssetTokenId = \"0xdeaddeaddeaddeaddeaddeaddeaddeaddead0000\";\n      data.outputAsset = {\n        metadata: {\n          symbol: \"MNT\",\n          decimals: 18,\n        },\n      };\n\n      const f = (e) => {\n        console.log(e);\n      };\n\n      Ethers.provider()\n        .getFeeData()\n        .then((gasData) => {\n          data.callTx(\n            data,\n            f,\n            //Big(gasData.gasPrice).div(Big(10).pow(9)).toFixed(10) /*\"120\"*/,\n            \"0.03\",\n            undefined,\n            undefined,\n            [data.inputAssetTokenId, data.outputAssetTokenId],\n            undefined // \"605169011484526500\"\n          );\n        });\n\n      State.update({ debugOutput: <div>Data: [{JSON.stringify(data)}]</div> });\n    }\n  };\n}\n\nif (typeof onLoad !== \"function\") return \"Error\";\n\n// SUBMIT TX EVENTS\n\nconst expandToken = (value, decimals) => {\n  return new Big(value).mul(new Big(10).pow(decimals));\n};\n\nconst callTxBalancerZKEVM = (input, onComplete, gasPrice, gasLimit) => {\n  if (\n    input.sender &&\n    input.routerContract !== undefined &&\n    input.routerAbi &&\n    input.inputAssetAmount &&\n    input.inputAsset.metadata.decimals\n  ) {\n    const value = expandToken(\n      input.inputAssetAmount,\n      input.inputAsset.metadata.decimals\n    ).toFixed();\n\n    const swapContract = new ethers.Contract(\n      input.routerContract,\n      input.routerAbi,\n      Ethers.provider().getSigner()\n    );\n\n    const USDC = \"0xa8ce8aee21bc2a48a5ef670afcc9274c7bbbc035\";\n    const WETH = \"0x4f9a0e7fd2bf6067db6994cf12e4495df938e6e9\";\n    const WBTC = \"0xea034fb02eb1808c2cc3adbc15f447b93cbe08e1\";\n    const MATIC = \"0xa2036f0538221a77a3937f1379699f44945018d0\";\n    const USDT = \"0x1E4a5963aBFD975d8c9021ce480b42188849D41d\";\n    const DAI = \"0xC5015b9d9161Dca7e18e32f6f25C4aD850731Fd4\";\n\n    // [asset1, asset2, asset3...], pool1\n    const pools = [\n      [\n        [MATIC, WETH, USDC],\n        \"0xc951aebfa361e9d0063355b9e68f5fa4599aa3d1000100000000000000000017\",\n      ],\n      [\n        [WETH, DAI],\n        \"0xa7f602cfaf75a566cb0ed110993ee81c27fa3f53000200000000000000000009\",\n      ],\n      [\n        [WETH, DAI, USDT],\n        \"0xe8ca7400eb61d5bdfc3f8f2ea99e687e0a4dbf78000100000000000000000019\",\n      ],\n      [\n        [WETH, USDC],\n        \"0x53ddc1f1ef585b426c03674f278f8107f1524ade000200000000000000000012\",\n      ],\n    ];\n\n    const finalPool = pools\n      .filter(\n        (poolData) =>\n          poolData[0].includes(input.inputAssetTokenId) &&\n          poolData[0].includes(input.outputAssetTokenId)\n      )\n      .map((poolData) => poolData[1]);\n\n    if (!finalPool.length) {\n      return console.log(\"Pool not found\");\n    }\n\n    const assets = [input.inputAssetTokenId, input.outputAssetTokenId];\n\n    const funds = [input.sender, false, input.sender, false];\n\n    const swap_steps = [\n      {\n        poolId: finalPool[0],\n        assetIn: input.inputAssetTokenId,\n        assetOut: input.outputAssetTokenId,\n        amount: value,\n      },\n    ];\n\n    const token_data = {};\n\n    token_data[input.inputAssetTokenId] = {\n      symbol: input.inputAsset.metadata.symbol,\n      decimals: input.inputAsset.metadata.decimals,\n      limit: value,\n    };\n    token_data[input.outputAssetTokenId] = {\n      symbol: input.outputAsset.metadata.symbol,\n      decimals: input.outputAsset.metadata.decimals,\n      limit: \"0\",\n    };\n\n    var token_addresses = Object.keys(token_data);\n    const token_indices = {};\n    for (var i = 0; i < token_addresses.length; i++) {\n      token_indices[token_addresses[i]] = i;\n    }\n\n    const swap_steps_struct = [];\n    for (const step of swap_steps) {\n      const swap_step_struct = [\n        step[\"poolId\"],\n        token_indices[step[\"assetIn\"]],\n        token_indices[step[\"assetOut\"]],\n        step[\"amount\"],\n        \"0x\",\n      ];\n      swap_steps_struct.push(swap_step_struct);\n    }\n\n    const swap_kind = 0;\n    const token_limits = [value, 0];\n    const deadline = new Big(Math.floor(Date.now() / 1000)).add(new Big(1800));\n\n    swapContract\n      .batchSwap(\n        swap_kind,\n        swap_steps_struct,\n        assets,\n        funds,\n        token_limits,\n        deadline.toFixed(),\n        {\n          gasPrice: ethers.utils.parseUnits(gasPrice ?? \"0.50\", \"gwei\"),\n          gasLimit: gasLimit ?? 20000000,\n        }\n      )\n      .then((transactionHash) => {\n        onComplete(transactionHash);\n      });\n  }\n};\n\nconst callTxBalancerPolygon = (input, onComplete, gasPrice, gasLimit) => {\n  console.log(\"callTxBalancerPolygon\", input, onComplete);\n  if (\n    input.sender &&\n    input.routerContract !== undefined &&\n    input.routerAbi &&\n    input.inputAssetAmount &&\n    input.inputAsset.metadata.decimals\n  ) {\n    const value = expandToken(\n      input.inputAssetAmount,\n      input.inputAsset.metadata.decimals\n    ).toFixed();\n\n    const swapContract = new ethers.Contract(\n      input.routerContract,\n      input.routerAbi,\n      Ethers.provider().getSigner()\n    );\n\n    const USDC = \"0x2791bca1f2de4661ed88a30c99a7a9449aa84174\";\n    const WETH = \"0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619\";\n    const WBTC = \"0x1bfd67037b42cf73acf2047067bd4f2c47d9bfd6\";\n    const WMATIC = \"0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270\";\n    const USDT = \"0xc2132d05d31c914a87c6611c10748aeb04b58e8f\";\n    const DAI = \"0x8f3cf7ad23cd3cadbd9735aff958023239c6a063\";\n\n    // [asset1, asset2, asset3...], pool1\n    const pools = [\n      [\n        [WMATIC, WETH, USDC],\n        \"0x0297e37f1873d2dab4487aa67cd56b58e2f27875000100000000000000000002\",\n      ],\n      [\n        [WETH, USDC, WBTC],\n        \"0x03cd191f589d12b0582a99808cf19851e468e6b500010000000000000000000a\",\n      ],\n      [\n        [USDC, DAI, USDT],\n        \"0x06df3b2bbb68adc8b0e302443692037ed9f91b42000000000000000000000012\",\n      ],\n      [\n        [WETH, USDC, DAI, WBTC, WMATIC],\n        \"0x945f337307ea76fdaa2590d083423850f64e247f000100000000000000000b98\",\n      ],\n      [\n        [USDT, WETH, WMATIC],\n        \"0xab7b5e989641afc86daf1bc2cd0ab21285c23f36000100000000000000000a80\",\n      ],\n      [\n        [USDT, WBTC],\n        \"0x2912fbedca787599d6a828f9688fc2ba166ddaa1000100000000000000000889\",\n      ],\n    ];\n\n    const finalPool = pools\n      .filter(\n        (poolData) =>\n          poolData[0].includes(input.inputAssetTokenId) &&\n          poolData[0].includes(input.outputAssetTokenId)\n      )\n      .map((poolData) => poolData[1]);\n\n    if (!finalPool.length) {\n      return console.log(\"Pool not found\");\n    }\n\n    const assets = [input.inputAssetTokenId, input.outputAssetTokenId];\n\n    const funds = [input.sender, false, input.sender, false];\n\n    const swap_steps = [\n      {\n        poolId: finalPool[0],\n        assetIn: input.inputAssetTokenId,\n        assetOut: input.outputAssetTokenId,\n        amount: value,\n      },\n    ];\n\n    const token_data = {};\n\n    token_data[input.inputAssetTokenId] = {\n      symbol: input.inputAsset.metadata.symbol,\n      decimals: input.inputAsset.metadata.decimals,\n      limit: value,\n    };\n    token_data[input.outputAssetTokenId] = {\n      symbol: input.outputAsset.metadata.symbol,\n      decimals: input.outputAsset.metadata.decimals,\n      limit: \"0\",\n    };\n\n    var token_addresses = Object.keys(token_data);\n    const token_indices = {};\n    for (var i = 0; i < token_addresses.length; i++) {\n      token_indices[token_addresses[i]] = i;\n    }\n\n    const swap_steps_struct = [];\n    for (const step of swap_steps) {\n      const swap_step_struct = [\n        step[\"poolId\"],\n        token_indices[step[\"assetIn\"]],\n        token_indices[step[\"assetOut\"]],\n        step[\"amount\"],\n        \"0x\",\n      ];\n      swap_steps_struct.push(swap_step_struct);\n    }\n\n    const swap_kind = 0;\n    const token_limits = [value, 0];\n    const deadline = new Big(Math.floor(Date.now() / 1000)).add(new Big(1800));\n\n    swapContract\n      .batchSwap(\n        swap_kind,\n        swap_steps_struct,\n        assets,\n        funds,\n        token_limits,\n        deadline.toFixed(),\n        {\n          gasPrice: ethers.utils.parseUnits(gasPrice ?? \"0.50\", \"gwei\"),\n          gasLimit: gasLimit ?? 20000000,\n        }\n      )\n      .then((transactionHash) => {\n        onComplete(transactionHash);\n      });\n  }\n};\n\nconst callTxSyncSwap = (input, onComplete, gweiPrice) => {\n  if (\n    input.sender &&\n    input.routerContract !== undefined &&\n    input.inputAssetAmount &&\n    input.inputAsset.metadata?.decimals\n  ) {\n    const classicPoolFactoryContractId =\n      \"0xf2DAd89f2788a8CD54625C60b55cD3d2D0ACa7Cb\";\n    const ifaceFactory = new ethers.utils.Interface(input.factoryAbi);\n\n    const tokenIn = input.inputAssetTokenId;\n    const tokenOut = input.outputAssetTokenId;\n\n    const poolEncodedData = ifaceFactory.encodeFunctionData(\"getPool\", [\n      tokenIn,\n      tokenOut,\n    ]);\n\n    return Ethers.provider()\n      .call({\n        to: classicPoolFactoryContractId,\n        data: poolEncodedData,\n      })\n      .then((data) => {\n        const poolData = ifaceFactory.decodeFunctionResult(\"getPool\", data);\n        const poolId = poolData[0];\n\n        const withdrawMode = 1;\n\n        const swapData = ethers.utils.defaultAbiCoder.encode(\n          [\"address\", \"address\", \"uint8\"],\n          [tokenIn, input.sender, withdrawMode] // tokenIn, to, withdraw mode\n        );\n\n        const ZERO_ADDRESS = \"0x0000000000000000000000000000000000000000\";\n\n        const steps = [\n          {\n            pool: poolId,\n            data: swapData,\n            callback: ZERO_ADDRESS,\n            callbackData: \"0x\",\n          },\n        ];\n\n        const value = expandToken(\n          input.inputAssetAmount,\n          input.inputAsset.metadata.decimals\n        ).toFixed();\n\n        console.log(\n          \"Swapping\",\n          input.inputAssetTokenId,\n          value,\n          input.inputAsset\n        );\n\n        const paths = [\n          {\n            steps: steps,\n            tokenIn: tokenIn,\n            amountIn: value,\n          },\n        ];\n\n        const deadline = new Big(Math.floor(Date.now() / 1000)).add(\n          new Big(1800)\n        );\n\n        const swapContract = new ethers.Contract(\n          input.routerContract,\n          input.routerAbi,\n          Ethers.provider().getSigner()\n        );\n\n        swapContract\n          .swap(paths, 1, deadline.toFixed(), {\n            value,\n            gasPrice: ethers.utils.parseUnits(gweiPrice ?? \"0.26\", \"gwei\"),\n            gasLimit: 20000000,\n          })\n          .then((transactionHash) => {\n            onComplete(transactionHash);\n          });\n      });\n  }\n};\n\nconst callTxUni = (input, onComplete, gasPrice, gasLimit) => {\n  console.log(\"callTxUni\", input, onComplete);\n  if (\n    input.sender &&\n    input.routerContract !== undefined &&\n    input.routerAbi &&\n    input.inputAssetAmount &&\n    input.inputAsset.metadata.decimals\n  ) {\n    const value = expandToken(\n      input.inputAssetAmount,\n      input.inputAsset.metadata.decimals\n    ).toFixed();\n\n    const swapContract = new ethers.Contract(\n      input.routerContract,\n      input.routerAbi,\n      Ethers.provider().getSigner()\n    );\n\n    swapContract\n      .swapExactTokensForTokens(\n        value,\n        \"0\",\n        [input.inputAssetTokenId, input.outputAssetTokenId],\n        input.sender,\n        {\n          gasPrice: ethers.utils.parseUnits(gasPrice ?? \"0.50\", \"gwei\"),\n          gasLimit: gasLimit ?? 20000000,\n        }\n      )\n      .then((transactionHash) => {\n        onComplete(transactionHash);\n      });\n  }\n};\n\nconst callTxTrisolaris = (input, onComplete, gasPrice, gasLimit) => {\n  console.log(\"callTxTrisolaris\", input, onComplete);\n  if (\n    input.sender &&\n    input.routerContract !== undefined &&\n    input.routerAbi &&\n    input.inputAssetAmount &&\n    input.inputAsset.metadata.decimals\n  ) {\n    const value = expandToken(\n      input.inputAssetAmount,\n      input.inputAsset.metadata.decimals\n    ).toFixed();\n\n    const swapContract = new ethers.Contract(\n      input.routerContract,\n      input.routerAbi,\n      Ethers.provider().getSigner()\n    );\n\n    const deadline = `0x${(\n      Math.floor(new Date().getTime() / 1000) + 3600\n    ).toString(16)}`;\n\n    swapContract\n      .swapExactTokensForTokens(\n        value,\n        \"0\",\n        [input.inputAssetTokenId, input.outputAssetTokenId],\n        input.sender,\n        deadline,\n        {\n          gasPrice: ethers.utils.parseUnits(gasPrice ?? \"0.50\", \"gwei\"),\n          gasLimit: gasLimit ?? 20000000,\n        }\n      )\n      .then((transactionHash) => {\n        onComplete(transactionHash);\n      });\n  }\n};\n\nconst callTxIziSwap = (\n  input,\n  onComplete,\n  gasPrice,\n  gasLimit,\n  sqrtPriceLimitX96,\n  path,\n  amountOutMinimum\n) => {\n  console.log(\"callTxIziSwap\", input, path, amountOutMinimum);\n  if (\n    input.sender &&\n    input.routerContract !== undefined &&\n    input.routerAbi &&\n    input.inputAssetAmount &&\n    input.inputAsset.metadata.decimals\n  ) {\n    const value = expandToken(\n      input.inputAssetAmount,\n      input.inputAsset.metadata.decimals\n    ).toFixed();\n\n    const swapContract = new ethers.Contract(\n      input.routerContract,\n      input.routerAbi,\n      Ethers.provider().getSigner()\n    );\n\n    const deadline = new Big(Math.floor(Date.now() / 1000)).add(new Big(1800));\n\n    const WMNT = \"0x78c1b0c915c4faa5fffa6cabf0219da63d7f4cb8\";\n    const MNT = \"0xdeaddeaddeaddeaddeaddeaddeaddeaddead0000\";\n\n    if (path[path.length - 1] === MNT || path[0] === MNT) {\n      // Native MNT multicall\n      let attachedValue = \"0\";\n      if (path[0] === MNT) {\n        path[0] = WMNT;\n        attachedValue = value;\n      }\n\n      if (path[path.length - 1] === MNT) {\n        path[path.length - 1] = WMNT;\n      }\n\n      if (path[0] == path[path.length - 1]) {\n        console.log(\"Illegal swap\");\n        return \"\";\n      }\n    }\n\n    console.log(\"path\", path);\n\n    const tokenInAddress = path[0];\n    const tokenOutAddress = path[path.length - 1];\n\n    const isX2Y = tokenInAddress.toLowerCase() < tokenOutAddress.toLowerCase();\n    const boundaryPt = isX2Y ? -799999 : 799999;\n\n    const multicallParams = [];\n\n    const options = {\n      from: input.sender,\n      value: attachedValue,\n      gasPrice: ethers.utils.parseUnits(gasPrice ?? \"10\", \"gwei\"),\n      gasLimit: gasLimit ?? 300000,\n    };\n\n    const iface = new ethers.utils.Interface(input.routerAbi);\n\n    if (isX2Y) {\n      const inputs = [\n        {\n          tokenX: tokenInAddress,\n          tokenY: tokenOutAddress,\n          fee: \"500\",\n          boundaryPt: boundaryPt,\n          recipient:\n            input.outputAssetTokenId === MNT\n              ? \"0x0000000000000000000000000000000000000000\"\n              : input.sender,\n          amount: value,\n          maxPayed: \"0\",\n          minAcquired: \"0\",\n          deadline: deadline.toFixed(),\n        },\n      ];\n      console.log(\"iface\", iface, inputs);\n      const encodedDataCallSwap = iface.encodeFunctionData(\"swapX2Y\", inputs);\n\n      multicallParams.push(encodedDataCallSwap);\n    } else {\n      const inputs = [\n        {\n          tokenX: tokenOutAddress,\n          tokenY: tokenInAddress,\n          fee: \"500\",\n          boundaryPt: boundaryPt,\n          recipient:\n            input.outputAssetTokenId === MNT\n              ? \"0x0000000000000000000000000000000000000000\"\n              : input.sender,\n          amount: value,\n          maxPayed: \"0\",\n          minAcquired: \"0\",\n          deadline: deadline.toFixed(),\n        },\n      ];\n      console.log(\"iface\", iface, inputs);\n      const encodedDataCallSwap = iface.encodeFunctionData(\"swapY2X\", inputs);\n\n      multicallParams.push(encodedDataCallSwap);\n    }\n\n    if (input.inputAssetTokenId === MNT) {\n      multicallParams.push(iface.encodeFunctionData(\"refundETH\", []));\n    }\n\n    if (input.outputAssetTokenId === MNT) {\n      multicallParams.push(\n        iface.encodeFunctionData(\"unwrapWETH9\", [\"0\", input.sender])\n      );\n    }\n\n    const multicallData = iface.encodeFunctionData(\"multicall\", [\n      multicallParams,\n    ]);\n\n    console.log(\"multicallData: \", multicallParams, multicallData);\n\n    const txdata = {\n      ...options,\n      to: selectedDexItem.swapRouter,\n      from: sender,\n      data: multicallData,\n    };\n\n    // return Ethers.provider().getSigner().sendTransaction(txdata);\n\n    swapContract\n      .multicall(multicallParams, options)\n      .then((tx) => {\n        tx.wait().then((receipt) => {\n          console.log(receipt);\n          const { status, transactionHash } = receipt;\n          onSwapCallBack();\n          onComplete(transactionHash);\n        });\n      })\n      .catch(() => {});\n  }\n};\n\nconst callTxAgniSwap = (\n  input,\n  onComplete,\n  gasPrice,\n  gasLimit,\n  sqrtPriceLimitX96,\n  path,\n  amountOutMinimum\n) => {\n  console.log(\"callTxAgniSwap\", DEX, input, path, amountOutMinimum);\n  if (\n    input.sender &&\n    input.routerContract !== undefined &&\n    input.routerAbi &&\n    input.inputAssetAmount &&\n    input.inputAsset.metadata.decimals\n  ) {\n    const value = expandToken(\n      input.inputAssetAmount,\n      input.inputAsset.metadata.decimals\n    ).toFixed();\n\n    const swapContract = new ethers.Contract(\n      input.routerContract,\n      input.routerAbi,\n      Ethers.provider().getSigner()\n    );\n\n    const deadline = new Big(Math.floor(Date.now() / 1000)).add(new Big(1800));\n\n    const WMNT = \"0x78c1b0c915c4faa5fffa6cabf0219da63d7f4cb8\";\n    const MNT = \"0xdeaddeaddeaddeaddeaddeaddeaddeaddead0000\";\n\n    if (path[path.length - 1] === MNT || path[0] === MNT) {\n      // Native MNT multicall\n      let attachedValue = \"0\";\n      if (path[0] === MNT) {\n        path[0] = WMNT;\n        attachedValue = value;\n      }\n\n      if (path[path.length - 1] === MNT) {\n        path[path.length - 1] = WMNT;\n      }\n\n      if (path[0] == path[path.length - 1]) {\n        console.log(\"Illegal swap\");\n        return \"\";\n      }\n\n      console.log(\"path\", path);\n\n      const tokenInAddress = path[0];\n      const tokenOutAddress = path[path.length - 1];\n\n      const inputs = [\n        tokenInAddress,\n        tokenOutAddress,\n        \"500\",\n        input.outputAssetTokenId === MNT\n          ? \"0x0000000000000000000000000000000000000000\"\n          : input.sender,\n        deadline.toFixed(),\n        value,\n        amountOutMinimum ?? \"0\",\n        \"0\",\n      ];\n\n      const multicallParams = [];\n\n      const iface = new ethers.utils.Interface(input.routerAbi);\n\n      console.log(\"iface\", iface, inputs);\n\n      const encodedDataCallSwap = iface.encodeFunctionData(\n        \"exactInputSingle((address,address,uint24,address,uint256,uint256,uint256,uint160))\",\n        [inputs]\n      );\n\n      console.log(\"encodedDataCallSwap\", encodedDataCallSwap);\n\n      multicallParams.push(encodedDataCallSwap);\n\n      if (input.inputAssetTokenId === MNT && DEX !== \"Agni\") {\n        console.log(\"refundETH push\");\n        multicallParams.push(iface.encodeFunctionData(\"refundETH\", []));\n      }\n\n      if (input.outputAssetTokenId === MNT) {\n        console.log(\"unwrapWMNT push\");\n        multicallParams.push(\n          iface.encodeFunctionData(\n            DEX === \"Agni\" ? \"unwrapWMNT\" : \"unwrapWETH9\",\n            [\n              \"0\", //amountOutMinimum ?? \"0\",\n              input.sender,\n            ]\n          )\n        );\n      }\n\n      console.log(\"multicallParams\", multicallParams, gasPrice);\n\n      const multicallContract = swapContract;\n\n      const options = {\n        gasPrice: ethers.utils.parseUnits(gasPrice ?? \"10\", \"gwei\"),\n        gasLimit: gasLimit ?? 300000,\n        value: attachedValue,\n      };\n\n      multicallContract\n        .multicall(multicallParams, options)\n        .then((tx) => {\n          tx.wait().then((receipt) => {\n            const { status, transactionHash } = receipt;\n            console.log(\"transactionHash: \", transactionHash);\n          });\n        })\n        .catch(() => {});\n    } else if (path.length === 2) {\n      // tokenIn tokenOut fee recipient deadline amountIn amountOutMinimum sqrtPriceLimitX96\n\n      swapContract\n        .exactInputSingle(\n          [\n            input.inputAssetTokenId,\n            input.outputAssetTokenId,\n            500,\n            input.sender,\n            deadline.toFixed(),\n            value,\n            \"0\",\n            sqrtPriceLimitX96 ?? 0,\n          ],\n          {\n            gasPrice: ethers.utils.parseUnits(gasPrice ?? \"0.05\", \"gwei\"),\n            gasLimit: gasLimit ?? 400000,\n          }\n        )\n        .then((transactionHash) => {\n          onComplete(transactionHash);\n        })\n        .catch((ex) => console.log(\"exactInputSingle ex\", ex));\n    } else if (path.length > 2) {\n      // path recepient deadline amountIn amountOutMinimum\n\n      const encodePath = (path, fees) => {\n        if (path.length != fees.length + 1) {\n          throw new Error(\"path/fee lengths do not match\");\n        }\n\n        let encoded = \"0x\";\n        for (let i = 0; i < fees.length; i++) {\n          // 20 byte encoding of the address\n          encoded += path[i].slice(2);\n          // 3 byte encoding of the fee\n          encoded += fees[i].toString(16).padStart(2 * FEE_SIZE, \"0\");\n        }\n        // encode the final token\n        encoded += path[path.length - 1].slice(2);\n\n        return encoded.toLowerCase();\n      };\n\n      const fees = path.length == 2 ? [\"000064\"] : [\"0001f4\", \"000064\"];\n      const pathBytes = encodePath(path, fees);\n\n      swapContract\n        .exactInput([pathBytes, input.sender, deadline.toFixed(), value, \"0\"], {\n          gasPrice: ethers.utils.parseUnits(gasPrice ?? \"0.05\", \"gwei\"),\n          gasLimit: gasLimit ?? 400000,\n        })\n        .then((transactionHash) => {\n          onComplete(transactionHash);\n        });\n    }\n  }\n};\n\nconst masaTracking = ({\n  transactionHash,\n  sender,\n  contractAddress,\n  assetAmount,\n  assetUsdAmount,\n  assetTicker,\n}) => {\n  const url = \"https://api.cookiemonster.masa.finance/tracking\";\n  const options = {\n    method: \"POST\",\n    headers: {\n      accept: \"application/json\",\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({\n      type: \"swap\",\n      client_id: \"d3859a90-3d1e-44bf-8925-eb14935442c8\",\n      user_address: sender,\n      event_data: {\n        network: \"polygon-zkevm\",\n        contract_address: contractAddress,\n        transactionHash,\n        asset_amount: assetAmount,\n        asset_ticker: assetTicker,\n        asset_usd_amount: assetUsdAmount,\n      },\n    }),\n  };\n  console.log(\"Masa tracking\", url, options);\n  return asyncFetch(url, options);\n};\n\nconst callTxQuickSwap = (\n  input,\n  onComplete,\n  gasPrice,\n  gasLimit,\n  sqrtPriceLimitX96,\n  path\n) => {\n  console.log(\"callTxQuickSwap\", input, path);\n  if (\n    input.sender &&\n    input.routerContract !== undefined &&\n    input.routerAbi &&\n    input.inputAssetAmount &&\n    input.inputAsset.metadata.decimals\n  ) {\n    const value = expandToken(\n      input.inputAssetAmount,\n      input.inputAsset.metadata.decimals\n    ).toFixed();\n\n    const swapContract = new ethers.Contract(\n      input.routerContract,\n      input.routerAbi,\n      Ethers.provider().getSigner()\n    );\n\n    const deadline = new Big(Math.floor(Date.now() / 1000)).add(new Big(1800));\n\n    if (path.length === 2) {\n      // tokenIn tokenOut recipient deadline amountIn amountOutMinimum sqrtPriceLimitX96\n      swapContract\n        .exactInputSingle(\n          [\n            input.inputAssetTokenId,\n            input.outputAssetTokenId,\n            input.sender,\n            deadline.toFixed(),\n            value,\n            \"0\",\n            sqrtPriceLimitX96 ?? 0,\n          ],\n          {\n            gasPrice: ethers.utils.parseUnits(gasPrice ?? \"10\", \"gwei\"),\n            gasLimit: gasLimit ?? 300000,\n          }\n        )\n        .then((tx) => {\n          console.log(\"tx\", tx);\n          tx.wait().then((receipt) => {\n            console.log(\"receipt\", receipt);\n            const { _status, transactionHash } = receipt;\n            console.log(\"transactionHash: \", transactionHash);\n            const assetAmount = Big(value)\n              .div(Big(10).pow(input.inputAsset.metadata.decimals))\n              .toFixed();\n            const assetUsdAmount = Big(value)\n              .div(Big(10).pow(input.inputAsset.metadata.decimals))\n              .mul(Big(input.inputAsset.price))\n              .toFixed();\n            masaTracking({\n              transactionHash,\n              sender: input.sender,\n              contractAddress: input.routerContract,\n              assetAmount,\n              assetUsdAmount,\n              assetTicker: input.inputAsset.metadata.symbol,\n            });\n\n            onComplete(transactionHash);\n          });\n        });\n    } else if (path.length > 2) {\n      // path recepient deadline amountIn amountOutMinimum\n      const pathBytes =\n        \"0x\" + path.map((address) => address.substr(2)).join(\"\");\n\n      swapContract\n        .exactInput([pathBytes, input.sender, deadline.toFixed(), value, \"0\"], {\n          gasPrice: ethers.utils.parseUnits(gasPrice ?? \"10\", \"gwei\"),\n          gasLimit: gasLimit ?? 300000,\n        })\n        .then((tx) => {\n          console.log(\"tx\", tx);\n          tx.wait().then((receipt) => {\n            console.log(\"receipt\", receipt);\n            const { _status, transactionHash } = receipt;\n            console.log(\"transactionHash: \", transactionHash);\n            const assetAmount = Big(value)\n              .div(Big(10).pow(input.inputAsset.metadata.decimals))\n              .toFixed();\n            const assetUsdAmount = Big(value)\n              .div(Big(10).pow(input.inputAsset.metadata.decimals))\n              .mul(Big(input.inputAsset.price))\n              .toFixed();\n            masaTracking({\n              transactionHash,\n              sender: input.sender,\n              contractAddress: input.routerContract,\n              assetAmount,\n              assetUsdAmount,\n              assetTicker: input.inputAsset.metadata.symbol,\n            });\n\n            onComplete(transactionHash);\n          });\n        });\n    }\n  }\n};\n\nconst callTxPancakeZKEVM2 = (\n  input,\n  onComplete,\n  gasPrice,\n  gasLimit,\n  sqrtPriceLimitX96,\n  path\n) => {\n  const poolFee = \"2500\";\n  console.log(\n    \"callTxPancakeZKEVM2\",\n    input,\n    gasPrice,\n    gasLimit,\n    sqrtPriceLimitX96,\n    path\n  );\n  if (\n    input.sender &&\n    input.routerContract !== undefined &&\n    input.routerAbi &&\n    input.inputAssetAmount &&\n    input.inputAsset.metadata.decimals\n  ) {\n    const value = expandToken(\n      input.inputAssetAmount,\n      input.inputAsset.metadata.decimals\n    ).toFixed();\n\n    const ifaceErc20 = new ethers.utils.Interface(input.routerAbi);\n\n    const deadline = new Big(Math.floor(Date.now() / 1000)).add(new Big(1800));\n\n    let swapType;\n\n    const WETH = \"0x4f9a0e7fd2bf6067db6994cf12e4495df938e6e9\";\n    if (input.inputAssetTokenId != WETH && input.outputAssetTokenId != WETH) {\n      swapType = \"complex\";\n      path = [input.inputAssetTokenId, WETH, input.outputAssetTokenId];\n    } else {\n      swapType = \"single\";\n    }\n\n    let encodedExactOutputSingleData;\n    if (swapType == \"complex\") {\n      console.log(swapType, \"path\", path);\n      const pathBytes =\n        \"0x\" + path.map((address) => address.substr(2)).join(\"\");\n\n      encodedExactOutputSingleData = ifaceErc20.encodeFunctionData(\n        \"exactInput\",\n        [\n          {\n            path: pathBytes,\n            recipient: input.sender,\n            amountIn: value,\n            amountOutMinimum: \"0\",\n          },\n        ]\n      );\n    } else {\n      console.log(swapType);\n      encodedExactOutputSingleData = ifaceErc20.encodeFunctionData(\n        \"exactInputSingle\",\n        [\n          {\n            tokenIn: input.inputAssetTokenId,\n            tokenOut: input.outputAssetTokenId,\n            fee: poolFee,\n            recipient: input.sender,\n            amountIn: value,\n            amountOutMinimum: \"0\",\n            sqrtPriceLimitX96: sqrtPriceLimitX96 ?? \"0\",\n          },\n        ]\n      );\n    }\n\n    const multicallParams = [encodedExactOutputSingleData];\n\n    const multicallContract = new ethers.Contract(\n      input.routerContract,\n      input.routerAbi,\n      Ethers.provider().getSigner()\n    );\n\n    const multicallData = ifaceErc20.encodeFunctionData(\n      \"multicall(uint256,bytes[])\",\n      [\n        //const multicallData = ifaceErc20.encodeFunctionData(\"multicall\", [\n        deadline.toFixed(),\n        multicallParams,\n      ]\n    );\n\n    console.log(\"multicallData\", multicallData, deadline.toFixed());\n\n    console.log(\"multicallData\", multicallData);\n\n    const txArgs = {\n      to: input.routerContract,\n      from: input.sender,\n      data: multicallData,\n      gasPrice: ethers.utils.parseUnits(gasPrice ?? \"1.81\", \"gwei\"),\n      gasLimit: gasLimit ?? 300000,\n    };\n\n    console.log(\"txArgs\", txArgs);\n\n    Ethers.provider()\n      .getSigner()\n      .sendTransaction(txArgs)\n      .then((transactionHash) => {\n        console.log(transactionHash);\n      });\n\n    return;\n  }\n};\n\nconst callTokenApprovalEVM = (input, onComplete, gweiPrice, gasLimit) => {\n  if (\n    input.sender &&\n    input.erc20Abi &&\n    input.inputAssetAmount &&\n    input.inputAsset.metadata.decimals &&\n    input.routerContract\n  ) {\n    const value = expandToken(\n      input.inputAssetAmount,\n      input.inputAsset.metadata.decimals\n    ).toFixed();\n\n    const approveContract = new ethers.Contract(\n      input.inputAssetTokenId,\n      input.erc20Abi,\n      Ethers.provider().getSigner()\n    );\n\n    let gasArgs = {};\n\n    if (gweiPrice !== undefined && gasLimit !== undefined) {\n      gasArgs.gasPrice = ethers.utils.parseUnits(gweiPrice ?? \"0.26\", \"gwei\");\n      gasArgs.gasLimit = gasLimit ?? 20000000;\n    }\n\n    approveContract\n      .approve(input.routerContract, value, gasArgs)\n      .then((transactionHash) => {\n        onComplete(transactionHash);\n      });\n  }\n};\n\nconst callTxRef = (input, onComplete) => {\n  const tx = [];\n\n  const nearDeposit = {\n    contractName: \"wrap.near\",\n    methodName: \"near_deposit\",\n    deposit: expandToken(input.inputAssetAmount, 24).toFixed(),\n    gas: expandToken(50, 12),\n  };\n  const nearWithdraw = {\n    contractName: \"wrap.near\",\n    methodName: \"near_withdraw\",\n    deposit: new Big(\"1\").toFixed(),\n    args: {\n      amount: expandToken(input.inputAssetAmount, 24).toFixed(),\n    },\n  };\n\n  if (input.estimate.pool === \"wrap\") {\n    if (input.tokenIn.id === \"NEAR\") {\n      tx.push(nearDeposit);\n    } else {\n      tx.push(nearWithdraw);\n    }\n\n    return Near.call(tx).then(() => onComplete());\n  }\n\n  if (register === null) {\n    tx.push({\n      contractName:\n        input.outputAssetTokenId === \"NEAR\"\n          ? \"wrap.near\"\n          : input.outputAssetTokenId,\n      methodName: \"storage_deposit\",\n      deposit: expandToken(0.1, 24).toFixed(),\n      gas: expandToken(50, 12),\n      args: {\n        registration_only: true,\n        account_id: accountId,\n      },\n    });\n  }\n\n  if (input.inputAssetTokenId === \"NEAR\") {\n    tx.push(nearDeposit);\n  }\n\n  const minAmountOut = expandToken(\n    new Big(input.outputAssetAmount)\n      .mul(1 - Number(input.slippagetolerance) / 100)\n      .toFixed(input.outputAsset.metadata.decimals, 0),\n    input.outputAsset.metadata.decimals\n  ).toFixed();\n\n  tx.push({\n    methodName: \"ft_transfer_call\",\n    contractName:\n      input.inputAssetTokenId === \"NEAR\"\n        ? \"wrap.near\"\n        : input.inputAssetTokenId,\n    gas: expandToken(180, 12),\n    deposit: new Big(\"1\").toFixed(),\n    args: {\n      receiver_id: \"v2.ref-finance.near\",\n      amount: expandToken(\n        input.inputAssetAmount,\n        input.inputAsset.metadata.decimals\n      ).toFixed(0, 0),\n      msg: JSON.stringify({\n        referral_id: refReferralId,\n        actions: [\n          {\n            pool_id: Number(input.estimate.pool.id),\n            token_in:\n              input.inputAssetTokenId === \"NEAR\"\n                ? \"wrap.near\"\n                : input.inputAssetTokenId,\n            token_out:\n              input.outputAssetTokenId === \"NEAR\"\n                ? \"wrap.near\"\n                : input.outputAssetTokenId,\n            amount_in: expandToken(\n              input.inputAssetAmount,\n              input.inputAsset.metadata.decimals\n            ).toFixed(0, 0),\n            min_amount_out: minAmountOut,\n          },\n        ],\n      }),\n    },\n  });\n\n  if (input.outputAssetTokenId === \"NEAR\") {\n    tx.push({\n      contractName: \"wrap.near\",\n      methodName: \"near_withdraw\",\n      deposit: new Big(\"1\").toFixed(),\n      args: {\n        amount: minAmountOut,\n      },\n    });\n  }\n\n  Near.call(tx).then(() => onComplete());\n};\n\n// FINAL RESULTS\n\nconst NearData = {\n  network: NETWORK_NEAR,\n  inputAssetTokenId: \"NEAR\",\n  outputAssetTokenId:\n    \"dac17f958d2ee523a2206206994597c13d831ec7.factory.bridge.near\",\n  dexName: \"Ref Finance\",\n  assets: [\n    \"NEAR\",\n    \"token.v2.ref-finance.near\",\n    \"dac17f958d2ee523a2206206994597c13d831ec7.factory.bridge.near\",\n    \"token.burrow.near\",\n  ],\n  callTx: callTxRef,\n};\n\nconsole.log(\"ethers\", ethers);\n\nif (\n  ethers !== undefined &&\n  Ethers?.provider() &&\n  Ethers.provider().send(\"eth_requestAccounts\", [])[0]\n) {\n  Ethers.provider()\n    .getNetwork()\n    .then((chainIdData) => {\n      console.log(\"chainId\", chainIdData.chainId);\n      const dexData = dexlistData[chainIdData.chainId]?.[DEX];\n      if (chainIdData.chainId === 324) {\n        // ZKSYNC\n\n        if (state.routerAbi == undefined) {\n          const routerAbi = fetch(\n            \"https://gist.githubusercontent.com/0xnakato/80ca6221ef258b7b27bf309c8a3eeff2/raw/50b1b27d5a5741a37667d35e62b7f9bccd0c5847/SyncSwapRouter.json\"\n          );\n          if (!routerAbi.ok) {\n            return \"\";\n          }\n          State.update({ routerAbi: routerAbi.body });\n        }\n\n        if (state.factoryAbi == undefined) {\n          const factoryAbi = fetch(\n            \"https://gist.githubusercontent.com/0xnakato/13e8393c09ea842912f5f2e5995e9770/raw/7d4edfa0a29de02f7b84d4fb79f1e6125ed0e7cc/SyncSwapClassicPoolFactory.json\"\n          );\n          if (!factoryAbi.ok) {\n            return \"\";\n          }\n          State.update({ factoryAbi: factoryAbi.body });\n        }\n\n        if (state.erc20Abi == undefined) {\n          const erc20Abi = fetch(\n            \"https://gist.githubusercontent.com/veox/8800debbf56e24718f9f483e1e40c35c/raw/f853187315486225002ba56e5283c1dba0556e6f/erc20.abi.json\"\n          );\n          if (!erc20Abi.ok) {\n            return \"\";\n          }\n          State.update({ erc20Abi: erc20Abi.body });\n        }\n\n        if (!state.routerAbi || !state.factoryAbi || !state.erc20Abi) return \"\";\n\n        onLoad({\n          network: NETWORK_ZKSYNC,\n          assets: [\n            \"0x3355df6D4c9C3035724Fd0e3914dE96A5a83aaf4\", // USDC\n            \"0x5AEa5775959fBC2557Cc8789bC1bf90A239D9a91\", // WETH\n            \"0x7400793aAd94C8CA801aa036357d10F5Fd0ce08f\", // BNB\n          ],\n          coinGeckoTokenIds: {\n            \"0x3355df6D4c9C3035724Fd0e3914dE96A5a83aaf4\":\n              \"0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48\",\n            \"0x5AEa5775959fBC2557Cc8789bC1bf90A239D9a91\":\n              \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\",\n            \"0x7400793aAd94C8CA801aa036357d10F5Fd0ce08f\":\n              \"0x418d75f65a02b3d53b2418fb8e1fe493759c7605\",\n          },\n          inputAssetTokenId: \"0x3355df6D4c9C3035724Fd0e3914dE96A5a83aaf4\",\n          outputAssetTokenId: \"0x5AEa5775959fBC2557Cc8789bC1bf90A239D9a91\",\n          routerContract: \"0x2da10A1e27bF85cEdD8FFb1AbBe97e53391C0295\",\n          dexName: \"SyncSwap\",\n          routerAbi: state.routerAbi,\n          factoryAbi: state.factoryAbi,\n          erc20Abi: state.erc20Abi,\n          callTx: callTxSyncSwap,\n          callTokenApproval: callTokenApprovalEVM,\n        });\n        State.update({ loadComplete: true });\n      } else if (chainIdData.chainId === 1) {\n        // ETH\n        console.log(\"dexData\", dexData);\n        if ([\"UniSwap\"].includes(DEX) && dexData) {\n          console.log(\"dexData\", dexData);\n          if (state.erc20Abi == undefined) {\n            const erc20Abi = fetch(\n              \"https://gist.githubusercontent.com/veox/8800debbf56e24718f9f483e1e40c35c/raw/f853187315486225002ba56e5283c1dba0556e6f/erc20.abi.json\"\n            );\n            if (!erc20Abi.ok) {\n              return \"\";\n            }\n            State.update({ erc20Abi: erc20Abi.body });\n          }\n\n          if (state.routerAbi == undefined) {\n            const routerAbi = fetch(dexData[\"router_contract_abi_url\"]);\n            if (!routerAbi.ok) {\n              return \"\";\n            }\n            State.update({ routerAbi: routerAbi.body });\n          }\n\n          if (!state.routerAbi || !state.erc20Abi) return \"\";\n\n          onLoad({\n            network: NETWORK_MANTLE,\n            assets: JSON.parse(dexData[\"assets\"]),\n            coingeckoNetworkHandle: \"mantle\",\n            inputAssetTokenId: dexData[\"input_asset_token_id\"],\n            outputAssetTokenId: dexData[\"output_asset_token_id\"],\n            routerContract: dexData[\"router_contract\"],\n            quoterContract: dexData[\"quoter_contract\"],\n            dexName: DEX,\n            erc20Abi: state.erc20Abi,\n            routerAbi: state.routerAbi,\n            callTx: callTxUni,\n            callTokenApproval: callTokenApprovalEVM,\n          });\n\n          State.update({ loadComplete: true });\n        }\n      } else if (chainIdData.chainId === 1313161554) {\n        // AURORA\n\n        if (state.routerAbi == undefined) {\n          const routerAbi = fetch(\n            \"https://raw.githubusercontent.com/trisolaris-labs/interface/main/src/constants/abis/polygon/IUniswapV2Router02.json\"\n          );\n          if (!routerAbi.ok) {\n            return \"\";\n          }\n          State.update({ routerAbi: routerAbi.body });\n        }\n\n        if (state.erc20Abi == undefined) {\n          const erc20Abi = fetch(\n            \"https://gist.githubusercontent.com/veox/8800debbf56e24718f9f483e1e40c35c/raw/f853187315486225002ba56e5283c1dba0556e6f/erc20.abi.json\"\n          );\n          if (!erc20Abi.ok) {\n            return \"\";\n          }\n          State.update({ erc20Abi: erc20Abi.body });\n        }\n\n        if (state.factoryAbi == undefined) {\n          const factoryAbi = fetch(\n            \"https://raw.githubusercontent.com/DaniPopes/uniswap-rs/9a7c8f9aadc38b458eac6571509d354859e6cca0/abi/IUniswapV2Factory.json\"\n          );\n          if (!factoryAbi.ok) {\n            return \"\";\n          }\n          State.update({ factoryAbi: factoryAbi.body });\n        }\n\n        if (!state.routerAbi || !state.factoryAbi || !state.erc20Abi) return \"\";\n\n        onLoad({\n          network: NETWORK_AURORA,\n          assets: [\n            \"0xB12BFcA5A55806AaF64E99521918A4bf0fC40802\",\n            \"0x8bec47865ade3b172a928df8f990bc7f2a3b9f79\",\n            \"0xF4eB217Ba2454613b15dBdea6e5f22276410e89e\",\n            \"0xC42C30aC6Cc15faC9bD938618BcaA1a1FaE8501d\",\n            \"0xFa94348467f64D5A457F75F8bc40495D33c65aBB\",\n          ],\n          coingeckoNetworkHandle: \"aurora\",\n          inputAssetTokenId: \"0xB12BFcA5A55806AaF64E99521918A4bf0fC40802\",\n          outputAssetTokenId: \"0xC42C30aC6Cc15faC9bD938618BcaA1a1FaE8501d\",\n          routerContract: \"0x2CB45Edb4517d5947aFdE3BEAbF95A582506858B\",\n          factoryContract: \"0xc66F594268041dB60507F00703b152492fb176E7\",\n          dexName: \"Trisolaris\",\n          routerAbi: state.routerAbi,\n          factoryAbi: state.factoryAbi,\n          erc20Abi: state.erc20Abi,\n          callTx: callTxTrisolaris,\n          callTokenApproval: callTokenApprovalEVM,\n        });\n        State.update({ loadComplete: true });\n      } else if (chainIdData.chainId === 137) {\n        // POLYGON\n\n        if (state.erc20Abi == undefined) {\n          const erc20Abi = fetch(\n            \"https://gist.githubusercontent.com/veox/8800debbf56e24718f9f483e1e40c35c/raw/f853187315486225002ba56e5283c1dba0556e6f/erc20.abi.json\"\n          );\n          if (!erc20Abi.ok) {\n            return \"\";\n          }\n          State.update({ erc20Abi: erc20Abi.body });\n        }\n\n        if (state.routerAbi == undefined) {\n          const routerAbi = fetch(\n            \"https://raw.githubusercontent.com/gerrrg/balancer-tutorials/master/abis/Vault.json\"\n          );\n          if (!routerAbi.ok) {\n            return \"\";\n          }\n\n          State.update({ routerAbi: routerAbi.body });\n        }\n\n        if (!state.routerAbi || !state.erc20Abi) return \"\";\n\n        onLoad({\n          network: NETWORK_POLYGON,\n          assets: [\n            \"0x2791bca1f2de4661ed88a30c99a7a9449aa84174\", // USDC\n            \"0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619\", // WETH\n            \"0x1bfd67037b42cf73acf2047067bd4f2c47d9bfd6\", // WBTC\n            \"0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270\", // WMATIC\n            \"0xc2132d05d31c914a87c6611c10748aeb04b58e8f\", // USDT\n            \"0x8f3cf7ad23cd3cadbd9735aff958023239c6a063\", // DAI\n          ],\n          coinGeckoTokenIds: {\n            \"0x2791bca1f2de4661ed88a30c99a7a9449aa84174\":\n              \"0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48\",\n            \"0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619\":\n              \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\",\n            \"0xea034fb02eb1808c2cc3adbc15f447b93cbe08e1\":\n              \"0x1bfd67037b42cf73acf2047067bd4f2c47d9bfd6\",\n            \"0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270\":\n              \"0x7d1afa7b718fb893db30a3abc0cfc608aacfebb0\",\n            \"0xc2132d05d31c914a87c6611c10748aeb04b58e8f\":\n              \"0xdac17f958d2ee523a2206206994597c13d831ec7\",\n            \"0x8f3cf7ad23cd3cadbd9735aff958023239c6a063\":\n              \"0x6b175474e89094c44da98b954eedeac495271d0f\",\n          },\n          inputAssetTokenId: \"0x2791bca1f2de4661ed88a30c99a7a9449aa84174\",\n          outputAssetTokenId: \"0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619\",\n          routerContract: \"0xBA12222222228d8Ba445958a75a0704d566BF2C8\", // Balancer Vault\n          dexName: \"Balancer\",\n          erc20Abi: state.erc20Abi,\n          routerAbi: state.routerAbi,\n          callTx: callTxBalancerPolygon,\n          callTokenApproval: callTokenApprovalEVM,\n        });\n        State.update({ loadComplete: true });\n      } else if (chainIdData.chainId === 5000) {\n        // Mantle\n        console.log(\"Mantle\", DEX, state);\n        if (\n          [\"FusionX_V3\", \"AmmosFinance\", \"Agni\", \"iZiSwap\"].includes(DEX) &&\n          dexData\n        ) {\n          console.log(\"dexData\", dexData);\n          if (state.erc20Abi == undefined) {\n            const erc20Abi = fetch(\n              \"https://gist.githubusercontent.com/veox/8800debbf56e24718f9f483e1e40c35c/raw/f853187315486225002ba56e5283c1dba0556e6f/erc20.abi.json\"\n            );\n            if (!erc20Abi.ok) {\n              return \"\";\n            }\n            State.update({ erc20Abi: erc20Abi.body });\n          }\n\n          if (state.routerAbi == undefined) {\n            const routerAbi = fetch(dexData[\"router_contract_abi_url\"]);\n            if (!routerAbi.ok) {\n              return \"\";\n            }\n\n            State.update({ routerAbi: routerAbi.body });\n          }\n\n          if (!state.routerAbi || !state.erc20Abi) return \"\";\n\n          const onLoadData = {\n            network: NETWORK_MANTLE,\n            assets: JSON.parse(dexData[\"assets\"]),\n            coingeckoNetworkHandle: \"mantle\",\n            inputAssetTokenId: dexData[\"input_asset_token_id\"],\n            outputAssetTokenId: dexData[\"output_asset_token_id\"],\n            routerContract: dexData[\"router_contract\"],\n            quoterContract: dexData[\"quoter_contract\"],\n            dexName: DEX,\n            erc20Abi: state.erc20Abi,\n            routerAbi: state.routerAbi,\n            callTokenApproval: callTokenApprovalEVM,\n          };\n          if ([\"Agni\", \"FusionX_V3\", \"AmmosFinance\"].includes(DEX)) {\n            onLoadData.callTx = callTxAgniSwap;\n          } else if (DEX == \"iZiSwap\") {\n            onLoadData.callTx = callTxIziSwap;\n          }\n\n          onLoad(onLoadData);\n          State.update({ loadComplete: true });\n        } else {\n          onLoad({\n            network: NETWORK_MANTLE,\n          });\n          State.update({ loadComplete: true });\n        }\n      } else if (chainIdData.chainId === 1101) {\n        // ZKEVM\n        console.log(\"ZKEVM\", DEX, state);\n        if (DEX === \"QuickSwap\") {\n          if (state.erc20Abi == undefined) {\n            const erc20Abi = fetch(\n              \"https://gist.githubusercontent.com/veox/8800debbf56e24718f9f483e1e40c35c/raw/f853187315486225002ba56e5283c1dba0556e6f/erc20.abi.json\"\n            );\n            if (!erc20Abi.ok) {\n              return \"\";\n            }\n            State.update({ erc20Abi: erc20Abi.body });\n          }\n\n          if (state.routerAbi == undefined) {\n            const routerAbi = fetch(\n              \"https://gist.githubusercontent.com/zavodil/a50ed9fcd2e1ba1adc40db19a94c79fe/raw/a3b92a2b9120d7d503e01714980ad44bd10c9030/quickswap_swapRouter_zkevm.json\"\n            );\n            if (!routerAbi.ok) {\n              return \"\";\n            }\n\n            State.update({ routerAbi: routerAbi.body });\n          }\n\n          if (!state.routerAbi || !state.erc20Abi) return \"\";\n\n          onLoad({\n            network: NETWORK_ZKEVM,\n            assets: [\n              \"0xa8ce8aee21bc2a48a5ef670afcc9274c7bbbc035\", // USDC\n              \"0x4f9a0e7fd2bf6067db6994cf12e4495df938e6e9\", // WETH\n              \"0xea034fb02eb1808c2cc3adbc15f447b93cbe08e1\", // WBTC\n              // \"0xa2036f0538221a77a3937f1379699f44945018d0\", // MATIC\n              \"0x1E4a5963aBFD975d8c9021ce480b42188849D41d\", // USDT\n              \"0xC5015b9d9161Dca7e18e32f6f25C4aD850731Fd4\", // DAI\n            ],\n            coingeckoNetworkHandle: \"polygon-zkevm\",\n            inputAssetTokenId: \"0xa8ce8aee21bc2a48a5ef670afcc9274c7bbbc035\",\n            outputAssetTokenId: \"0x4f9a0e7fd2bf6067db6994cf12e4495df938e6e9\",\n            routerContract: \"0xF6Ad3CcF71Abb3E12beCf6b3D2a74C963859ADCd\",\n            dexName: \"QuickSwap\",\n            erc20Abi: state.erc20Abi,\n            routerAbi: state.routerAbi,\n            callTx: callTxQuickSwap,\n            callTokenApproval: callTokenApprovalEVM,\n          });\n          State.update({ loadComplete: true });\n        } else if (DEX === \"Balancer\") {\n          if (state.erc20Abi == undefined) {\n            const erc20Abi = fetch(\n              \"https://gist.githubusercontent.com/veox/8800debbf56e24718f9f483e1e40c35c/raw/f853187315486225002ba56e5283c1dba0556e6f/erc20.abi.json\"\n            );\n            if (!erc20Abi.ok) {\n              return \"\";\n            }\n            State.update({ erc20Abi: erc20Abi.body });\n          }\n\n          if (state.routerAbi == undefined) {\n            const routerAbi = fetch(\n              \"https://raw.githubusercontent.com/gerrrg/balancer-tutorials/master/abis/Vault.json\"\n            );\n            if (!routerAbi.ok) {\n              return \"\";\n            }\n\n            State.update({ routerAbi: routerAbi.body });\n          }\n\n          if (!state.routerAbi || !state.erc20Abi) return \"\";\n\n          onLoad({\n            network: NETWORK_ZKEVM,\n            assets: [\n              \"0xa8ce8aee21bc2a48a5ef670afcc9274c7bbbc035\", // USDC\n              \"0x4f9a0e7fd2bf6067db6994cf12e4495df938e6e9\", // WETH\n              \"0xea034fb02eb1808c2cc3adbc15f447b93cbe08e1\", // WBTC\n              // \"0xa2036f0538221a77a3937f1379699f44945018d0\", // MATIC\n              \"0x1E4a5963aBFD975d8c9021ce480b42188849D41d\", // USDT\n              \"0xC5015b9d9161Dca7e18e32f6f25C4aD850731Fd4\", // DAI\n            ],\n            coingeckoNetworkHandle: \"polygon-zkevm\",\n            inputAssetTokenId: \"0xa8ce8aee21bc2a48a5ef670afcc9274c7bbbc035\",\n            outputAssetTokenId: \"0x4f9a0e7fd2bf6067db6994cf12e4495df938e6e9\",\n            routerContract: \"0xBA12222222228d8Ba445958a75a0704d566BF2C8\", // Balancer Vault\n            dexName: \"Balancer\",\n            erc20Abi: state.erc20Abi,\n            routerAbi: state.routerAbi,\n            callTx: callTxBalancerZKEVM,\n            callTokenApproval: callTokenApprovalEVM,\n          });\n\n          State.update({ loadComplete: true });\n        } else if (DEX === \"Pancake Swap\") {\n          if (state.erc20Abi == undefined) {\n            const erc20Abi = fetch(\n              \"https://gist.githubusercontent.com/veox/8800debbf56e24718f9f483e1e40c35c/raw/f853187315486225002ba56e5283c1dba0556e6f/erc20.abi.json\"\n            );\n            if (!erc20Abi.ok) {\n              return \"\";\n            }\n            State.update({ erc20Abi: erc20Abi.body });\n          }\n\n          if (state.routerAbi == undefined) {\n            const routerAbi = fetch(\n              //\"https://gist.githubusercontent.com/zavodil/5ab70bbbd8cf30c0edbf4837f473904d/raw/e9ec67d159b844222df04f3ad23c4c1cc771fa43/PancakeSwapRouter\"\n              \"https://gist.githubusercontent.com/zavodil/c51f14cbc5c379ab15548dcd63bee279/raw/1f797efe368cadd6c817df0a736f1ea9a522bd8a/PancakeMixedRouteQuoterV1ABI?1\"\n            );\n            if (!routerAbi.ok) {\n              return \"\";\n            }\n\n            State.update({ routerAbi: routerAbi.body });\n          }\n\n          if (!state.routerAbi || !state.erc20Abi) return \"\";\n\n          onLoad({\n            network: NETWORK_ZKEVM,\n            assets: [\n              \"0xa8ce8aee21bc2a48a5ef670afcc9274c7bbbc035\", // USDC\n              \"0x4f9a0e7fd2bf6067db6994cf12e4495df938e6e9\", // WETH\n              \"0x1E4a5963aBFD975d8c9021ce480b42188849D41d\", // USDT\n            ],\n            coingeckoNetworkHandle: \"polygon-zkevm\",\n            inputAssetTokenId: \"0xa8ce8aee21bc2a48a5ef670afcc9274c7bbbc035\",\n            outputAssetTokenId: \"0x4f9a0e7fd2bf6067db6994cf12e4495df938e6e9\",\n            routerContract: \"0x678Aa4bF4E210cf2166753e054d5b7c31cc7fa86\", // PancakeMixedRouteQuoterV1ABI\n            dexName: \"Pancake Swap\",\n            erc20Abi: state.erc20Abi,\n            routerAbi: state.routerAbi,\n            callTx: callTxPancakeZKEVM2,\n            callTokenApproval: callTokenApprovalEVM,\n          });\n\n          State.update({ loadComplete: true });\n        } else {\n          onLoad({\n            network: NETWORK_ZKEVM,\n          });\n          State.update({ loadComplete: true });\n        }\n      } else {\n        // not supported evm chain\n        onLoad(NearData);\n        State.update({ loadComplete: true });\n      }\n    });\n} else {\n  // ethers not supported on this gateway\n  onLoad(NearData);\n  State.update({ loadComplete: true });\n}\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/zavodil.near/widget/DexData3", "fact_widget_deployments_id": "b212b06b461ecff9011ba9631e85dfd0", "inserted_timestamp": "2023-10-17T21:20:16.198Z", "modified_timestamp": "2023-10-17T21:20:16.198Z", "__row_index": 1}