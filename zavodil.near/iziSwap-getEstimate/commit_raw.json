{"tx_hash": "8bAgef7bTP44Jo6uNEcGebPU2F9RFyZTfHMiMAWVhZ2M", "action_id_social": "8eJ6We5yjikykbBTLD49kbj9hBuNZnhHWSKaFBKxLJjc-0-widget", "block_id": 100597724, "block_timestamp": "2023-09-07T15:24:55.696Z", "signer_id": "zavodil.near", "widget_name": "iziSwap-getEstimate", "source_code": "const {\n  tokenIn,\n  tokenOut,\n  amountIn,\n  tokenInDecimals,\n  tokenOutDecimals,\n  loadRes,\n} = props;\n\nState.init({ res: { tokenIn, tokenOut, amountIn } });\n\nconst middlePool =\n  props.middlePool ?? \"0x201EBa5CC46D216Ce6DC03F6a759e8E766e956aE\";\n\nconst useMiddlePool = tokenIn !== middlePool && tokenOut !== middlePool;\n\nconst WMNT = \"0x78c1b0c915c4faa5fffa6cabf0219da63d7f4cb8\";\nconst MNT = \"0xdeaddeaddeaddeaddeaddeaddeaddeaddead0000\";\n\nif (tokenIn == MNT) {\n  tokenIn = WMNT;\n}\n\nif (tokenOut == MNT) {\n  tokenOut = WMNT;\n}\n\nconst optionDirectSwap = {\n  name: \"directSwap\",\n  path: [tokenIn, tokenOut],\n};\n\nconst optionMiddlePoolSwap = {\n  name: \"middlePoolSwap\",\n  path: [tokenIn, middlePool, tokenOut],\n};\n\nconst swapOptions = useMiddlePool\n  ? [optionMiddlePoolSwap, optionDirectSwap]\n  : [optionDirectSwap];\n\nif (state.res.amountIn !== amountIn) {\n  const resetObject = { amountIn };\n  swapOptions.map((option) => (resetObject[option.name] = undefined));\n\n  console.log(\"reset\", resetObject);\n  State.update({\n    res: Object.assign(state.res ?? {}, resetObject),\n  });\n}\n\nconst quoterContractId =\n  props.quoterContractId ?? \"0x032b241De86a8660f1Ae0691a4760B426EA246d7\";\nconst sqrtPriceLimitX96 = props.sqrtPriceLimitX96 ?? 0;\n\nconst quoterABI =\n  props.quoterABI ??\n  \"https://gist.githubusercontent.com/zavodil/d20c267e2f1318f76fdee1a9ce000ac6/raw/2eb1c452e171b6665c353812c268acf7319cf7ca/iziSwap-quoter.txt\";\n\nconst quoterContractJson = fetch(quoterABI);\nif (!quoterContractJson.ok) {\n  return \"\";\n}\n\nconst encodePath = (path, fees) => {\n  if (path.length != fees.length + 1) {\n    throw new Error(\"path/fee lengths do not match\");\n  }\n\n  let encoded = \"0x\";\n  for (let i = 0; i < fees.length; i++) {\n    // 20 byte encoding of the address\n    encoded += path[i].slice(2);\n    // 3 byte encoding of the fee\n    encoded += fees[i].toString(16).padStart(2 * FEE_SIZE, \"0\");\n  }\n  // encode the final token\n  encoded += path[path.length - 1].slice(2);\n\n  return encoded.toLowerCase();\n};\n\nconst getEstimate = (path, name) => {\n  console.log(\"path\", path);\n  const abi = JSON.parse(quoterContractJson.body);\n  const iface = new ethers.utils.Interface(abi);\n\n  // const fees = path.length == 2 ? [\"000064\"] : [\"0001f4\", \"000064\"];\n\n  //const pathBytes = encodePath(path, fees);\n  // console.log(\"pathBytes\", pathBytes);\n\n  console.log(\"iface\", iface);\n\n  const feeList = [100, 500, 3000, 10000];\n  feeList.map((fee) => {\n    console.log(\"check fee\", fee);\n    //const fee = 10000;\n    const tokenInAddress = path[0];\n    const tokenOutAddress = path[path.length - 1];\n    const isX2Y = tokenInAddress.toLowerCase() < tokenOutAddress.toLowerCase();\n    const boundaryPt = isX2Y ? -799999 : 799999;\n    const amountHex = ethers.utils.parseUnits(amountIn, tokenInDecimals);\n    console.log(\"amountIn\", amountIn, amountHex);\n    const inputs = isX2Y\n      ? [tokenInAddress, tokenOutAddress, fee, amountHex, boundaryPt]\n      : [tokenOutAddress, tokenInAddress, fee, amountHex, boundaryPt];\n    const method = isX2Y ? \"swapX2Y\" : \"swapY2X\";\n    console.log(\"inputs: \", inputs, method);\n    const encodedData = iface.encodeFunctionData(method, inputs);\n    console.log(\"encodedData: \", encodedData);\n    console.log(\"quoterContractId: \", quoterContractId);\n\n    return Ethers.provider()\n      .call({\n        to: quoterContractId,\n        data: encodedData,\n      })\n      .then((data) => {\n        console.log(\"data\", data);\n        const res = iface.decodeFunctionResult(method, data);\n        console.log(\"resdata: \", res);\n\n        const amountName = isX2Y ? \"amountY\" : \"amountX\";\n\n        const rawAmountOut = Big(Number(res[amountName]._hex)).toFixed();\n        const estimate = new Big(rawAmountOut)\n          .div(Big(10).pow(tokenOutDecimals))\n          .toFixed();\n\n        console.log(\n          \"estimate\",\n          estimate,\n          state.res[name]?.estimate,\n          \"fee\",\n          fee\n        );\n        if (\n          parseFloat(estimate) > parseFloat(state.res[name]?.estimate ?? \"0\")\n        ) {\n          State.update({\n            res: Object.assign(state.res ?? {}, {\n              [name]: { estimate, path, fee },\n            }),\n          });\n        }\n      })\n      .catch((e) => {\n        console.log(e);\n      });\n  });\n  /*\n  const inputs = [pathBytes, amountIn];\n\n  const encodedData = iface.encodeFunctionData(\"quoteExactInput\", inputs);\n\n  Ethers.provider()\n    .call({\n      to: quoterContractId,\n      data: encodedData,\n    })\n    .then((data) => {\n      console.log(\"data\", data);\n      const decodedData = iface.decodeFunctionResult(\"quoteExactInput\", data);\n\n      // decodedData = [amountOut, fee]\n      const amountOut = decodedData[0];\n      const fee = decodedData[1];\n\n      const estimate = Big(amountOut.toString())\n        .div(Big(10).pow(tokenOutDecimals))\n        .toFixed(18);\n\n      console.log(\"estimate\", estimate);\n      State.update({\n        res: Object.assign(state.res ?? {}, {\n          [name]: { estimate, path, fee },\n        }),\n      });\n    });*/\n};\n\nswapOptions.map((option) => {\n  if (state.res[option.name] === undefined) {\n    getEstimate(option.path, option.name);\n  }\n});\n\nconst allDataReceived = swapOptions.reduce(\n  (accumulator, option) => accumulator && state.res[option.name] !== undefined,\n  true\n);\n\nif (state.res !== undefined && allDataReceived) {\n  if (props.debug) {\n    console.log(\"res\", state.res);\n    if (typeof loadRes !== \"function\") {\n      loadRes = (res) => {\n        return <div>{JSON.stringify(res)}</div>;\n      };\n    }\n  }\n\n  if (typeof loadRes === \"function\") {\n    let res = state.res;\n\n    res.estimate = 0;\n    res.path = \"\";\n\n    swapOptions.map((option) => {\n      let estimate = parseFloat(state.res[option.name].estimate);\n      if (res.estimate < estimate) {\n        res.estimate = estimate;\n        res.path = state.res[option.name].path;\n        res.fee = state.res[option.name].fee;\n      }\n    });\n\n    return loadRes(res);\n  }\n}\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/zavodil.near/widget/iziSwap-getEstimate", "fact_widget_deployments_id": "91d8ac3c09c2099376bdbb5e59024550", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 0}