{"tx_hash": "EbCXVJy9PSYv5ohaxuLF3kHjCtnpEbUkGLGg7HuwGaXn", "action_id_social": "4yVko94LvgjqwqL3QvarrxVPRksNP5DrpCLTg6fDVtNh-0-widget", "block_id": 99952354, "block_timestamp": "2023-08-29T20:32:32.233Z", "signer_id": "zavodil.near", "widget_name": "mantle-getEstimate", "source_code": "const { tokenIn, tokenOut, amountIn, tokenOutDecimals, loadRes } = props;\n\nState.init({ res: { tokenIn, tokenOut, amountIn } });\n\nconst middlePool =\n  props.middlePool ?? \"0x201EBa5CC46D216Ce6DC03F6a759e8E766e956aE\";\n\nconst useMiddlePool = tokenIn !== middlePool && tokenOut !== middlePool;\n\nconst WMNT = \"0x78c1b0c915c4faa5fffa6cabf0219da63d7f4cb8\";\nconst MNT = \"0xdeaddeaddeaddeaddeaddeaddeaddeaddead0000\";\n\nif (tokenIn == MNT) {\n  tokenIn = WMNT;\n}\n\nif (tokenOut == MNT) {\n  tokenOut = WMNT;\n}\n\nconst optionDirectSwap = {\n  name: \"directSwap\",\n  path: [tokenIn, tokenOut],\n};\n\nconst optionMiddlePoolSwap = {\n  name: \"middlePoolSwap\",\n  path: [tokenIn, middlePool, tokenOut],\n};\n\nconst swapOptions = useMiddlePool\n  ? [optionMiddlePoolSwap, optionDirectSwap]\n  : [optionDirectSwap];\n\nif (state.res.amountIn !== amountIn) {\n  const resetObject = { amountIn };\n  swapOptions.map((option) => (resetObject[option.name] = undefined));\n\n  console.log(\"resetObject\", resetObject);\n  State.update({\n    res: Object.assign(state.res ?? {}, resetObject),\n  });\n}\n\nconst quoterContractId =\n  props.quoterContractId ?? \"0x9488C05a7b75a6FefdcAE4f11a33467bcBA60177\";\nconst sqrtPriceLimitX96 = props.sqrtPriceLimitX96 ?? 0;\n\nconst quoterABI =\n  props.quoterABI ??\n  \"https://gist.githubusercontent.com/zavodil/a9f97cdace5b2050e0895ae9ff4a0d03/raw/9bbd537c5d5a73f179ef31d3a62f09beb87cc198/Quoter.Agni.json\";\n\nconst quoterContractJson = fetch(quoterABI);\nif (!quoterContractJson.ok) {\n  return \"\";\n}\n\nconst encodePath = (path, fees) => {\n  if (path.length != fees.length + 1) {\n    throw new Error(\"path/fee lengths do not match\");\n  }\n\n  let encoded = \"0x\";\n  for (let i = 0; i < fees.length; i++) {\n    // 20 byte encoding of the address\n    encoded += path[i].slice(2);\n    // 3 byte encoding of the fee\n    encoded += fees[i].toString(16).padStart(2 * FEE_SIZE, \"0\");\n  }\n  // encode the final token\n  encoded += path[path.length - 1].slice(2);\n\n  return encoded.toLowerCase();\n};\n\nconst getEstimate = (path, name) => {\n  console.log(\"path\", path);\n  const abi = JSON.parse(quoterContractJson.body);\n  const iface = new ethers.utils.Interface(abi);\n\n  const fees = path.length == 2 ? [\"000064\"] : [\"0001f4\", \"000064\"];\n\n  const pathBytes = encodePath(path, fees);\n  console.log(\"pathBytes\", pathBytes);\n\n  const inputs = [pathBytes, amountIn];\n\n  const encodedData = iface.encodeFunctionData(\"quoteExactInput\", inputs);\n\n  Ethers.provider()\n    .call({\n      to: quoterContractId,\n      data: encodedData,\n    })\n    .then((data) => {\n      console.log(\"data\", data);\n      const decodedData = iface.decodeFunctionResult(\"quoteExactInput\", data);\n\n      // decodedData = [amountOut, fee]\n      const amountOut = decodedData[0];\n      const fee = decodedData[1];\n\n      const estimate = Big(amountOut.toString())\n        .div(Big(10).pow(tokenOutDecimals))\n        .toFixed(18);\n\n      console.log(\"estimate\", estimate);\n      State.update({\n        res: Object.assign(state.res ?? {}, {\n          [name]: { estimate, path, fee },\n        }),\n      });\n    });\n};\n\nswapOptions.map((option) => {\n  if (state.res[option.name] === undefined) {\n    getEstimate(option.path, option.name);\n  }\n});\n\nconst allDataReceived = swapOptions.reduce(\n  (accumulator, option) => accumulator && state.res[option.name] !== undefined,\n  true\n);\n\nif (state.res !== undefined && allDataReceived) {\n  if (props.debug) {\n    console.log(\"res\", state.res);\n    if (typeof loadRes !== \"function\") {\n      loadRes = (res) => {\n        return <div>{JSON.stringify(res)}</div>;\n      };\n    }\n  }\n\n  if (typeof loadRes === \"function\") {\n    let res = state.res;\n\n    res.estimate = 0;\n    res.path = \"\";\n\n    swapOptions.map((option) => {\n      let estimate = parseFloat(state.res[option.name].estimate);\n      if (res.estimate < estimate) {\n        res.estimate = estimate;\n        res.path = state.res[option.name].path;\n        res.fee = state.res[option.name].fee;\n      }\n    });\n\n    return loadRes(res);\n  }\n}\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/zavodil.near/widget/mantle-getEstimate", "fact_widget_deployments_id": "6d36be1c3a071eb0aac5cc7786470ff3", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 0}