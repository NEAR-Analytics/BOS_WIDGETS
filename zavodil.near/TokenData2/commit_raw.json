{"tx_hash": "7JEyPZwwKBi9wpZAVyhX36pt8h1qjsXvJQDvQdb3F5NX", "action_id_social": "6cByUGXq69sEiSPKjk5ekkW9iCzHX5Y1H3WrMF8JcKoE-0-widget", "block_id": 103610486, "block_timestamp": "2023-10-17T21:21:18.360Z", "signer_id": "zavodil.near", "widget_name": "TokenData2", "source_code": "const { tokenId, coinGeckoTokenId, coingeckoNetworkHandle } = props;\n\nconst accountId = context.accountId;\nconst debug = props.debug ?? false;\n\nconst NETWORK_NEAR = \"NEAR\";\nconst NETWORK_ETH = \"ETH\";\nconst NETWORK_ZKSYNC = \"ZKSYNC\";\nconst NETWORK_ZKEVM = \"ZKEVM\";\nconst NETWORK_AURORA = \"AURORA\";\nconst NETWORK_POLYGON = \"POLYGON\";\nconst NETWORK_MANTLE = \"MANTLE\";\n\nconst network = props.network ?? NETWORK_NEAR;\nlet cacheTokenData = undefined;\n\nif ([NETWORK_MANTLE, NETWORK_ETH].includes(network)) {\n  const cachedData = fetch(\n    `https://raw.githubusercontent.com/zavodil/near-nft-owners-list/main/${network.toLowerCase()}.json`\n  );\n  if (cachedData.ok) {\n    const cache = JSON.parse(cachedData.body);\n    const cacheDate = new Date(cache.timestamp);\n    const timeDifference = Date.now() - cacheDate.getTime();\n    if (timeDifference <= 30 * 60 * 1000 /* 30 min  cache */) {\n      if (!cacheTokenData) {\n        console.log(\n          \"cache was loaded, timestamp\",\n          cacheDate.toLocaleTimeString()\n        );\n      }\n      cacheTokenData = cache.data;\n    }\n  }\n}\n\nif (!tokenId) return;\n\nif (\n  state.balance !== null &&\n  state.balance !== undefined &&\n  state.metadata !== undefined &&\n  state.price !== undefined\n) {\n  const res = {\n    balance: state.balance,\n    balance_hr: new Big(state?.balance ?? 0)\n      .div(new Big(10).pow(state?.metadata?.decimals ?? 1))\n      .toFixed(4),\n    balance_hr_full: new Big(state?.balance ?? 0)\n      .div(new Big(10).pow(state?.metadata?.decimals ?? 1))\n      .toFixed(),\n    price: state.price,\n    metadata: state.metadata,\n  };\n\n  if (typeof props.onLoad === \"function\") {\n    props.onLoad(res);\n  }\n\n  return debug ? <>Debug: {JSON.stringify(res)}</> : <div />;\n}\n\n// HELPER METHODS FOR NETWORKS\n\n// NEAR **************\n\nconst NEAR_LOGO = `data:image/svg+xml,%3Csvg width='35' height='35' fill='none' xmlns='http://www.w3.org/2000/svg' class='MuiSvgIcon-root MuiSvgIcon-fontSizeMedium css-vubbuv' focusable='false' aria-hidden='true' viewBox='0 0 35 35' style='width: 35px; height: 35px; filter: invert(100%25);'%3E%3Ccircle cx='17.5' cy='17.5' r='17.5' fill='%23fff'%3E%3C/circle%3E%3Cpath d='m24.027 9.022-4.174 6.2c-.288.422.267.934.666.578l4.107-3.578c.111-.089.266-.022.266.134v11.177c0 .156-.2.223-.288.111L12.174 8.756A2.053 2.053 0 0 0 10.552 8h-.444C8.954 8 8 8.956 8 10.133v15.734C8 27.044 8.954 28 10.131 28a2.14 2.14 0 0 0 1.82-1.022l4.173-6.2c.289-.422-.266-.934-.666-.578l-4.106 3.556c-.111.088-.267.022-.267-.134V12.467c0-.156.2-.223.289-.111l12.43 14.888c.4.49 1 .756 1.621.756h.444A2.133 2.133 0 0 0 28 25.867V10.133A2.133 2.133 0 0 0 25.869 8a2.15 2.15 0 0 0-1.842 1.022Z' fill='%23000'%3E%3C/path%3E%3C/svg%3E`;\n\nconst getNearNativeBalance = () => {\n  const account = fetch(\"https://rpc.mainnet.near.org\", {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({\n      jsonrpc: \"2.0\",\n      id: \"dontcare\",\n      method: \"query\",\n      params: {\n        request_type: \"view_account\",\n        finality: \"final\",\n        account_id: accountId,\n      },\n    }),\n  });\n  if (!account) return;\n  else return account?.body?.result?.amount;\n};\n\nconst getRefPrice = (tokenId) => {\n  const refPricesResponse = fetch(\n    \"https://indexer.ref.finance/list-token-price\"\n  );\n  if (!refPricesResponse) return 0;\n  const refPrices = JSON.parse(refPricesResponse.body);\n  return parseFloat(refPrices?.[tokenId]?.price ?? 0);\n};\n\n// ETH *******************************\nconst getErc20Balance = (tokenId, receiver) => {\n  const iface = new ethers.utils.Interface(state.erc20Abi);\n\n  // find out token balance\n  const encodedBalanceData = iface.encodeFunctionData(\"balanceOf\", [receiver]);\n\n  Ethers.provider()\n    .call({\n      to: tokenId,\n      data: encodedBalanceData,\n    })\n    .then((rawBalance) => {\n      const receiverBalanceHex = iface.decodeFunctionResult(\n        \"balanceOf\",\n        rawBalance\n      );\n\n      State.update({\n        balance: Big(receiverBalanceHex).toFixed(),\n      });\n    });\n};\n\nconst getErc20Tokendata = (tokenId) => {\n  if (cacheTokenData) {\n    const metadata = cacheTokenData?.[tokenId.toLowerCase()]?.metadata;\n    const price = cacheTokenData?.[tokenId.toLowerCase()]?.price;\n    if (\n      price > 0 &&\n      metadata.name &&\n      metadata.symbol &&\n      metadata.icon &&\n      metadata.decimals\n    ) {\n      console.log(\n        \"cache used for tokenId \",\n        tokenId,\n        \"metadata\",\n        metadata,\n        \"price\",\n        price\n      );\n      return State.update({ metadata, price });\n    }\n  }\n\n  let dataUrl = `https://api.coingecko.com/api/v3/coins/${\n    coingeckoNetworkHandle ?? \"ethereum\"\n  }/contract/${tokenId}`;\n\n  const data = fetch(dataUrl);\n  if (!data.ok) {\n    return \"\";\n  }\n\n  const tokenData = data.body;\n  console.log(\"tokenData\", tokenData);\n\n  const metadata = {\n    name: tokenData.name,\n    symbol: tokenData.symbol,\n    icon: tokenData.image.small,\n    decimals:\n      tokenData.detail_platforms[coingeckoNetworkHandle ?? \"ethereum\"]\n        .decimal_place,\n  };\n\n  const price = Number(tokenData.market_data.current_price.usd);\n\n  State.update({ metadata, price });\n};\n\n// DATA CONNECTOR *******************\n\nswitch (network) {\n  case NETWORK_NEAR: {\n    let balance, metadata, price;\n    if (tokenId === \"NEAR\") {\n      metadata = {\n        name: \"NEAR\",\n        symbol: \"NEAR\",\n        icon: NEAR_LOGO,\n        decimals: 24,\n      };\n\n      // NATIVE NEAR BALANCE\n      balance = getNearNativeBalance();\n\n      // REF PRICE\n      price = getRefPrice(\"wrap.near\");\n    } else {\n      // FT METADATA\n      metadata = Near.view(tokenId, \"ft_metadata\");\n      if (!metadata) return;\n      metadata.icon = metadata.icon ?? NEAR_LOGO;\n\n      // FT BALANCE\n      balance = Near.view(tokenId, \"ft_balance_of\", {\n        account_id: accountId,\n      });\n\n      // REF PRICE\n      price = getRefPrice(tokenId);\n    }\n    State.update({\n      balance,\n      metadata,\n      price,\n    });\n\n    break;\n  }\n  case NETWORK_ETH:\n  case NETWORK_ZKSYNC:\n  case NETWORK_AURORA:\n  case NETWORK_ZKEVM:\n  case NETWORK_POLYGON:\n  case NETWORK_MANTLE: {\n    if (state.ethAccountId === undefined) {\n      const accounts = Ethers.send(\"eth_requestAccounts\", []);\n      if (accounts.length) {\n        State.update({ ethAccountId: accounts[0] });\n      }\n    }\n\n    if (state.erc20Abi === undefined) {\n      const erc20Abi = fetch(\n        \"https://gist.githubusercontent.com/veox/8800debbf56e24718f9f483e1e40c35c/raw/f853187315486225002ba56e5283c1dba0556e6f/erc20.abi.json\"\n      );\n      if (!erc20Abi.ok) {\n        return \"\";\n      }\n\n      State.update({ erc20Abi: erc20Abi.body });\n    }\n\n    let tokenIdForCoingeckoAPI =\n      !!coingeckoNetworkHandle || !coingeckoNetworkHandle\n        ? tokenId\n        : coinGeckoTokenId;\n\n    // LOAD TOKEN METADATA & PRICE\n    getErc20Tokendata(tokenIdForCoingeckoAPI);\n\n    // LOAD TOKEN BALANCE\n    if (state.ethAccountId && state.erc20Abi && state.metadata?.decimals) {\n      getErc20Balance(tokenId, state.ethAccountId);\n    }\n\n    break;\n  }\n}\n\nreturn <div />;\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/zavodil.near/widget/TokenData2", "fact_widget_deployments_id": "9b7657d6fa501f5a0c1625f4e3f5ba95", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 0}