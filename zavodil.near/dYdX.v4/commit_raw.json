{"tx_hash": "3XjXr3cnuDTTSrk6uYWvnSYGUNnzZqGRHhz3Fiqpu1JN", "action_id_social": "3HMk1fXJkoAMn15MdXZqV6GWGwr8KTMtGW8tYcqr2tpm-0-widget", "block_id": 107366198, "block_timestamp": "2023-12-07T14:47:47.081Z", "signer_id": "zavodil.near", "widget_name": "dYdX.v4", "source_code": "const etherProviderEnabled = !!Ethers?.provider();\n\nif (etherProviderEnabled) {\n  Ethers.provider()\n    .send(\"eth_chainId\", [])\n    .then((chainId) => {\n      chainId = parseInt(chainId, 16);\n      if (state.chainId !== chainId) {\n        console.log(\"Set chainId\", chainId);\n        State.update({ chainId });\n      }\n    });\n\n  Ethers.provider()\n    .send(\"eth_requestAccounts\", [])\n    .then((accounts) => {\n      if (accounts.length && state.sender !== accounts[0]) {\n        console.log(\"Set sender\", accounts[0]);\n        State.update({ sender: accounts[0] });\n      }\n    });\n}\n\nif (!state.sender) {\n  return (\n    <div class=\"mb-3\">\n      <Web3Connect connectLabel=\"Connect Web3 Wallet to continue\" />\n    </div>\n  );\n}\n\nconst stripHexPrefix = (input) => {\n  if (input.indexOf(\"0x\") === 0) {\n    return input.slice(2);\n  }\n\n  return input;\n};\n\nconst exportMnemonicAndPrivateKey = (entropy, path) => {\n  const mnemonic = ethers.utils.entropyToMnemonic(entropy);\n  // console.log(\"mnemonic\", mnemonic);\n  const seed = ethers.utils.mnemonicToSeed(mnemonic);\n  const hdNode = ethers.utils.HDNode.fromSeed(seed);\n\n  return {\n    mnemonic,\n    privateKey: hdNode.privateKey,\n    publicKey: hdNode.publicKey,\n  };\n};\n\nconst deriveHDKeyFromEthereumSignature = (signature) => {\n  const buffer = Buffer.from(stripHexPrefix(signature), \"hex\");\n\n  if (buffer.length !== 65) {\n    throw new Error(\"Signature must be 65 bytes\");\n  }\n\n  // Remove the 'v' value by taking only the first 64 bytes of the signature\n  const rsValues = buffer.subarray(0, 64);\n  // Hash the 'r' and 's' values down to 32 bytes (256 bits) using Keccak-256\n  const entropy = ethers.utils.keccak256(rsValues);\n\n  return exportMnemonicAndPrivateKey(entropy);\n};\n\nconst getWalletFromEvmSignature = (signature) => {\n  console.log(signature);\n  const { mnemonic, privateKey, publicKey } =\n    deriveHDKeyFromEthereumSignature(signature);\n  console.log(\"deriveHDKeyFromEthereumSignature\", {\n    mnemonic,\n    privateKey,\n    publicKey,\n  });\n\n  DirectSecp256k1HdWallet.fromMnemonic(mnemonic, {\n    prefix: \"dydx\",\n  }).then((wallet) => {\n    let w = new DirectSecp256k1HdWallet(mnemonic, {\n      prefix: \"dydx\",\n      seed: wallet.seed,\n    });\n\n    w.getAccounts().then(([dydx_account]) => {\n      console.log(\"dYdX account derived\", dydx_account);\n      State.update({ dydx_account: dydx_account.address });\n    });\n  });\n};\n\nconst apiUrl = \"https://indexer.v4testnet.dydx.exchange/v4\";\nconst accountId = state.dydx_account;\nconst headers = {\n  Accept: \"application/json\",\n};\n\nconst loadAccount = () => {\n  asyncFetch(`${apiUrl}/addresses/${accountId}`, { headers }).then((r) =>\n    State.update({ account: r?.body?.subaccounts[0] })\n  );\n\n  asyncFetch(\n    `${apiUrl}/orders?address=${accountId}&subaccountNumber=0&limit=100`,\n    {\n      headers,\n    }\n  ).then((r) => State.update({ orders: r?.body }));\n};\n\nif (state.dydx_account == undefined) {\n  const toSign = {\n    domain: {\n      name: \"dYdX V4\",\n      chainId: 5,\n    },\n    primaryType: \"dYdX\",\n    types: {\n      dYdX: [{ name: \"action\", type: \"string\" }],\n    },\n    message: {\n      action: \"dYdX Chain Onboarding\",\n    },\n  };\n\n  /*getWalletFromEvmSignature(\n    \"0xb33020bc2b4c2be8cf28dd6fcaf06dc94f856cd85041ca34afc648c0a1a12298361d3c494404c1b7a6cdec71305c81da8ad318434dac6d9a706c500a650391fa1b\"\n  );*/\n\n  Ethers.provider()\n    .getSigner()\n    ._signTypedData(toSign.domain, { dYdX: toSign.types.dYdX }, toSign.message)\n    .then((signature) => getWalletFromEvmSignature(signature));\n} else {\n  useEffect(() => {\n    loadAccount();\n  }, [state.account, state.orders, state.nonce]);\n\n  return (\n    <div>\n      <ul>\n        <li>Address: {state.account.address}</li>\n        <li>Equity: {state.account.equity}</li>\n        <li>Free Collateral: {state.account.freeCollateral}</li>\n        <li>\n          Open Perpetual Positions:{\" \"}\n          {JSON.stringify(state.account.openPerpetualPositions)}\n        </li>\n\n        <li>\n          Orders:{\" \"}\n          <ol>\n            {(state.orders ?? []).map((order) => (\n              <li>\n                {order.side} {order.ticker} at {order.price}. Size: {order.size}\n                , filled: {order.totalFilled} . Updated: {order.updatedAt}\n                {/*JSON.stringify(order)*/}\n              </li>\n            ))}\n          </ol>\n        </li>\n      </ul>\n      <button\n        onClick={() => {\n          const nonce = state.nonce ?? 0;\n          State.update({ nonce: nonce + 1 });\n        }}\n      >\n        Refresh\n      </button>\n      <hr />\n      state:\n      {JSON.stringify(state)}\n    </div>\n  );\n}\n\nreturn (\n  <>\n    Ethereum Account: {state.sender}\n    <Web3Connect connectLabel=\"Connect Web3 Wallet to continue\" />\n  </>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/zavodil.near/widget/dYdX.v4", "fact_widget_deployments_id": "0c3f6ca10d262a83069183a57994162b", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 0}