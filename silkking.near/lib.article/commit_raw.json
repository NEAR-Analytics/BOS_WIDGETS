{"tx_hash": "GL66FTAxb8qVW26QrNBEdYuBQ5iLT2VQJasMgZ12Pc1a", "action_id_social": "2JspLD1ZeGGW3ZuK1TT4gumpntQdkgLSxHiqv5BBtTe4-0-widget", "block_id": 103765135, "block_timestamp": "2023-10-19T22:49:18.403Z", "signer_id": "silkking.near", "widget_name": "lib.article", "source_code": "const { isTest, stateUpdate, functionsToCallByLibrary, callLibs, baseAction } =\n  props;\nconst functionsToCall = functionsToCallByLibrary.article;\nconst libName = \"article\";\n\nlet resultFunctionsToCallByLibrary = Object.assign(\n  {},\n  functionsToCallByLibrary\n);\nlet resultFunctionsToCall = [];\n\nconst currentVersion = \"0.0.2\";\n\nconst prodAction = `${baseAction}_v${currentVersion}`;\nconst testAction = `test_${prodAction}`;\nconst action = isTest ? testAction : prodAction;\n\nconst libAuthor = \"silkking.near\";\n\nconst libSrcArray = [`${libAuthor}/widget/lib.SBT`]; // string to lib widget\n\n// interface FunctionCall {\n//     functionName: string,\n//     key: string, // The state of the caller will be updated with this string as a key\n//     props: Record<string, any> // function parameters as object\n// }\n\n// type LibsCalls = Record<string, FunctionCall> // Key is lib name after lib.\n\nconst libsCalls = {};\nlibSrcArray.forEach((libSrc) => {\n  const libName = libSrc.split(\"lib.\")[1];\n  libsCalls[libName] = [];\n});\n\nState.init({\n  libsCalls, // is a LibsCalls object\n});\n\nfunction log(message) {\n  console.log(`lib.${libName}`, message);\n}\n\nfunction logError(message) {\n  console.error(`lib.${libName}`, message);\n}\n\nfunction libStateUpdate(obj) {\n  State.update(obj);\n}\n\nfunction canUserCreateArticle(props) {\n  const { env, accountId, sbtsNames } = props;\n\n  setAreValidUsers([accountId], sbtsNames);\n  const result = state[`isValidUser-${accountId}`];\n\n  resultFunctionsToCall = resultFunctionsToCall.filter((call) => {\n    const discardCondition =\n      call.functionName === \"canUserCreateArticle\" && result !== undefined;\n    return !discardCondition;\n  });\n\n  return result;\n}\n\nfunction setAreValidUsers(accountIds, sbtsNames) {\n  const newLibsCalls = Object.assign({}, state.libsCalls);\n  if (!newLibsCalls.SBT) {\n    logError(\"Key SBT is not set in lib.\", libName);\n  }\n\n  accountIds.forEach((accountId) => {\n    const isCallPushed =\n      newLibsCalls.SBT.find((libCall) => {\n        return (\n          libCall.functionName === \"isValidUser\" &&\n          libCall.props.accountId === accountId\n        );\n      }) !== undefined;\n    const isCallReturned = state[`isValidUser-${accountId}`] !== undefined;\n\n    if (isCallPushed || isCallReturned) {\n      return;\n    }\n\n    newLibsCalls.SBT.push({\n      functionName: \"isValidUser\",\n      key: `isValidUser-${accountId}`,\n      props: {\n        accountId,\n        sbtsNames,\n      },\n    });\n  });\n  State.update({ libsCalls: newLibsCalls });\n}\n\nfunction createArticle(props) {\n  const { article, onCommit, onCancel } = props;\n\n  saveHandler(article, onCommit, onCancel);\n\n  resultFunctionsToCall = resultFunctionsToCall.filter((call) => {\n    return call.functionName !== \"createArticle\";\n  });\n\n  return article;\n}\n\nconst saveHandler = (article, onCommit, onCancel) => {\n  if (article.title && article.body) {\n    const newData = composeData(article);\n\n    Social.set(newData, {\n      force: true,\n      onCommit,\n      onCancel,\n    });\n  } else {\n    logError(\"Article is missing title or body\");\n  }\n};\n\nfunction composeData(article) {\n  let data;\n  data = {\n    [action]: {\n      main: JSON.stringify(article),\n    },\n    index: {\n      [action]: JSON.stringify({\n        key: \"main\",\n        value: {\n          type: \"md\",\n          id: article.id ?? `${context.accountId}-${Date.now()}`,\n        },\n      }),\n    },\n  };\n\n  return data;\n}\n\nfunction getArticleBlackListByBlockHeight() {\n  return [\n    91092435, 91092174, 91051228, 91092223, 91051203, 98372095, 96414482,\n    96412953, 103131250,\n  ];\n}\n\nfunction getArticleBlackListByRealArticleId() {\n  return [\n    \"blaze.near-1690410074090\",\n    \"blaze.near-1690409577184\",\n    \"blaze.near-1690803928696\",\n    \"blaze.near-1690803872147\",\n    \"blaze.near-1690574978421\",\n    \"f2bc8abdb8ba64fe5aac9689ded9491ff0e6fdcd7a5c680b7cf364142d1789fb-1691703303485\",\n    \"f2bc8abdb8ba64fe5aac9689ded9491ff0e6fdcd7a5c680b7cf364142d1789fb-1691702619510\",\n    \"f2bc8abdb8ba64fe5aac9689ded9491ff0e6fdcd7a5c680b7cf364142d1789fb-1691702487944\",\n    \"f2bc8abdb8ba64fe5aac9689ded9491ff0e6fdcd7a5c680b7cf364142d1789fb-1691707918243\",\n    \"f2bc8abdb8ba64fe5aac9689ded9491ff0e6fdcd7a5c680b7cf364142d1789fb-1691707889297\",\n  ];\n}\n\nfunction canUserEditArticle(props) {\n  const { article } = props;\n\n  return article.author === context.accountId;\n}\n\nfunction getArticlesIndexes(action) {\n  return Social.index(action, \"main\", {\n    order: \"desc\",\n    subscribe: true,\n  });\n}\n\nfunction getArticlesNormalized(env) {\n  const articlesByVersion = Object.keys(versions).map((version) => {\n    const action = versions[version].action;\n\n    const articlesIndexes = getArticlesIndexes(action);\n\n    const validArticlesIndexes = filterInvalidArticlesIndexes(\n      env,\n      articlesIndexes\n    );\n\n    const validLatestEdits = getLatestEdits(validArticlesIndexes);\n\n    const articles = validLatestEdits.map((article) => {\n      return getArticle(article, action);\n    });\n    return articles;\n  });\n\n  return normalizeArticles(articlesByVersion);\n}\n\nfunction getArticle(articleIndex, action) {\n  const article = Social.get(\n    `${articleIndex.accountId}/${action}/main`,\n    articleIndex.blockHeight\n  );\n\n  let articleParsed = undefined;\n  if (article) {\n    articleParsed = JSON.parse(article);\n    articleParsed.blockHeight = articleIndex.blockHeight;\n    articleParsed.id = articleIndex.value.id;\n  }\n\n  if (articleParsed) {\n    return articleParsed;\n  }\n}\n\nfunction getLatestEdits(newFormatArticlesIndexes) {\n  return newFormatArticlesIndexes.filter((articleIndex) => {\n    const latestEditForThisArticle = newFormatArticlesIndexes.find(\n      (newArticleData) => newArticleData.value.id === articleIndex.value.id\n    );\n    return (\n      JSON.stringify(articleIndex) === JSON.stringify(latestEditForThisArticle)\n    );\n  });\n}\n\nfunction filterInvalidArticlesIndexes(env, articlesIndexes) {\n  return articlesIndexes\n    .filter((articleIndex) => articleIndex.value.id) // Has id\n    .filter(\n      (articleIndex) =>\n        articleIndex.value.id.split(\"-\")[0] === articleIndex.accountId\n    ) // id begins with same accountId as index object\n    .filter(\n      (articleIndex) =>\n        !getArticleBlackListByBlockHeight().includes(articleIndex.blockHeight) // Blockheight is not in blacklist\n    )\n    .filter(\n      (articleIndex) =>\n        !getArticleBlackListByRealArticleId().includes(articleIndex.value.id) // Article id is not in blacklist\n    );\n}\n\nfunction getArticles(props) {\n  const { env, sbtsNames } = props;\n  // Call other libs\n  const normArticles = getArticlesNormalized(env);\n\n  // Keep last edit from every article\n  const lastEditionArticles = normArticles.filter((article) => {\n    return normArticles.find(\n      (compArticle) => JSON.stringify(compArticle) === JSON.stringify(article)\n    );\n  });\n\n  const lastEditionArticlesAuthors = lastEditionArticles.map((article) => {\n    return article.author;\n  });\n\n  setAreValidUsers(lastEditionArticlesAuthors, sbtsNames);\n\n  resultFunctionsToCall = resultFunctionsToCall.filter((call) => {\n    const discardCondition =\n      call.functionName === \"getArticles\" &&\n      state[`isValidUser-${call.props.accountId}`] !== undefined;\n    return !discardCondition;\n  });\n\n  const finalArticles = filterValidArticles(lastEditionArticles);\n  const finalArticlesMapped = {};\n  sbtsNames.forEach((sbtName) => {\n    const sbtArticles = finalArticles.filter((article) => {\n      if (!article.sbts) return false;\n      return article.sbts.indexOf(sbtName) !== -1;\n    });\n    finalArticlesMapped[sbtName] = sbtArticles;\n  });\n\n  return finalArticlesMapped;\n}\n\nfunction filterValidator(articles) {\n  return articles.filter((article) => {\n    return (\n      article.sbts.find((articleSbt) => {\n        return (\n          state[`isValidUser-${article.author}`][articleSbt] ||\n          articleSbt === \"public\"\n        );\n      }) !== undefined\n    );\n  });\n}\n\nfunction filterValidArticles(articles) {\n  let filteredArticles = filterValidator(filteredArticles ?? articles);\n\n  return filteredArticles;\n}\n\nfunction normalizeOldToV_0_0_1(article) {\n  article.realArticleId = `${article.author}-${article.timeCreate}`;\n  article.sbts = [\"public\"];\n\n  return article;\n}\n\nfunction normalizeFromV0_0_1ToV0_0_2(article) {\n  article.title = article.articleId;\n  article.id = article.realArticleId;\n  if (article.sbts[0] !== \"public\") {\n    article.sbts[0] = article.sbts[0] + \" - class 1\";\n  } // There is only one article that is not public and only has class 1\n\n  delete article.articleId;\n  delete article.realArticleId;\n\n  return article;\n}\n\nfunction normalizeFromV0_0_2ToV0_0_3(article) {\n  if (!Array.isArray(article.tags) && typeof article.tags === \"object\") {\n    article.tags = Object.keys(article.tags);\n  }\n  return article;\n}\n\nfunction normalizeArticles(articlesByVersion) {\n  let articles;\n\n  Object.keys(versions).forEach((version, index, array) => {\n    const normFn = versions[version].normalizationFunction;\n    const normArticles = articlesByVersion[index].map((article, i) => {\n      return normFn(article);\n    });\n\n    if (index + 1 === array.length) {\n      // Last index\n      articles = normArticles;\n      return;\n    }\n    articlesByVersion[index + 1] =\n      articlesByVersion[index + 1].concat(normArticles);\n  });\n\n  return articles;\n}\n\nconst versions = {\n  old: {\n    normalizationFunction: normalizeOldToV_0_0_1,\n    action: baseAction,\n  },\n  \"v0.0.1\": {\n    normalizationFunction: normalizeFromV0_0_1ToV0_0_2,\n    action: `${baseAction}_v0.0.1`,\n  },\n  \"v0.0.2\": {\n    normalizationFunction: normalizeFromV0_0_2ToV0_0_3,\n    action: `${baseAction}_v0.0.2`,\n  },\n};\n\nfunction callFunction(call) {\n  if (call.functionName === \"canUserCreateArticle\") {\n    return canUserCreateArticle(call.props);\n  } else if (call.functionName === \"createArticle\") {\n    return createArticle(call.props);\n  } else if (call.functionName === \"canUserEditArticle\") {\n    return canUserEditArticle(call.props);\n  } else if (call.functionName === \"getArticles\") {\n    return getArticles(call.props);\n  }\n}\n\nif (functionsToCall && functionsToCall.length > 0) {\n  const updateObj = Object.assign({}, functionsToCallByLibrary);\n  resultFunctionsToCall = [...functionsToCall];\n  functionsToCall.forEach((call) => {\n    updateObj[call.key] = callFunction(call);\n  });\n\n  resultFunctionsToCallByLibrary[libName] = resultFunctionsToCall;\n  updateObj.functionsToCallByLibrary = resultFunctionsToCallByLibrary;\n  stateUpdate(updateObj);\n}\n\nreturn (\n  <>\n    {libSrcArray.map((src) => {\n      return callLibs(\n        src,\n        libStateUpdate,\n        state.libsCalls,\n        {},\n        `lib.${libName}`\n      );\n    })}\n  </>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/silkking.near/widget/lib.article", "fact_widget_deployments_id": "c9f633a9497a971a4b5de0c958f7b67e", "inserted_timestamp": "2023-10-20T00:45:34.875Z", "modified_timestamp": "2023-10-20T00:45:34.875Z", "__row_index": 18}