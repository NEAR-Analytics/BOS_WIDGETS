{"tx_hash": "EgaDoqtR2Umj6NFUEikh8rAnXiXHz63fpiPdhQJGJMWA", "action_id_social": "89Ka4r2XaLGbUa5mMZGnFFbNM7JK4YXcUJWEghydVXD1-0-widget", "block_id": 103817197, "block_timestamp": "2023-10-20T16:36:02.493Z", "signer_id": "silkking.near", "widget_name": "lib.template", "source_code": "// HOW TO USE\r\n// Create the functions that you want. Then add the functions you want to 'export' inside the `callFunction` function\r\n\r\n// INTERFACES\r\n// interface FunctionCall {\r\n//     functionName: string,\r\n//     key: string, // The state of the caller will be updated with this string as a key\r\n//     props: Record<string, any> // function parameters as object\r\n// }\r\n\r\n// type LibsCalls = Record<string, FunctionCall> // Key is lib name after lib.\r\n\r\nconst { isTest, stateUpdate, functionsToCallByLibrary, callLibs } = props;\r\nconst functionsToCall = functionsToCallByLibrary.template; // Change this with the name of your widget\r\nconst libName = \"template\";\r\n\r\nlet resultFunctionsToCallByLibrary = Object.assign(\r\n  {},\r\n  functionsToCallByLibrary\r\n); // We make a copy of the functions we're going to call to clean it afterwards if needed, so it isn't called every time the caller gets updated.\r\nlet resultFunctionsToCall = []; // Util for resultFunctionsToCallByLibrary\r\n\r\nconst libSrcArray = []; // string to lib widget\r\n\r\nState.init({\r\n  libsCalls: {}, // is a LibsCalls object. It's used to call another library's functions\r\n});\r\n\r\nfunction log(message) {\r\n  console.log(`lib.${libName}`, message);\r\n}\r\n\r\nfunction logError(message) {\r\n  console.error(`lib.${libName}`, message);\r\n}\r\n\r\nfunction firstFunctionName(props) {\r\n  const { firstProp, secondProp } = props;\r\n  //Execute function\r\n  const saveValueToReturn = true;\r\n\r\n  resultFunctionsToCall = resultFunctionsToCall.filter((call) => {\r\n    return call.functionName !== \"firstFunctionName\";\r\n  });\r\n  return saveValueToReturn;\r\n}\r\n\r\nfunction secondFunctionName(props) {\r\n  const { firstProp, secondProp } = props;\r\n  //Execute function\r\n  const saveValueToReturn = true;\r\n\r\n  resultFunctionsToCall = resultFunctionsToCall.filter((call) => {\r\n    return call.functionName !== \"secondFunctionName\";\r\n  });\r\n  return saveValueToReturn;\r\n}\r\n\r\nfunction callFunction(call) {\r\n  if (call.functionName === \"firstFunctionName\") {\r\n    return firstFunctionName(call.props);\r\n  } else if (call.functionName === \"secondFunctionName\") {\r\n    return secondFunctionName(call.props);\r\n  }\r\n}\r\n\r\nif (functionsToCall && functionsToCall.length > 0) {\r\n  const updateObj = Object.assign({}, functionsToCallByLibrary);\r\n  resultFunctionsToCall = [...functionsToCall];\r\n  functionsToCall.forEach((call) => {\r\n    updateObj[call.key] = callFunction(call);\r\n  });\r\n\r\n  resultFunctionsToCallByLibrary[libName] = resultFunctionsToCall;\r\n  updateObj.functionsToCallByLibrary = resultFunctionsToCallByLibrary;\r\n  stateUpdate(updateObj);\r\n}\r\n\r\nreturn (\r\n  <>\r\n    {libSrcArray.map((src) => {\r\n      return callLibs(src, libStateUpdate, state.libsCalls, `lib.${libName}`);\r\n    })}\r\n  </>\r\n);\r\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/silkking.near/widget/lib.template", "fact_widget_deployments_id": "f92eb494cd2872a4e71fbd0c36f2a102", "inserted_timestamp": "2023-10-20T18:35:39.384Z", "modified_timestamp": "2023-10-20T18:35:39.384Z", "__row_index": 0}