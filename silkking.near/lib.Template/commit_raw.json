{"tx_hash": "72RCaAeiK8FnLGkbABXbqMr5x1CLZb2gsGFyU6paGjVA", "action_id_social": "8WG9B4jYhJbmstQWJr5pbsb9kftpYamC5565akk2Fy5p-0-widget", "block_id": 103742101, "block_timestamp": "2023-10-19T15:29:34.561Z", "signer_id": "silkking.near", "widget_name": "lib.Template", "source_code": "const { isTest, stateUpdate, functionsToCallByLibrary, callLibs } = props;\r\nconst functionsToCall = functionsToCallByLibrary.template; // Change this with the name of your widget\r\n\r\nlet resultFunctionsToCallByLibrary = Object.assign(\r\n  {},\r\n  functionsToCallByLibrary\r\n);\r\nlet resultFunctionsToCall = [];\r\n\r\nconst libSrcArray = []; // string to lib widget\r\n\r\n// interface FunctionCall {\r\n//     functionName: string,\r\n//     key: string, // The state of the caller will be updated with this string as a key\r\n//     props: Record<string, any> // function parameters as object\r\n// }\r\n\r\n// type LibsCalls = Record<string, FunctionCall> // Key is lib name after lib.\r\n\r\nState.init({\r\n  libsCalls: {}, // is a LibsCalls object\r\n});\r\n\r\nfunction firstFunctionName(props) {\r\n  const { firstProp, secondProp } = props;\r\n  //Execute function\r\n  const saveValueToReturn = true;\r\n\r\n  resultFunctionsToCall = resultFunctionsToCall.filter((call) => {\r\n    return call.functionName !== \"firstFunctionName\";\r\n  });\r\n  return saveValueToReturn;\r\n}\r\n\r\nfunction secondFunctionName(props) {\r\n  const { firstProp, secondProp } = props;\r\n  //Execute function\r\n  const saveValueToReturn = true;\r\n\r\n  resultFunctionsToCall = resultFunctionsToCall.filter((call) => {\r\n    return call.functionName !== \"secondFunctionName\";\r\n  });\r\n  return saveValueToReturn;\r\n}\r\n\r\nfunction callFunction(call) {\r\n  if (call.functionName === \"firstFunctionName\") {\r\n    return firstFunctionName(call.props);\r\n  } else if (call.functionName === \"secondFunctionName\") {\r\n    return secondFunctionName(call.props);\r\n  }\r\n}\r\n\r\nif (functionsToCall && functionsToCall.length > 0) {\r\n  const updateObj = Object.assign({}, functionsToCallByLibrary);\r\n  resultFunctionsToCall = [...functionsToCall];\r\n  functionsToCall.forEach((call) => {\r\n    updateObj[call.key] = callFunction(call);\r\n  });\r\n\r\n  resultFunctionsToCallByLibrary.template = resultFunctionsToCall;\r\n  updateObj.functionsToCallByLibrary = resultFunctionsToCallByLibrary;\r\n  stateUpdate(updateObj);\r\n}\r\n\r\nreturn (\r\n  <>\r\n    <>\r\n      {libSrcArray.map((src) => {\r\n        return callLibs(src, libStateUpdate, state.libsCalls, \"lib.template\");\r\n      })}\r\n    </>\r\n  </>\r\n);\r\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/silkking.near/widget/lib.Template", "fact_widget_deployments_id": "c33dfaec045b1070c2e00bcaa1c02d14", "inserted_timestamp": "2023-10-19T17:30:19.094Z", "modified_timestamp": "2023-10-19T17:30:19.094Z", "__row_index": 0}