{"tx_hash": "3S66XHJymnt2utSKVeGc27vCbydWz2YDG3fzoQ7gc5L8", "action_id_social": "HKiULpov3ZijtyVxFEDPjBEP9boaGVFPgZarvEfdfgJ2-0-widget", "block_id": 103742474, "block_timestamp": "2023-10-19T15:37:02.311Z", "signer_id": "silkking.near", "widget_name": "lib.Template", "source_code": "// HOW TO USE\n// Create the functions that you want. Then add the functions you want to 'export' inside the `callFunction` function\n\n// INTERFACES\n// interface FunctionCall {\n//     functionName: string,\n//     key: string, // The state of the caller will be updated with this string as a key\n//     props: Record<string, any> // function parameters as object\n// }\n\n// type LibsCalls = Record<string, FunctionCall> // Key is lib name after lib.\n\nconst { isTest, stateUpdate, functionsToCallByLibrary, callLibs } = props;\nconst functionsToCall = functionsToCallByLibrary.template; // Change this with the name of your widget\n\nlet resultFunctionsToCallByLibrary = Object.assign(\n  {},\n  functionsToCallByLibrary\n); // We make a copy of the functions we're going to call to clean it afterwards if needed, so it isn't called every time the caller gets updated.\nlet resultFunctionsToCall = []; // Util for resultFunctionsToCallByLibrary\n\nconst libSrcArray = []; // string to lib widget\n\nState.init({\n  libsCalls: {}, // is a LibsCalls object. It's used to call another library's functions\n});\n\nfunction firstFunctionName(props) {\n  const { firstProp, secondProp } = props;\n  //Execute function\n  const saveValueToReturn = true;\n\n  resultFunctionsToCall = resultFunctionsToCall.filter((call) => {\n    return call.functionName !== \"firstFunctionName\";\n  });\n  return saveValueToReturn;\n}\n\nfunction secondFunctionName(props) {\n  const { firstProp, secondProp } = props;\n  //Execute function\n  const saveValueToReturn = true;\n\n  resultFunctionsToCall = resultFunctionsToCall.filter((call) => {\n    return call.functionName !== \"secondFunctionName\";\n  });\n  return saveValueToReturn;\n}\n\nfunction callFunction(call) {\n  if (call.functionName === \"firstFunctionName\") {\n    return firstFunctionName(call.props);\n  } else if (call.functionName === \"secondFunctionName\") {\n    return secondFunctionName(call.props);\n  }\n}\n\nif (functionsToCall && functionsToCall.length > 0) {\n  const updateObj = Object.assign({}, functionsToCallByLibrary);\n  resultFunctionsToCall = [...functionsToCall];\n  functionsToCall.forEach((call) => {\n    updateObj[call.key] = callFunction(call);\n  });\n\n  resultFunctionsToCallByLibrary.template = resultFunctionsToCall;\n  updateObj.functionsToCallByLibrary = resultFunctionsToCallByLibrary;\n  stateUpdate(updateObj);\n}\n\nreturn (\n  <>\n    <>\n      {libSrcArray.map((src) => {\n        return callLibs(src, libStateUpdate, state.libsCalls, \"lib.template\");\n      })}\n    </>\n  </>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/silkking.near/widget/lib.Template", "fact_widget_deployments_id": "f6d35331be7151cab114d19f03670a2c", "inserted_timestamp": "2023-10-19T17:35:34.698Z", "modified_timestamp": "2023-10-19T17:35:34.698Z", "__row_index": 1}