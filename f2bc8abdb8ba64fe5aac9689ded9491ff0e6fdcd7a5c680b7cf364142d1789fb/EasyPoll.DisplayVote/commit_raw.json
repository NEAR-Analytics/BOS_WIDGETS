{"tx_hash": "Cyayqs3LAx8beWzeWqD2DxwHN54gER3M9pPLinJKEdNG", "action_id_social": "CiS5RDABKscQVPeMSi5PLuck8GtTfXu36uQth1rRoar9-0-widget", "block_id": 94258496, "block_timestamp": "2023-06-15T19:10:31.918Z", "signer_id": "f2bc8abdb8ba64fe5aac9689ded9491ff0e6fdcd7a5c680b7cf364142d1789fb", "widget_name": "EasyPoll.DisplayVote", "source_code": "let isPreview = props.isPreview ?? false;\nlet poll = props.poll ?? {\n  accountId: \"neardigitalcollective.near\",\n  blockHeight: 94242300,\n  value: {\n    isDraft: false,\n    title: \"OG Criteria Poll\",\n    description:\n      \"Greetings! We're thrilled to welcome you to this significant discussion on the role and qualifications of an OG in the NEAR Digital Collective.\\nUnderstanding the 'OG' role, in our community context, is crucial as it impacts our collective's governance and development. We're looking at defining the criteria for an OG, discussing their level of activity, and considering a proposal that only OG's with an SBT should run for NDC V1 Gov.\\n\\nWe highly value your perspective. Regardless if you're a long-time member or a recent addition to our community, your opinion matters greatly. Your input enriches our collective decision-making and ensures our decisions truly reflect the community's voice.\\nThank you for participating in this discussion and contributing to the future direction of the NEAR Digital Collective. \\n\\nRemember, your responses are invaluable to us, and we thank you for taking the time to participate in this poll. Your voice matters to us and helps shape the future direction of the NEAR Digital Collective. Thank you for your contribution!\",\n    tgLink: \"\",\n    startTimestamp: 1686837600000,\n    endTimestamp: 1688047200000,\n    questions: [\n      {\n        question:\n          \"The GWG has proposed specific criteria for what qualifies as an OG you only need to fit one of the criteria to qualify. How much do you agree or disagree with these criteria ? 1. Champion/Contributor to GWG/NDC Gov (Anyone that received a 2022 Q4, 2023 Q1, or Q2 Gig/Bounty Reward)  2. NEAR Inc or NF member (before Pagoda Rebrand Feb \u201822) and is still a current member  3. Active in NEAR Community for 1.5 years before the election\",\n        questionType: \"1\",\n        choicesOptions: [\n          \"Strongly Agree\",\n          \"Agree\",\n          \"Neutral\",\n          \"Disagree\",\n          \"Strongly Disagree \",\n        ],\n      },\n      {\n        question:\n          \"Could you explain why you feel this way about the proposed criteria for an OG?\",\n        questionType: \"3\",\n        choicesOptions: [],\n      },\n      {\n        question:\n          \"The OG criteria was a guardrail made by the GWG to ensure only people that are well informed and knowledgeable in the ecosystem can run for the governing bodies. How much do you agree or disagree with the proposal by the GWG that only qualified OG's with an SBT should be eligible to run for NDC V1 Gov instead of people from other chains that aren\u2019t knowledgeable about NEAR.?\",\n        questionType: \"1\",\n        choicesOptions: [\n          \"Strongly Agree\",\n          \"Agree\",\n          \"Neutral\",\n          \"Disagree\",\n          \"Strongly Disagree\",\n        ],\n      },\n      {\n        question:\n          \"What are your reasons for agreeing or disagreeing with this proposal above?\",\n        questionType: \"3\",\n        choicesOptions: [],\n      },\n      {\n        question:\n          \"In your opinion, what should be the minimum level of on-chain activity over the past 6 months required for an OG to be considered active when the market slowed down?\",\n        questionType: \"1\",\n        choicesOptions: [\n          \"No minimum requirement\",\n          \"Low level of activity (1 transaction per 6 months)\",\n          \"Moderate level of activity (1 transaction per 3 months)\",\n          \"High level of activity (1 transaction per month)\",\n          \"Very high level of activity (1 transaction per week)\",\n        ],\n      },\n      {\n        question:\n          \"Could you share your thoughts on why you believe this level of activity is appropriate for an OG? Additionally, how would you quantify this level of activity?\u201d\",\n        questionType: \"3\",\n        choicesOptions: [],\n      },\n      {\n        question:\n          \"What do you believe should be the duration of an OG SBT before it expires?\",\n        questionType: \"1\",\n        choicesOptions: [\n          \"1 year\",\n          \"1.5 years\",\n          \"2 years\",\n          \"Other (please specify in the question below)\",\n        ],\n      },\n      {\n        question:\n          \"Could you explain your reasons for choosing this duration for an OG SBT?\",\n        questionType: \"3\",\n        choicesOptions: [],\n      },\n    ],\n    timestamp: 1686834874377,\n  },\n};\n\nlet whitelist = props.whitelist ?? [\n  \"neardigitalcollective.near\",\n  \"blaze.near\",\n  \"jlw.near\",\n  \"joep.near\",\n  \"sarahkornfeld.near\",\n  \"yuensid.near\",\n  \"f2bc8abdb8ba64fe5aac9689ded9491ff0e6fdcd7a5c680b7cf364142d1789fb\",\n];\n\nif (!isPreview && !poll) {\n  return \"Property poll not set\";\n}\n\nif (!whitelist) {\n  return \"Property whitelist not set\";\n}\n\nconst indexVersion = props.indexVersion ?? \"3.2.0\";\n\nlet widgetOwner = \"neardigitalcollective.near\";\n\nlet defaultVotes = [];\nfor (let i = 0; i < poll.value.questions.length; i++) {\n  if (poll.value.questions[i].questionType == \"2\") {\n    defaultVotes.push([\"\"]);\n  } else {\n    defaultVotes.push(\"\");\n  }\n}\n\nState.init({\n  vote: userVote ?? defaultVotes,\n  answers: {},\n  showErrorsInForm: false,\n  hoveringElement: \"\",\n});\n\nlet bgBlue = \"#96C0FF\";\nlet bgRed = \"#FFB4B4\";\nlet bgYellow = \"#FFE999\";\nlet bgPurple = \"#E6C0FF\";\nlet bgGreen = \"#96FFE0\";\nlet bgPink = \"#FF96B9\";\nlet bgSkyBlue = \"#96EAFF\";\nlet bgIndigo = \"#96DCD2\";\n\nlet allBgColors = [\n  bgBlue,\n  bgRed,\n  bgYellow,\n  bgPurple,\n  bgGreen,\n  bgPink,\n  bgSkyBlue,\n  bgIndigo,\n];\n\nlet secondaryBgBlue = \"#E6F0FF\";\nlet secondaryBgRed = \"#FFEDED\";\nlet secondaryBgYellow = \"#FFFAE6\";\nlet secondaryBgPurple = \"#F9F0FF\";\nlet secondaryBgGreen = \"#E6FFF7\";\nlet secondaryBgPink = \"#FFE6EE\";\nlet secondaryBgSkyBlue = \"#E6FAFF\";\nlet secondaryBgIndigo = \"#E6F6F4\";\n\nlet allSecondaryBgColors = [\n  secondaryBgBlue,\n  secondaryBgRed,\n  secondaryBgYellow,\n  secondaryBgPurple,\n  secondaryBgGreen,\n  secondaryBgPink,\n  secondaryBgSkyBlue,\n  secondaryBgIndigo,\n];\n\nlet fontColorBlue = \"#003E9C\";\nlet fontColorRed = \"#9C2B2B\";\nlet fontColorYellow = \"#9C7B03\";\nlet fontColorPurple = \"#763E9C\";\nlet fontColorGreen = \"#009C6D\";\nlet fontColorPink = \"#9C0034\";\nlet fontColorSkyBlue = \"#007C9C\";\nlet fontColorIndigo = \"#006758\";\n\nlet allFontColors = [\n  fontColorBlue,\n  fontColorRed,\n  fontColorYellow,\n  fontColorPurple,\n  fontColorGreen,\n  fontColorPink,\n  fontColorSkyBlue,\n  fontColorIndigo,\n];\n\nlet secondaryColor = \"#E9EBF8\";\n\nfunction getBgColor(index, isPrimary) {\n  let allColorsOfThisType =\n    state.vote != `${index}` && isPrimary ? allBgColors : allSecondaryBgColors;\n\n  return Number.isInteger((index + 1) / allColorsOfThisType.length)\n    ? allColorsOfThisType[0]\n    : allColorsOfThisType[\n        ((index + 1) / allColorsOfThisType.length -\n          Math.trunc((index + 1) / allColorsOfThisType.length)) *\n          allColorsOfThisType.length -\n          1\n      ];\n}\n\nfunction getFontColor(index) {\n  return Number.isInteger((index + 1) / allFontColors.length)\n    ? allFontColors[0]\n    : allFontColors[\n        ((index + 1) / allFontColors.length -\n          Math.trunc((index + 1) / allFontColors.length)) *\n          allFontColors.length -\n          1\n      ];\n}\n\nfunction getInputStyles(questionType, questionNumber, optionNumber) {\n  if (questionType == \"2\") {\n    return state.vote[questionNumber].includes(optionNumber + \"\")\n      ? {\n          borderColor: \"black\",\n          backgroundColor: \"black\",\n          width: \"1rem\",\n          marginRight: \"0.7rem\",\n        }\n      : {\n          width: \"1rem\",\n          marginRight: \"0.7rem\",\n        };\n  } else {\n    return optionNumber + \"\" == state.vote[questionNumber]\n      ? {\n          borderColor: \"black\",\n          backgroundColor: \"black\",\n          width: \"1rem\",\n          marginRight: \"0.7rem\",\n        }\n      : {\n          width: \"1rem\",\n          marginRight: \"0.7rem\",\n        };\n  }\n}\n\n// Utility function\nfunction getBlockTimestamp(blockHeight) {\n  // It is stored in nanoseconds which is 1e-6 miliseconds\n  return Near.block(blockHeight).header.timestamp / 1e6;\n}\n\n// Discards answers that were posted after question's end date\nfunction getTimeRelatedValidAnswers(answers) {\n  let low = 0;\n  let high = answers.length - 1;\n  const questionEndTimestamp = poll.value.endTimestamp;\n  let endBlockTimestamp = getBlockTimestamp(answers[high].blockHeight);\n  if (endBlockTimestamp < questionEndTimestamp) return answers;\n  // For tries to exceed 50 there should be more than 10e15 answers which will never happen. But if you mess up and make an infinite cycle it will crash. This way it will never be infinite\n  let tries = 10;\n  while (high - low > 1 && tries > 0) {\n    tries--;\n    let curr = Math.floor((high - low) / 2) + low;\n    let currBlockTimestamp = getBlockTimestamp(answers[curr].blockHeight);\n    if (currBlockTimestamp < questionEndTimestamp) {\n      low = curr;\n    } else {\n      high = curr;\n    }\n  }\n  // Slice ignores the index of the last one. Since high - low == 1, high = low + 1\n  return answers.slice(0, high);\n}\n\nfunction getOptionRelatedValidAnswers(answers) {\n  return answers.filter((a) => {\n    const userAnswers = a.value.answer;\n    return userAnswers.every((an, i) => {\n      // If has choicesOptions, then it's needs validation answer is among the options. If not, any answer is just fine\n      if (poll.value.questions[i].choicesOptions.length > 0) {\n        if (Array.isArray(an)) {\n          return an.every(\n            (ans) =>\n              0 <= Number(ans) &&\n              Number(ans) < poll.value.questions[i].choicesOptions.length\n          );\n        } else {\n          return (\n            0 <= Number(an) &&\n            Number(an) < poll.value.questions[i].choicesOptions.length\n          );\n        }\n      } else {\n        return true;\n      }\n    });\n  });\n}\n\n// Getting valid answers\nconst answers = Social.index(\"poll_question\", `answer-v${indexVersion}`);\n\nif (JSON.stringify(answers) != JSON.stringify(state.answers)) {\n  State.update({ answers: answers });\n}\n\nif (!state.answers) {\n  return \"Loading\";\n}\n\nconst isUserAllowedToVote = (accountId) => {\n  const view = Near.view(\"registry.i-am-human.near\", \"sbt_tokens_by_owner\", {\n    account: accountId,\n    issuer: \"fractal.i-am-human.near\",\n  });\n  const hasSBTToken = view?.[0]?.[1]?.[0];\n  return hasSBTToken || whitelist.includes(accountId);\n};\n\nconst answersToThisPoll = state.answers.filter(\n  (a) => a.value.questionBlockHeight == poll.blockHeight\n);\nfunction getValidAnswers() {\n  let validTimeAnswers = getTimeRelatedValidAnswers(answersToThisPoll);\n  let validOptionAndTimeAnswers =\n    getOptionRelatedValidAnswers(validTimeAnswers);\n  const validateAddresses = validOptionAndTimeAnswers.filter((item) => {\n    return isUserAllowedToVote(item.accountId);\n    // const view = Near.view(\"registry.i-am-human.near\", \"sbt_tokens_by_owner\", {\n    //   account: item.accountId,\n    //   issuer: \"fractal.i-am-human.near\",\n    // });\n    // return view?.[0]?.[1]?.[0] /*|| whitelist.includes(item.accountId)*/;\n  });\n  return validateAddresses;\n}\nconst validAnswersToThisPoll = getValidAnswers(answersToThisPoll);\n\nlet userVote;\n// Getting if user has already voted\nconst currAccountId = context.accountId ?? \"\";\nfunction userHasVoted() {\n  return (\n    validAnswersToThisPoll.find((a) => a.accountId == currAccountId) !=\n    undefined\n  );\n}\nlet hasVoted = userHasVoted();\nconst isQuestionOpen =\n  poll.value.startTimestamp < Date.now() &&\n  Date.now() < poll.value.endTimestamp;\nconst canVote = !hasVoted && isQuestionOpen;\n\n// Counting votes to display\nfunction countVotes(questionNumber, questionType) {\n  if (questionType == \"3\") return;\n  return validAnswersToThisPoll.reduce((acc, curr) => {\n    let ans = curr.value.answer[questionNumber];\n    if (Array.isArray(ans)) {\n      ans.forEach((a) => {\n        acc[Number(a)] += 1;\n      });\n    } else {\n      acc[Number(ans)] += 1;\n    }\n\n    return acc;\n  }, new Array(poll.value.questions[questionNumber].choicesOptions.length).fill(0));\n}\n\n//TODO review this!\nconst getPublicationParams = () => {\n  return {\n    index: {\n      poll_question: JSON.stringify(\n        {\n          key: `answer-v${indexVersion}`,\n          value: {\n            answer: state.vote,\n            questionBlockHeight: poll.blockHeight,\n          },\n        },\n        undefined,\n        0\n      ),\n    },\n  };\n};\n\nfunction isVoteValid() {\n  let isValid = state.vote.length == poll.value.questions.length;\n  isValid = isValid && context.accountId;\n  for (let i = 0; i < state.vote.length; i++) {\n    const vote = state.vote[i];\n    // vote should always be a string, but in one case is treated as an array. Replace array with csv\n    if (Array.isArray(vote)) {\n      isValid = isValid && vote.filter((v) => v.trim() != \"\").length > 0;\n    } else {\n      isValid = isValid && vote.trim() != \"\";\n    }\n  }\n  return isValid;\n}\n\nfunction calculatePercentage(votesToThisOption) {\n  if (validAnswersToThisPoll.length == 0) return 0;\n  return ((votesToThisOption / validAnswersToThisPoll.length) * 100).toFixed(2);\n}\n\nfunction calculatePercentageOfOption(votes, index) {\n  const validAnswers = votes.reduce((acc, curr) => acc + curr, 0);\n\n  if (validAnswers == 0 || votes.length == 0) return 0;\n\n  const votesToThisOption = votes[index];\n  return ((votesToThisOption / validAnswers) * 100).toFixed(2);\n}\n\nfunction getBorderRadious(questionNumber, optionNumber) {\n  if (optionNumber == 0) {\n    return \"12px 12px 4px 4px\";\n  } else if (\n    optionNumber ==\n    poll.value.questions[questionNumber].choicesOptions.length - 1\n  ) {\n    return \"4px 4px 12px 12px\";\n  } else {\n    return \"4px\";\n  }\n}\n\nconst isValidInput = () => {\n  let result = state.vote != \"\";\n  return result && !isPreview;\n};\n\nconst renderAnswers = (questionNumber) => {\n  return (\n    <Widget\n      src={`${widgetOwner}/widget/EasyPoll.AnswerCommentsContainer`}\n      props={{\n        answers: validAnswersToThisPoll,\n        questionNumber,\n      }}\n    />\n  );\n};\n\nfunction clickRadioInputHandler(questionNumber, optionNumber) {\n  return () => {\n    let newVote = state.vote;\n\n    newVote[questionNumber] = optionNumber + \"\";\n    State.update({ vote: newVote });\n  };\n}\n\nfunction clickCheckboxInputHandler(questionNumber, optionNumber) {\n  return () => {\n    let newVote = state.vote;\n\n    let oldQuestionVotes = newVote[questionNumber];\n    let newQuestionVotes = [];\n\n    if (!oldQuestionVotes.includes(optionNumber + \"\")) {\n      newQuestionVotes = oldQuestionVotes;\n      newQuestionVotes.push(optionNumber + \"\");\n    } else {\n      for (let i = 0; i < oldQuestionVotes.length; i++) {\n        if (oldQuestionVotes[i] != optionNumber + \"\") {\n          newQuestionVotes.push(oldQuestionVotes[i]);\n        }\n      }\n    }\n\n    newVote[questionNumber] = newQuestionVotes.filter((a) => a != \"\");\n\n    State.update({ votes: newVote });\n  };\n}\n\nreturn (\n  <Widget\n    src={`${widgetOwner}/widget/EasyPoll.DisplayVote2`}\n    props={{\n      state: {\n        vote: state.vote,\n        hoveringElement: state.hoveringElement,\n        showErrorsInForm: state.showErrorsInForm,\n      },\n      poll,\n      canVote,\n      getBgColor,\n      getFontColor,\n      countVotes,\n      getBorderRadious,\n      calculatePercentageOfOption,\n      getBlockTimestamp,\n      clickCheckboxInputHandler,\n      clickRadioInputHandler,\n      getInputStyles,\n      hasVoted,\n      getPublicationParams,\n      stateUpdate: (data) => State.update(data),\n      isQuestionOpen,\n      isVoteValid,\n      validAnswersToThisPoll,\n      renderAnswers,\n      whitelist,\n    }}\n  />\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/f2bc8abdb8ba64fe5aac9689ded9491ff0e6fdcd7a5c680b7cf364142d1789fb/widget/EasyPoll.DisplayVote", "fact_widget_deployments_id": "1a135d0fb5512663ed429ce2efe1c660", "inserted_timestamp": "2000-01-01T00:00:00.000Z", "modified_timestamp": "2000-01-01T00:00:00.000Z", "__row_index": 1}