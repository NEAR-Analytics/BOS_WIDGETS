{"tx_hash": "AwCgqatfKf1gDUntFEUQkTXzGgAkjsSdDHd4ydrPZfJD", "action_id_social": "BZmpxH5wYpxCvAZ76vTzjzs6EpHVfJKMVi38ZdaBV9cj-0-widget", "block_id": 113193762, "block_timestamp": "2024-02-20T02:48:08.914Z", "signer_id": "rodrigos.near", "widget_name": "lib.comment", "source_code": "// lib.comment\nconst {\n  mainStateUpdate,\n  isTest,\n  stateUpdate,\n  functionsToCallByLibrary,\n  callLibs,\n  baseAction,\n  widgets,\n  usersSBTs,\n} = props;\n\nconst libName = \"comment\"; // EDIT: set lib name\nconst functionsToCall = functionsToCallByLibrary[libName];\n\nlet resultFunctionsToCallByLibrary = Object.assign(\n  {},\n  functionsToCallByLibrary\n);\nlet resultFunctionsToCall = [];\n\nconst currentVersion = \"0.0.3\"; // EDIT: Set version\n\nconst prodAction = `${baseAction}_v${currentVersion}`; // TODO consider versions\n// const prodAction = `${baseAction}`;\nconst testAction = `test_${prodAction}`;\nconst action = isTest ? testAction : prodAction;\n\n// START LIB CALLS SECTION\n// interface FunctionCall {\n//     functionName: string,\n//     key: string, // The state of the caller will be updated with this string as a key\n//     props: Record<string, any> // function parameters as object\n// }\n\n// type LibsCalls = Record<string, FunctionCall> // Key is lib name after lib.\n\nconst libSrcArray = [widgets.libs.libSBT]; // string to lib widget // EDIT: set libs to call\n\nconst imports = { notifications: [\"getNotificationData\"] };\n\nconst libsCalls = {};\nlibSrcArray.forEach((libSrc) => {\n  const libName = libSrc.split(\"lib.\")[1];\n  libsCalls[libName] = [];\n});\n\nState.init({\n  libsCalls, // is a LibsCalls object\n  notifications: {},\n});\n// END LIB CALLS SECTION\n\nfunction log(message) {\n  console.log(`lib.${libName}`, message);\n}\n\nfunction logError(message) {\n  console.error(`lib.${libName}`, message);\n}\n\nfunction libStateUpdate(obj) {\n  State.update(obj);\n}\n\n// START LIB FUNCTIONS: EDIT set functions you need\n\nfunction canUserCreateComment(props) {\n  const { accountId, sbtsNames } = props;\n\n  if (sbtsNames.includes(\"public\")) return true;\n\n  if (accountId) {\n    setAreValidUsers([accountId], sbtsNames);\n  } else {\n    return false;\n  }\n\n  let allSBTsValidations = [];\n\n  let result;\n\n  let userCredentials =\n    usersSBTs.find((data) => data.user === accountId).credentials ??\n    state[`isValidUser-${accountId}`];\n\n  if (userCredentials) {\n    const allSBTs = Object.keys(userCredentials);\n\n    allSBTs.forEach((sbt) => {\n      sbt !== \"public\" && allSBTsValidations.push(userCredentials[sbt]);\n    });\n\n    result = allSBTsValidations.includes(true);\n  }\n\n  resultFunctionsToCall = resultFunctionsToCall.filter((call) => {\n    const discardCondition =\n      call.functionName === \"canUserCreateComment\" && result !== undefined;\n    return !discardCondition;\n  });\n\n  return result;\n}\n\nfunction setAreValidUsers(accountIds, sbtsNames) {\n  const newLibCalls = Object.assign({}, state.libsCalls);\n\n  if (newLibsCalls && !newLibsCalls.SBT) {\n    logError(\"Key SBT is not set in lib.\", libName);\n  }\n\n  accountIds.forEach((accountId) => {\n    const isCallPushed =\n      newLibCalls.SBT.find((libCall) => {\n        return (\n          libCall.functionName === \"isValidUser\" &&\n          libCall.props.accountId === accountId\n        );\n      }) !== undefined;\n    const isCallReturned = state[`isValidUser-${accountId}`] !== undefined;\n\n    if (isCallPushed || isCallReturned) {\n      return;\n    }\n\n    const existingUserSBTs = usersSBTs.find(\n      (userSBTs) => userSBTs.user === accountId\n    );\n\n    if (!existingUserSBTs) {\n      newLibCalls.SBT.push({\n        functionName: \"isValidUser\",\n        key: `isValidUser-${accountId}`,\n        props: {\n          accountId,\n        },\n      });\n    }\n  });\n  State.update({ libCalls: newLibCalls });\n}\n\nfunction createComment(props) {\n  const { comment, replyingTo, articleId, onClick, onCommit, onCancel } = props;\n\n  if (comment.commentId) {\n    console.error(\n      \"comment.commentId should not be provided when creating comment\"\n    );\n    return;\n  }\n\n  const commentId = `c_${context.accountId}-${Date.now()}`;\n\n  comment.commentId = commentId;\n\n  onClick();\n\n  saveComment(comment, replyingTo, articleId, onCommit, onCancel, false);\n\n  resultFunctionsToCall = resultFunctionsToCall.filter((call) => {\n    return call.functionName !== \"createComment\";\n  });\n\n  return comment;\n}\n\nfunction deleteComment(props) {\n  const { comment, articleId, onCommit, onCancel } = props;\n\n  if (!comment.commentId) {\n    console.error(\"comment.commentId should be provided when editing comment\");\n    return;\n  }\n\n  const replyingTo = undefined;\n\n  comment.isDeleted = true;\n\n  saveComment(comment, replyingTo, articleId, onCommit, onCancel, true);\n\n  resultFunctionsToCall = resultFunctionsToCall.filter((call) => {\n    return call.functionName !== \"deleteComment\";\n  });\n\n  return comment;\n}\n\nfunction editComment(props) {\n  const { comment, articleId, onClick, onCommit, onCancel } = props;\n\n  if (!comment.commentId) {\n    console.error(\"comment.commentId should be provided when editing comment\");\n    return;\n  }\n\n  const replyingTo = undefined;\n\n  onClick();\n\n  saveComment(comment, replyingTo, articleId, onCommit, onCancel, false);\n\n  resultFunctionsToCall = resultFunctionsToCall.filter((call) => {\n    return call.functionName !== \"editComment\";\n  });\n\n  return comment;\n}\n\nfunction getNotificationData(type, accountId, url) {\n  if (state.notifications.getNotificationData) {\n    return state.notifications.getNotificationData(type, accountId, url);\n  }\n}\n\nfunction extractMentions(text) {\n  const mentionRegex =\n    /@((?:(?:[a-z\\d]+[-_])*[a-z\\d]+\\.)*(?:[a-z\\d]+[-_])*[a-z\\d]+)/gi;\n  mentionRegex.lastIndex = 0;\n  const accountIds = new Set();\n  for (const match of text.matchAll(mentionRegex)) {\n    if (\n      !/[\\w`]/.test(match.input.charAt(match.index - 1)) &&\n      !/[/\\w`]/.test(match.input.charAt(match.index + match[0].length)) &&\n      match[1].length >= 2 &&\n      match[1].length <= 64\n    ) {\n      accountIds.add(match[1].toLowerCase());\n    }\n  }\n  return [...accountIds];\n}\n\nfunction composeCommentData(comment, replyingTo, articleId, isDelete) {\n  if (replyingTo) {\n    //We add the following so the user been replied get's a notification\n    comment.text = `@${replyingTo} ${comment.text}`;\n  }\n\n  const data = {\n    index: {\n      [action]: JSON.stringify({\n        key: articleId,\n        value: {\n          type: \"md\",\n          comment,\n        },\n      }),\n    },\n  };\n\n  const mentions = isDelete ? [] : extractMentions(comment.text);\n\n  if (mentions.length > 0) {\n    const dataToAdd = getNotificationData(\n      \"mentionOnComment\",\n      mentions,\n      `https://near.social/${\n        widgets.thisForum\n      }?sharedArticleId=${articleId}&sharedCommentId=${comment.commentId}${\n        isTest ? \"&isTest=t\" : \"\"\n      }`\n    );\n\n    data.post = dataToAdd.post;\n    data.index.notify = dataToAdd.index.notify;\n  }\n\n  return data;\n}\n\nfunction saveComment(\n  comment,\n  replyingTo,\n  articleId,\n  onCommit,\n  onCancel,\n  isDelete\n) {\n  if (comment.text) {\n    const newData = composeCommentData(\n      comment,\n      replyingTo,\n      articleId,\n      isDelete\n    );\n    Social.set(newData, {\n      force: true,\n      onCommit,\n      onCancel,\n    });\n  }\n}\n\nfunction getComments(action, id, subscribe) {\n  return Social.index(action, id, {\n    order: \"desc\",\n    subscribe,\n  });\n}\n\nfunction getCommentBlackListByBlockHeight() {\n  return [98588599];\n}\n\nfunction getUserNameFromCommentId(commentId) {\n  const userNamePlusTimestamp = commentId.split(\"c_\")[1];\n\n  const splittedUserNamePlusTimestamp = userNamePlusTimestamp.split(\"-\");\n\n  splittedUserNamePlusTimestamp.pop();\n\n  const userName = splittedUserNamePlusTimestamp.join(\"-\");\n\n  return userName;\n}\n\nfunction filterInvalidComments(comments) {\n  return comments\n    .filter(\n      (comment) =>\n        comment.blockHeight &&\n        !getCommentBlackListByBlockHeight().includes(comment.blockHeight) // Comment is not in blacklist\n    )\n    .filter(\n      (comment) =>\n        comment.accountId ===\n        getUserNameFromCommentId(comment.value.comment.commentId)\n    );\n}\n\nfunction getValidComments(props) {\n  const { env, articleSbts, id } = props;\n  // Call other libs\n  const normComments = getCommentsNormalized(env, id);\n\n  // Keep last edit from every article\n  const lastEditionComments = normComments.filter((comment) => {\n    const firstCommentWithThisCommentId = normComments.find((compComment) => {\n      return (\n        compComment.value.comment.commentId === comment.value.comment.commentId\n      );\n    });\n\n    return (\n      JSON.stringify(firstCommentWithThisCommentId) === JSON.stringify(comment)\n    );\n  });\n\n  const lastEditionCommentsWithoutDeletedOnes = lastEditionComments.filter(\n    (comment) => !comment.value.comment.isDeleted\n  );\n\n  const lastEditionCommentsWithEditionMark =\n    lastEditionCommentsWithoutDeletedOnes.map((comment) => {\n      const commentsWithThisCommentId = normComments.filter((compComment) => {\n        return (\n          comment.value.comment.commentId ===\n          compComment.value.comment.commentId\n        );\n      });\n\n      if (commentsWithThisCommentId.length > 1) {\n        comment.isEdition = true;\n      }\n\n      return comment;\n    });\n\n  const commentsAuthors = lastEditionCommentsWithEditionMark.map((comment) => {\n    return comment.accountId;\n  });\n\n  setAreValidUsers(commentsAuthors, articleSbts);\n\n  resultFunctionsToCall = resultFunctionsToCall.filter((call) => {\n    const discardCondition =\n      call.functionName === \"getValidComments\" &&\n      state[`isValidUser-${call.props.accountId}`] !== undefined;\n    return !discardCondition;\n  });\n\n  const finalComments = filterValidComments(\n    lastEditionCommentsWithEditionMark,\n    articleSbts\n  );\n\n  return sortComments(finalComments);\n}\n\nfunction filterValidator(comments, articleSbts) {\n  if (articleSbts.includes(\"public\")) return comments;\n\n  return comments.filter((comment) => {\n    let allSBTsValidations = [];\n\n    let result;\n\n    let userCredentials =\n      usersSBTs.find((data) => data.user === comment.accountId).credentials ??\n      state[`isValidUser-${comment.accountId}`];\n\n    if (userCredentials) {\n      const allSBTs = Object.keys(userCredentials);\n\n      allSBTs.forEach((sbt) => {\n        sbt !== \"public\" && allSBTsValidations.push(userCredentials[sbt]);\n      });\n\n      result = allSBTsValidations.includes(true);\n    }\n\n    return result;\n  });\n}\n\nfunction filterValidComments(comments, articleSbts) {\n  let filteredComments = filterValidator(\n    filteredComments ?? comments,\n    articleSbts\n  );\n\n  return filteredComments;\n}\n\nfunction sortComments(comments) {\n  comments.sort((c1, c2) => {\n    return c1.value.comment.timestamp - c2.value.comment.timestamp;\n  });\n\n  return comments;\n}\n\nfunction getCommentsNormalized(env, id) {\n  const commentsByVersion = Object.keys(versions).map((version, index, arr) => {\n    const action = versions[version].action;\n    const subscribe = index + 1 === arr.length;\n\n    const comments = getComments(action, id, subscribe);\n    if (!comments) return [];\n\n    const validComments = filterInvalidComments(comments);\n\n    return validComments;\n  });\n\n  return normalizeLibData(commentsByVersion);\n}\n\nfunction normalizeOldToV_0_0_1(comment) {\n  return comment;\n}\n\nfunction normalizeFromV0_0_1ToV0_0_2(comment) {\n  return comment;\n}\n\nfunction normalizeFromV0_0_2ToV0_0_3(comment) {\n  comment.value.comment.rootId = comment.value.comment.originalCommentId;\n  delete comment.value.comment.originalCommentId;\n  delete comment.value.comment.id;\n\n  return comment;\n}\n\nfunction normalizeFromV0_0_3ToV0_0_4(comment) {\n  return comment;\n}\n// END LIB FUNCTIONS\n\n// EDIT: set functions you want to export\nfunction callFunction(call) {\n  if (call.functionName === \"createComment\") {\n    return createComment(call.props);\n  } else if (call.functionName === \"editComment\") {\n    return editComment(call.props);\n  } else if (call.functionName === \"deleteComment\") {\n    return deleteComment(call.props);\n  } else if (call.functionName === \"getValidComments\") {\n    return getValidComments(call.props);\n  } else if (call.functionName === \"canUserCreateComment\") {\n    return canUserCreateComment(call.props);\n  }\n}\n\n// EDIT: set versions you want to handle, considering their action to Social.index and the way to transform to one version to another (normalization)\nconst versions = {\n  old: {\n    normalizationFunction: normalizeOldToV_0_0_1,\n    action: props.isTest ? `test_${baseAction}` : baseAction,\n  },\n  \"v1.0.1\": {\n    normalizationFunction: normalizeFromV0_0_1ToV0_0_2,\n    action: props.isTest ? `test_${baseAction}-v1.0.1` : `${baseAction}-v1.0.1`,\n  },\n  \"v0.0.2\": {\n    normalizationFunction: normalizeFromV0_0_2ToV0_0_3,\n    action: props.isTest ? `test_${baseAction}_v0.0.2` : `${baseAction}_v0.0.2`,\n  },\n  \"v0.0.3\": {\n    normalizationFunction: normalizeFromV0_0_3ToV0_0_4,\n    action: props.isTest ? `test_${baseAction}_v0.0.3` : `${baseAction}_v0.0.3`,\n  },\n};\n\nfunction normalizeLibData(libDataByVersion) {\n  let libData;\n\n  Object.keys(versions).forEach((version, index, array) => {\n    const normFn = versions[version].normalizationFunction;\n    const normLibData = libDataByVersion[index].map((libData, i) => {\n      return normFn(libData);\n    });\n\n    if (index + 1 === array.length) {\n      // Last index\n      libData = normLibData;\n      return;\n    }\n    libDataByVersion[index + 1] =\n      libDataByVersion[index + 1].concat(normLibData);\n  });\n\n  return libData;\n}\n\nif (functionsToCall && functionsToCall.length > 0) {\n  const updateObj = Object.assign({}, functionsToCallByLibrary);\n  resultFunctionsToCall = [...functionsToCall];\n  functionsToCall.forEach((call) => {\n    updateObj[call.key] = callFunction(call);\n  });\n\n  resultFunctionsToCallByLibrary[libName] = resultFunctionsToCall;\n  updateObj.functionsToCallByLibrary = resultFunctionsToCallByLibrary;\n\n  const oldUsersSBTs = usersSBTs;\n  // {\n  //   user: string,\n  //   credentials: {},\n  // }\n\n  const newUsersSBTs = Object.keys(state).map((key) => {\n    if (key.includes(\"isValidUser-\")) {\n      if (state[key] !== undefined) {\n        const user = key.split(\"isValidUser-\")[1];\n        const credentials = state[key];\n\n        const oldUsers = oldUsersSBTs.map((userSbts) => userSbts.user);\n\n        if (!oldUsers.includes(user)) {\n          return {\n            user,\n            credentials,\n          };\n        }\n      }\n    }\n  });\n\n  const finalUsersSBTs = [...oldUsersSBTs, ...newUsersSBTs].filter(\n    (userSBTs) => userSBTs !== undefined\n  );\n\n  if (finalUsersSBTs[0]) {\n    mainStateUpdate({ usersSBTs: finalUsersSBTs });\n  }\n\n  stateUpdate(updateObj);\n}\n\n// function callLibs(\n//   src,\n//   stateUpdate,\n//   functionsToCallByLibrary,\n//   extraProps,\n//   callerWidget\n// ) {\n//   return (\n//     <Widget\n//       src={src}\n//       props={{\n//         isTest,\n//         stateUpdate,\n//         functionsToCallByLibrary,\n//         callLibs,\n//         widgets,\n//         ...extraProps,\n//       }}\n//     />\n//   );\n// }\n\nreturn (\n  <>\n    {libSrcArray.map((src) => {\n      return callLibs(\n        src,\n        libStateUpdate,\n        state.libsCalls,\n        {},\n        `lib.${libName}`\n      );\n    })}\n\n    <Widget\n      src={`${widgets.libs.libNotifications}`}\n      props={{\n        stateUpdate: libStateUpdate,\n        imports: imports[\"notifications\"],\n        fatherNotificationsState: state.notifications,\n      }}\n    />\n  </>\n);\n", "metadata": {"platform": "jutsu.ai"}, "branch": {"draft": null}, "widget_modules_used": null, "widget_url": "https://near.social/#/rodrigos.near/widget/lib.comment", "fact_widget_deployments_id": "515f53ed138e29ee4b00c321928f7064", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 9}