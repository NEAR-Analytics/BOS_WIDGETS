{"tx_hash": "Cdicg9UXUKnH4YNJ8iSjcA6rz3NPW9u6newVSCfnVENX", "action_id_social": "2xhcq2zFWq1rw4mxucg5jWsjadHWoT6UzBnU4SAKoeZ7-0-widget", "block_id": 113193809, "block_timestamp": "2024-02-20T02:49:10.780Z", "signer_id": "rodrigos.near", "widget_name": "lib.SBT", "source_code": "// lib.SBT\n\nconst {\n  isTest,\n  stateUpdate,\n  functionsToCallByLibrary,\n  callLibs,\n  baseAction,\n  callerWidget,\n  widgets,\n} = props;\nconst libName = \"SBT\"; // EDIT: set lib name\nconst functionsToCall = functionsToCallByLibrary[libName];\n\nconst sbtWhiteList =\n  context.networkId === \"testnet\"\n    ? [\n        {\n          value: \"fractal-v2.i-am-human.testnet - class 1\",\n          title: \"Fractal\",\n          default: true,\n        },\n        {\n          value: \"community-v2.i-am-human.testnet - class 1\",\n          title: \"Community\",\n        },\n      ]\n    : [\n        {\n          value: \"fractal.i-am-human.near - class 1\",\n          title: \"General\",\n          default: true,\n        },\n        { value: \"community.i-am-human.near - class 1\", title: \"OG\" },\n        { value: \"community.i-am-human.near - class 2\", title: \"Contributor\" },\n        {\n          value: \"community.i-am-human.near - class 3\",\n          title: \"Core Contributor\",\n        },\n        { value: \"elections.ndc-gwg.near - class 2\", title: \"HoM\" },\n        { value: \"elections.ndc-gwg.near - class 3\", title: \"CoA\" },\n        { value: \"elections.ndc-gwg.near - class 4\", title: \"TC\" },\n        { value: \"public\", title: \"Public\" },\n      ];\n\nlet resultFunctionsToCallByLibrary = Object.assign(\n  {},\n  functionsToCallByLibrary\n);\nlet resultFunctionsToCall = [];\n\nconst registryContract =\n  context.networkId === \"mainnet\"\n    ? \"registry.i-am-human.near\"\n    : \"registry-v2.i-am-human.testnet\";\n\n// START LIB CALLS SECTION\n// This lib does not call any other lib\n// END LIB CALLS SECTION\n\nfunction log(message) {\n  console.log(`lib.${libName}`, message);\n}\n\nfunction logError(message) {\n  console.error(`lib.${libName}`, message);\n}\n\nfunction libStateUpdate(obj) {\n  State.update(obj);\n}\n\n// START LIB FUNCTIONS: EDIT set functions you need\n\nfunction getSBTWhiteList(props) {\n  const {} = props;\n\n  resultFunctionsToCall = resultFunctionsToCall.filter((call) => {\n    return call.functionName !== \"getSBTWhiteList\";\n  });\n\n  return sbtWhiteList;\n}\n\nfunction isValidUser(props) {\n  const { accountId, sbtsNames } = props;\n  const userSBTs = Near.view(registryContract, \"sbt_tokens_by_owner\", {\n    account: accountId,\n  });\n  const isSBTContractLoaded = userSBTs !== null;\n  if (!isSBTContractLoaded) {\n    return undefined;\n  }\n\n  const sbtsData = sbtsNames.map((sbt) => {\n    const data = sbt.split(\" - class \");\n    return { name: data[0], classNumber: Number(data[1]) };\n  });\n  const usersValidityBySBT = {};\n  sbtsNames.forEach((sbtName, index) => {\n    const isUserValid =\n      isSBTContractLoaded &&\n      userSBTs.find((userSbt) => {\n        return (\n          userSbt[0] === sbtsData[index].name &&\n          userSbt[1].find(\n            (sbtExtraData) =>\n              sbtExtraData.metadata[\"class\"] === sbtsData[index].classNumber\n          )\n        );\n      }) !== undefined;\n    usersValidityBySBT[sbtName] = isUserValid || sbtName === \"public\";\n  });\n\n  resultFunctionsToCall = resultFunctionsToCall.filter((call) => {\n    return call.functionName !== \"isValidUser\";\n  });\n\n  // return true;\n  return { ...usersValidityBySBT };\n}\n\nfunction getUserSBTs(props) {\n  const { accountId } = props;\n  const userSBTs = Near.view(registryContract, \"sbt_tokens_by_owner\", {\n    account: accountId,\n  });\n\n  if (userSBTs) {\n    resultFunctionsToCall = resultFunctionsToCall.filter((call) => {\n      return call.functionName !== \"getUserSBTs\";\n    });\n  }\n\n  return userSBTs;\n}\n// END LIB FUNCTIONS\n\n// EDIT: set functions you want to export\nfunction callFunction(call) {\n  if (call.functionName === \"getSBTWhiteList\") {\n    return getSBTWhiteList(call.props);\n  } else if (call.functionName === \"isValidUser\") {\n    return isValidUser(call.props);\n  } else if (call.functionName === \"getUserSBTs\") {\n    return getUserSBTs(call.props);\n  }\n}\n\nif (functionsToCall && functionsToCall.length > 0) {\n  const updateObj = Object.assign({}, functionsToCallByLibrary);\n  resultFunctionsToCall = [...functionsToCall];\n  functionsToCall.forEach((call) => {\n    updateObj[call.key] = callFunction(call);\n  });\n\n  resultFunctionsToCallByLibrary[libName] = resultFunctionsToCall;\n  updateObj.functionsToCallByLibrary = resultFunctionsToCallByLibrary;\n  stateUpdate(updateObj);\n}\n\nreturn <></>;\n", "metadata": {"platform": "jutsu.ai"}, "branch": {"draft": null}, "widget_modules_used": null, "widget_url": "https://near.social/#/rodrigos.near/widget/lib.SBT", "fact_widget_deployments_id": "24244fbb3fddbc38ca1426402c9387ca", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 10}