{"tx_hash": "GuPiNV5iSnhfNbWnT2z6LB7E8wEkDaGXw9UwsevXuqkh", "action_id_social": "4h29aBMGozGF6vrom1MGbYeVpH5SodZBTAX5HRnGUa6c-0-widget", "block_id": 98098273, "block_timestamp": "2023-08-05T02:15:07.042Z", "signer_id": "astro.sking.near", "widget_name": "CreateDAO.Step5", "source_code": "const { formState, errors, renderFooter } = props;\nconst { accountId } = context;\n\nconst initialAnswers = {\n  policy: formState.policy,\n};\n\nState.init({\n  answers: initialAnswers,\n});\n\n// -- roles\nconst rolesArray = [...state.answers.policy.roles.map((role) => role.name)];\n\nconst proposalKinds = {\n  ChangeDAOConfig: {\n    title: \"Change DAO Config\",\n    key: \"config\",\n  },\n  ChangeDAOPolicy: {\n    title: \"Change DAO Policy\",\n    key: \"policy\",\n  },\n  Bounty: {\n    title: \"Bounty\",\n    key: \"add_bounty\",\n  },\n  BountyDone: {\n    title: \"Bounty Done\",\n    key: \"bounty_done\",\n  },\n  Transfer: {\n    title: \"Transfer\",\n    key: \"transfer\",\n  },\n  Polls: {\n    title: \"Polls\",\n    key: \"vote\",\n  },\n  RemoveMembers: {\n    title: \"Remove Members\",\n    key: \"remove_member_from_role\",\n  },\n  AddMembers: {\n    title: \"Add Members\",\n    key: \"add_member_to_role\",\n  },\n  FunctionCall: {\n    title: \"Function Call\",\n    key: \"call\",\n  },\n  UpgradeSelf: {\n    title: \"Upgrade Self\",\n    key: \"upgrade_self\",\n  },\n  UpgradeRemote: {\n    title: \"Upgrade Remote\",\n    key: \"upgrade_remote\",\n  },\n  SetVoteToken: {\n    title: \"Set Vote Token\",\n    key: \"set_vote_token\",\n  },\n};\n\nconst proposalActions = {\n  AddProposal: {\n    title: \"Add Proposal\",\n    key: \"AddProposal\",\n  },\n  VoteApprove: {\n    title: \"Vote Approve\",\n    key: \"VoteApprove\",\n  },\n  VoteReject: {\n    title: \"Vote Reject\",\n    key: \"VoteReject\",\n  },\n  VoteRemove: {\n    title: \"Vote Remove\",\n    key: \"VoteRemove\",\n  },\n};\n\nconst allActionArray = Object.keys(proposalActions).map(\n  (key) => proposalActions[key].key\n);\nconst allProposalKindArray = Object.keys(proposalKinds).map(\n  (key) => proposalKinds[key].key\n);\n\nconst hasPermission = (role, proposalKind, permissionType) => {\n  const roleObj = state.answers.policy.roles.find((r) => r.name === role);\n\n  if (roleObj) {\n    const permission = `${proposalKind}:${permissionType}`;\n    return roleObj.permissions.some(\n      (p) =>\n        p === permission ||\n        p === \"*:*\" ||\n        p === `${proposalKind}:*` ||\n        p === `*:${permissionType}`\n    );\n  } else {\n    return false;\n  }\n};\n\nconst cleanPermissions = (permissions) => {\n  // if there is a *:* permission, remove all other permissions\n  if (permissions.includes(\"*:*\")) return [\"*:*\"];\n\n  // if there is a *:proposalAction, remove all other permissions with the same action except *:proposalAction\n  allActionArray.forEach((action) => {\n    if (permissions.some((p) => p === `*:${action}`)) {\n      permissions = permissions.filter(\n        (p) => !p.endsWith(`:${action}`) || p === `*:${action}`\n      );\n    }\n  });\n\n  // if there is a proposalKind:*, remove all other permissions with the same proposalKind except proposalKind:*\n  allProposalKindArray.forEach((kind) => {\n    if (permissions.some((p) => p === `${kind}:*`)) {\n      permissions = permissions.filter(\n        (p) => !p.startsWith(`${kind}:`) || p === `${kind}:*`\n      );\n    }\n  });\n\n  // Check for proposalKind:[allProposalActions], if true remove them and add proposalKind:*\n  allProposalKindArray.forEach((kind) => {\n    if (\n      allActionArray.every((action) =>\n        permissions.includes(`${kind}:${action}`)\n      )\n    ) {\n      permissions = permissions.filter(\n        (p) => !p.startsWith(`${kind}:`) || p === `${kind}:*`\n      );\n      permissions.push(`${kind}:*`);\n    }\n  });\n\n  // Check for [allProposalKinds]:proposalAction, if true remove them and add *:proposalAction\n  allActionArray.forEach((action) => {\n    if (\n      allProposalKindArray.every((kind) =>\n        permissions.includes(`${kind}:${action}`)\n      )\n    ) {\n      permissions = permissions.filter(\n        (p) => !p.endsWith(`:${action}`) || p === `*:${action}`\n      );\n      permissions.push(`*:${action}`);\n    }\n  });\n\n  // if there is a [allProposalKinds]:[allProposalActions], remove all other permissions and add *:*\n  if (\n    allProposalKindArray.every((kind) => permissions.includes(`${kind}:*`)) &&\n    allActionArray.every((action) => permissions.includes(`*:${action}`))\n  ) {\n    permissions = [\"*:*\"];\n  }\n\n  return permissions;\n};\n\nconst popActionWildCard = (permissions) => {\n  let expandedPermissions = [];\n  permissions.forEach((permission) => {\n    const [proposalKind, action] = permission.split(\":\");\n    if (action === \"*\") {\n      expandedPermissions.push(\n        ...allActionArray.map((a) => `${proposalKind}:${a}`)\n      );\n    } else {\n      expandedPermissions.push(permission);\n    }\n  });\n  return [...new Set(expandedPermissions)]; // Remove duplicates\n};\n\nconst popProposalKindWildCard = (permissions) => {\n  let expandedPermissions = [];\n  permissions.forEach((permission) => {\n    const [proposalKind, action] = permission.split(\":\");\n    if (proposalKind === \"*\") {\n      expandedPermissions.push(\n        ...allProposalKindArray.map((k) => `${k}:${action}`)\n      );\n    } else {\n      expandedPermissions.push(permission);\n    }\n  });\n  return [...new Set(expandedPermissions)]; // Remove duplicates\n};\n\nconst popAllWildCards = (permissions) => {\n  permissions = popActionWildCard(permissions);\n  permissions = popProposalKindWildCard(permissions);\n  return permissions;\n};\n\nconst setPermission = (role, proposalKind, permissionType, value) => {\n  const roleObj = role;\n\n  const permission = `${proposalKind}:${permissionType}`;\n\n  // if true add permission\n  if (value) {\n    // if permission already exists or there is a wildcard, do nothing\n    if (hasPermission(role.name, proposalKind, permissionType)) {\n      return roleObj;\n    }\n    // if permission does not exist, add it\n    roleObj.permissions.push(permission);\n    // clean up permissions and add wildcards if needed\n    roleObj.permissions = cleanPermissions(roleObj.permissions);\n  }\n  // if false remove permission\n  else {\n    // if permission does not exist, do nothing\n    if (!hasPermission(role.name, proposalKind, permissionType)) {\n      return roleObj;\n    }\n    // if permission exists, make sure to pop all wildcards\n    roleObj.permissions = popAllWildCards(roleObj.permissions);\n    // remove permission\n    roleObj.permissions = roleObj.permissions.filter((p) => p !== permission);\n    // clean up permissions and add wildcards back if needed\n    roleObj.permissions = cleanPermissions(roleObj.permissions);\n  }\n  return roleObj;\n};\n\nconst setCreatePermission = (roleName, proposalKind, value) => {\n  const role = state.answers.policy.roles.find((r) => r.name === roleName);\n\n  const newRole = setPermission(role, proposalKind, \"AddProposal\", value);\n\n  const newRoles = state.answers.policy.roles.map((r) =>\n    r.name === roleName ? newRole : r\n  );\n\n  State.update({\n    answers: {\n      ...state.answers,\n      policy: {\n        ...state.answers.policy,\n        roles: newRoles,\n      },\n    },\n  });\n};\n\nconst setVotePermission = (roleName, proposalKind, value) => {\n  const role = state.answers.policy.roles.find((r) => r.name === roleName);\n\n  let newRole = setPermission(role, proposalKind, \"VoteApprove\", value);\n  newRole = setPermission(newRole, proposalKind, \"VoteReject\", value);\n  newRole = setPermission(newRole, proposalKind, \"VoteRemove\", value);\n\n  const newRoles = state.answers.policy.roles.map((r) =>\n    r.name === roleName ? newRole : r\n  );\n\n  State.update({\n    answers: {\n      ...state.answers,\n      policy: {\n        ...state.answers.policy,\n        roles: newRoles,\n      },\n    },\n  });\n};\n\nconst Table = styled.ul`\n  border-radius: 4px;\n  width: 100%;\n  list-style: none;\n  padding: 0;\n  display: flex;\n  flex-direction: column;\n  overflow-x: auto;\n  position: relative;\n\n  li {\n    flex: 1;\n    display: grid;\n    grid-template-columns: minmax(100px, 2fr) repeat(\n        auto-fit,\n        minmax(100px, 1fr)\n      );\n    grid-auto-flow: column;\n    grid-auto-columns: minmax(100px, 1fr);\n    max-width: 100%;\n    align-items: center;\n    padding: 16px;\n    justify-items: center;\n    align-items: center;\n    gap: 16px;\n    border-bottom: 1px solid #eee;\n\n    & > *:first-child {\n      justify-self: flex-start;\n      display: block;\n    }\n\n    &:first-child {\n      border-color: #4498e0;\n    }\n\n    &:last-child {\n      border-bottom: none;\n    }\n  }\n\n  p {\n    font-size: 0.8rem;\n    color: #666;\n    margin: 0;\n  }\n\n  li .label {\n    display: none;\n  }\n\n  .cbx:not(:last-child) {\n    margin-right: 0 !important;\n  }\n\n  @media (max-width: 600px) {\n    li {\n      display: flex;\n      flex-wrap: wrap;\n    }\n    li > div:first-child {\n      margin-bottom: 1rem;\n      flex: 1;\n      min-width: 100%;\n    }\n    li .label {\n      display: block;\n    }\n\n    .cbx:not(:last-child) {\n      margin-right: 6px !important;\n    }\n    .hide-on-mobile {\n      display: none;\n    }\n  }\n`;\n\nconst renderTable = (roles, rows, action) => {\n  return (\n    <Table>\n      <li className=\"fw-bold\">\n        <span>Actions</span>\n        {roles.map((role) => (\n          <span className=\"hide-on-mobile\">{role}</span>\n        ))}\n      </li>\n      {Object.keys(rows).map((key) => (\n        <li>\n          <div>{rows[key].title}</div>\n          {roles.map((role) => (\n            <Widget\n              src=\"nui.sking.near/widget/Input.Checkbox\"\n              props={{\n                label: role,\n                onChange: (checked) => {\n                  if (action === \"Vote\") {\n                    setVotePermission(role, rows[key].key, checked);\n                  } else if (action === \"AddProposal\") {\n                    setCreatePermission(role, rows[key].key, checked);\n                  }\n                },\n                checked:\n                  action === \"Vote\"\n                    ? hasPermission(role, rows[key].key, \"VoteApprove\") ||\n                      hasPermission(role, rows[key].key, \"VoteReject\") ||\n                      hasPermission(role, rows[key].key, \"VoteRemove\")\n                    : hasPermission(role, rows[key].key, action),\n              }}\n            />\n          ))}\n        </li>\n      ))}\n    </Table>\n  );\n};\n\nreturn (\n  <div className=\"mt-4 ndc-card p-4\">\n    <div className=\"d-flex flex-column gap-4\">\n      <h2 className=\"h5 fw-bold mb-2\">\n        <span\n          className=\"rounded-circle d-inline-flex align-items-center justify-content-center fw-bolder h5 me-2\"\n          style={{\n            width: \"48px\",\n            height: \"48px\",\n            border: \"1px solid #82E299\",\n          }}\n        >\n          5\n        </span>\n        Proposal and permissions\n      </h2>\n\n      <div>\n        <h3 className=\"h6 fw-bold mb-0\">Proposal creation</h3>\n        <p className=\"text-black-50 fw-light small\">\n          Choose what creation rights you give DAO groups. This can be changed\n          in settings later.\n        </p>\n        {renderTable(rolesArray, proposalKinds, \"AddProposal\")}\n      </div>\n\n      <div>\n        <h3 className=\"h6 fw-bold mb-0\">Voting Permissions</h3>\n        <p className=\"text-black-50 fw-light small\">\n          Choose what voting permissions you give DAO groups.\n        </p>\n        {renderTable(rolesArray, proposalKinds, \"Vote\")}\n      </div>\n    </div>\n\n    {renderFooter(state.answers)}\n  </div>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/astro.sking.near/widget/CreateDAO.Step5", "fact_widget_deployments_id": "d5d1c8de7353e5b9527db53f2ccae1e2", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 6}