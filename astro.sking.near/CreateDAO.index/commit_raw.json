{"tx_hash": "2vmhEwDs4Dy8F774RhCfVaoUaPRXKk7myjxSyYXw42TY", "action_id_social": "3YfoohoyUCPKRV5BRvWeTFRE2aMnhPeBaQwnURcADodR-0-widget", "block_id": 97968505, "block_timestamp": "2023-08-03T08:02:16.507Z", "signer_id": "astro.sking.near", "widget_name": "CreateDAO.index", "source_code": "// -- Read and process types from SocialDB + helper functions\n\nconst isPrimitiveType = (type) =>\n  [\"string\", \"number\", \"boolean\"].includes(type);\n\nconst isComplexType = (type) =>\n  Array.isArray(type)\n    ? \"typesArray\"\n    : type === \"array\"\n    ? \"array\"\n    : typeof type === \"object\"\n    ? \"object\"\n    : typeof type === \"string\" && !isPrimitiveType(type)\n    ? \"custom\"\n    : null;\n\nconst rawTypes = Social.get(\"astro.sking.near/type/*\", \"final\");\nif (rawTypes === null) return null;\n\n// It finds custom types in the type definitions and fetches them from SocialDB.\nfunction getCustomTypes(type, depth) {\n  depth = depth || 0;\n  if (depth > 10) {\n    throw {\n      message: `Maximum type depth exceeded, please check your type definitions.`,\n      depth,\n      current: type,\n      types,\n    };\n  }\n\n  type.properties.forEach((prop) => {\n    (Array.isArray(prop.type) ? prop.type : [prop.type]).forEach((type) => {\n      if (isComplexType(type) === \"custom\" && !types[type]) {\n        const rawType = Social.get(`${type}`, \"final\");\n        if (rawType) {\n          types[type] = JSON.parse(rawType);\n          getCustomTypes(types[type], depth + 1);\n        }\n      }\n    });\n  });\n}\n\nObject.keys(rawTypes).forEach((key) => {\n  const type = JSON.parse(rawTypes[key]);\n  types[\"astro.sking.near/type/\" + key] = type;\n  getCustomTypes(type);\n});\n\nconst PRIMITIVE_VALIDATIONS = {\n  string: (value, { min, max, pattern }) => {\n    if (typeof value !== \"string\")\n      return `Expected a string, got ${typeof value}.`;\n\n    if (min && value.length < min)\n      return `Must be at least ${min} characters long.`;\n\n    if (max && value.length > max)\n      return `Must be at most ${max} characters long.`;\n\n    if (pattern && !value.match(pattern))\n      return `The value \"${value}\" does not match expected pattern: ${pattern}`;\n  },\n  number: (value, { min, max }) => {\n    if (typeof value !== \"number\")\n      return `Expected a number, got ${typeof value}.`;\n\n    if (min && value < min) return `Must be at least ${min}.`;\n\n    if (max && value > max) return `Must be at most ${max}.`;\n  },\n  boolean: (value) => {\n    if (typeof value !== \"boolean\")\n      return `Expected a boolean, got ${typeof value}.`;\n  },\n};\n\nfunction validatePrimitiveType(type, value, constraints) {\n  if (!isPrimitiveType(type))\n    throw {\n      message: `Unknown primitive type: ${type}`,\n      type,\n      value,\n    };\n\n  return PRIMITIVE_VALIDATIONS[type](value, constraints);\n}\n\nfunction validateType(type, value, parent) {\n  if (value === undefined || value === \"\" || value === null) {\n    if (parent.required) {\n      return `This field is required but missing.`;\n    }\n    return;\n  }\n\n  if (isPrimitiveType(type))\n    return validatePrimitiveType(type, value, parent[type].validation);\n\n  if (isComplexType(type) === \"typesArray\") {\n    const errors = [];\n    for (const subType of type) {\n      const error = validateType(subType, value, parent[subType]);\n      if (!error) return; // Stop if a valid type is found\n      errors.push(error);\n    }\n    if (errors.length === type.length) {\n      // only return the deepest error\n      for (const error of errors) {\n        if (typeof error === \"object\") return error;\n      }\n      return errors[errors.length - 1];\n    }\n  }\n\n  if (isComplexType(type) === \"array\") {\n    if (!Array.isArray(value)) {\n      return `Expected an array, got ${typeof value}.`;\n    }\n\n    if (\n      parent[\"array\"].validation.min &&\n      value.length < parent[\"array\"].validation.min\n    ) {\n      return `Must have at least ${parent[\"array\"].validation.min} items.`;\n    }\n\n    if (\n      parent[\"array\"].validation.max &&\n      value.length > parent[\"array\"].validation.max\n    ) {\n      return `Must have at most ${parent[\"array\"].validation.max} items.`;\n    }\n\n    for (const item of value) {\n      const error = validateType(parent[\"array\"].type, item, parent[\"array\"]);\n      if (error)\n        return {\n          [value.indexOf(item)]: error,\n        };\n    }\n  }\n\n  if (isComplexType(type) === \"object\") {\n    if (typeof value !== \"object\" || Array.isArray(value)) {\n      return `Expected an object, got ${typeof value}.`;\n    }\n\n    // Validate properties of the object\n    for (const property of type.properties) {\n      const propName = property.name;\n      const propType = property.type;\n      const propValue = value[propName];\n\n      if (property.required && propValue === undefined) {\n        return `Property ${propName} is required but missing.`;\n      }\n\n      if (propValue !== undefined) {\n        const error = validateType(propType, propValue, property);\n        if (error)\n          return {\n            [propName]: error,\n          };\n      }\n    }\n  }\n\n  if (isComplexType(type) === \"custom\") {\n    return validateType(types[type], value);\n  }\n}\n\nconst typeToEmptyData = (type) => {\n  if (isPrimitiveType(type)) {\n    switch (type) {\n      case \"string\":\n        return \"\";\n      case \"number\":\n        return null;\n      case \"boolean\":\n        return null;\n    }\n  }\n  if (isComplexType(type) === \"array\") {\n    return [];\n  }\n  if (isComplexType(type) === \"typesArray\") {\n    return typeToEmptyData(type[0]);\n  }\n  if (isComplexType(type) === \"object\") {\n    const obj = {};\n\n    type.properties.forEach((prop) => {\n      const propType =\n        isComplexType(prop.type) === \"typesArray\" ? prop.type[0] : prop.type;\n\n      if (isPrimitiveType(propType)) {\n        obj[prop.name] = typeToEmptyData(propType);\n      } else if (isComplexType(propType) === \"array\") {\n        obj[prop.name] = typeToEmptyData(propType);\n      } else if (isComplexType(propType) === \"object\") {\n        obj[prop.name] = typeToEmptyData(prop[propType]);\n      } else if (isComplexType(propType) === \"custom\") {\n        obj[prop.name] = typeToEmptyData(types[propType]);\n      }\n    });\n\n    return obj;\n  }\n  if (isComplexType(type) === \"custom\") {\n    return typeToEmptyData(types[type]);\n  }\n};\n\nreturn (\n  <Widget\n    src=\"astro.sking.near/widget/CreateDAO.form\"\n    props={{\n      validateType,\n      typeToEmptyData,\n      types,\n    }}\n  />\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/astro.sking.near/widget/CreateDAO.index", "fact_widget_deployments_id": "0d8975bd4c0aa34b2ea657856040bfe1", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 5}