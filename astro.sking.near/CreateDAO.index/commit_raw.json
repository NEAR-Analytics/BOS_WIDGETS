{"tx_hash": "8WFynkGx5r4mbDH9tu929frAyQuhpmmDXh1SP3ESLjFP", "action_id_social": "ETiPTJeyLzPxKF7fSwukj4nQe5r9WGG7mksLYR2nt182-0-widget", "block_id": 97894309, "block_timestamp": "2023-08-02T05:41:40.053Z", "signer_id": "astro.sking.near", "widget_name": "CreateDAO.index", "source_code": "// -- Read and process types from SocialDB + helper functions\nconst rawTypes = Social.get(\"astro.sking.near/type/*\", \"final\");\nif (rawTypes === null) return null;\n\nconst primitives = [\"string\", \"number\", \"boolean\", \"object\", \"array\"];\nconst types = {};\n\nfunction parseType(type, depth) {\n  depth = depth || 0;\n  if (depth > 10) {\n    throw {\n      message: `Maximum type depth exceeded, please check your type definitions.`,\n      depth,\n      current: type,\n      types,\n    };\n  }\n\n  type.properties.forEach((prop) => {\n    (Array.isArray(prop.type) ? prop.type : [prop.type]).forEach((type) => {\n      if (!primitives.includes(type)) {\n        if (types[type]) return;\n        const rawType = Social.get(`${type}`, \"final\");\n        if (rawType) {\n          types[type] = JSON.parse(rawType);\n          parseType(types[type], depth + 1);\n        }\n      }\n    });\n  });\n}\n\nconst typeToObj = ({ properties }) => {\n  const obj = {};\n  properties.forEach((prop) => {\n    const type = Array.isArray(prop.type) ? prop.type[0] : prop.type;\n    if (!primitives.includes(type)) {\n      if (typeof type === \"object\" && type.properties) {\n        obj[prop.name] = typeToObj(type);\n      } else if (typeof type === \"string\" && types[type].properties) {\n        obj[prop.name] = typeToObj(types[type]);\n      } else {\n        // unknown type, just set to empty string\n        obj[prop.name] = \"\";\n      }\n      return;\n    }\n    if (type === \"array\") {\n      obj[prop.name] = [];\n    } else if (type === \"object\") {\n      obj[prop.name] = {};\n    } else {\n      obj[prop.name] = prop.default ?? \"\";\n    }\n  });\n  return obj;\n};\n\nconst validatePrimitive = (type, value, options) => {\n  switch (type) {\n    case \"string\":\n      if (typeof value !== \"string\")\n        return { valid: false, message: \"Expected a string.\" };\n      if (options?.min && value.length < options.min)\n        return {\n          valid: false,\n          message: `Expected at least ${options.min} characters.`,\n        };\n      if (options?.max && value.length > options.max)\n        return {\n          valid: false,\n          message: `Expected at most ${options.max} characters.`,\n        };\n      if (options?.pattern && !value.match(options.pattern))\n        return {\n          valid: false,\n          message: `Does not match expected pattern: ${options.pattern}`,\n        };\n      return { valid: true };\n\n    case \"number\":\n      if (typeof value !== \"number\")\n        return { valid: false, message: \"Expected a number.\" };\n      if (options?.min && value < options.min)\n        return {\n          valid: false,\n          message: `Expected a number greater than or equal to ${options.min}.`,\n        };\n      if (options?.max && value > options.max)\n        return {\n          valid: false,\n          message: `Expected a number less than or equal to ${options.max}.`,\n        };\n      return { valid: true };\n\n    case \"boolean\":\n      if (typeof value !== \"boolean\")\n        return { valid: false, message: \"Expected a boolean.\" };\n      return { valid: true };\n\n    case \"array\":\n      if (!Array.isArray(value))\n        return { valid: false, message: \"Expected an array.\" };\n      if (options?.min && value.length < options.min)\n        return {\n          valid: false,\n          message: `Expected at least ${options.min} items.`,\n        };\n      if (options?.max && value.length > options.max)\n        return {\n          valid: false,\n          message: `Expected at most ${options.max} items.`,\n        };\n      if (options?.type) {\n        for (let v of value) {\n          const result = validatePrimitive(options.type, v);\n          if (!result.valid) {\n            return {\n              valid: false,\n              message: `An item in the array is invalid: ${result.message}`,\n            };\n          }\n        }\n      }\n      return { valid: true };\n\n    case \"object\":\n      if (typeof value !== \"object\")\n        return { valid: false, message: \"Expected an object.\" };\n      if (options?.min && Object.keys(value).length < options.min)\n        return {\n          valid: false,\n          message: `Expected at least ${options.min} properties.`,\n        };\n      if (options?.max && Object.keys(value).length > options.max)\n        return {\n          valid: false,\n          message: `Expected at most ${options.max} properties.`,\n        };\n      return { valid: true };\n  }\n};\n\nconst validate = (type, value, parent) => {\n  if (value === undefined || value === \"\" || value === null) {\n    if (parent.required) {\n      return { valid: false, message: \"This field is required.\" };\n    }\n    return {\n      valid: true,\n    };\n  }\n\n  if (Array.isArray(type)) {\n    return type.some((t) => validate(t, value, parent));\n  }\n  if (typeof type === \"object\") {\n    if (type.properties) {\n      return type.properties.every((prop) => {\n        if (prop.required && value[prop.name] === undefined)\n          return {\n            valid: false,\n            message: \"This field is required.\",\n          };\n        const val = value[prop.name];\n        if (val === undefined)\n          return {\n            valid: true,\n          };\n        return validate(prop.type, val, prop);\n      });\n    }\n  }\n  if (typeof type === \"string\") {\n    if (primitives.includes(type)) {\n      return validatePrimitive(type, value, parent[type]);\n    }\n    if (types[type]) {\n      return validate(types[type], value, parent);\n    }\n  }\n  return { valid: true };\n};\n\nObject.keys(rawTypes).forEach((key) => {\n  const type = JSON.parse(rawTypes[key]);\n  types[\"astro.sking.near/type/\" + key] = type;\n  parseType(type);\n});\n\n// --\n\n// -- form state\nconst initialFormState = typeToObj(types[\"astro.sking.near/type/dao\"]);\n\nState.init({\n  step: 0,\n  form: initialFormState,\n  errors: null,\n});\n\nconst handleStepComplete = (value) => {\n  const stepValid = true;\n  Object.keys(value).forEach((key) => {\n    const properties = types[\"astro.sking.near/type/dao\"].properties.find(\n      (p) => p.name === key\n    );\n    const validation = validate(properties.type, value[key], properties);\n    console.log(key, value, validation);\n    if (validation.valid === false) {\n      State.update({\n        errors: {\n          ...state.errors,\n          [key]: validation.message,\n        },\n      });\n      stepValid = false;\n    } else {\n      State.update({\n        errors: {\n          ...state.errors,\n          [key]: null,\n        },\n      });\n    }\n  });\n\n  if (stepValid) {\n    State.update({\n      step: state.step + 1,\n      form: {\n        ...state.form,\n        ...value,\n      },\n    });\n  }\n};\n\nconsole.log(\"render\", state);\n\nconst steps = [\n  {\n    title: \"DAO Info & KYC\",\n    active: state.step === 0,\n    icon: state.step > 0 ? <i className=\"bi bi-check2\"></i> : undefined,\n    className: state.step > 0 ? \"active-outline\" : undefined,\n  },\n  {\n    title: \"Links & Socials\",\n    active: state.step === 1,\n    icon: state.step > 1 ? <i className=\"bi bi-check2\"></i> : undefined,\n    className: state.step > 1 ? \"active-outline\" : undefined,\n  },\n  {\n    title: \"Cool Down Period\",\n    active: state.step === 2,\n    icon: state.step > 2 ? <i className=\"bi bi-check2\"></i> : undefined,\n    className: state.step > 2 ? \"active-outline\" : undefined,\n  },\n  {\n    title: \"Add Groups & Members\",\n    active: state.step === 3,\n    icon: state.step > 3 ? <i className=\"bi bi-check2\"></i> : undefined,\n    className: state.step > 3 ? \"active-outline\" : undefined,\n  },\n  {\n    title: \"Proposal & Voting Permission\",\n    active: state.step === 4,\n    icon: state.step > 4 ? <i className=\"bi bi-check2\"></i> : undefined,\n    className: state.step > 4 ? \"active-outline\" : undefined,\n  },\n  {\n    title: \"DAO Assets\",\n    active: state.step === 5,\n    icon: state.step > 5 ? <i className=\"bi bi-check2\"></i> : undefined,\n    className: state.step > 5 ? \"active-outline\" : undefined,\n  },\n];\n\nreturn (\n  <>\n    <h1 className=\"h3 fw-bold mb-4\">Create a new DAO</h1>\n    <Widget\n      src={`nui.sking.near/widget/Navigation.Steps`}\n      props={{\n        steps: steps,\n        onClick: (i) => {\n          State.update({\n            step: i,\n          });\n        },\n      }}\n    />\n    <Widget\n      src={`astro.sking.near/widget/CreateDAO.Step${state.step + 1}`}\n      props={{\n        formState: state.form,\n        onComplete: handleStepComplete,\n        errors: state.errors,\n        renderFooter: (stepState) => (\n          <Widget\n            src={`astro.sking.near/widget/CreateDAO.Footer`}\n            props={{\n              isLast: state.step >= steps.length - 1,\n              hasPrevious: state.step > 0,\n              onNext: () => {\n                handleStepComplete(stepState);\n              },\n              onPrevious: () => {\n                State.update({\n                  step: state.step - 1,\n                });\n              },\n            }}\n          />\n        ),\n      }}\n    />\n  </>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/astro.sking.near/widget/CreateDAO.index", "fact_widget_deployments_id": "e1516992f5d55b52cb67d0d74595586b", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 4}