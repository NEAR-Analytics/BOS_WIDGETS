{"tx_hash": "7KWT8Mp9UpCUy6enaPhnPnhBMYSkC9iwSpfgC6k1zPC1", "action_id_social": "AJVGX39TBGrhRdb5Gb7LLUtSzbGHXufjRArZEAoonVxf-0-widget", "block_id": 104718697, "block_timestamp": "2023-11-01T22:26:10.038Z", "signer_id": "aaron.near", "widget_name": "VitalPointAI.Notifications.NotificationsList", "source_code": "const accountId = context.accountId;\nconst showLimit = props?.showLimit;\nconst showInBox = props?.showInBox;\n\nif (!accountId) {\n  return <></>;\n}\n\nconst index = {\n  action: \"notify\",\n  key: accountId,\n  options: {\n    limit: 10,\n    order: \"desc\",\n    subscribe: true,\n  },\n};\n\nconst renderItem = (item, i) => {\n  if (i === 0) {\n    Storage.set(\"lastBlockHeight\", item.blockHeight);\n  }\n  const { accountId: initiator } = item;\n  return (\n    <Widget\n      src=\"aaron.near/widget/VitalPointAI.Notifications.Notification\"\n      key={i}\n      props={{ initiator, ...item }}\n    />\n  );\n};\n\nif (!index) {\n  return <></>;\n}\n\nconst moderatorAccount = props?.moderatorAccount || \"bosmod.near\";\n\nconst filterUsersRaw = Social.get(\n  `${moderatorAccount}/moderate/users`, //TODO\n  \"optimistic\",\n  {\n    subscribe: true,\n  }\n);\nif (filterUsers === null) {\n  // haven't loaded filter list yet, return early\n  return \"\";\n}\nconst filterUsers = filterUsersRaw ? JSON.parse(filterUsersRaw) : [];\n\n// WIP refresh in place when moderation list changes\n// const jFilterUsers = JSON.stringify(filterUsers);\n// if (state.filterUsers !== jFilterUsers) {\n//   State.update({ filterUsers: jFilterUsers, cachedItems: {} });\n// }\n\n// get the full list of posts that the current user has flagged so\n// they can be hidden\nconst selfFlaggedPosts = context.accountId\n  ? Social.index(\"flag\", \"main\", {\n      accountId: context.accountId,\n    })\n  : [];\n\n// declares that a post/comment should be filtered if it is authored\n// by an account on the global block list or if the user has personally\n// flagged the item for moderation\nconst shouldFilter = (item) => {\n  return (\n    filterUsers.includes(item.accountId) ||\n    selfFlaggedPosts.find((flagged) => {\n      let itemPath;\n      switch (index.action) {\n        case \"comment\":\n          itemPath = `${item.accountId}/post/comment`;\n          break;\n        case \"post\":\n          itemPath = `${item.accountId}/post/main`;\n          break;\n        case \"discuss\":\n          itemPath = `${item.accountId}/discuss`;\n          break;\n        default:\n          console.log(\"Found flagged item of unknown type: \", item);\n          break;\n      }\n      return (\n        flagged?.value?.blockHeight === item.blockHeight &&\n        flagged?.value?.path === itemPath\n      );\n    })\n  );\n};\n\n// const renderItem =\n//   props.renderItem ??\n//   ((item, i) => (\n//     <div key={i}>\n//       #{item.blockHeight}: {JSON.stringify(item)}\n//     </div>\n//   ));\nconst cachedRenderItem = (item, i) => {\n  if (showLimit && i >= showLimit) {\n    return;\n  }\n  const key = JSON.stringify(item);\n\n  if (!(key in state.cachedItems)) {\n    state.cachedItems[key] = renderItem(item, i);\n    State.update();\n  }\n  return state.cachedItems[key];\n};\n\nindex.options = index.options || {};\nconst initialRenderLimit =\n  props.initialRenderLimit ?? index.options.limit ?? 10;\nconst addDisplayCount = props.nextLimit ?? initialRenderLimit;\n\nindex.options.limit = Math.min(\n  Math.max(initialRenderLimit + addDisplayCount * 2, index.options.limit ?? 0),\n  100\n);\nconst reverse = !!props.reverse;\n\nlet initialItems = Social.index(index.action, index.key, index.options);\n\nif (initialItems === null) {\n  return \"\";\n}\nconst initialFoundItems = !!initialItems.length;\n// moderate\ninitialItems = initialItems.filter((i) => !shouldFilter(i));\n\nconst computeFetchFrom = (items, limit, previouslyFoundItems) => {\n  // we must get an explicit bool on whether we previously found items\n  // in order to determine whether to do the next fetch since we can't\n  // rely on the previous fetched count being less than the limit with\n  // moderation now in the picture\n  if (!previouslyFoundItems) {\n    return false;\n  }\n\n  const blockHeight = items[items.length - 1].blockHeight;\n  return index.options.order === \"desc\" ? blockHeight - 1 : blockHeight + 1;\n};\n\nconst mergeItems = (newItems) => {\n  const items = [\n    ...new Set(\n      [...newItems, ...(state.items || [])].map((i) => JSON.stringify(i))\n    ),\n  ].map((i) => JSON.parse(i));\n  items.sort((a, b) => a.blockHeight - b.blockHeight);\n  if (index.options.order === \"desc\") {\n    items.reverse();\n  }\n  return items;\n};\n\nconst jInitialItems = JSON.stringify(initialItems);\nif (state.jInitialItems !== jInitialItems) {\n  const jIndex = JSON.stringify(index);\n  if (jIndex !== state.jIndex) {\n    State.update({\n      jIndex,\n      jInitialItems,\n      items: initialItems,\n      fetchFrom: false,\n      nextFetchFrom: computeFetchFrom(\n        initialItems,\n        index.options.limit,\n        initialFoundItems\n      ),\n      displayCount: initialRenderLimit,\n      cachedItems: {},\n    });\n  } else {\n    State.update({\n      jInitialItems,\n      items: mergeItems(initialItems),\n    });\n  }\n}\n\nif (state.fetchFrom) {\n  const limit = addDisplayCount;\n  let newItems = Social.index(\n    index.action,\n    index.key,\n    Object.assign({}, index.options, {\n      from: state.fetchFrom,\n      subscribe: undefined,\n      limit,\n    })\n  );\n  if (newItems !== null) {\n    const newFoundItems = !!newItems.length;\n    // moderate\n    newItems = newItems.filter((i) => !shouldFilter(i));\n    State.update({\n      items: mergeItems(newItems),\n      fetchFrom: false,\n      nextFetchFrom: computeFetchFrom(newItems, limit, newFoundItems),\n    });\n  }\n}\n\nconst makeMoreItems = () => {\n  State.update({\n    displayCount: state.displayCount + addDisplayCount,\n  });\n  if (\n    state.items.length - state.displayCount < addDisplayCount * 2 &&\n    !state.fetchFrom &&\n    state.nextFetchFrom &&\n    state.nextFetchFrom !== state.fetchFrom\n  ) {\n    State.update({\n      fetchFrom: state.nextFetchFrom,\n    });\n  }\n};\n\nconst loader = (\n  <div className=\"loader\" key={\"loader\"}>\n    <span\n      className=\"spinner-grow spinner-grow-sm me-1\"\n      role=\"status\"\n      aria-hidden=\"true\"\n    />\n    Loading ...\n  </div>\n);\n\nconst fetchMore =\n  props.manual &&\n  (state.fetchFrom && state.items.length < state.displayCount\n    ? loader\n    : state.displayCount < state.items.length && (\n        <div key={\"loader more\"}>\n          <button type=\"button\" onClick={(e) => makeMoreItems()}>\n            {props.loadMoreText ?? \"Load more...\"}\n          </button>\n        </div>\n      ));\n\nconst items = state.items ? state.items.slice(0, state.displayCount) : [];\nif (reverse) {\n  items.reverse();\n}\n\nconst renderedItems = items.map(cachedRenderItem);\n\nreturn props.manual ? (\n  <>\n    {reverse && fetchMore}\n    {renderedItems}\n    {!reverse && fetchMore}\n  </>\n) : (\n  <InfiniteScroll\n    pageStart={0}\n    loadMore={makeMoreItems}\n    hasMore={state.displayCount < state.items.length}\n    loader={\n      <div className=\"loader\">\n        <span\n          className=\"spinner-grow spinner-grow-sm me-1\"\n          role=\"status\"\n          aria-hidden=\"true\"\n        />\n        Loading ...\n      </div>\n    }\n  >\n    {renderedItems}\n  </InfiniteScroll>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/aaron.near/widget/VitalPointAI.Notifications.NotificationsList", "fact_widget_deployments_id": "3e192326fbfd3a5198a8cf71a9af498a", "inserted_timestamp": "2023-11-02T00:29:23.867Z", "modified_timestamp": "2023-11-02T00:29:23.867Z", "__row_index": 0}