{"tx_hash": "2uaJB4jwagyk6UrGtENzcGgvUugje7boqoTZB23JX46m", "action_id_social": "2eV9BsUpYZ2BXeDmPVBFXk8zwYZX1pi3HrMVbpgPyUrG-0-widget", "block_id": 104575592, "block_timestamp": "2023-10-31T00:37:19.283Z", "signer_id": "owa-is-bos.near", "widget_name": "Maverick-LP-NewPool", "source_code": "const routerAbi = fetch(\n  \"https://raw.githubusercontent.com/yaairnaavaa/Maverick/main/maverick-router.txt\"\n);\n\nconst positionAbi = fetch(\n  \"https://raw.githubusercontent.com/yaairnaavaa/Maverick/main/maverick-position.txt\"\n);\n\nif (!routerAbi.ok) {\n  return \"Loading\";\n}\nconst tokensForNEtwork = fetch(\"https://api.mav.xyz/api/v3/allTokens/5\").body\n  .tokens;\n\nconst POOLSMODE = [\n  {\n    id: 0,\n    name: \"Mode Static\",\n    description:\n      \"This mode features static bins that you can use to define your own custom liquidity strategy.\",\n    img: \"https://raw.githubusercontent.com/yaairnaavaa/Maverick/main/ModeStatic.gif\",\n  },\n  {\n    id: 1,\n    name: \"Mode Right\",\n    description:\n      \"This mode functions like a dynamic range order that follows the price of USDC up.\",\n    img: \"https://raw.githubusercontent.com/yaairnaavaa/Maverick/main/ModeRight.gif\",\n  },\n  {\n    id: 2,\n    name: \"Mode Left\",\n    description:\n      \"This mode functions like a dynamic range order that follows the price of cBUSD up.\",\n    img: \"https://raw.githubusercontent.com/yaairnaavaa/Maverick/main/ModeLeft.gif\",\n  },\n  {\n    id: 3,\n    name: \"Mode Both\",\n    description:\n      \"This mode functions like a dynamic range order that follows the pool price right and left, keeping liquidity as active as possible.\",\n    img: \"https://raw.githubusercontent.com/yaairnaavaa/Maverick/main/ModeBoth.gif\",\n  },\n];\n\nconst DISTRIBUTIONMODE = [\n  {\n    name: \"Exponential\",\n    description:\n      \"This distribution starts with a high concentration of liquidity around the current pool price and adds exponentially decreasing amounts across the bins to the left and right.\",\n  },\n  {\n    name: \"Flat\",\n    description:\n      \"This will distribute your liquidity evenly across bins, centered around the current pool price.\",\n  },\n  {\n    name: \"Single Bin\",\n    description: \"This will distribute your liquidity only in the active bin\",\n  },\n];\n\nState.init({\n  isZkSync: false,\n  routerContract: \"0x9563Fdb01BFbF3D6c548C2C64E446cb5900ACA88\",\n  positionContract: \"0x46040d596fe176A1b88A43be3537d9f6365ccbe1\",\n  step: 1,\n  step1TokenAAmount: 0,\n  refStep1Amount: null,\n  newTokenASelected: tokensForNEtwork.find(\n    (option) => option.name === tokensForNEtwork[0].name\n  ),\n  newTokenBSelected: tokensForNEtwork.find(\n    (option) => option.name === tokensForNEtwork[1].name\n  ),\n  tokenOptionsA: tokensForNEtwork.filter(\n    (option) => option.name != tokensForNEtwork[1].name\n  ),\n  tokenOptionsB: tokensForNEtwork.filter(\n    (option) => option.name != tokensForNEtwork[0].name\n  ),\n  tokensForNetwork: tokensForNEtwork,\n  poolSelected: POOLS[0],\n  poolModeSelected: POOLSMODE[0],\n  poolDistributionSelected: DISTRIBUTIONMODE[0],\n  amountInputTokenA: null,\n  inputBalanceTokenA: null,\n  amountInputTokenB: null,\n  inputBalanceTokenB: null,\n  fee: 0,\n  width: 0,\n  showSelectOptionsModal: false,\n  show: false,\n  need2Tokens: true,\n});\n\nconst getUserBalances = () => {\n  const accounts = Ethers.send(\"eth_requestAccounts\", []);\n  asyncFetch(`https://api.mav.xyz/api/v3/tokenBalances/5/${accounts[0]}`)\n    .catch((err) => {\n      console.log(err);\n    })\n    .then((res) => {\n      State.update({ userBalances: res.body.tokenBalances });\n    });\n};\n\nconst getApprovedNFT = () => {\n  const position = new ethers.Contract(\n    state.positionContract,\n    positionAbi.body,\n    Ethers.provider().getSigner()\n  );\n\n  try {\n    position.getApproved(state.poolSelected.nftId).then((res) => {\n      console.log(\"approvedNFT: \" + parseInt(res, 16));\n      State.update({ approveNFT: parseInt(res, 16) });\n    });\n  } catch (err) {\n    console.log(err);\n  }\n};\n\nconst getNFTUser = () => {\n  const accounts = Ethers.send(\"eth_requestAccounts\", []);\n  asyncFetch(`https://api.mav.xyz/api/v3/user/${accounts[0]}/5`)\n    .catch((err) => {\n      console.log(err);\n    })\n    .then((res) => {\n      if (res.body.user.positions.length > 0) {\n        State.update({ userNFT: res.body.user.positions[0].nftId });\n        console.log(\"nft\", res.body.user.positions[0].nftId);\n      }\n    });\n};\n\nconst handleTokenSelect = (token, _sel) => {\n  const _tokenin = tokensForNEtwork.find((p) => p.name === token.target.value);\n  const filteredOptions = tokensForNEtwork.filter(\n    (option) => option.name !== token.target.value\n  );\n  _sel === \"A\"\n    ? State.update({\n        newTokenASelected: _tokenin,\n        tokenOptionsB: filteredOptions,\n      })\n    : State.update({\n        newTokenBSelected: _tokenin,\n        tokenOptionsA: filteredOptions,\n      });\n};\n\nconst handlePoolModeSelect = (data) => {\n  const mode = POOLSMODE.find((m) => m.name === data.target.value);\n  State.update({ poolModeSelected: mode });\n};\n\nconst handlePoolDistributionSelect = (data) => {\n  const mode = DISTRIBUTIONMODE.find((m) => m.name === data.target.value);\n  State.update({ poolDistributionSelected: mode });\n};\n\nconst getNetwork = () => {\n  let chainId = 5;\n  Ethers.provider()\n    .getNetwork()\n    .then((res) => {\n      if (res.chainId == chainId) {\n        State.update({ isZkSync: true });\n      } else {\n        switchNetwork(5);\n      }\n    });\n};\n\nconst switchNetwork = (chainId) => {\n  Ethers.provider().send(\"wallet_switchEthereumChain\", [\n    { chainId: `0x${chainId.toString(16)}` },\n  ]);\n};\n\nif (state.sender === undefined) {\n  const accounts = Ethers.send(\"eth_requestAccounts\", []);\n  if (accounts.length) {\n    State.update({ sender: accounts[0] });\n    getNetwork();\n    getNFTUser();\n    getApprovedNFT();\n    state.userBalances ? \"\" : getUserBalances();\n  }\n}\n\nconst next = () => {\n  console.log(\"state\", state);\n  if (\n    (state.step === 1 && state.step1TokenAAmount <= 0) ||\n    state.fee === 0 ||\n    state.width === 0\n  ) {\n    return;\n  } else {\n    if (state.step + 1 == 2) {\n      setUserBalances();\n    } else if (state.step + 1 == 3) {\n      if (!(state.tokenAAllowance || state.tokenBAllowance)) {\n        getAccountAllowance({\n          token: state.newTokenASelected,\n          vAllowance: false,\n          mode: \"TA\",\n        });\n        getAccountAllowance({\n          token: state.newTokenBSelected,\n          vAllowance: false,\n          mode: \"TB\",\n        });\n      }\n    }\n    State.update({ step: state.step + 1 });\n  }\n};\n\nconst back = () => {\n  State.update({ step: state.step - 1 });\n};\n\nconst formatNumber = (n) => {\n  if (n >= 1000000) {\n    return \"$\" + (n / 1000000).toFixed(2) + \"m\";\n  } else if (n >= 1000) {\n    return \"$\" + (n / 1000).toFixed(2) + \"k\";\n  } else {\n    return \"$\" + n.toFixed(2);\n  }\n};\n\nconst setUserBalances = () => {\n  console.log(\"entra a set de balances\");\n  const tokABalance = state.userBalances.find(\n    (token) => token.symbol == state.newTokenASelected.symbol\n  );\n  const tokBBalance = state.userBalances.find(\n    (token) => token.symbol == state.newTokenBSelected.symbol\n  );\n  console.log(\"balance a \", tokABalance);\n  console.log(\"balance b \", tokBBalance);\n  tokABalance\n    ? State.update({\n        tokenABalance: {\n          fixed: (\n            parseFloat(tokABalance.tokenBalance).toFixed(6) - 0.000001\n          ).toString(),\n          unfixed: tokABalance.tokenBalanceBN,\n        },\n      })\n    : State.update({ tokABalance: undefined });\n  tokBBalance\n    ? State.update({\n        tokenBBalance: {\n          fixed: (\n            parseFloat(tokBBalance.tokenBalance).toFixed(6) - 0.000001\n          ).toString(),\n          unfixed: tokBBalance.tokenBalanceBN,\n        },\n      })\n    : State.update({ tokBBalance: undefined });\n};\n\nconst setMaxBalanceTokenA = () => {\n  if (state.tokenABalance.fixed > 0) {\n    State.update({ amountInputTokenA: state.tokenABalance.fixed });\n  }\n};\n\nconst setMaxBalanceTokenB = () => {\n  if (state.tokenBBalance.fixed > 0) {\n    State.update({ amountInputTokenB: state.tokenBBalance.fixed });\n  }\n};\n\nconst validateAllowance = (input, mode) => {\n  let divider, tokenAllowance;\n  if (mode == \"TA\") {\n    divider =\n      state.newTokenASelected.decimals == 18 ? 1000000000000000000 : 1000000;\n    tokenAllowance = state.tokenAAllowance / divider;\n    input * 1 > tokenAllowance\n      ? State.update({ moreTokenAAllowance: true })\n      : State.update({ moreTokenAAllowance: false });\n  } else {\n    divider =\n      state.newTokenBSelected.decimals == 18 ? 1000000000000000000 : 1000000;\n    tokenAllowance = state.tokenBAllowance / divider;\n    input * 1 > tokenAllowance\n      ? State.update({ moreTokenBAllowance: true })\n      : State.update({ moreTokenBAllowance: false });\n  }\n};\n\nconst handleInputTokenA = (input) => {\n  console.log(\"entra handle input A\", state.poolModeSelected.id);\n  if (state.poolModeSelected.id == 0 || state.poolModeSelected.id == 3) {\n    const step1TokenAAmount = parseFloat(state.step1TokenAAmount);\n    const width = state.width / 100;\n    const tickSpacing = Math.ceil(Math.log(1 + width) / Math.log(1.0001));\n    const ic = Math.floor(\n      Math.log(step1TokenAAmount) / (Math.log(1.0001) * tickSpacing)\n    );\n    const il = Math.pow(1.0001, ic * tickSpacing);\n    const iu = Math.pow(1.0001, (ic + 1) * tickSpacing);\n\n    let deltaX = 0;\n    let deltaY = 0;\n    let deltaL = 1;\n\n    if (step1TokenAAmount < il) {\n      deltaX = deltaL * (1 / Math.sqrt(il) - 1 / Math.sqrt(iu));\n      deltaY = 0;\n    }\n    if (il <= step1TokenAAmount && step1TokenAAmount < iu) {\n      deltaX = deltaL * (1 / Math.sqrt(step1TokenAAmount) - 1 / Math.sqrt(iu));\n      deltaY = deltaL * (Math.sqrt(step1TokenAAmount) - Math.sqrt(il));\n    }\n    if (step1TokenAAmount >= iu) {\n      deltaX = 0;\n      deltaY = Math.sqrt(iu) - Math.sqrt(il);\n    }\n\n    let tokenB = 0;\n    if (ic !== 0) {\n      tokenB = input * (deltaX / deltaY);\n      State.update({\n        amountInputTokenB: tokenB,\n        amountInputTokenA: input,\n        validation: undefined,\n      });\n    } else {\n      State.update({\n        amountInputTokenA: 0,\n        validation: undefined,\n        need2Tokens: false,\n      });\n    }\n  }\n};\n\nconst handleInputTokenB = (input) => {\n  console.log(\"entra handle input B\", state.poolModeSelected.id);\n  if (state.poolModeSelected.id == 0 || state.poolModeSelected.id == 3) {\n    const step1TokenAAmount = parseFloat(state.step1TokenAAmount);\n    const width = state.width / 100;\n    const tickSpacing = Math.ceil(Math.log(1 + width) / Math.log(1.0001));\n    const ic = Math.floor(\n      Math.log(step1TokenAAmount) / (Math.log(1.0001) * tickSpacing)\n    );\n    const il = Math.pow(1.0001, ic * tickSpacing);\n    const iu = Math.pow(1.0001, (ic + 1) * tickSpacing);\n\n    let deltaX = 0;\n    let deltaY = 0;\n    let deltaL = 1;\n\n    if (step1TokenAAmount < il) {\n      deltaX = deltaL * (1 / Math.sqrt(il) - 1 / Math.sqrt(iu));\n      deltaY = 0;\n    }\n    if (il <= step1TokenAAmount && step1TokenAAmount < iu) {\n      deltaX = deltaL * (1 / Math.sqrt(step1TokenAAmount) - 1 / Math.sqrt(iu));\n      deltaY = deltaL * (Math.sqrt(step1TokenAAmount) - Math.sqrt(il));\n    }\n    if (step1TokenAAmount >= iu) {\n      deltaX = 0;\n      deltaY = Math.sqrt(iu) - Math.sqrt(il);\n    }\n\n    let tokenA = 0;\n    if (ic !== 0) {\n      tokenA = (input / deltaX) * deltaY;\n      State.update({\n        amountInputTokenA: tokenA,\n        amountInputTokenB: input,\n        validation: undefined,\n      });\n    } else {\n      State.update({\n        amountInputTokenA: 0,\n        need2Tokens: false,\n        amountInputTokenB: input,\n        validation: undefined,\n      });\n    }\n  }\n};\n\nconst validateConfirm = () => {\n  if (state.poolModeSelected.id == 0 || state.poolModeSelected.id == 3) {\n    validateAllowance(state.amountInputTokenA, \"TA\");\n    validateAllowance(state.amountInputTokenB, \"TB\");\n    State.update({ validation: true });\n  } else if (state.poolModeSelected.id == 1) {\n    validateAllowance(state.amountInputTokenA, \"TA\");\n    State.update({ validation: true });\n  } else if (state.poolModeSelected.id == 2) {\n    validateAllowance(state.amountInputTokenB, \"TB\");\n    State.update({ validation: true });\n  }\n};\n\nconst approveErc20Token = (mode) => {\n  asyncFetch(\n    \"https://gist.githubusercontent.com/veox/8800debbf56e24718f9f483e1e40c35c/raw/f853187315486225002ba56e5283c1dba0556e6f/erc20.abi.json\"\n  ).then((res) => {\n    let value, token;\n    if (mode == \"TA\") {\n      value = state.tokenABalance.unfixed;\n      token = state.newTokenASelected;\n    } else {\n      value = state.tokenBBalance.unfixed;\n      token = state.newTokenBSelected;\n    }\n    const approveContract = new ethers.Contract(\n      token.address,\n      res.body,\n      Ethers.provider().getSigner()\n    );\n\n    if (gweiPrice !== undefined && gasLimit !== undefined) {\n      gasArgs.gasPrice = ethers.utils.parseUnits(gweiPrice ?? \"0.26\", \"gwei\");\n      gasArgs.gasLimit = gasLimit ?? 20000000;\n    }\n\n    approveContract\n      .approve(state.routerContract, value)\n      .then((transactionHash) => {\n        State.update({ onApprovingToken: true });\n        setTimeout(() => {\n          getAccountAllowance({\n            token:\n              mode == \"TA\" ? state.newTokenASelected : state.newTokenBSelected,\n            vAllowance: false,\n            mode: mode,\n          });\n          State.update({ onApprovingToken: false, validation: undefined });\n        }, 20000);\n      });\n  });\n};\n\nconst getAccountAllowance = (data) => {\n  console.log(data);\n  let token = data.token;\n  if (token.symbol == \"ETH\") {\n    if (data.mode == \"TA\") {\n      State.update({ tokenAAllowance: undefined });\n    } else {\n      State.update({ tokenBAllowance: undefined });\n    }\n  } else {\n    asyncFetch(\n      \"https://gist.githubusercontent.com/veox/8800debbf56e24718f9f483e1e40c35c/raw/f853187315486225002ba56e5283c1dba0556e6f/erc20.abi.json\"\n    ).then((res) => {\n      const approveContract = new ethers.Contract(\n        token.address,\n        res.body,\n        Ethers.provider().getSigner()\n      );\n      approveContract\n        .allowance(state.sender, state.routerContract)\n        .then((res) => {\n          if (data.mode == \"TA\") {\n            State.update({ tokenAAllowance: parseInt(res.toString()) });\n          } else {\n            State.update({ tokenBAllowance: parseInt(res.toString()) });\n          }\n          console.log(\n            \"actual allowance \" + data.mode + \": \" + parseInt(res.toString())\n          );\n        });\n    });\n  }\n};\n\nconst confirm = () => {\n  if (state.amountInputTokenA <= 0 || state.amountInputTokenB <= 0) {\n    state.width === 0;\n    return;\n  } else {\n  }\n};\n// modal\n\nconst formatNumberFee = (n) => {\n  if (n > 0.01) {\n    return n.toFixed(2) + \" %\";\n  }\n  return n.toFixed(3) + \" %\";\n};\n\nconst formatNumberWidth = (n) => {\n  if (n < 0.1) {\n    return n.toFixed(2) + \" %\";\n  }\n  if (n < 1) {\n    return n.toFixed(1) + \" %\";\n  }\n  return n + \" %\";\n};\n\nconst showPoolOptionsModal = () => {\n  State.update({ showSelectOptionsModal: true });\n};\n\nconst closeModal = () => {\n  State.update({ showSelectOptionsModal: false });\n};\n\nconst setFeeWidth = (fee, width) => {\n  State.update({\n    fee: fee,\n    width: width,\n    showSelectOptionsModal: false,\n  });\n};\n\nconst floatToFixed = (num, decimals) => {\n  decimals ? decimals : 18;\n  return ethers.BigNumber.from(\n    ethers.utils.parseUnits(num.toString(), decimals)\n  );\n};\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/owa-is-bos.near/widget/Maverick-LP-NewPool", "fact_widget_deployments_id": "8dd960df36228a72fb3bd4d7ea344919", "inserted_timestamp": "2023-10-31T02:39:38.590Z", "modified_timestamp": "2023-10-31T02:39:38.590Z", "__row_index": 18}