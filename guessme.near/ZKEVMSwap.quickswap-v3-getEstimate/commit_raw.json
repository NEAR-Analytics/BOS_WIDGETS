{"tx_hash": "Cnu6iSLJcv1HNS3zJebNsk8Abv672zRFPXSfiGhybxB1", "action_id_social": "FeDGdV5uEf5tuj8kZGYZwAf25BLTgRsZEeeJjZ4WnBoq-0-widget", "block_id": 97886859, "block_timestamp": "2023-08-02T03:23:23.672Z", "signer_id": "guessme.near", "widget_name": "ZKEVMSwap.quickswap-v3-getEstimate", "source_code": "const { tokenIn, tokenOut, amountIn, tokenOutDecimals, loadRes, dex } = props;\n\nState.init({ res: { tokenIn, tokenOut, amountIn, dex } });\n\nconst middlePool =\n  props.middlePool ?? \"0x4f9a0e7fd2bf6067db6994cf12e4495df938e6e9\";\n\nconst useMiddlePool = tokenIn !== middlePool && tokenOut !== middlePool;\n\nconst optionDirectSwap = {\n  name: `directSwap`,\n  path: [tokenIn, tokenOut],\n};\n\nconst optionMiddlePoolSwap = {\n  name: `middlePoolSwap`,\n  path: [tokenIn, middlePool, tokenOut],\n};\n\nlet swapOptions = useMiddlePool\n  ? [optionDirectSwap, optionMiddlePoolSwap]\n  : [optionDirectSwap];\n\nif (state.res.amountIn !== amountIn || state.res.dex !== dex) {\n  if (state.res.dex !== dex) {\n    loadRes(null);\n  }\n\n  const resetObject = { amountIn, dex };\n  swapOptions = swapOptions.map(\n    (option) => (resetObject[option.name] = undefined)\n  );\n\n  console.log(\"resetObject\", resetObject);\n  State.update({\n    res: Object.assign(state.res ?? {}, resetObject),\n  });\n}\n\nconsole.log(\"swapOptions: \", swapOptions);\n\nconst quoterContractId =\n  props.quoterContractId ?? \"0x55BeE1bD3Eb9986f6d2d963278de09eE92a3eF1D\";\nconst sqrtPriceLimitX96 = props.sqrtPriceLimitX96 ?? 0;\n\nconst quoterABI =\n  props.quoterABI ??\n  \"https://gist.githubusercontent.com/zavodil/6a6e93e079deb3f8992e3d28d1ff0d78/raw/c6693b2ea41605ec215c912bfa82d67bad90258b/zkevm-quoter-abi.json\";\n\nconst quoterContractJson = fetch(quoterABI);\nif (!quoterContractJson.ok) {\n  return <div />;\n}\n\nconst getEstimate = (path, name) => {\n  const abi = JSON.parse(quoterContractJson.body);\n  const iface = new ethers.utils.Interface(abi);\n\n  const pathBytes = \"0x\" + path.map((address) => address.substr(2)).join(\"\");\n\n  const inputs = [pathBytes, amountIn];\n\n  const encodedData = iface.encodeFunctionData(\"quoteExactInput\", inputs);\n\n  Ethers.provider()\n    .call({\n      to: quoterContractId,\n      data: encodedData,\n    })\n    .then((data) => {\n      console.log(\"dataquote: \", data);\n      const decodedData = iface.decodeFunctionResult(\"quoteExactInput\", data);\n\n      // decodedData = [amountOut, fee]\n      const amountOut = decodedData[0];\n      const fee = decodedData[1];\n\n      const estimate = Big(amountOut.toString())\n        .div(Big(10).pow(tokenOutDecimals))\n        .toFixed(18);\n\n      State.update({\n        res: Object.assign(state.res ?? {}, {\n          [name]: { estimate, path, fee },\n        }),\n      });\n    });\n};\n\nswapOptions.map((option) => {\n  if (state.res[option.name] === undefined) {\n    getEstimate(option.path, option.name);\n  }\n});\n\nconst allDataReceived = swapOptions.reduce(\n  (accumulator, option) => accumulator && state.res[option.name] !== undefined,\n  true\n);\n\nif (state.res !== undefined && allDataReceived) {\n  if (typeof loadRes === \"function\") {\n    let res = state.res;\n\n    res.estimate = 0;\n    res.path = \"\";\n\n    swapOptions.map((option) => {\n      let estimate = parseFloat(state.res[option.name].estimate);\n      if (res.estimate < estimate) {\n        res.estimate = estimate;\n        res.path = state.res[option.name].path;\n        res.fee = state.res[option.name].fee;\n      }\n    });\n\n    loadRes(res);\n  }\n}\n\nconsole.log(\"on final return\");\n\nreturn <div />;\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/guessme.near/widget/ZKEVMSwap.quickswap-v3-getEstimate", "fact_widget_deployments_id": "e1034dcacfe0952ea352df659d855d91", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 3}