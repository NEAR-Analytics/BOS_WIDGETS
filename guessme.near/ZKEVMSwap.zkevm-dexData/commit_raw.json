{"tx_hash": "HUjvwiNGKQwJf2tEiqEoxUkEoJ2nAGzasM3eMMAq3U5t", "action_id_social": "531AikfK6NPmVA2gSxXij4cGh1Ta6TiGLGAisyJAjGWh-0-widget", "block_id": 101617799, "block_timestamp": "2023-09-21T10:13:23.879Z", "signer_id": "guessme.near", "widget_name": "ZKEVMSwap.zkevm-dexData", "source_code": "const ethAddress = \"0x0000000000000000000000000000000000000000\";\nconst wethAddress = \"0x4f9a0e7fd2bf6067db6994cf12e4495df938e6e9\";\n\nconst {\n  NETWORK_NEAR,\n  NETWORK_ETH,\n  NETWORK_ZKSYNC,\n  NETWORK_ZKEVM,\n  NETWORK_AURORA,\n  NETWORK_POLYGON,\n  DEX,\n  debug,\n} = props;\n\nlet onLoad = props.onLoad;\nconst forceReload = props.forceReload ?? false;\n\nconst { onShowNoPool } = props;\n\nState.init({ loadComplete: false });\n\nif (forceReload) {\n  State.update({\n    forceReload: false,\n    factoryAbi: undefined,\n    erc20Abi: undefined,\n    routerAbi: undefined,\n  });\n}\n\nif (state.loadComplete && !forceReload) {\n  return <div />;\n}\n\nif (typeof onLoad !== \"function\") return \"Error\";\n\nconst expandToken = (value, decimals) => {\n  return new Big(value).mul(new Big(10).pow(decimals));\n};\n\nconst callTxBalancerZKEVM = (input, onComplete, gasPrice, gasLimit) => {\n  if (\n    input.sender &&\n    input.routerContract !== undefined &&\n    input.routerAbi &&\n    input.inputAssetAmount &&\n    input.inputAsset.metadata.decimals\n  ) {\n    const value = expandToken(\n      input.inputAssetAmount,\n      input.inputAsset.metadata.decimals\n    ).toFixed();\n\n    const swapContract = new ethers.Contract(\n      input.routerContract,\n      input.routerAbi,\n      Ethers.provider().getSigner()\n    );\n\n    const USDC = \"0xa8ce8aee21bc2a48a5ef670afcc9274c7bbbc035\";\n    const WETH = \"0x4f9a0e7fd2bf6067db6994cf12e4495df938e6e9\";\n    const WBTC = \"0xea034fb02eb1808c2cc3adbc15f447b93cbe08e1\";\n    const MATIC = \"0xa2036f0538221a77a3937f1379699f44945018d0\";\n    const USDT = \"0x1E4a5963aBFD975d8c9021ce480b42188849D41d\";\n    const DAI = \"0xC5015b9d9161Dca7e18e32f6f25C4aD850731Fd4\";\n\n    // [asset1, asset2, asset3...], pool1\n    const pools = [\n      [\n        [MATIC, WETH, USDC],\n        \"0xc951aebfa361e9d0063355b9e68f5fa4599aa3d1000100000000000000000017\",\n      ],\n      [\n        [WETH, DAI],\n        \"0xa7f602cfaf75a566cb0ed110993ee81c27fa3f53000200000000000000000009\",\n      ],\n      [\n        [WETH, DAI, USDT],\n        \"0xe8ca7400eb61d5bdfc3f8f2ea99e687e0a4dbf78000100000000000000000019\",\n      ],\n      [\n        [WETH, USDC],\n        \"0x53ddc1f1ef585b426c03674f278f8107f1524ade000200000000000000000012\",\n      ],\n    ];\n\n    const WethContract = new ethers.Contract(\n      wethAddress,\n      [\n        {\n          constant: false,\n          inputs: [],\n          name: \"deposit\",\n          outputs: [],\n          payable: true,\n          stateMutability: \"payable\",\n          type: \"function\",\n        },\n        {\n          constant: false,\n          inputs: [{ internalType: \"uint256\", name: \"wad\", type: \"uint256\" }],\n          name: \"withdraw\",\n          outputs: [],\n          payable: false,\n          stateMutability: \"nonpayable\",\n          type: \"function\",\n        },\n      ],\n      Ethers.provider().getSigner()\n    );\n\n    if (\n      input.inputAssetTokenId === ethAddress &&\n      input.outputAssetTokenId === wethAddress\n    ) {\n      return WethContract.deposit({\n        value: ethers.utils.parseEther(input.inputAssetAmount),\n        gasLimit: gasLimit ?? 10000,\n      }).then((res) => {\n        onComplete(res);\n      });\n    }\n\n    if (\n      input.inputAssetTokenId === wethAddress &&\n      input.outputAssetTokenId === ethAddress\n    ) {\n      return WethContract.withdraw(\n        ethers.utils.parseEther(input.inputAssetAmount)\n      ).then((res) => {\n        onComplete(res);\n      });\n    }\n\n    const inputId =\n      input.inputAssetTokenId === ethAddress ? WETH : input.inputAssetTokenId;\n\n    const outputId =\n      input.outputAssetTokenId === ethAddress ? WETH : input.outputAssetTokenId;\n\n    const finalPool = pools\n      .filter(\n        (poolData) =>\n          poolData[0].includes(inputId) && poolData[0].includes(outputId)\n      )\n      .map((poolData) => poolData[1]);\n\n    if (!finalPool.length && inputId !== outputId) {\n      return onShowNoPool();\n    }\n\n    console.log(\"finalPool: \", finalPool);\n\n    const assets = [input.inputAssetTokenId, input.outputAssetTokenId];\n\n    const funds = [input.sender, false, input.sender, false];\n\n    const swap_steps = [\n      {\n        poolId: finalPool[0],\n        assetIn: input.inputAssetTokenId,\n        assetOut: input.outputAssetTokenId,\n        amount: value,\n      },\n    ];\n\n    const token_data = {};\n\n    token_data[input.inputAssetTokenId] = {\n      symbol: input.inputAsset.metadata.symbol,\n      decimals: input.inputAsset.metadata.decimals,\n      limit: value,\n    };\n    token_data[input.outputAssetTokenId] = {\n      symbol: input.outputAsset.metadata.symbol,\n      decimals: input.outputAsset.metadata.decimals,\n      limit: \"0\",\n    };\n\n    const token_addresses = Object.keys(token_data);\n    const token_indices = {};\n    for (let i = 0; i < token_addresses.length; i++) {\n      token_indices[token_addresses[i]] = i;\n    }\n\n    const swap_steps_struct = [];\n    for (const step of swap_steps) {\n      const swap_step_struct = [\n        step[\"poolId\"],\n        token_indices[step[\"assetIn\"]],\n        token_indices[step[\"assetOut\"]],\n        step[\"amount\"],\n        \"0x\",\n      ];\n      swap_steps_struct.push(swap_step_struct);\n    }\n\n    const swap_kind = 0;\n    const token_limits = [value, 0];\n    const deadline = new Big(Math.floor(Date.now() / 1000)).add(new Big(1800));\n\n    console.log(\"swap_steps_struct: \", swap_steps_struct, assets);\n\n    swapContract\n      .batchSwap(\n        swap_kind,\n        swap_steps_struct,\n        assets,\n        funds,\n        token_limits,\n        deadline.toFixed(),\n        {\n          gasLimit: 200000,\n          value: input.inputAssetTokenId === ethAddress ? value : \"0\",\n        }\n      )\n      .then((transactionHash) => {\n        onComplete(transactionHash);\n      })\n      .catch((e) => {\n        console.log(e, \"e111111\");\n      });\n  }\n};\n\nconst callTxQuickSwap = (\n  input,\n  onComplete,\n  gasPrice,\n  gasLimit,\n  sqrtPriceLimitX96,\n  path\n) => {\n  if (\n    input.sender &&\n    input.routerContract !== undefined &&\n    input.routerAbi &&\n    input.inputAssetAmount &&\n    input.inputAsset.metadata.decimals\n  ) {\n    const value = expandToken(\n      input.inputAssetAmount,\n      input.inputAsset.metadata.decimals\n    ).toFixed(0);\n\n    const WethContract = new ethers.Contract(\n      wethAddress,\n      [\n        {\n          constant: false,\n          inputs: [],\n          name: \"deposit\",\n          outputs: [],\n          payable: true,\n          stateMutability: \"payable\",\n          type: \"function\",\n        },\n        {\n          constant: false,\n          inputs: [{ internalType: \"uint256\", name: \"wad\", type: \"uint256\" }],\n          name: \"withdraw\",\n          outputs: [],\n          payable: false,\n          stateMutability: \"nonpayable\",\n          type: \"function\",\n        },\n      ],\n      Ethers.provider().getSigner()\n    );\n\n    if (\n      input.inputAssetTokenId === ethAddress &&\n      input.outputAssetTokenId === wethAddress\n    ) {\n      return WethContract.deposit({\n        value: ethers.utils.parseEther(input.inputAssetAmount),\n        gasLimit: gasLimit ?? 10000,\n      }).then((res) => {\n        onComplete(res);\n      });\n    }\n\n    if (\n      input.inputAssetTokenId === wethAddress &&\n      input.outputAssetTokenId === ethAddress\n    ) {\n      return WethContract.withdraw(\n        ethers.utils.parseEther(input.inputAssetAmount)\n      ).then((res) => {\n        onComplete(res);\n      });\n    }\n\n    const deadline = new Big(Math.floor(Date.now() / 1000)).add(new Big(1800));\n\n    const iface = new ethers.utils.Interface(input.routerAbi);\n\n    const tokenIn =\n      input.inputAssetTokenId === ethAddress\n        ? wethAddress\n        : input.inputAssetTokenId;\n\n    const tokenOut =\n      input.outputAssetTokenId === ethAddress\n        ? wethAddress\n        : input.outputAssetTokenId;\n\n    const recipient =\n      input.outputAssetTokenId === ethAddress\n        ? input.outputAssetTokenId\n        : input.sender;\n\n    const multicallParams = [];\n\n    if (path.length === 2) {\n      const inputs = [\n        {\n          tokenIn,\n          tokenOut,\n          recipient,\n          deadline: deadline.toFixed(),\n          amountIn: value,\n          amountOutMinimum: \"0\",\n          limitSqrtPrice: sqrtPriceLimitX96 ?? 0,\n        },\n      ];\n\n      const encodedDataCallSwap = iface.encodeFunctionData(\n        \"exactInputSingle\",\n        inputs\n      );\n\n      multicallParams.push(encodedDataCallSwap);\n    } else if (path.length > 2) {\n      // path recepient deadline amountIn amountOutMinimum\n      const pathBytes =\n        \"0x\" + path.map((address) => address.substr(2)).join(\"\");\n\n      const inputs = [pathBytes, input.sender, deadline, value, \"0\"];\n\n      const encodedDataCallSwap = iface.encodeFunctionData(\n        \"exactInput\",\n        inputs\n      );\n      multicallParams.push(encodedDataCallSwap);\n    }\n\n    if (input.outputAssetTokenId === ethAddress) {\n      multicallParams.push(\n        iface.encodeFunctionData(\"unwrapWNativeToken\", [\"0\", input.sender])\n      );\n    }\n\n    const swapContract = new ethers.Contract(\n      input.routerContract,\n      input.routerAbi,\n      Ethers.provider().getSigner()\n    );\n\n    const options = {\n      gasLimit: gasLimit ?? swapType === 10000,\n      value: input.inputAssetTokenId === ethAddress ? value : \"0\",\n    };\n\n    return swapContract\n      .multicall(multicallParams, options)\n      .then((transactionHash) => {\n        onComplete(transactionHash);\n      })\n      .catch((e) => {\n        console.log(\"e111\", e);\n      });\n  }\n};\n\nconst callTxPancakeZKEVM2 = (\n  input,\n  onComplete,\n  gasPrice,\n  gasLimit,\n  sqrtPriceLimitX96,\n  path\n) => {\n  const poolFee = \"2500\";\n\n  if (\n    input.sender &&\n    input.routerContract !== undefined &&\n    input.routerAbi &&\n    input.inputAssetAmount &&\n    input.inputAsset.metadata.decimals\n  ) {\n    const value = expandToken(\n      input.inputAssetAmount,\n      input.inputAsset.metadata.decimals\n    ).toFixed();\n\n    const WethContract = new ethers.Contract(\n      wethAddress,\n      [\n        {\n          constant: false,\n          inputs: [],\n          name: \"deposit\",\n          outputs: [],\n          payable: true,\n          stateMutability: \"payable\",\n          type: \"function\",\n        },\n        {\n          constant: false,\n          inputs: [{ internalType: \"uint256\", name: \"wad\", type: \"uint256\" }],\n          name: \"withdraw\",\n          outputs: [],\n          payable: false,\n          stateMutability: \"nonpayable\",\n          type: \"function\",\n        },\n      ],\n      Ethers.provider().getSigner()\n    );\n\n    if (\n      input.inputAssetTokenId === ethAddress &&\n      input.outputAssetTokenId === wethAddress\n    ) {\n      return WethContract.deposit({\n        value: ethers.utils.parseEther(input.inputAssetAmount),\n        gasLimit: gasLimit ?? 10000,\n      }).then((res) => {\n        onComplete(res);\n      });\n    }\n\n    if (\n      input.inputAssetTokenId === wethAddress &&\n      input.outputAssetTokenId === ethAddress\n    ) {\n      return WethContract.withdraw(\n        ethers.utils.parseEther(input.inputAssetAmount)\n      ).then((res) => {\n        onComplete(res);\n      });\n    }\n\n    const deadline = new Big(Math.floor(Date.now() / 1000))\n      .add(new Big(1800))\n      .toFixed();\n\n    const ifaceErc20 = new ethers.utils.Interface(input.routerAbi);\n    console.log(\"ifaceErc20: \", ifaceErc20);\n\n    const tokenIn =\n      input.inputAssetTokenId === ethAddress\n        ? wethAddress\n        : input.inputAssetTokenId;\n\n    const tokenOut =\n      input.outputAssetTokenId === ethAddress\n        ? wethAddress\n        : input.outputAssetTokenId;\n\n    const recipient =\n      input.outputAssetTokenId === ethAddress\n        ? input.routerContract\n        : input.sender;\n\n    let swapType;\n    const WETH = \"0x4f9a0e7fd2bf6067db6994cf12e4495df938e6e9\";\n    if (tokenIn != wethAddress && tokenOut != wethAddress) {\n      swapType = \"complex\";\n      path = [tokenIn, tokenOut];\n    } else {\n      swapType = \"single\";\n    }\n\n    const swapContract = new ethers.Contract(\n      input.routerContract,\n      input.routerAbi,\n      Ethers.provider().getSigner()\n    );\n\n    const multicallParams = [];\n\n    const options = {\n      gasLimit: gasLimit ?? 10000,\n      value: input.inputAssetTokenId === ethAddress ? value : \"0\",\n    };\n\n    if (swapType == \"complex\") {\n      const encodedExactOutputSingleData = ifaceErc20.encodeFunctionData(\n        \"swapExactTokensForTokens\",\n        [value, \"0\", [tokenIn, WETH, tokenOut], input.sender]\n      );\n      multicallParams.push(encodedExactOutputSingleData);\n    } else {\n      const encodedExactOutputSingleData = ifaceErc20.encodeFunctionData(\n        \"exactInputSingle\",\n        [\n          {\n            tokenIn: tokenIn,\n            tokenOut: tokenOut,\n            fee: poolFee,\n            recipient: recipient,\n            amountIn: value,\n            amountOutMinimum: \"0\",\n            sqrtPriceLimitX96: sqrtPriceLimitX96 ?? \"0\",\n          },\n        ]\n      );\n\n      multicallParams.push(encodedExactOutputSingleData);\n    }\n\n    if (input.outputAssetTokenId === ethAddress) {\n      multicallParams.push(\n        ifaceErc20.encodeFunctionData(\"unwrapWETH9\", [\"0\", input.sender])\n      );\n    }\n\n    console.log(\"multicallParams: \", multicallParams);\n\n    return swapContract[\"multicall(uint256,bytes[])\"](\n      deadline,\n      multicallParams,\n      {\n        ...options,\n        gasLimit: 200000,\n      }\n    )\n      .then((transactionHash) => {\n        onComplete(transactionHash);\n      })\n      .catch((e) => {\n        console.log(\"e111\", e);\n      });\n  }\n};\n\nconst callTokenApprovalEVM = (input, onComplete, gweiPrice, gasLimit) => {\n  if (\n    input.sender &&\n    input.erc20Abi &&\n    input.inputAssetAmount &&\n    input.inputAsset.metadata.decimals &&\n    input.routerContract\n  ) {\n    const value = expandToken(\n      input.inputAssetAmount,\n      input.inputAsset.metadata.decimals || 18\n    ).toFixed();\n\n    console.log(\"input.inputAsset: \", input.inputAsset);\n\n    const approveContract = new ethers.Contract(\n      input.inputAssetTokenId,\n      input.erc20Abi,\n      Ethers.provider().getSigner()\n    );\n\n    let gasArgs = {};\n\n    if (gweiPrice !== undefined && gasLimit !== undefined) {\n      gasArgs.gasLimit = gasLimit ?? 20000000;\n    }\n\n    approveContract\n      .approve(input.routerContract, value, gasArgs)\n      .then((transactionHash) => {\n        transactionHash.wait().then(() => {\n          onComplete(transactionHash);\n        });\n      })\n      .catch((e) => {\n        console.log(\"e1111\", e);\n      });\n  }\n};\n\nif (ethers !== undefined && Ethers.send(\"eth_requestAccounts\", [])[0]) {\n  Ethers.provider()\n    .getNetwork()\n    .then(() => {\n      if (DEX === \"QuickSwap\") {\n        if (state.erc20Abi == undefined) {\n          const erc20Abi = fetch(\n            \"https://gist.githubusercontent.com/veox/8800debbf56e24718f9f483e1e40c35c/raw/f853187315486225002ba56e5283c1dba0556e6f/erc20.abi.json\"\n          );\n          if (!erc20Abi.ok) {\n            return \"Loading\";\n          }\n          State.update({ erc20Abi: erc20Abi.body });\n        }\n\n        if (state.routerAbi == undefined) {\n          const routerAbi = fetch(\n            \"https://gist.githubusercontent.com/zavodil/a50ed9fcd2e1ba1adc40db19a94c79fe/raw/a3b92a2b9120d7d503e01714980ad44bd10c9030/quickswap_swapRouter_zkevm.json\"\n          );\n          if (!routerAbi.ok) {\n            return \"Loading\";\n          }\n\n          State.update({ routerAbi: routerAbi.body });\n        }\n\n        if (!state.routerAbi || !state.erc20Abi) return \"Loading ABIs\";\n\n        onLoad({\n          network: NETWORK_ZKEVM,\n          assets: [\n            \"0x0000000000000000000000000000000000000000\", // ETH\n            \"0xa8ce8aee21bc2a48a5ef670afcc9274c7bbbc035\", // USDC\n            \"0x4f9a0e7fd2bf6067db6994cf12e4495df938e6e9\", // WETH\n            \"0xea034fb02eb1808c2cc3adbc15f447b93cbe08e1\", // WBTC\n            \"0xa2036f0538221a77a3937f1379699f44945018d0\", // MATIC\n            \"0x1E4a5963aBFD975d8c9021ce480b42188849D41d\", // USDT\n            \"0xC5015b9d9161Dca7e18e32f6f25C4aD850731Fd4\", // DAI\n          ],\n          coinGeckoTokenIds: {\n            \"0x0000000000000000000000000000000000000000\":\n              \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\",\n            \"0xa8ce8aee21bc2a48a5ef670afcc9274c7bbbc035\":\n              \"0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48\",\n            \"0xA8CE8aee21bC2A48a5EF670afCc9274C7bbbC035\":\n              \"0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48\",\n            \"0x4f9a0e7fd2bf6067db6994cf12e4495df938e6e9\":\n              \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\",\n            \"0xea034fb02eb1808c2cc3adbc15f447b93cbe08e1\":\n              \"0x2260fac5e5542a773aa44fbcfedf7c193bc2c599\",\n            \"0xa2036f0538221a77a3937f1379699f44945018d0\":\n              \"0x7d1afa7b718fb893db30a3abc0cfc608aacfebb0\",\n            \"0x1E4a5963aBFD975d8c9021ce480b42188849D41d\":\n              \"0xdac17f958d2ee523a2206206994597c13d831ec7\",\n            \"0xC5015b9d9161Dca7e18e32f6f25C4aD850731Fd4\":\n              \"0x6b175474e89094c44da98b954eedeac495271d0f\",\n            \"0xa2036f0538221a77A3937F1379699f44945018d0\":\n              \"0x7d1afa7b718fb893db30a3abc0cfc608aacfebb0\",\n          },\n          routerContract: \"0xF6Ad3CcF71Abb3E12beCf6b3D2a74C963859ADCd\",\n          dexName: \"QuickSwap\",\n          erc20Abi: state.erc20Abi,\n          routerAbi: state.routerAbi,\n          callTx: callTxQuickSwap,\n          callTokenApproval: callTokenApprovalEVM,\n        });\n        State.update({ loadComplete: true });\n      } else if (DEX === \"Balancer\") {\n        if (state.erc20Abi == undefined) {\n          const erc20Abi = fetch(\n            \"https://gist.githubusercontent.com/veox/8800debbf56e24718f9f483e1e40c35c/raw/f853187315486225002ba56e5283c1dba0556e6f/erc20.abi.json\"\n          );\n          if (!erc20Abi.ok) {\n            return \"Loading\";\n          }\n          State.update({ erc20Abi: erc20Abi.body });\n        }\n\n        if (state.routerAbi == undefined) {\n          const routerAbi = fetch(\n            \"https://raw.githubusercontent.com/gerrrg/balancer-tutorials/master/abis/Vault.json\"\n          );\n          if (!routerAbi.ok) {\n            return \"Loading\";\n          }\n\n          State.update({ routerAbi: routerAbi.body });\n        }\n\n        if (!state.routerAbi || !state.erc20Abi) return \"Loading ABIs\";\n\n        onLoad({\n          network: NETWORK_ZKEVM,\n          assets: [\n            \"0x0000000000000000000000000000000000000000\", // ETH\n            \"0xa8ce8aee21bc2a48a5ef670afcc9274c7bbbc035\", // USDC\n            \"0x4f9a0e7fd2bf6067db6994cf12e4495df938e6e9\", // WETH\n            \"0xea034fb02eb1808c2cc3adbc15f447b93cbe08e1\", // WBTC\n            \"0xa2036f0538221a77a3937f1379699f44945018d0\", // MATIC\n            \"0x1E4a5963aBFD975d8c9021ce480b42188849D41d\", // USDT\n            \"0xC5015b9d9161Dca7e18e32f6f25C4aD850731Fd4\", // DAI\n          ],\n          coinGeckoTokenIds: {\n            \"0x0000000000000000000000000000000000000000\":\n              \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\",\n            \"0xa8ce8aee21bc2a48a5ef670afcc9274c7bbbc035\":\n              \"0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48\",\n            \"0x4f9a0e7fd2bf6067db6994cf12e4495df938e6e9\":\n              \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\",\n            \"0xea034fb02eb1808c2cc3adbc15f447b93cbe08e1\":\n              \"0x2260fac5e5542a773aa44fbcfedf7c193bc2c599\",\n            \"0xa2036f0538221a77a3937f1379699f44945018d0\":\n              \"0x7d1afa7b718fb893db30a3abc0cfc608aacfebb0\",\n            \"0x1E4a5963aBFD975d8c9021ce480b42188849D41d\":\n              \"0xdac17f958d2ee523a2206206994597c13d831ec7\",\n            \"0xC5015b9d9161Dca7e18e32f6f25C4aD850731Fd4\":\n              \"0x6b175474e89094c44da98b954eedeac495271d0f\",\n            \"0xa2036f0538221a77A3937F1379699f44945018d0\":\n              \"0x7d1afa7b718fb893db30a3abc0cfc608aacfebb0\",\n            \"0xA8CE8aee21bC2A48a5EF670afCc9274C7bbbC035\":\n              \"0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48\",\n          },\n          routerContract: \"0xBA12222222228d8Ba445958a75a0704d566BF2C8\", // Balancer Vault\n          dexName: \"Balancer\",\n          erc20Abi: state.erc20Abi,\n          routerAbi: state.routerAbi,\n          callTx: callTxBalancerZKEVM,\n          callTokenApproval: callTokenApprovalEVM,\n        });\n\n        State.update({ loadComplete: true });\n      } else if (DEX === \"Pancake Swap\") {\n        if (state.erc20Abi == undefined) {\n          const erc20Abi = fetch(\n            \"https://gist.githubusercontent.com/veox/8800debbf56e24718f9f483e1e40c35c/raw/f853187315486225002ba56e5283c1dba0556e6f/erc20.abi.json\"\n          );\n          if (!erc20Abi.ok) {\n            return \"Loading\";\n          }\n          State.update({ erc20Abi: erc20Abi.body });\n        }\n\n        if (state.routerAbi == undefined) {\n          const routerAbi = fetch(\n            //\"https://gist.githubusercontent.com/zavodil/5ab70bbbd8cf30c0edbf4837f473904d/raw/e9ec67d159b844222df04f3ad23c4c1cc771fa43/PancakeSwapRouter\"\n            \"https://gist.githubusercontent.com/zavodil/c51f14cbc5c379ab15548dcd63bee279/raw/1f797efe368cadd6c817df0a736f1ea9a522bd8a/PancakeMixedRouteQuoterV1ABI?1\"\n          );\n          if (!routerAbi.ok) {\n            return \"Loading\";\n          }\n\n          State.update({ routerAbi: routerAbi.body });\n        }\n\n        if (!state.routerAbi || !state.erc20Abi) return \"Loading ABIs\";\n\n        onLoad({\n          network: NETWORK_ZKEVM,\n          assets: [\n            \"0x0000000000000000000000000000000000000000\",\n            \"0xa8ce8aee21bc2a48a5ef670afcc9274c7bbbc035\",\n            \"0x4f9a0e7fd2bf6067db6994cf12e4495df938e6e9\",\n            \"0x1E4a5963aBFD975d8c9021ce480b42188849D41d\",\n          ],\n          coinGeckoTokenIds: {\n            \"0x0000000000000000000000000000000000000000\":\n              \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\",\n            \"0xa8ce8aee21bc2a48a5ef670afcc9274c7bbbc035\":\n              \"0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48\",\n            \"0x4f9a0e7fd2bf6067db6994cf12e4495df938e6e9\":\n              \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\",\n            \"0x1E4a5963aBFD975d8c9021ce480b42188849D41d\":\n              \"0xdac17f958d2ee523a2206206994597c13d831ec7\",\n            \"0xA8CE8aee21bC2A48a5EF670afCc9274C7bbbC035\":\n              \"0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48\",\n          },\n          routerContract: \"0x678Aa4bF4E210cf2166753e054d5b7c31cc7fa86\", // PancakeMixedRouteQuoterV1ABI\n          dexName: \"Pancake Swap\",\n          erc20Abi: state.erc20Abi,\n          routerAbi: state.routerAbi,\n          callTx: callTxPancakeZKEVM2,\n          callTokenApproval: callTokenApprovalEVM,\n        });\n\n        State.update({ loadComplete: true });\n      }\n    });\n}\n\nreturn <div></div>;\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/guessme.near/widget/ZKEVMSwap.zkevm-dexData", "fact_widget_deployments_id": "7fcb3ff3bb81a2593ed207ea2ec409de", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 23}