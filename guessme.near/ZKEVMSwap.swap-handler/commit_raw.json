{"tx_hash": "E9AczJswmHdNLMc15xRr6a9eT5FycNghrZXfi1B2W4kL", "action_id_social": "DxXq8iSDYP4sMSxVsEHq5AsWQBDALTcZdgw1Y8vWm5n1-0-widget", "block_id": 108390088, "block_timestamp": "2023-12-20T07:58:00.905Z", "signer_id": "guessme.near", "widget_name": "ZKEVMSwap.swap-handler", "source_code": "const ROUTER_ABI = [\n  {\n    inputs: [\n      {\n        internalType: \"bytes[]\",\n        name: \"data\",\n        type: \"bytes[]\",\n      },\n    ],\n    name: \"multicall\",\n    outputs: [\n      {\n        internalType: \"bytes[]\",\n        name: \"results\",\n        type: \"bytes[]\",\n      },\n    ],\n    stateMutability: \"payable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            internalType: \"address\",\n            name: \"tokenIn\",\n            type: \"address\",\n          },\n          {\n            internalType: \"address\",\n            name: \"tokenOut\",\n            type: \"address\",\n          },\n          {\n            internalType: \"address\",\n            name: \"recipient\",\n            type: \"address\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"deadline\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"amountIn\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"amountOutMinimum\",\n            type: \"uint256\",\n          },\n          {\n            internalType: \"uint160\",\n            name: \"limitSqrtPrice\",\n            type: \"uint160\",\n          },\n        ],\n        internalType: \"struct ISwapRouter.ExactInputSingleParams\",\n        name: \"params\",\n        type: \"tuple\",\n      },\n    ],\n    name: \"exactInputSingle\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"amountOut\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"payable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"uint256\",\n        name: \"amountMinimum\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"address\",\n        name: \"recipient\",\n        type: \"address\",\n      },\n    ],\n    name: \"unwrapWNativeToken\",\n    outputs: [],\n    stateMutability: \"payable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"uint256\",\n        name: \"amountIn\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"amountOutMin\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"address[]\",\n        name: \"path\",\n        type: \"address[]\",\n      },\n      {\n        internalType: \"address\",\n        name: \"to\",\n        type: \"address\",\n      },\n    ],\n    name: \"swapExactTokensForTokens\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"amountOut\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"payable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"uint256\",\n        name: \"amountMinimum\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"address\",\n        name: \"recipient\",\n        type: \"address\",\n      },\n    ],\n    name: \"unwrapWETH9\",\n    outputs: [],\n    stateMutability: \"payable\",\n    type: \"function\",\n  },\n];\n\nconst {\n  routerAddress,\n  wethAddress,\n  inputCurrencyAmount,\n  inputCurrency,\n  outputCurrencyAmount,\n  outputCurrency,\n  account,\n  onSuccess,\n  onError,\n  swapping,\n  title,\n} = props;\n\nif (!swapping) return;\n\nconst type =\n  inputCurrency.address === \"native\"\n    ? 1\n    : outputCurrency.address === \"native\"\n    ? 2\n    : 0;\n\nconst deadline = new Big(Math.floor(Date.now() / 1000)).add(new Big(1800));\n\nconst iface = new ethers.utils.Interface(ROUTER_ABI);\n\nconst amount = ethers.utils.parseUnits(\n  Big(inputCurrencyAmount).toFixed(inputCurrency.decimals),\n  inputCurrency.decimals\n);\n\nconst multicallParams = [];\n\nconst _inputCurrencyAddress =\n  inputCurrency.address === \"native\" ? wethAddress : inputCurrency.address;\nconst _outputCurrencyAddress =\n  outputCurrency.address === \"native\" ? wethAddress : outputCurrency.address;\n\nif (title === \"QuickSwap\") {\n  const inputs = [\n    {\n      tokenIn: _inputCurrencyAddress,\n      tokenOut: _outputCurrencyAddress,\n      recipient: type === 2 ? wethAddress : account,\n      deadline: deadline.toFixed(),\n      amountIn: amount,\n      amountOutMinimum: \"0\",\n      limitSqrtPrice: 0,\n    },\n  ];\n\n  const encodedDataCallSwap = iface.encodeFunctionData(\n    \"exactInputSingle\",\n    inputs\n  );\n\n  multicallParams.push(encodedDataCallSwap);\n\n  if (type === 2) {\n    multicallParams.push(\n      iface.encodeFunctionData(\"unwrapWNativeToken\", [\"0\", account])\n    );\n  }\n}\n\nif (title === \"Pancake Swap\") {\n  const encodedExactOutputSingleData = iface.encodeFunctionData(\n    \"swapExactTokensForTokens\",\n    [\n      amount,\n      \"0\",\n      [_inputCurrencyAddress, wethAddress, _outputCurrencyAddress],\n      account,\n    ]\n  );\n  if (type === 2) {\n    multicallParams.push(\n      iface.encodeFunctionData(\"unwrapWETH9\", [\"0\", account])\n    );\n  }\n  multicallParams.push(encodedExactOutputSingleData);\n}\n\nif ([\"QuickSwap\", \"Pancake Swap\"].includes(title)) {\n  const RouterContract = new ethers.Contract(\n    routerAddress,\n    ROUTER_ABI,\n    Ethers.provider().getSigner()\n  );\n  const options = {\n    value: type === 1 ? amount : \"0\",\n  };\n  RouterContract.estimateGas\n    .multicall(multicallParams, options)\n    .then((gas) => {\n      RouterContract.multicall(multicallParams, {\n        ...options,\n        gasLimit: gas,\n      })\n        .then((tx) => {\n          onSuccess(tx);\n        })\n        .catch((err) => {\n          onError(err);\n        });\n    })\n    .catch((err) => {\n      onError(err);\n    });\n  return \"\";\n}\n\nif (title === \"Balancer\") {\n  const pools = [\n    [\n      [\n        \"0xa2036f0538221a77a3937f1379699f44945018d0\",\n        \"0x4f9a0e7fd2bf6067db6994cf12e4495df938e6e9\",\n        \"0xa8ce8aee21bc2a48a5ef670afcc9274c7bbbc035\",\n      ],\n      \"0xc951aebfa361e9d0063355b9e68f5fa4599aa3d1000100000000000000000017\",\n    ],\n    [\n      [\n        \"0x4f9a0e7fd2bf6067db6994cf12e4495df938e6e9\",\n        \"0xC5015b9d9161Dca7e18e32f6f25C4aD850731Fd4\",\n      ],\n      \"0xa7f602cfaf75a566cb0ed110993ee81c27fa3f53000200000000000000000009\",\n    ],\n    [\n      [\n        \"0x4f9a0e7fd2bf6067db6994cf12e4495df938e6e9\",\n        \"0xC5015b9d9161Dca7e18e32f6f25C4aD850731Fd4\",\n        \"0x1E4a5963aBFD975d8c9021ce480b42188849D41d\",\n      ],\n      \"0xe8ca7400eb61d5bdfc3f8f2ea99e687e0a4dbf78000100000000000000000019\",\n    ],\n    [\n      [\n        \"0x4f9a0e7fd2bf6067db6994cf12e4495df938e6e9\",\n        \"0xa8ce8aee21bc2a48a5ef670afcc9274c7bbbc035\",\n      ],\n      \"0x53ddc1f1ef585b426c03674f278f8107f1524ade000200000000000000000012\",\n    ],\n  ];\n\n  const finalPool = pools\n    .filter(\n      (poolData) =>\n        poolData[0].includes(_inputCurrencyAddress) &&\n        poolData[0].includes(_outputCurrencyAddress)\n    )\n    .map((poolData) => poolData[1]);\n\n  const _inputAddress =\n    inputCurrency.address === \"native\"\n      ? \"0x0000000000000000000000000000000000000000\"\n      : inputCurrency.address;\n  const _outputAddress =\n    outputCurrency.address === \"native\"\n      ? \"0x0000000000000000000000000000000000000000\"\n      : outputCurrency.address;\n\n  const assets = [_inputAddress, _outputAddress];\n  const funds = [account, false, account, false];\n  const swap_steps = [\n    {\n      poolId: finalPool[0],\n      assetIn: _inputAddress,\n      assetOut: _outputAddress,\n      amount,\n    },\n  ];\n\n  const token_indices = {};\n  for (let i = 0; i < assets.length; i++) {\n    token_indices[assets[i]] = i;\n  }\n  const swap_steps_struct = [];\n  for (const step of swap_steps) {\n    const swap_step_struct = [\n      step[\"poolId\"],\n      token_indices[step[\"assetIn\"]],\n      token_indices[step[\"assetOut\"]],\n      step[\"amount\"],\n      \"0x\",\n    ];\n    swap_steps_struct.push(swap_step_struct);\n  }\n  const token_limits = [amount, 0];\n\n  const SwapContract = new ethers.Contract(\n    routerAddress,\n    [\n      {\n        inputs: [\n          {\n            internalType: \"enum IVault.SwapKind\",\n            name: \"kind\",\n            type: \"uint8\",\n          },\n          {\n            components: [\n              {\n                internalType: \"bytes32\",\n                name: \"poolId\",\n                type: \"bytes32\",\n              },\n              {\n                internalType: \"uint256\",\n                name: \"assetInIndex\",\n                type: \"uint256\",\n              },\n              {\n                internalType: \"uint256\",\n                name: \"assetOutIndex\",\n                type: \"uint256\",\n              },\n              {\n                internalType: \"uint256\",\n                name: \"amount\",\n                type: \"uint256\",\n              },\n              {\n                internalType: \"bytes\",\n                name: \"userData\",\n                type: \"bytes\",\n              },\n            ],\n            internalType: \"struct IVault.BatchSwapStep[]\",\n            name: \"swaps\",\n            type: \"tuple[]\",\n          },\n          {\n            internalType: \"contract IAsset[]\",\n            name: \"assets\",\n            type: \"address[]\",\n          },\n          {\n            components: [\n              {\n                internalType: \"address\",\n                name: \"sender\",\n                type: \"address\",\n              },\n              {\n                internalType: \"bool\",\n                name: \"fromInternalBalance\",\n                type: \"bool\",\n              },\n              {\n                internalType: \"address payable\",\n                name: \"recipient\",\n                type: \"address\",\n              },\n              {\n                internalType: \"bool\",\n                name: \"toInternalBalance\",\n                type: \"bool\",\n              },\n            ],\n            internalType: \"struct IVault.FundManagement\",\n            name: \"funds\",\n            type: \"tuple\",\n          },\n          {\n            internalType: \"int256[]\",\n            name: \"limits\",\n            type: \"int256[]\",\n          },\n          {\n            internalType: \"uint256\",\n            name: \"deadline\",\n            type: \"uint256\",\n          },\n        ],\n        name: \"batchSwap\",\n        outputs: [\n          {\n            internalType: \"int256[]\",\n            name: \"assetDeltas\",\n            type: \"int256[]\",\n          },\n        ],\n        stateMutability: \"payable\",\n        type: \"function\",\n      },\n    ],\n    Ethers.provider().getSigner()\n  );\n\n  const params = [\n    0,\n    swap_steps_struct,\n    assets,\n    funds,\n    token_limits,\n    deadline.toFixed(),\n  ];\n  const options = {\n    value: type === 1 ? amount : \"0\",\n  };\n\n  SwapContract.estimateGas\n    .batchSwap(...params, options)\n    .then((gas) => {\n      SwapContract.batchSwap(...params, {\n        ...options,\n        gasLimit: gas,\n      })\n        .then((tx) => {\n          onSuccess(tx);\n        })\n        .catch((err) => {\n          onError(err);\n        });\n    })\n    .catch((err) => {\n      onError(err);\n    });\n}\n\nreturn \"\";\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/guessme.near/widget/ZKEVMSwap.swap-handler", "fact_widget_deployments_id": "0ca7ba9f348b37d58c9fb59dcbe5bcae", "inserted_timestamp": "2023-12-20T09:52:28.043Z", "modified_timestamp": "2023-12-20T10:21:46.284Z", "__row_index": 0}