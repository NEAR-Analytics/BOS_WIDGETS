{"tx_hash": "Bqawojao6nQUSMrGRD4MpxJqQaRRbnYmeZBqpjmoVNVe", "action_id_social": "F2riApyzEW1BTsLc5WeBnZFE4421xmeFXYx5NykBKehp-0-widget", "block_id": 105706381, "block_timestamp": "2023-11-14T19:53:24.707Z", "signer_id": "astraplusplus.ndctools.near", "widget_name": "DAO.Proposals.Card.index", "source_code": "const multiSelectMode = props.multiSelectMode ?? false;\nlet { proposalString, proposalId, daoId, daoConfig } = props;\nconst accountId = context.accountId;\n\nconst CoADaoId = props.dev\n    ? \"coa.gwg-testing.near\"\n    : \"congress-coa-v1.ndc-gwg.near\";\nconst VotingBodyDaoId = props.dev\n    ? \"voting-body-v1.gwg-testing.near\"\n    : \"voting-body-v1.ndc-gwg.near\";\nconst TCDaoId = props.dev\n    ? \"tc.gwg-testing.near\"\n    : \"congress-tc-v1.ndc-gwg.near\";\nconst HoMDaoId = props.dev\n    ? \"hom.gwg-testing.near\"\n    : \"congress-hom-v1.ndc-gwg.near\";\nconst registry = props.dev\n    ? \"registry-v1.gwg-testing.near\"\n    : \"registry.i-am-human.near\";\n\nconst isCongressDaoID =\n    daoId === HoMDaoId || daoId === CoADaoId || daoId === TCDaoId;\n\nconst isVotingBodyDao = daoId === VotingBodyDaoId;\n\nif (!daoConfig) {\n    if (isCongressDaoID || isVotingBodyDao) {\n        daoConfig = Near.view(daoId, \"config\", {});\n    }\n}\n\nconst currentuserCongressHouse = null; // if the current user is a member of any house\n\nfunction itemIsInArray(item, array) {\n    return array.includes(item);\n}\n\nif (isVotingBodyDao || daoId === HoMDaoId) {\n    currentuserCongressHouse = useCache(\n        () =>\n            Near.asyncView(HoMDaoId, \"get_members\").then((res) =>\n                itemIsInArray(accountId, res?.members) ? HoMDaoId : null\n            ),\n        HoMDaoId + \"-is-hom-member\",\n        { subscribe: false }\n    );\n\n    if (!currentuserCongressHouse) {\n        currentuserCongressHouse = useCache(\n            () =>\n                Near.asyncView(CoADaoId, \"get_members\").then((res) =>\n                    itemIsInArray(accountId, res?.members) ? CoADaoId : null\n                ),\n            CoADaoId + \"-is-coa-member\",\n            { subscribe: false }\n        );\n    }\n\n    if (!currentuserCongressHouse) {\n        currentuserCongressHouse = useCache(\n            () =>\n                Near.asyncView(TCDaoId, \"get_members\").then((res) =>\n                    itemIsInArray(accountId, res?.members) ? TCDaoId : null\n                ),\n            TCDaoId + \"-is-tc-member\",\n            { subscribe: false }\n        );\n    }\n}\n\nconst isHuman = useCache(\n    () =>\n        asyncFetch(\n            `https://api.pikespeak.ai/sbt/sbt-by-owner?holder=${accountId}&registry=registry.i-am-human.near`,\n            {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    \"x-api-key\": \"36f2b87a-7ee6-40d8-80b9-5e68e587a5b5\"\n                }\n            }\n        ).then((res) => res?.body?.length > 0),\n    daoId + \"-is-voting-allowed\",\n    { subscribe: false }\n);\n\nif (isHuman === null) {\n    return <Widget src=\"nearui.near/widget/Feedback.Spinner\" />;\n}\n\nconst policy = isCongressDaoID\n    ? Near.view(daoId, \"get_members\")\n    : isVotingBodyDao\n    ? \"\"\n    : Near.view(daoId, \"get_policy\");\nlet roles = policy;\n\nfunction getPreVoteVotes(supported) {\n    const votes = {};\n    for (const item of supported) {\n        votes[item] = \"Support\";\n    }\n    return votes;\n}\n\nif (roles === null)\n    return (\n        <Widget src=\"astraplusplus.ndctools.near/widget/DAO.Proposals.Card.skeleton\" />\n    );\n\nlet new_proposal = null;\nif (!proposalString && proposalId && daoId) {\n    if (isCongressDaoID || isVotingBodyDao) {\n        const resp = Near.view(daoId, \"get_proposal\", {\n            id: parseInt(proposalId)\n        });\n        if (res === null) {\n            return (\n                <Widget src=\"astraplusplus.ndctools.near/widget/DAO.Proposals.Card.skeleton\" />\n            );\n        } else {\n            new_proposal = {\n                id: resp.id,\n                kind: resp.kind,\n                votes:\n                    resp.status === \"PreVote\"\n                        ? getPreVoteVotes(resp.supported)\n                        : resp.votes ?? {},\n                status: resp.status,\n                proposer: resp?.proposer,\n                description: resp.description,\n                vote_counts: {},\n                submission_time: resp?.submission_time ?? resp?.start, // for vb it's start\n                supported: resp?.supported ?? [], // for vb\n                approve: resp?.approve ?? 0,\n                reject: resp?.reject ?? 0,\n                spam: resp?.spam ?? 0,\n                abstain: resp?.abstain ?? 0\n            };\n        }\n    } else {\n        // TODO: THIS API IS SO WEIRD AND INCONSISTENT WITH PROPOSALS API, VOTE IS BROKEN\n        new_proposal = fetch(\n            `https://api.pikespeak.ai/daos/proposal/${daoId}?id=${proposalId}`,\n            {\n                mode: \"cors\",\n                headers: {\n                    \"x-api-key\": \"36f2b87a-7ee6-40d8-80b9-5e68e587a5b5\"\n                }\n            }\n        );\n\n        if (new_proposal === null) {\n            return (\n                <Widget src=\"astraplusplus.ndctools.near/widget/DAO.Proposals.Card.skeleton\" />\n            );\n        } else if (!new_proposal.ok) {\n            return \"Proposal not found, check console for details.\";\n        }\n        new_proposal = new_proposal.body[0].proposal;\n    }\n} else if (!proposalString) {\n    return \"Please provide a daoId and a proposal or proposalId.\";\n}\n\nif (!proposalString && !new_proposal) {\n    return (\n        <Widget src=\"astraplusplus.ndctools.near/widget/DAO.Proposals.Card.skeleton\" />\n    );\n}\n\nconst proposal = proposalString ? JSON.parse(proposalString) : new_proposal;\n\nconst expensiveWork = () => {\n    let my_proposal = new_proposal ? new_proposal : proposal;\n\n    // --- check user permissions\n    const proposalKinds = {\n        ChangeConfig: \"config\",\n        ChangePolicy: \"policy\",\n        AddMemberToRole: \"add_member_to_role\",\n        RemoveMemberFromRole: \"remove_member_from_role\",\n        FunctionCall: isCongressDaoID ? \"FunctionCall\" : \"call\",\n        UpgradeSelf: \"upgrade_self\",\n        UpgradeRemote: \"upgrade_remote\",\n        Transfer: \"transfer\",\n        SetStakingContract: \"set_vote_token\",\n        AddBounty: \"add_bounty\",\n        BountyDone: \"bounty_done\",\n        Vote: \"vote\",\n        FactoryInfoUpdate: \"factory_info_update\",\n        ChangePolicyAddOrUpdateRole: \"policy_add_or_update_role\",\n        ChangePolicyRemoveRole: \"policy_remove_role\",\n        ChangePolicyUpdateDefaultVotePolicy:\n            \"policy_update_default_vote_policy\",\n        ChangePolicyUpdateParameters: \"policy_update_parameters\",\n        Text: \"Text\",\n        FundingRequest: \"FundingRequest\",\n        RecurrentFundingRequest: \"RecurrentFundingRequest\",\n        DismissAndBan: \"DismissAndBan\"\n    };\n\n    const actions = {\n        AddProposal: \"AddProposal\",\n        VoteApprove: \"VoteApprove\",\n        VoteReject: \"VoteReject\",\n        VoteRemove: \"VoteRemove\",\n        VoteAbstain: \"VoteAbstain\"\n    };\n\n    // -- Get all the roles from the DAO policy\n    roles = roles === null ? [] : roles?.roles ?? roles;\n\n    // -- Filter the user roles\n    const userRoles = [];\n    if (Array.isArray(roles)) {\n        for (const role of roles) {\n            if (role.kind === \"Everyone\") {\n                userRoles.push(role);\n                continue;\n            }\n            if (!role.kind.Group) continue;\n            if (\n                accountId &&\n                role.kind.Group &&\n                role.kind.Group.includes(accountId)\n            ) {\n                userRoles.push(role);\n            }\n        }\n    }\n\n    if (isCongressDaoID) {\n        userRoles = [\n            {\n                name: \"all\",\n                kind: \"Everyone\",\n                permissions: roles?.permissions,\n                vote_policy: {}\n            }\n        ];\n    }\n\n    if (isVotingBodyDao) {\n        userRoles = [\n            {\n                name: \"all\",\n                kind: \"Everyone\",\n                permissions: {},\n                vote_policy: {}\n            }\n        ];\n    }\n\n    const isAllowedTo = (kind, action) => {\n        // -- Check if the user is allowed to perform the action\n        let allowed = false;\n        userRoles\n            .filter(({ permissions }) => {\n                if (isCongressDaoID) {\n                    const allowedRole =\n                        permissions.includes(`${kind.toString()}`) &&\n                        roles?.members?.includes(accountId);\n                    allowed = allowed || allowedRole;\n                    return allowedRole;\n                } else {\n                    const allowedRole =\n                        permissions.includes(\n                            `${kind.toString()}:${action.toString()}`\n                        ) ||\n                        permissions.includes(`${kind.toString()}:*`) ||\n                        permissions.includes(`*:${action.toString()}`) ||\n                        permissions.includes(\"*:*\");\n                    allowed = allowed || allowedRole;\n                    return allowedRole;\n                }\n            })\n            .map((role) => role.name);\n        return allowed;\n    };\n\n    const kindName =\n        typeof my_proposal.kind === \"string\"\n            ? my_proposal.kind\n            : isCongressDaoID || isVotingBodyDao\n            ? Object.keys(my_proposal.kind)[0]\n            : typeof my_proposal.kind.typeEnum === \"string\"\n            ? my_proposal.kind.typeEnum\n            : Object.keys(my_proposal.kind)[0];\n\n    const isAllowedToVote = isVotingBodyDao\n        ? [isHuman, isHuman, isHuman, isHuman]\n        : [\n              isAllowedTo(proposalKinds[kindName], actions.VoteApprove),\n              isAllowedTo(proposalKinds[kindName], actions.VoteReject),\n              isCongressDaoID\n                  ? isAllowedTo(proposalKinds[kindName], actions.VoteAbstain)\n                  : isAllowedTo(proposalKinds[kindName], actions.VoteRemove)\n          ];\n\n    // --- end check user permissions\n    // --- Votes required:\n    // TODO: Needs to be reviewed\n\n    // Fixes pikespeak API for single proposal\n    Object.keys(my_proposal.vote_counts).forEach((k) => {\n        if (typeof my_proposal.vote_counts[k] !== \"string\") return;\n        my_proposal.vote_counts[k] = my_proposal.vote_counts[k]\n            .match(/.{1,2}/g)\n            .slice(0, 3)\n            .map((a) => parseInt(a));\n    });\n\n    let totalVotesNeeded = 0;\n\n    if (policy?.roles) {\n        policy.roles.forEach((role) => {\n            // Determine if the role is eligible for the given proposalType\n            const isRoleAllowedToVote =\n                role.permissions.includes(\n                    `${proposalKinds[kindName]}:VoteApprove`\n                ) ||\n                role.permissions.includes(\n                    `${proposalKinds[kindName]}:VoteReject`\n                ) ||\n                role.permissions.includes(`${proposalKinds[kindName]}:*`) ||\n                role.permissions.includes(`*:VoteApprove`) ||\n                role.permissions.includes(`*:VoteReject`) ||\n                role.permissions.includes(\"*:*\");\n\n            if (isRoleAllowedToVote) {\n                const threshold = (role.vote_policy &&\n                    role.vote_policy[proposalKinds[kindName]]?.threshold) ||\n                    policy[\"default_vote_policy\"]?.threshold || [0, 0];\n                const eligibleVoters = role.kind.Group\n                    ? role.kind.Group.length\n                    : 0;\n\n                // Apply the threshold\n                const votesNeeded = Math.ceil(\n                    (threshold[0] / threshold[1]) * eligibleVoters\n                );\n\n                totalVotesNeeded += votesNeeded;\n            }\n        });\n    }\n    my_proposal.typeName = kindName.replace(/([A-Z])/g, \" $1\").trim(); // Add spaces between camelCase\n    if (isCongressDaoID) {\n        totalVotesNeeded = daoConfig?.threshold;\n    }\n\n    if (isVotingBodyDao) {\n        if (my_proposal.typeName === \"Dissolve\") {\n            totalVotesNeeded = daoConfig?.super_consent?.quorum;\n        } else if (my_proposal.typeName === \"Pre Vote\") {\n            totalVotesNeeded = daoConfig?.pre_vote_support;\n        } else {\n            totalVotesNeeded = daoConfig?.simple_consent?.quorum;\n        }\n    }\n\n    let totalVotes = {\n        yes: 0,\n        no: 0,\n        spam: 0,\n        abstain: 0,\n        total: 0\n    };\n\n    Object.keys(my_proposal.vote_counts).forEach((key) => {\n        totalVotes.yes += my_proposal.vote_counts[key][0];\n        totalVotes.no += my_proposal.vote_counts[key][1];\n        totalVotes.spam += my_proposal.vote_counts[key][2];\n    });\n\n    if (isVotingBodyDao) {\n        totalVotes.yes = my_proposal?.approve ?? 0;\n        totalVotes.no = my_proposal?.reject ?? 0;\n        totalVotes.abstain = my_proposal?.abstain ?? 0;\n        totalVotes.spam = my_proposal?.spam ?? 0;\n    }\n\n    if (isCongressDaoID) {\n        for (const { vote } of Object.values(my_proposal.votes)) {\n            if (vote === \"Approve\") {\n                totalVotes.yes++;\n            } else if (vote === \"Reject\") {\n                totalVotes.no++;\n            } else if (vote === \"Abstain\") {\n                totalVotes.abstain++;\n            } else if (vote === \"Spam\") {\n                totalVotes.spam++;\n            }\n        }\n    }\n    totalVotes.total =\n        totalVotes.yes + totalVotes.no + totalVotes.spam + totalVotes.abstain;\n\n    if (my_proposal.status === \"PreVote\") {\n        totalVotes.total = my_proposal?.support ?? 0;\n    }\n\n    my_proposal.totalVotesNeeded = totalVotesNeeded;\n    my_proposal.totalVotes = totalVotes;\n    // --- end Votes required\n\n    my_proposal.statusName = my_proposal.status\n        .replace(/([A-Z])/g, \" $1\")\n        .trim();\n\n    if (!state) {\n        State.init({\n            proposal: my_proposal,\n            isAllowedToVote\n        });\n    } else {\n        State.update({\n            proposal: my_proposal,\n            isAllowedToVote\n        });\n    }\n};\n\nconst comments = Social.index(\"comment\", {\n    type: \"dao_proposal_comment\",\n    path: `${daoId}/proposal/main`,\n    proposal_id: proposal.id + \"-beta\"\n});\n\nif (!state || state.proposal.id !== proposal.id) {\n    // Only execute expensive work once\n    expensiveWork();\n    return multiSelectMode ? (\n        \"\"\n    ) : (\n        <Widget src=\"astraplusplus.ndctools.near/widget/DAO.Proposals.Card.skeleton\" />\n    );\n}\n\nconst handleVote = ({ action, proposalId, daoId }) => {\n    let args = {};\n    if (isVotingBodyDao) {\n        args[\"prop_id\"] = parseInt(proposalId);\n        args[\"caller\"] = accountId;\n        args[\"vote\"] = action.replace(\"Vote\", \"\");\n\n        Near.call([\n            {\n                contractName: registry,\n                methodName: \"is_human_call_lock\",\n                args: {\n                    ctr: daoId,\n                    function: \"vote\",\n                    payload: JSON.stringify(args),\n                    lock_duration:\n                        proposal?.submission_time +\n                        daoConfig?.vote_duration -\n                        Date.now() +\n                        1,\n                    with_proof: false\n                },\n                gas: 200000000000000,\n                deposit: 20000000000000000000000\n            }\n        ]);\n    } else {\n        args[\"id\"] = JSON.parse(proposalId);\n        if (isCongressDaoID) {\n            args[\"vote\"] = action.replace(\"Vote\", \"\");\n        } else {\n            args[\"action\"] = action;\n        }\n        Near.call([\n            {\n                contractName: daoId,\n                methodName: isCongressDaoID ? \"vote\" : \"act_proposal\",\n                args: args,\n                gas: 200000000000000\n            }\n        ]);\n    }\n};\n\nconst handlePreVoteAction = ({ action, proposalId }) => {\n    switch (action) {\n        case \"support_proposal_by_congress\": {\n            Near.call([\n                {\n                    contractName: daoId,\n                    methodName: \"support_proposal_by_congress\",\n                    args: {\n                        prop_id: parseInt(proposalId),\n                        dao: currentuserCongressHouse\n                    },\n                    gas: 200000000000000\n                }\n            ]);\n            break;\n        }\n        case \"support_proposal\": {\n            Near.call([\n                {\n                    contractName: registry,\n                    methodName: \"is_human_call_lock\",\n                    args: {\n                        ctr: daoId,\n                        function: \"support_proposal\",\n                        payload: JSON.stringify(parseInt(proposalId)),\n                        lock_duration:\n                            proposal?.submission_time +\n                            daoConfig?.pre_vote_duration -\n                            Date.now() +\n                            1,\n                        with_proof: false\n                    },\n                    gas: 200000000000000\n                }\n            ]);\n            break;\n        }\n        case \"top_up_proposal\": {\n            const deposit =\n                parseInt(daoConfig?.active_queue_bond) -\n                parseInt(daoConfig?.pre_vote_bond);\n\n            Near.call([\n                {\n                    contractName: daoId,\n                    methodName: \"top_up_proposal\",\n                    args: {\n                        id: parseInt(proposalId)\n                    },\n                    gas: 200000000000000,\n                    deposit: deposit\n                }\n            ]);\n            break;\n        }\n    }\n};\n\nreturn (\n    <Widget\n        src=\"astraplusplus.ndctools.near/widget/DAO.Proposals.Card.ui\"\n        props={{\n            proposal: state.proposal,\n            isAllowedToVote: state.isAllowedToVote,\n            multiSelectMode,\n            daoId,\n            policy,\n            comments: comments,\n            handleVote,\n            isCongressDaoID,\n            isVotingBodyDao,\n            daoConfig,\n            handlePreVoteAction,\n            isHuman,\n            currentuserCongressHouse,\n            dev: props.dev,\n            HoMDaoId,\n            CoADaoId,\n            registry\n        }}\n    />\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/astraplusplus.ndctools.near/widget/DAO.Proposals.Card.index", "fact_widget_deployments_id": "b486ff9ba8f2b3fcdaf050681ad1cdaa", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 6}