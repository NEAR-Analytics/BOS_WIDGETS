{"tx_hash": "HavxhB7dgmvZvm8sVNACM2XT8CCMt4TVcBP1AbUCcU3r", "action_id_social": "DT9oQUFzdqupEp1nn2BWB4PgM8iSXcPxR483qJskvHHn-0-widget", "block_id": 103217881, "block_timestamp": "2023-10-12T17:18:32.272Z", "signer_id": "astraplusplus.ndctools.near", "widget_name": "DAO.Proposals.Card.index", "source_code": "const multiSelectMode = props.multiSelectMode ?? false;\nconst { proposalString, proposalId, daoId, isCongressDaoID, daoConfig } = props;\nconst accountId = context.accountId;\n\nconst proposal = proposalString ? JSON.parse(proposalString) : null;\n\nconst policy = isCongressDaoID\n    ? Near.view(daoId, \"get_members\")\n    : Near.view(daoId, \"get_policy\");\nlet roles = policy;\n\nif (roles === null)\n    return (\n        <Widget src=\"astraplusplus.ndctools.near/widget/DAO.Proposals.Card.skeleton\" />\n    );\n\nlet new_proposal = null;\nif (!proposalString && proposalId && daoId && !isCongressDaoID) {\n    // TODO: THIS API IS SO WEIRD AND INCONSISTENT WITH PROPOSALS API, VOTE IS BROKEN\n    new_proposal = fetch(\n        `https://api.pikespeak.ai/daos/proposal/${daoId}?id=${proposalId}`,\n        {\n            mode: \"cors\",\n            headers: {\n                \"x-api-key\": \"36f2b87a-7ee6-40d8-80b9-5e68e587a5b5\"\n            }\n        }\n    );\n    if (new_proposal === null) {\n        return (\n            <Widget src=\"astraplusplus.ndctools.near/widget/DAO.Proposals.Card.skeleton\" />\n        );\n    } else if (!new_proposal.ok) {\n        return \"Proposal not found, check console for details.\";\n    }\n    new_proposal = new_proposal.body[0].proposal;\n} else if (!proposalString) {\n    return \"Please provide a daoId and a proposal or proposalId.\";\n}\n\nconst expensiveWork = () => {\n    let my_proposal = new_proposal ? new_proposal : proposal;\n\n    // --- check user permissions\n    const proposalKinds = {\n        ChangeConfig: \"config\",\n        ChangePolicy: \"policy\",\n        AddMemberToRole: \"add_member_to_role\",\n        RemoveMemberFromRole: \"remove_member_from_role\",\n        FunctionCall: isCongressDaoID ? \"FunctionCall\" : \"call\",\n        UpgradeSelf: \"upgrade_self\",\n        UpgradeRemote: \"upgrade_remote\",\n        Transfer: \"transfer\",\n        SetStakingContract: \"set_vote_token\",\n        AddBounty: \"add_bounty\",\n        BountyDone: \"bounty_done\",\n        Vote: \"vote\",\n        FactoryInfoUpdate: \"factory_info_update\",\n        ChangePolicyAddOrUpdateRole: \"policy_add_or_update_role\",\n        ChangePolicyRemoveRole: \"policy_remove_role\",\n        ChangePolicyUpdateDefaultVotePolicy:\n            \"policy_update_default_vote_policy\",\n        ChangePolicyUpdateParameters: \"policy_update_parameters\",\n        Text: \"Text\",\n        FundingRequest: \"FundingRequest\",\n        RecurrentFundingRequest: \"RecurrentFundingRequest\",\n        DismissAndBan: \"DismissAndBan\"\n    };\n\n    const actions = {\n        AddProposal: \"AddProposal\",\n        VoteApprove: \"VoteApprove\",\n        VoteReject: \"VoteReject\",\n        VoteRemove: \"VoteRemove\"\n    };\n\n    // -- Get all the roles from the DAO policy\n    roles = roles === null ? [] : roles?.roles ?? roles;\n\n    // -- Filter the user roles\n    const userRoles = [];\n    if (Array.isArray(roles)) {\n        for (const role of roles) {\n            if (role.kind === \"Everyone\") {\n                userRoles.push(role);\n                continue;\n            }\n            if (!role.kind.Group) continue;\n            if (\n                accountId &&\n                role.kind.Group &&\n                role.kind.Group.includes(accountId)\n            ) {\n                userRoles.push(role);\n            }\n        }\n    }\n\n    if (isCongressDaoID) {\n        userRoles = [\n            {\n                name: \"all\",\n                kind: \"Everyone\",\n                permissions: roles?.permissions,\n                vote_policy: {}\n            }\n        ];\n    }\n\n    const isAllowedTo = (kind, action) => {\n        // -- Check if the user is allowed to perform the action\n        let allowed = false;\n        userRoles\n            .filter(({ permissions }) => {\n                if (isCongressDaoID) {\n                    const allowedRole =\n                        permissions.includes(`${kind.toString()}`) &&\n                        roles?.members?.includes(accountId);\n                    allowed = allowed || allowedRole;\n                    return allowedRole;\n                } else {\n                    const allowedRole =\n                        permissions.includes(\n                            `${kind.toString()}:${action.toString()}`\n                        ) ||\n                        permissions.includes(`${kind.toString()}:*`) ||\n                        permissions.includes(`*:${action.toString()}`) ||\n                        permissions.includes(\"*:*\");\n                    allowed = allowed || allowedRole;\n                    return allowedRole;\n                }\n            })\n            .map((role) => role.name);\n        return allowed;\n    };\n\n    const kindName =\n        typeof my_proposal.kind === \"string\"\n            ? my_proposal.kind\n            : isCongressDaoID\n            ? Object.keys(my_proposal.kind)[0]\n            : typeof my_proposal.kind.typeEnum === \"string\"\n            ? my_proposal.kind.typeEnum\n            : Object.keys(my_proposal.kind)[0];\n\n    const isAllowedToVote = [\n        isAllowedTo(proposalKinds[kindName], actions.VoteApprove),\n        isAllowedTo(proposalKinds[kindName], actions.VoteReject),\n        isAllowedTo(proposalKinds[kindName], actions.VoteRemove)\n    ];\n    // --- end check user permissions\n    // --- Votes required:\n    // TODO: Needs to be reviewed\n\n    // Fixes pikespeak API for single proposal\n    Object.keys(my_proposal.vote_counts).forEach((k) => {\n        if (typeof my_proposal.vote_counts[k] !== \"string\") return;\n        my_proposal.vote_counts[k] = my_proposal.vote_counts[k]\n            .match(/.{1,2}/g)\n            .slice(0, 3)\n            .map((a) => parseInt(a));\n    });\n\n    let totalVotesNeeded = 0;\n\n    if (policy?.roles) {\n        policy.roles.forEach((role) => {\n            // Determine if the role is eligible for the given proposalType\n            const isRoleAllowedToVote =\n                role.permissions.includes(\n                    `${proposalKinds[kindName]}:VoteApprove`\n                ) ||\n                role.permissions.includes(\n                    `${proposalKinds[kindName]}:VoteReject`\n                ) ||\n                role.permissions.includes(`${proposalKinds[kindName]}:*`) ||\n                role.permissions.includes(`*:VoteApprove`) ||\n                role.permissions.includes(`*:VoteReject`) ||\n                role.permissions.includes(\"*:*\");\n\n            if (isRoleAllowedToVote) {\n                const threshold = (role.vote_policy &&\n                    role.vote_policy[proposalKinds[kindName]]?.threshold) ||\n                    policy[\"default_vote_policy\"]?.threshold || [0, 0];\n                const eligibleVoters = role.kind.Group\n                    ? role.kind.Group.length\n                    : 0;\n\n                // Apply the threshold\n                const votesNeeded = Math.ceil(\n                    (threshold[0] / threshold[1]) * eligibleVoters\n                );\n\n                totalVotesNeeded += votesNeeded;\n            }\n        });\n    }\n\n    if (isCongressDaoID) {\n        totalVotesNeeded = daoConfig?.threshold;\n    }\n\n    let totalVotes = {\n        yes: 0,\n        no: 0,\n        spam: 0,\n        total: 0\n    };\n\n    Object.keys(my_proposal.vote_counts).forEach((key) => {\n        totalVotes.yes += my_proposal.vote_counts[key][0];\n        totalVotes.no += my_proposal.vote_counts[key][1];\n        totalVotes.spam += my_proposal.vote_counts[key][2];\n    });\n\n    if (isCongressDaoID) {\n        for (const value of Object.values(my_proposal.votes)) {\n            if (value === \"Approve\") {\n                totalVotes.yes++;\n            } else if (value === \"Reject\") {\n                totalVotes.no++;\n            }\n        }\n    }\n    totalVotes.total = totalVotes.yes + totalVotes.no + totalVotes.spam;\n\n    my_proposal.totalVotesNeeded = totalVotesNeeded;\n    my_proposal.totalVotes = totalVotes;\n    // --- end Votes required\n\n    my_proposal.typeName = kindName.replace(/([A-Z])/g, \" $1\").trim(); // Add spaces between camelCase\n    my_proposal.statusName = my_proposal.status\n        .replace(/([A-Z])/g, \" $1\")\n        .trim();\n\n    if (!state) {\n        State.init({\n            proposal: my_proposal,\n            isAllowedToVote\n        });\n    } else {\n        State.update({\n            proposal: my_proposal,\n            isAllowedToVote\n        });\n    }\n};\n\nconst comments = Social.index(\"comment\", {\n    type: \"dao_proposal_comment\",\n    path: `${daoId}/proposal/main`,\n    proposal_id: proposal.id + \"-beta\"\n});\n\nif (!state || state.proposal.id !== proposal.id) {\n    // Only execute expensive work once\n    expensiveWork();\n    return multiSelectMode ? (\n        \"\"\n    ) : (\n        <Widget src=\"astraplusplus.ndctools.near/widget/DAO.Proposals.Card.skeleton\" />\n    );\n}\n\nconst handleVote = ({ action, proposalId, daoId }) => {\n    let args = {\n        id: JSON.parse(proposalId)\n    };\n    if (isCongressDaoID) {\n        args[\"vote\"] = action.replace(\"Vote\", \"\");\n    } else {\n        args[\"action\"] = action;\n    }\n    Near.call([\n        {\n            contractName: daoId,\n            methodName: isCongressDaoID ? \"vote\" : \"act_proposal\",\n            args: args,\n            gas: 200000000000000\n        }\n    ]);\n};\n\nreturn (\n    <Widget\n        src=\"astraplusplus.ndctools.near/widget/DAO.Proposals.Card.ui\"\n        props={{\n            proposal: state.proposal,\n            isAllowedToVote: state.isAllowedToVote,\n            multiSelectMode,\n            daoId,\n            policy,\n            comments: comments,\n            handleVote,\n            isCongressDaoID,\n            daoConfig\n        }}\n    />\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/astraplusplus.ndctools.near/widget/DAO.Proposals.Card.index", "fact_widget_deployments_id": "e88d964cf780b902347c17a24164a31b", "inserted_timestamp": "2023-10-12T19:24:29.485Z", "modified_timestamp": "2023-10-12T19:24:29.485Z", "__row_index": 7}