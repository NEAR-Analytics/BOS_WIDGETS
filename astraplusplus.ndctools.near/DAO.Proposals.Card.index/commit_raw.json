{"tx_hash": "C5fmdue4JbBaxHkHptMeEwYgBFa5UVn25TCWk2B28p6e", "action_id_social": "B7NHrAk3M9MCx3qdnw7YAKbTLpKEQAbu2i4WPRov2oBU-0-widget", "block_id": 116697630, "block_timestamp": "2024-04-12T16:52:21.471Z", "signer_id": "astraplusplus.ndctools.near", "widget_name": "DAO.Proposals.Card.index", "source_code": "const multiSelectMode = props.multiSelectMode ?? false;\nlet { proposalString, proposalId, daoId, daoConfig, showNavButton } = props;\nconst accountId = context.accountId;\n\nconst CoADaoId = props.dev\n  ? \"coa.gwg-testing.near\"\n  : \"congress-coa-v1.ndc-gwg.near\";\nconst VotingBodyDaoId = props.dev\n  ? \"voting-body-v1.gwg-testing.near\"\n  : \"voting-body-v1.ndc-gwg.near\";\nconst TCDaoId = props.dev\n  ? \"tc.gwg-testing.near\"\n  : \"congress-tc-v1.ndc-gwg.near\";\nconst HoMDaoId = props.dev\n  ? \"hom.gwg-testing.near\"\n  : \"congress-hom-v1.ndc-gwg.near\";\nconst registry = props.dev\n  ? \"registry-v1.gwg-testing.near\"\n  : \"registry.i-am-human.near\";\n\nconst isCongressDaoID =\n  daoId === HoMDaoId || daoId === CoADaoId || daoId === TCDaoId;\n\nconst isVotingBodyDao = daoId === VotingBodyDaoId;\n\nif (!daoConfig) {\n  if (isCongressDaoID || isVotingBodyDao) {\n    daoConfig = Near.view(daoId, \"config\", {});\n  }\n}\n\nconst currentuserCongressHouse = null; // if the current user is a member of any house\n\nfunction itemIsInArray(item, array) {\n  return array.includes(item);\n}\n\nif (isVotingBodyDao || daoId === HoMDaoId) {\n  currentuserCongressHouse = useCache(\n    () =>\n      Near.asyncView(HoMDaoId, \"get_members\").then((res) =>\n        itemIsInArray(accountId, res?.members) ? HoMDaoId : null\n      ),\n    HoMDaoId + \"-is-hom-member\",\n    { subscribe: false }\n  );\n\n  if (!currentuserCongressHouse) {\n    currentuserCongressHouse = useCache(\n      () =>\n        Near.asyncView(CoADaoId, \"get_members\").then((res) =>\n          itemIsInArray(accountId, res?.members) ? CoADaoId : null\n        ),\n      CoADaoId + \"-is-coa-member\",\n      { subscribe: false }\n    );\n  }\n\n  if (!currentuserCongressHouse) {\n    currentuserCongressHouse = useCache(\n      () =>\n        Near.asyncView(TCDaoId, \"get_members\").then((res) =>\n          itemIsInArray(accountId, res?.members) ? TCDaoId : null\n        ),\n      TCDaoId + \"-is-tc-member\",\n      { subscribe: false }\n    );\n  }\n}\n\nconst isHuman = useCache(\n  () =>\n    Near.asyncView(registry, \"is_human\", { account: accountId }).then(\n      (sbts) => {\n        return sbts.length > 0;\n      }\n    ),\n  daoId + \"-is-voting-allowed\",\n  { subscribe: false }\n);\n\nif (isHuman === null) {\n  return <Widget src=\"nearui.near/widget/Feedback.Spinner\" />;\n}\n\nconst policy = isCongressDaoID\n  ? Near.view(daoId, \"get_members\")\n  : isVotingBodyDao\n  ? \"\"\n  : Near.view(daoId, \"get_policy\");\nlet roles = policy;\n\nfunction getPreVoteVotes(supported) {\n  const votes = {};\n  for (const item of supported) {\n    votes[item] = \"Support\";\n  }\n  return votes;\n}\n\nif (roles === null)\n  return (\n    <Widget src=\"astraplusplus.ndctools.near/widget/DAO.Proposals.Card.skeleton\" />\n  );\n\nlet new_proposal = null;\nif (!proposalString && proposalId && daoId) {\n  if (isCongressDaoID || isVotingBodyDao) {\n    const resp = Near.view(daoId, \"get_proposal\", {\n      id: parseInt(proposalId)\n    });\n    if (res === null) {\n      return (\n        <Widget src=\"astraplusplus.ndctools.near/widget/DAO.Proposals.Card.skeleton\" />\n      );\n    } else {\n      new_proposal = {\n        id: resp.id,\n        kind: resp.kind,\n        votes:\n          resp.status === \"PreVote\"\n            ? getPreVoteVotes(resp.supported)\n            : resp.votes ?? {},\n        status: resp.status,\n        proposer: resp?.proposer,\n        description: resp.description,\n        vote_counts: {},\n        submission_time: resp?.submission_time ?? resp?.start, // for vb it's start\n        supported: resp?.supported ?? [], // for vb\n        approve: resp?.approve ?? 0,\n        reject: resp?.reject ?? 0,\n        spam: resp?.spam ?? 0,\n        abstain: resp?.abstain ?? 0\n      };\n    }\n  } else {\n    // TODO: THIS API IS SO WEIRD AND INCONSISTENT WITH PROPOSALS API, VOTE IS BROKEN\n    new_proposal = fetch(\n      `https://api.pikespeak.ai/daos/proposal/${daoId}?id=${proposalId}`,\n      {\n        mode: \"cors\",\n        headers: {\n          \"x-api-key\": \"36f2b87a-7ee6-40d8-80b9-5e68e587a5b5\"\n        }\n      }\n    );\n\n    if (new_proposal === null) {\n      return (\n        <Widget src=\"astraplusplus.ndctools.near/widget/DAO.Proposals.Card.skeleton\" />\n      );\n    } else if (!new_proposal.ok) {\n      return \"Proposal not found, check console for details.\";\n    }\n    new_proposal = new_proposal.body[0].proposal;\n    if (typeof new_proposal.kind !== \"string\") {\n      new_proposal.kind = {\n        [new_proposal.kind.typeEnum]: new_proposal.kind\n      };\n    }\n  }\n} else if (!proposalString) {\n  return \"Please provide a daoId and a proposal or proposalId.\";\n}\n\nif (!proposalString && !new_proposal) {\n  return (\n    <Widget src=\"astraplusplus.ndctools.near/widget/DAO.Proposals.Card.skeleton\" />\n  );\n}\n\nconst proposal = proposalString ? JSON.parse(proposalString) : new_proposal;\n\nconst expensiveWork = () => {\n  let my_proposal = new_proposal ? new_proposal : proposal;\n\n  // --- check user permissions\n  const proposalKinds = {\n    ChangeConfig: \"config\",\n    ChangePolicy: \"policy\",\n    AddMemberToRole: \"add_member_to_role\",\n    RemoveMemberFromRole: \"remove_member_from_role\",\n    FunctionCall: isCongressDaoID ? \"FunctionCall\" : \"call\",\n    UpgradeSelf: \"upgrade_self\",\n    UpgradeRemote: \"upgrade_remote\",\n    Transfer: \"transfer\",\n    SetStakingContract: \"set_vote_token\",\n    AddBounty: \"add_bounty\",\n    BountyDone: \"bounty_done\",\n    Vote: \"vote\",\n    FactoryInfoUpdate: \"factory_info_update\",\n    ChangePolicyAddOrUpdateRole: \"policy_add_or_update_role\",\n    ChangePolicyRemoveRole: \"policy_remove_role\",\n    ChangePolicyUpdateDefaultVotePolicy: \"policy_update_default_vote_policy\",\n    ChangePolicyUpdateParameters: \"policy_update_parameters\",\n    Text: \"Text\",\n    FundingRequest: \"FundingRequest\",\n    RecurrentFundingRequest: \"RecurrentFundingRequest\",\n    DismissAndBan: \"DismissAndBan\"\n  };\n\n  const actions = {\n    AddProposal: \"AddProposal\",\n    VoteApprove: \"VoteApprove\",\n    VoteReject: \"VoteReject\",\n    VoteRemove: \"VoteRemove\",\n    VoteAbstain: \"VoteAbstain\"\n  };\n\n  // -- Get all the roles from the DAO policy\n  roles = roles === null ? [] : roles?.roles ?? roles;\n\n  // -- Filter the user roles\n  const userRoles = [];\n  if (Array.isArray(roles)) {\n    for (const role of roles) {\n      if (role.kind === \"Everyone\") {\n        userRoles.push(role);\n        continue;\n      }\n      if (!role.kind.Group) continue;\n      if (accountId && role.kind.Group && role.kind.Group.includes(accountId)) {\n        userRoles.push(role);\n      }\n    }\n  }\n\n  if (isCongressDaoID) {\n    userRoles = [\n      {\n        name: \"all\",\n        kind: \"Everyone\",\n        permissions: roles?.permissions,\n        vote_policy: {}\n      }\n    ];\n  }\n\n  if (isVotingBodyDao) {\n    userRoles = [\n      {\n        name: \"all\",\n        kind: \"Everyone\",\n        permissions: {},\n        vote_policy: {}\n      }\n    ];\n  }\n\n  const isAllowedTo = (kind, action) => {\n    // -- Check if the user is allowed to perform the action\n    let allowed = false;\n    userRoles\n      .filter(({ permissions }) => {\n        if (isCongressDaoID) {\n          const allowedRole =\n            permissions.includes(`${kind.toString()}`) &&\n            roles?.members?.includes(accountId);\n          allowed = allowed || allowedRole;\n          return allowedRole;\n        } else {\n          const allowedRole =\n            permissions.includes(`${kind.toString()}:${action.toString()}`) ||\n            permissions.includes(`${kind.toString()}:*`) ||\n            permissions.includes(`*:${action.toString()}`) ||\n            permissions.includes(\"*:*\");\n          allowed = allowed || allowedRole;\n          return allowedRole;\n        }\n      })\n      .map((role) => role.name);\n    return allowed;\n  };\n\n  const kindName =\n    typeof my_proposal.kind === \"string\"\n      ? my_proposal.kind\n      : isCongressDaoID || isVotingBodyDao\n      ? Object.keys(my_proposal.kind)[0]\n      : typeof my_proposal.kind.typeEnum === \"string\"\n      ? my_proposal.kind.typeEnum\n      : Object.keys(my_proposal.kind)[0];\n\n  const isAllowedToVote = isVotingBodyDao\n    ? [isHuman, isHuman, isHuman, isHuman]\n    : [\n        isAllowedTo(proposalKinds[kindName], actions.VoteApprove),\n        isAllowedTo(proposalKinds[kindName], actions.VoteReject),\n        isCongressDaoID\n          ? isAllowedTo(proposalKinds[kindName], actions.VoteAbstain)\n          : isAllowedTo(proposalKinds[kindName], actions.VoteRemove)\n      ];\n\n  let totalVotesNeeded = 0;\n\n  if (policy?.roles) {\n    policy.roles.forEach((role) => {\n      // Determine if the role is eligible for the given proposalType\n      const isRoleAllowedToVote =\n        role.permissions.includes(`${proposalKinds[kindName]}:VoteApprove`) ||\n        role.permissions.includes(`${proposalKinds[kindName]}:VoteReject`) ||\n        role.permissions.includes(`${proposalKinds[kindName]}:*`) ||\n        role.permissions.includes(`*:VoteApprove`) ||\n        role.permissions.includes(`*:VoteReject`) ||\n        role.permissions.includes(\"*:*\");\n\n      if (isRoleAllowedToVote) {\n        const threshold = (role.vote_policy &&\n          role.vote_policy[proposalKinds[kindName]]?.threshold) ||\n          policy[\"default_vote_policy\"]?.threshold || [0, 0];\n        const eligibleVoters = role.kind.Group ? role.kind.Group.length : 0;\n\n        // Apply the threshold\n        if (eligibleVoters === 0) {\n          return;\n        }\n        const votesNeeded =\n          Math.floor((threshold[0] / threshold[1]) * eligibleVoters) + 1;\n\n        totalVotesNeeded += votesNeeded;\n      }\n    });\n  }\n  my_proposal.typeName = kindName.replace(/([A-Z])/g, \" $1\").trim(); // Add spaces between camelCase\n  if (isCongressDaoID) {\n    totalVotesNeeded = daoConfig?.threshold;\n  }\n\n  if (isVotingBodyDao) {\n    const votesConfig = Near.view(daoId, \"get_proposal_consent\", {\n      id: proposal.id\n    });\n    if (votesConfig === null) {\n      return;\n    }\n    totalVotesNeeded = votesConfig.quorum;\n  }\n\n  let totalVotes = {\n    yes: 0,\n    no: 0,\n    spam: 0,\n    abstain: 0,\n    total: 0\n  };\n\n  Object.values(my_proposal.votes).forEach((vote) => {\n    if (vote === \"Approve\") {\n      totalVotes.yes++;\n    } else if (vote === \"Reject\") {\n      totalVotes.no++;\n    } else if (vote === \"Remove\") {\n      totalVotes.spam++;\n    }\n  });\n\n  if (isVotingBodyDao) {\n    totalVotes.yes = my_proposal?.approve ?? 0;\n    totalVotes.no = my_proposal?.reject ?? 0;\n    totalVotes.abstain = my_proposal?.abstain ?? 0;\n    totalVotes.spam = my_proposal?.spam ?? 0;\n  }\n\n  if (isCongressDaoID) {\n    for (const { vote } of Object.values(my_proposal.votes)) {\n      if (vote === \"Approve\") {\n        totalVotes.yes++;\n      } else if (vote === \"Reject\") {\n        totalVotes.no++;\n      } else if (vote === \"Abstain\") {\n        totalVotes.abstain++;\n      } else if (vote === \"Spam\") {\n        totalVotes.spam++;\n      }\n    }\n  }\n  totalVotes.total =\n    totalVotes.yes + totalVotes.no + totalVotes.spam + totalVotes.abstain;\n\n  if (my_proposal.status === \"PreVote\") {\n    totalVotes.total = my_proposal?.support ?? 0;\n  }\n\n  my_proposal.totalVotesNeeded = totalVotesNeeded;\n  my_proposal.totalVotes = totalVotes;\n  // --- end Votes required\n\n  my_proposal.statusName = my_proposal.status.replace(/([A-Z])/g, \" $1\").trim();\n\n  if (!state) {\n    State.init({\n      proposal: my_proposal,\n      isAllowedToVote\n    });\n  } else {\n    State.update({\n      proposal: my_proposal,\n      isAllowedToVote\n    });\n  }\n};\n\nconst comments = Social.index(\"comment\", {\n  type: \"dao_proposal_comment\",\n  path: `${daoId}/proposal/main`,\n  proposal_id: proposal.id + \"-beta\"\n});\n\nif (!state || state.proposal.id !== proposal.id) {\n  // Only execute expensive work once\n  expensiveWork();\n  return multiSelectMode ? (\n    \"\"\n  ) : (\n    <Widget src=\"astraplusplus.ndctools.near/widget/DAO.Proposals.Card.skeleton\" />\n  );\n}\n\nconst handleVote = ({\n  action,\n  proposalId,\n  daoId,\n  proposer,\n  showNotification\n}) => {\n  let args = {};\n  if (isVotingBodyDao) {\n    args[\"prop_id\"] = parseInt(proposalId);\n    args[\"caller\"] = accountId;\n    args[\"vote\"] = action.replace(\"Vote\", \"\");\n\n    Near.call([\n      {\n        contractName: registry,\n        methodName: \"is_human_call_lock\",\n        args: {\n          ctr: daoId,\n          function: \"vote\",\n          payload: JSON.stringify(args),\n          lock_duration:\n            proposal?.submission_time +\n            (daoConfig?.vote_duration ?? daoConfig?.voting_duration) -\n            Date.now() +\n            1,\n          with_proof: false\n        },\n        gas: 200000000000000,\n        deposit: 20000000000000000000000\n      }\n    ]);\n  } else {\n    const customAction = action.replace(\"Vote\", \"\");\n    const notification = {\n      [accountId]: {\n        index: {\n          notify: JSON.stringify([\n            {\n              key: proposer,\n              value: {\n                message: `${accountId} voted to ${customAction} your proposal for ${daoId} (Proposal ID: ${proposalId})`,\n                params: {\n                  daoId: daoId,\n                  tab: \"proposals\",\n                  page: \"dao\",\n                  proposalId: proposalId\n                },\n                type: \"custom\",\n                widget: \"astraplusplus.ndctools.near/widget/home\"\n              }\n            }\n          ])\n        }\n      }\n    };\n    args[\"id\"] = JSON.parse(proposalId);\n    if (isCongressDaoID) {\n      args[\"vote\"] = action.replace(\"Vote\", \"\");\n    } else {\n      args[\"action\"] = action;\n    }\n    const calls = [\n      {\n        contractName: daoId,\n        methodName: isCongressDaoID ? \"vote\" : \"act_proposal\",\n        args: args,\n        gas: 300000000000000\n      }\n    ];\n    if (showNotification) {\n      calls.push({\n        contractName: \"social.near\",\n        methodName: \"set\",\n        args: { data: notification, options: { refund_unused_deposit: true } },\n        deposit: 100000000000000000000000\n      });\n    }\n    Near.call(calls);\n  }\n};\n\nconst handlePreVoteAction = ({ action, proposalId }) => {\n  switch (action) {\n    case \"support_proposal_by_congress\": {\n      Near.call([\n        {\n          contractName: daoId,\n          methodName: \"support_proposal_by_congress\",\n          args: {\n            prop_id: parseInt(proposalId),\n            dao: currentuserCongressHouse\n          },\n          gas: 200000000000000\n        }\n      ]);\n      break;\n    }\n    case \"support_proposal\": {\n      Near.call([\n        {\n          contractName: registry,\n          methodName: \"is_human_call_lock\",\n          args: {\n            ctr: daoId,\n            function: \"support_proposal\",\n            payload: JSON.stringify(parseInt(proposalId)),\n            lock_duration:\n              proposal?.submission_time +\n              daoConfig?.pre_vote_duration -\n              Date.now() +\n              1,\n            with_proof: false\n          },\n          gas: 200000000000000\n        }\n      ]);\n      break;\n    }\n    case \"top_up_proposal\": {\n      const deposit =\n        parseInt(daoConfig?.active_queue_bond) -\n        parseInt(daoConfig?.pre_vote_bond);\n\n      Near.call([\n        {\n          contractName: daoId,\n          methodName: \"top_up_proposal\",\n          args: {\n            id: parseInt(proposalId)\n          },\n          gas: 200000000000000,\n          deposit: deposit\n        }\n      ]);\n      break;\n    }\n  }\n};\n\nreturn (\n  <Widget\n    src=\"astraplusplus.ndctools.near/widget/DAO.Proposals.Card.ui\"\n    props={{\n      proposal: state.proposal,\n      isAllowedToVote: state.isAllowedToVote,\n      multiSelectMode,\n      daoId,\n      policy,\n      comments: comments,\n      handleVote,\n      isCongressDaoID,\n      isVotingBodyDao,\n      daoConfig,\n      handlePreVoteAction,\n      isHuman,\n      currentuserCongressHouse,\n      dev: props.dev,\n      HoMDaoId,\n      CoADaoId,\n      registry,\n      showNavButton\n    }}\n  />\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/astraplusplus.ndctools.near/widget/DAO.Proposals.Card.index", "fact_widget_deployments_id": "b338a361812add277084b94e4904dfc0", "inserted_timestamp": "2024-04-12T18:33:43.909Z", "modified_timestamp": "2024-04-12T18:33:43.909Z", "__row_index": 4}