{"tx_hash": "2cFcVwVGgNJP4pj1aum9QpR93oJmGZjf6vK5g3L91X9M", "action_id_social": "DDBJWX9FRFHqENq139EeMgfvCUGWVHjZkHeqVpMayosk-0-widget", "block_id": 118228480, "block_timestamp": "2024-05-04T13:01:15.128Z", "signer_id": "megha19.near", "widget_name": "CheddarMazeReact", "source_code": "const { Modal } = VM.require(\"buildhub.near/widget/components\");\nif (!Modal) {\n  return <></>;\n}\nconst [mazeData, setMazeData] = useState([]);\nconst [playerPosition, setPlayerPosition] = useState({ x: 1, y: 1 });\nconst [score, setScore] = useState(0);\nconst [timeLimitInSeconds, setTimeLimitInSeconds] = useState(120);\nconst [timerId, setTimerId] = useState(null);\nconst [cheeseCooldown, setCheeseCooldown] = useState(false);\nconst [enemyCooldown, setEnemyCooldown] = useState(false);\nconst [moves, setMoves] = useState(0);\nconst [gameOverFlag, setGameOverFlag] = useState(false);\nconst [remainingTime, setRemainingTime] = useState(timeLimitInSeconds);\nconst [remainingMinutes, setRemainingMinutes] = useState(\n  Math.floor(timeLimitInSeconds / 60)\n);\nconst [remainingSeconds, setRemainingSeconds] = useState(\n  timeLimitInSeconds % 60\n);\nconst [gameOverMessage, setGameOverMessage] = useState(\"\");\nconst [initialTouch, setInitialTouch] = useState(null);\nconst [playerStartX, setPlayerStartX] = useState(0);\nconst [playerStartY, setPlayerStartY] = useState(0);\nconst [timerStarted, setTimerStarted] = useState(false);\nconst [luckyColor] = useState(Math.random() < 0.1 ? \"#9d67ef\" : \"Gold\");\nconst [direction, setDirection] = useState(\"right\");\nconst [selectedColorSet, setSelectedColorSet] = useState(null);\nconst [backgroundImage, setBackgroundImage] = useState(\"\");\nconst [rarity, setRarity] = useState(\"\");\nconst [won, setWon] = useState(false);\nconst [touchStart, setTouchStart] = useState({ x: null, y: null });\nconst [touchEnd, setTouchEnd] = useState({ x: null, y: null });\nconst [showStartModal, setShowStartModal] = useState(false);\nconst [userAllowedGame, setAllowedGame] = useState(false);\nconst accountId = context.accountId;\n\nif (!accountId) {\n  return <>Please Login</>;\n}\n\nconst handleTouchStart = (e) => {\n  const touchDownX = e.touches[0].clientX;\n  const touchDownY = e.touches[0].clientY;\n\n  setTouchStart({ x: touchDownX, y: touchDownY });\n};\n\nconst handleTouchMove = (e) => {\n  const touchMoveX = e.touches[0].clientX;\n  const touchMoveY = e.touches[0].clientY;\n\n  setTouchEnd({ x: touchMoveX, y: touchMoveY });\n};\n\nconst handleTouchEnd = () => {\n  if (touchStart.x === null || touchStart.y === null) return;\n\n  const deltaX = touchEnd.x - touchStart.x;\n  const deltaY = touchEnd.y - touchStart.y;\n  const absDeltaX = Math.abs(deltaX);\n  const absDeltaY = Math.abs(deltaY);\n\n  if (absDeltaX > absDeltaY) {\n    // Horizontal movement\n    if (deltaX > 0) {\n      movePlayerDirection(\"right\");\n    } else {\n      movePlayerDirection(\"left\");\n    }\n  } else {\n    // Vertical movement\n    if (deltaY > 0) {\n      movePlayerDirection(\"down\");\n    } else {\n      movePlayerDirection(\"up\");\n    }\n  }\n\n  // Reset touch coordinates after handling\n  setTouchStart({ x: null, y: null });\n  setTouchEnd({ x: null, y: null });\n};\n\n// Function to select a random color set, background image, and rarity\nconst selectRandomColorSet = () => {\n  const colorSets = [\n    {\n      backgroundColor: \"#F0F0F0\",\n      pathColor: \"#9d67ef\",\n      nonPathColor: \"white\",\n      textColor: \"#000000\",\n      rarity: \"common\",\n      backgroundImage:\n        \"url('\thttps://cheddar.farm/newFarmBackground.c6905a5e.png')\",\n    },\n    {\n      backgroundColor: \"#E0E0E0\",\n      pathColor: \"gold\",\n      nonPathColor: \"white\",\n      textColor: \"#333333\",\n      rarity: \"rare\",\n      backgroundImage:\n        \"url('https://ipfs.near.social/ipfs/bafkreihpddbzbioe7kctes25rr52klcs5we4pocwiwbmwldqf4acdarpcm')\",\n    },\n    // Add more color sets as needed\n  ];\n\n  return colorSets[Math.floor(Math.random() * colorSets.length)];\n};\n\n// Set the selected color set, background image, and rarity once at the start of the game\nuseEffect(() => {\n  const randomColorSet = selectRandomColorSet();\n  setSelectedColorSet(randomColorSet);\n  setBackgroundImage(randomColorSet.backgroundImage);\n  setRarity(randomColorSet.rarity);\n}, []);\n\n// Initialize path color from the selected color set\nconst pathColor = selectedColorSet ? selectedColorSet.pathColor : \"\";\nconst backgroundImageStyle = {\n  backgroundImage: backgroundImage,\n  backgroundSize: \"cover\",\n};\n\nconst gameOver = (message, cell) => {\n  const enemyWon = cell.enemyWon;\n  const cartelWon = cell.cartelWon;\n\n  setCheeseCooldown(false);\n  setEnemyCooldown(false);\n  setGameOverMessage(message);\n  setGameOverFlag(true);\n  if (enemyWon || cartelWon || remainingTime === 0) {\n    setScore(0);\n  }\n  stopTimer();\n};\n\nconst startTimer = () => {\n  if (timerId === null && timerStarted) {\n    const id = setInterval(() => {\n      setRemainingTime((prevTime) => {\n        if (prevTime === 1) {\n          clearInterval(id);\n          gameOver(\"Time's up! Game Over!\");\n          return prevTime;\n        }\n        return prevTime - 1;\n      });\n    }, 1000);\n    setTimerId(id);\n  }\n};\n\n// Define a new useEffect hook to manage the timer\nuseEffect(() => {\n  let intervalId;\n  if (timerStarted && !gameOverFlag) {\n    intervalId = setInterval(() => {\n      setRemainingTime((prevTime) => {\n        if (prevTime === 1) {\n          clearInterval(intervalId);\n          gameOver(\"Time's up! Game Over!\");\n          return prevTime;\n        }\n        return prevTime - 1;\n      });\n    }, 1000);\n  } else {\n    clearInterval(intervalId);\n  }\n\n  return () => clearInterval(intervalId); // Cleanup function to clear interval on unmount or when timer conditions change\n}, [timerStarted, gameOverFlag]);\n\nuseEffect(() => {\n  const minutes = Math.floor(remainingTime / 60);\n  const seconds = remainingTime % 60;\n  setRemainingMinutes(minutes);\n  setRemainingSeconds(seconds);\n}, [remainingTime]);\n\nconst startTimerOnTap = () => {\n  if (!timerStarted) {\n    setTimerStarted(true); // Set timerStarted to true to start the timer\n  }\n};\n\nconst stopTimer = () => {\n  clearInterval(timerId);\n  setTimerStarted(false); // Set timerStarted to false to stop the timer\n  setTimerId(null);\n};\n\nuseEffect(() => {\n  // Initial delay before enemy encounters become possible\n  setEnemyCooldown(true);\n  setTimeout(() => {\n    setEnemyCooldown(false);\n  }, 3000); // Delay for 5.5 seconds\n}, []);\n\nconst restartGame = () => {\n  clearInterval(timerId);\n  setScore(0);\n  setTimeLimitInSeconds(120);\n  setRemainingTime(120);\n  setCheeseCooldown(false);\n  setEnemyCooldown(true);\n  setMoves(0);\n  setGameOverFlag(false);\n  setWon(false);\n  setGameOverMessage(\"\");\n\n  // Regenerate maze data\n  const mazeRows = 11;\n  const mazeCols = 9;\n  const newMazeData = generateMazeData(mazeRows, mazeCols);\n\n  // Find a valid starting position for the player\n  let playerStartX = Math.floor(Math.random() * (mazeCols - 2)) + 1;\n  let playerStartY = Math.floor(Math.random() * (mazeRows - 2)) + 1;\n  while (!newMazeData[playerStartY][playerStartX].isPath) {\n    playerStartX = Math.floor(Math.random() * (mazeCols - 2)) + 1;\n    playerStartY = Math.floor(Math.random() * (mazeRows - 2)) + 1;\n  }\n\n  // Set the maze data with the new maze and player's starting position\n  setMazeData(newMazeData);\n  setPlayerPosition({ x: playerStartX, y: playerStartY });\n\n  startTimer(); // Start the timer again after resetting the game\n};\n\nconst generateMazeData = (rows, cols) => {\n  const maze = Array.from({ length: rows }, () =>\n    Array.from({ length: cols }, () => ({\n      isPath: false,\n      isActive: false,\n      hasCheese: false,\n      hasEnemy: false,\n      hasExit: false,\n      enemyWon: false,\n    }))\n  );\n\n  // Choose a random starting position on the outer border\n  const startEdge = Math.floor(Math.random() * 4); // 0: top, 1: right, 2: bottom, 3: left\n  let x, y;\n\n  switch (startEdge) {\n    case 0: // Top edge\n      x = Math.floor(Math.random() * (cols - 2)) + 1;\n      y = 0;\n      break;\n    case 1: // Right edge\n      x = cols - 1;\n      y = Math.floor(Math.random() * (rows - 2)) + 1;\n      break;\n    case 2: // Bottom edge\n      x = Math.floor(Math.random() * (cols - 2)) + 1;\n      y = rows - 1;\n      break;\n    case 3: // Left edge\n      x = 0;\n      y = Math.floor(Math.random() * (rows - 2)) + 1;\n      break;\n  }\n\n  maze[y][x].isPath = true;\n  const stack = [[x, y]];\n\n  while (stack.length) {\n    const [cx, cy] = stack[stack.length - 1];\n    const directions = [];\n\n    // Check all possible directions\n    [\n      [2, 0], // Increase step to 2 for wider paths\n      [-2, 0], // Increase step to 2 for wider paths\n      [0, 2], // Increase step to 2 for wider paths\n      [0, -2], // Increase step to 2 for wider paths\n    ].forEach(([dx, dy]) => {\n      const nx = cx + dx,\n        ny = cy + dy;\n      if (\n        nx >= 0 &&\n        nx < cols &&\n        ny >= 0 &&\n        ny < rows &&\n        !maze[ny][nx].isPath\n      ) {\n        directions.push([nx, ny, cx + dx / 2, cy + dy / 2]); // Adjust coordinates for wider paths\n      }\n    });\n\n    if (directions.length) {\n      const [nx, ny, px, py] =\n        directions[Math.floor(Math.random() * directions.length)];\n      maze[ny][nx].isPath = true;\n      maze[py][px].isPath = true;\n      stack.push([nx, ny]);\n    } else {\n      stack.pop();\n    }\n  }\n\n  return maze;\n};\n\nuseEffect(() => {\n  const mazeRows = 11;\n  const mazeCols = 9; // Updated width to 9 columns\n  const newMazeData = generateMazeData(mazeRows, mazeCols);\n  let startX = Math.floor(Math.random() * (mazeCols - 2)) + 1;\n  let startY = Math.floor(Math.random() * (mazeRows - 2)) + 1;\n\n  while (!newMazeData[startY][startX].isPath) {\n    startX = Math.floor(Math.random() * (mazeCols - 2)) + 1;\n    startY = Math.floor(Math.random() * (mazeRows - 2)) + 1;\n  }\n\n  newMazeData[startY][startX].isActive = true;\n  setPlayerPosition({ x: startX, y: startY });\n  setPlayerStartX(startX);\n  setPlayerStartY(startY);\n  setMazeData(newMazeData);\n}, []);\n\nuseEffect(() => {\n  if (remainingTime === 0) {\n    gameOver(\n      \"Time's up! Game Over!\",\n      mazeData[playerPosition.y][playerPosition.x]\n    );\n    stopTimer();\n  }\n}, [remainingTime]);\n\nconst handleKeyPress = (event) => {\n  if (gameOverFlag) return; // If game over, prevent further movement\n\n  const key = event.key;\n  let newX = playerPosition.x;\n  let newY = playerPosition.y;\n\n  switch (key) {\n    case \"ArrowUp\":\n      newY--;\n      setDirection(\"up\"); // Update direction when moving up\n      break;\n    case \"ArrowDown\":\n      newY++;\n      setDirection(\"down\"); // Update direction when moving down\n      break;\n    case \"ArrowLeft\":\n      newX--;\n      setDirection(\"left\"); // Update direction when moving left\n      break;\n    case \"ArrowRight\":\n      newX++;\n      setDirection(\"right\"); // Update direction when moving right\n      break;\n    default:\n      return;\n  }\n\n  movePlayer(newX, newY);\n};\n\nconst checkForEvents = (cell) => {\n  if (!cell.isPath) {\n    return; // Exit the function if the cell is not a path cell\n  }\n\n  if (cell.isPath && !enemyCooldown && !cell.hasCheese && !cell.hasEnemy) {\n    console.log(\"enemy encountered\");\n\n    const chance = Math.random();\n    if (chance < 0.9) {\n      // 80% chance of encounter\n      const newMazeData = mazeData.map((row, rowIndex) =>\n        row.map((mazeCell, colIndex) => {\n          if (rowIndex === playerPosition.y && colIndex === playerPosition.x) {\n            return { ...mazeCell, hasEnemy: true };\n          }\n          return mazeCell;\n        })\n      );\n\n      setMazeData(newMazeData);\n      setEnemyCooldown(true);\n      const cooldownPeriod = Math.floor(Math.random() * 5000) + 10000;\n      setTimeout(() => {\n        setEnemyCooldown(false);\n      }, cooldownPeriod);\n\n      if (Math.random() < 0.1) {\n        console.log(\"enemy won\");\n        const newMazeData = mazeData.map((row, rowIndex) =>\n          row.map((mazeCell, colIndex) => {\n            const isPlayerPosition =\n              rowIndex === playerPosition.y && colIndex === playerPosition.x;\n            if (isPlayerPosition) {\n              return {\n                ...mazeCell,\n                enemyWon: true, // Update enemyWon flag\n                isActive: false, // Update isActive flag\n              };\n            }\n            return mazeCell;\n          })\n        );\n        setMazeData(newMazeData);\n        setScore(0); // Set score to zero\n        gameOver(\"Enemy won! Game Over!\", cell);\n        stopTimer();\n      }\n    } else if (true) {\n      // 1% chance of hitting the \"cartel\" event\n      console.log(\"Hit the cartel!\");\n      const newMazeData = mazeData.map((row, rowIndex) =>\n        row.map((mazeCell, colIndex) => {\n          const isPlayerPosition =\n            rowIndex === playerPosition.y && colIndex === playerPosition.x;\n          if (isPlayerPosition) {\n            return {\n              ...mazeCell,\n              cartelWon: true, // Update enemyWon flag\n            };\n          }\n          return mazeCell;\n        })\n      );\n      setMazeData(newMazeData);\n      setScore(0); // Set score to zero\n      gameOver(\"You ran into the cartel! Game Over!\", cell);\n      stopTimer();\n    } else {\n      console.log(\"enemy defeated...\");\n    }\n  }\n\n  if (cell.isPath && !cheeseCooldown && !cell.hasCheese && !cell.hasEnemy) {\n    // Generate cheese only if the cell does not already have an enemy\n    if (Math.random() < 0.055) {\n      // 1% chance of winning cheese\n      console.log(\"cheese\");\n      const newMazeData = mazeData.map((row, rowIndex) =>\n        row.map((mazeCell, colIndex) => {\n          if (rowIndex === playerPosition.y && colIndex === playerPosition.x) {\n            return { ...mazeCell, hasCheese: true };\n          }\n          return mazeCell;\n        })\n      );\n      setMazeData(newMazeData);\n      setScore(score + 1);\n      setCheeseCooldown(true);\n      const cooldownPeriod = Math.floor(Math.random() * 5000) + 1000;\n      setTimeout(() => {\n        setCheeseCooldown(false);\n      }, cooldownPeriod);\n    }\n  }\n\n  const totalCells = mazeData.length * mazeData[0].length;\n  const navigatedCells = moves;\n  const percentNavigated = (navigatedCells / totalCells) * 100;\n\n  if (percentNavigated >= 99 && Math.random() < 0.2) {\n    const newMazeData = mazeData.map((row, rowIndex) =>\n      row.map((mazeCell, colIndex) => {\n        if (rowIndex === playerPosition.y && colIndex === playerPosition.x) {\n          return { ...mazeCell, hasExit: true };\n        }\n        return mazeCell;\n      })\n    );\n    setMazeData(newMazeData);\n    gameOver(\"Congrats! You found the Hidden Door.\", cell);\n    stopTimer();\n  }\n};\n\nconst containerStyle = {\n  display: \"grid\",\n  gridTemplateColumns: `repeat(${mazeData[0].length}, ${cellSize}px)`,\n  gridTemplateRows: `repeat(${mazeData.length}, ${cellSize}px)`,\n  gap: \"0px\",\n  padding: \"0px\", // Adjusted padding\n  margin: \"0\",\n  position: \"relative\",\n  width: `${mazeData[0].length * cellSize}px`, // Removed extra padding from the width\n  outline: \"none\", // Hide outline when the container is focused\n  border: \"none\", // Remove border\n};\n\nconst renderMazeCells = () => {\n  const containerStyle = {\n    width: \"100%\",\n    height: \"100%\",\n    display: \"grid\",\n    gridTemplateColumns: `repeat(${mazeData[0].length}, 40px)`, // Assuming each cell is 40px\n    gridTemplateRows: `repeat(${mazeData.length}, 40px)`, // Assuming each cell is 40px\n  };\n\n  return mazeData.map((row, rowIndex) =>\n    row.map((cell, colIndex) => {\n      const isActive =\n        playerPosition.x === colIndex && playerPosition.y === rowIndex;\n      const isPath = cell.isPath;\n      const hasCheese = cell.hasCheese;\n      const hasEnemy = cell.hasEnemy;\n      const hasExit = cell.hasExit;\n      const enemyWon = cell.enemyWon;\n      const cartelWon = cell.cartelWon;\n\n      const cellId = `cell-${rowIndex}-${colIndex}`;\n\n      const backgroundImageTransform = isActive\n        ? direction === \"up\"\n          ? `rotate(-90deg)`\n          : direction === \"down\"\n          ? `rotate(90deg)`\n          : direction === \"left\"\n          ? `scaleX(-1)` // Apply leftTransform when facing left\n          : \"\"\n        : \"\";\n\n      const cellStyle = {\n        width: \"40px\",\n        height: \"40px\",\n        fontSize: \"20px\",\n        border: isPath ? \"thin solid #ececec\" : \"\",\n        textAlign: \"center\",\n        display: \"flex\",\n        justifyContent: \"center\",\n        alignItems: \"center\",\n        backgroundColor: isPath ? pathColor : selectedColorSet.nonPathColor,\n        color: isActive ? \"#FFFFFF\" : selectedColorSet.textColor,\n        backgroundImage: isActive\n          ? `url('https://lh3.googleusercontent.com/d/114_RLl18MAzX035svMyvNJpE3ArfLNCF=w500')`\n          : \"\",\n        backgroundSize: \"cover\",\n        backgroundRepeat: \"no-repeat\",\n        backgroundPosition: \"center\",\n        backgroundSize: \"70%\",\n        position: \"relative\",\n        transform: backgroundImageTransform,\n        WebkitTransform: backgroundImageTransform, // for Safari and older iOS browsers\n        MozTransform: backgroundImageTransform, // for older Firefox versions\n        msTransform: backgroundImageTransform, // for Internet Explorer (not needed in Edge)\n      };\n\n      const emojiStyle = {\n        position: \"absolute\",\n        top: \"50%\",\n        left: \"50%\",\n        transform: \"translate(-50%, -50%)\",\n        zIndex: 1,\n      };\n\n      return (\n        <div className=\"maze-container\" style={containerStyle} tabIndex=\"0\">\n          <div\n            key={cellId}\n            id={cellId}\n            className={`maze-cell ${isPath ? \"path\" : \"\"} ${\n              isActive ? \"active\" : \"\"\n            }`}\n            style={{ ...cellStyle }}\n          >\n            {hasCheese && !isActive ? <div style={emojiStyle}>\ud83e\uddc0</div> : \"\"}\n            {hasEnemy && !isActive ? <div style={emojiStyle}>\ud83e\uddb9\u200d\u2642\ufe0f</div> : \"\"}\n            {hasExit ? \"\ud83d\udeaa\" : \"\"}\n            {enemyWon ? \"\ud83d\udca2\" : \"\"}\n            {cartelWon ? \"\ud83e\udd2e\" : \"\"}\n          </div>\n        </div>\n      );\n    })\n  );\n};\n\nconst isMobile = () => {\n  const userAgent = navigator.userAgent;\n  return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(\n    userAgent\n  );\n};\n\nconst movePlayer = (newX, newY) => {\n  // Check if the new position is within the bounds of the maze\n  if (\n    newX < 0 ||\n    newX >= mazeData[0].length ||\n    newY < 0 ||\n    newY >= mazeData.length\n  ) {\n    return; // Ignore movement if outside maze bounds\n  }\n\n  if (!mazeData[newY][newX].isPath) {\n    return; // Player cannot move to non-path cells\n  }\n\n  const newCell = mazeData[newY][newX];\n  setMoves((moves) => moves + 1);\n\n  // Check if the new cell is the exit cell\n  if (newCell.isExit) {\n    setWon(true);\n    gameOver(\"Congratulations! You found the exit!\");\n  }\n\n  const newMazeData = mazeData.map((row, rowIndex) =>\n    row.map((cell, colIndex) => ({\n      ...cell,\n      isActive: rowIndex === newY && colIndex === newX,\n    }))\n  );\n\n  // Reset isActive for the previous player position\n  newMazeData[playerPosition.y][playerPosition.x].isActive = false;\n\n  // Update player position state\n  setPlayerPosition({ x: newX, y: newY });\n\n  // Update mazeData state\n  setMazeData(newMazeData);\n\n  // Check for events at the new player position\n  checkForEvents(newMazeData[newY][newX]);\n\n  // Increment moves count\n  setMoves(moves + 1);\n};\n\nlet isMouseDown = false;\nlet lastCellX = null;\nlet lastCellY = null;\n\nconst handleMouseDown = (event) => {\n  isMouseDown = true;\n  handleMouseMove(event);\n};\n\nconst handleMouseMove = (event) => {\n  if (!mazeContainerRef || !isMouseDown) return;\n\n  const cellWidth = isMobile() ? 30 : 40; // Adjusted cell size for mobile devices\n\n  // Extract cell coordinates from the id attribute\n  const id = event.target.id;\n  const [_, y, x] = id.split(\"-\");\n  const newX = parseInt(x);\n  const newY = parseInt(y);\n\n  // Update last cell coordinates\n  lastCellX = newX;\n  lastCellY = newY;\n};\n\nconst handleMouseUp = () => {\n  isMouseDown = false;\n  lastCellX = null;\n  lastCellY = null;\n};\n\nconst handleClick = (event) => {\n  if (!mazeContainerRef) return;\n\n  // Extract cell coordinates from the id attribute\n  const id = event.target.id;\n  const [_, y, x] = id.split(\"-\");\n  const newX = parseInt(x);\n  const newY = parseInt(y);\n\n  console.log(`Clicked on cell (${newX}, ${newY})`);\n\n  // Save the current player position as the starting cell\n  const startX = playerPosition.x;\n  const startY = playerPosition.y;\n\n  // Calculate the path from the current position to the clicked cell\n  const path = calculatePath(startX, startY, newX, newY);\n\n  // Move the player along the calculated path\n  moveAlongPath(path);\n\n  // Stop the timer if the exit is found\n  if (mazeData[newY][newX].hasExit) {\n    setWon(true);\n    stopTimer();\n  }\n};\n\n// Function to calculate the path from the current position to the target position\nconst calculatePath = (currentX, currentY, targetX, targetY) => {\n  console.log(\n    `Calculating path from (${currentX}, ${currentY}) to (${targetX}, ${targetY})`\n  );\n  const path = [];\n\n  let deltaX = Math.sign(targetX - currentX);\n  let deltaY = Math.sign(targetY - currentY);\n\n  let x = currentX;\n  let y = currentY;\n\n  console.log(\"Delta X:\", deltaX);\n  console.log(\"Delta Y:\", deltaY);\n\n  // Ensure that both x and y are not equal to their respective target values\n  while (x !== targetX || y !== targetY) {\n    path.push([x, y]);\n\n    // Move along the x-axis towards the target\n    if (x !== targetX) x += deltaX;\n\n    // Move along the y-axis towards the target\n    if (y !== targetY) y += deltaY;\n  }\n\n  // Add the target position to the path\n  path.push([targetX, targetY]);\n\n  console.log(\"Calculated path:\", path);\n\n  return path;\n};\n\n// Function to move the player along the calculated path\nconst moveAlongPath = (path) => {\n  console.log(\"Moving along path:\", path);\n  path.forEach(([x, y]) => {\n    console.log(`Moving to cell (${x}, ${y})`);\n    movePlayer(x, y);\n  });\n};\n\nconst cellSize = isMobile() ? 30 : 40; // Adjust cell size for mobile devices\nlet mazeContainerRef = null;\n\nconst handleContainerRef = (event) => {\n  mazeContainerRef = event.target;\n};\n\nconst ControlPad = ({ movePlayerDirection }) => {\n  return (\n    <div\n      style={{ display: \"flex\", flexDirection: \"column\", alignItems: \"center\" }}\n    >\n      <button\n        disabled={userAllowedGame}\n        onClick={() => movePlayerDirection(\"up\")}\n      >\n        Up\n      </button>\n      <div style={{ display: \"flex\", justifyContent: \"center\" }}>\n        <button\n          disabled={userAllowedGame}\n          onClick={() => movePlayerDirection(\"left\")}\n        >\n          Left\n        </button>\n        <button\n          disabled={userAllowedGame}\n          onClick={() => movePlayerDirection(\"down\")}\n        >\n          Down\n        </button>\n        <button\n          disabled={userAllowedGame}\n          onClick={() => movePlayerDirection(\"right\")}\n        >\n          Right\n        </button>\n      </div>\n    </div>\n  );\n};\n\nconst movePlayerDirection = (direction) => {\n  if (gameOverFlag) return;\n\n  let newX = playerPosition.x;\n  let newY = playerPosition.y;\n\n  switch (direction) {\n    case \"up\":\n      newY--;\n      break;\n    case \"down\":\n      newY++;\n      break;\n    case \"left\":\n      newX--;\n      break;\n    case \"right\":\n      newX++;\n      break;\n    default:\n      return;\n  }\n\n  setDirection(direction);\n  movePlayer(newX, newY);\n};\n\nconst isUserNadaVerified = Near.view(\"v1.nadabot.near\", \"is_human\", {\n  account_id: context.accountId,\n});\n\nconst isFulfilled = (value) => {\n  return value ? \"\u2705\" : \"\u274c\";\n};\n\nconst TOKEN_CONTRACT_ADDRESS = \"token.cheddar.near\";\n\nconst cheddarBalance = Near.view(TOKEN_CONTRACT_ADDRESS, \"ft_balance_of\", {\n  account_id: accountId,\n});\n\nconst isPlayerEligible = !context.accountId;\n\nconst Container = styled.div`\n  --modal-background-color: #fff !important;\n  --modal-text-color: #000 !important;\n`;\n\nuseEffect(() => {\n  if (\n    cheddarBalance !== null &&\n    isUserNadaVerified !== null &&\n    !userAllowedGame\n  ) {\n    setAllowedGame(parseFloat(cheddarBalance) >= 555 && isUserNadaVerified);\n  }\n}, [cheddarBalance, isUserNadaVerified]);\n\nconst handleEvent = (e, eventType) => {\n  if (!userAllowedGame) {\n    e.preventDefault();\n    return;\n  }\n\n  handleContainerRef(e);\n\n  switch (eventType) {\n    case \"touchstart\":\n      handleMouseDown(e);\n      break;\n    case \"touchmove\":\n      handleMouseMove(e);\n      break;\n    case \"touchend\":\n      handleMouseUp(e);\n      break;\n    case \"click\":\n      startTimerOnTap();\n      handleClick(e);\n      break;\n    case \"keydown\":\n      handleKeyPress(e);\n      break;\n    default:\n      break;\n  }\n};\n\nreturn (\n  <Container\n    style={{\n      maxWidth: `${mazeData[0].length * cellSize + 5}px`,\n      margin: \"0 auto\",\n      padding: \"0\",\n      border: \"1px solid #000\",\n      backgroundColor: backgroundColor, // Set the background color\n      color: selectedColorSet.textColor, // Set the text color\n      backgroundImage: backgroundImage,\n    }}\n  >\n    <h3>Cheddar MAzE</h3>\n    <div\n      style={{\n        display: \"flex\",\n        justifyContent: \"space-between\",\n        padding: \"0 10px\", // Adjust padding to add space on left and right\n        marginTop: \"1rem\",\n      }}\n    >\n      <div style={{ fontWeight: \"bold\" }}>Score: {score}</div>\n      <div style={{ fontWeight: \"bold\" }}>\n        Time: {remainingMinutes}m {remainingSeconds}s\n      </div>\n    </div>\n\n    {gameOverMessage ? (\n      <div\n        style={{ backgroundColor: \"rgba(255, 255, 255, 0.8)\", padding: \"10px\" }}\n      >\n        <button onClick={restartGame}>Restart Game</button>\n        <p style={{ color: won ? \"green\" : \"red\" }}>{gameOverMessage}</p>\n      </div>\n    ) : (\n      <>\n        <br />\n      </>\n    )}\n    <div\n      className=\"maze-container\"\n      disabled={!userAllowedGame}\n      onTouchStart={(e) => handleEvent(e, \"touchstart\")}\n      onTouchMove={(e) => handleEvent(e, \"touchmove\")}\n      onTouchEnd={(e) => handleEvent(e, \"touchend\")}\n      onClick={(e) => handleEvent(e, \"click\")}\n      style={{\n        display: \"grid\",\n        gridTemplateColumns: `repeat(${mazeData[0].length}, ${cellSize}px)`, // Adjusted cell size\n        gridTemplateRows: `repeat(${mazeData.length}, ${cellSize}px)`, // Adjusted cell size\n        gap: \"0px\",\n        padding: \"0px\",\n        position: \"relative\",\n        width: `${mazeData[0].length * cellSize}px`, // Adjusted width\n        backgroundImage: `url(${backgroundImage})`, // Set the background image\n        backgroundSize: \"cover\",\n      }}\n      tabIndex=\"0\"\n      autoFocus={userAllowedGame}\n      onKeyDown={(e) => handleEvent(e, \"keydown\")}\n    >\n      {renderMazeCells(pathColor)}\n    </div>\n    <ControlPad />\n\n    {!timerStarted && (\n      <div className=\"mt-2 d-flex justify-content-center\">\n        <button onClick={() => setShowStartModal(true)}>Start</button>\n      </div>\n    )}\n    <Modal\n      open={showStartModal}\n      title={\"Start a game\"}\n      onOpenChange={setShowStartModal}\n      toggle={setShowStartModal}\n    >\n      <h6>Requirements to be an eligible player:</h6>\n      <ol>\n        <li>\n          Minimum balance of 555 Cheddar{\" \"}\n          {isFulfilled(parseFloat(cheddarBalance) >= 555)}\n        </li>\n        <li>NADA bot Verified {isFulfilled(isUserNadaVerified)}</li>\n      </ol>\n      <h6>Steps:</h6>\n      <ol>\n        <li>Click on board to start the game</li>\n        <li>Navigate with Arrows or Tap</li>\n        <li>Collect Cheddar\ud83e\uddc0</li>\n        <li>Battle Cartel to protect your Bag</li>\n        <li>Find the Hidden Door\ud83d\udeaa to Win!</li>\n      </ol>\n\n      <div className=\"d-flex justify-content-center\">\n        <button\n          disabled={!userAllowedGame}\n          onClick={() => {\n            setShowStartModal(false);\n          }}\n        >\n          Start\n        </button>\n      </div>\n    </Modal>\n  </Container>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/megha19.near/widget/CheddarMazeReact", "fact_widget_deployments_id": "9cd16fd5785e449f33a95a1e9a993a6c", "inserted_timestamp": "2024-05-04T14:39:10.632Z", "modified_timestamp": "2024-05-04T14:39:10.632Z", "__row_index": 0}