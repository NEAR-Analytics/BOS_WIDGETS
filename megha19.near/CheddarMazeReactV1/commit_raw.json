{"tx_hash": "HKWE4KiRAojoJQWk32tNib5DDAKqbJq1fqnhss17gvzm", "action_id_social": "9GE5FSRz6Ai1MPuYqpMb3Wb8oSmrDu8jo2yEWLfxRCug-0-widget", "block_id": 118353944, "block_timestamp": "2024-05-06T08:26:24.278Z", "signer_id": "megha19.near", "widget_name": "CheddarMazeReactV1", "source_code": "const { Modal } = VM.require(\"buildhub.near/widget/components\");\nif (!Modal) {\n  return <></>;\n}\nconst [mazeData, setMazeData] = useState([]);\nconst [playerPosition, setPlayerPosition] = useState({ x: 1, y: 1 });\nconst [score, setScore] = useState(0);\nconst [timeLimitInSeconds, setTimeLimitInSeconds] = useState(120);\nconst [timerId, setTimerId] = useState(null);\nconst [cheeseCooldown, setCheeseCooldown] = useState(false);\nconst [enemyCooldown, setEnemyCooldown] = useState(false);\nconst [moves, setMoves] = useState(0);\nconst [gameOverFlag, setGameOverFlag] = useState(false);\nconst [remainingTime, setRemainingTime] = useState(timeLimitInSeconds);\nconst [remainingMinutes, setRemainingMinutes] = useState(0);\nconst [remainingSeconds, setRemainingSeconds] = useState(0);\nconst [gameOverMessage, setGameOverMessage] = useState(\"\");\nconst [playerStartY, setPlayerStartY] = useState(0);\nconst [timerStarted, setTimerStarted] = useState(false);\nconst [direction, setDirection] = useState(\"right\");\nconst [selectedColorSet, setSelectedColorSet] = useState(null);\nconst [backgroundImage, setBackgroundImage] = useState(\"\");\nconst [rarity, setRarity] = useState(\"\");\nconst [won, setWon] = useState(false);\nconst [touchStart, setTouchStart] = useState({ x: null, y: null });\nconst [touchEnd, setTouchEnd] = useState({ x: null, y: null });\nconst [lastCellX, setLastCellX] = useState(null);\nconst [lastCellY, setLastCellY] = useState(null);\nconst [coveredCells, setCoveredCells] = useState(0);\n\nconst [showStartModal, setShowStartModal] = useState(false);\nconst [userAllowedGame, setAllowedGame] = useState(false);\nconst [parsedCheddarBalance, setCheddarBalance] = useState(0);\nconst accountId = context.accountId;\n\nif (!accountId) {\n  return <>Please Login</>;\n}\n\nconst isUserNadaVerified = Near.view(\"v1.nadabot.near\", \"is_human\", {\n  account_id: context.accountId,\n});\n\nconst isFulfilled = (value) => {\n  return value ? \"\u2705\" : \"\u274c\";\n};\n\nconst TOKEN_CONTRACT_ADDRESS = \"token.cheddar.near\";\n\nconst cheddarBalance = Near.view(TOKEN_CONTRACT_ADDRESS, \"ft_balance_of\", {\n  account_id: accountId,\n});\n\nuseEffect(() => {\n  if (\n    cheddarBalance !== null &&\n    isUserNadaVerified !== null &&\n    !userAllowedGame\n  ) {\n    const balance = Big(cheddarBalance).div(Big(10).pow(24)).toFixed();\n    setCheddarBalance(balance);\n    setAllowedGame(parseFloat(balance) >= 555 && isUserNadaVerified);\n  }\n}, [cheddarBalance, isUserNadaVerified]);\n\nconst Maze = ({\n  mazeData,\n  playerPosition,\n  score,\n  remainingMinutes,\n  remainingSeconds,\n  gameOverFlag,\n  gameOverMessage,\n  startTimerOnTap,\n  handleKeyPress,\n  handleTouchMove,\n  handleMouseClick,\n  restartGame,\n  selectedColorSet,\n  hasExit,\n}) => {\n  const styles = {\n    gameContainer: {\n      display: \"flex\",\n      flexDirection: \"column\",\n      alignItems: \"center\",\n      margin: \"0 auto\",\n      padding: \"0\",\n      maxWidth: `${mazeData[0].length * cellSize + 25}px`,\n      border: \"1px solid gold\",\n      fontFamily: \"Bubblegum Sans !important\", // Add font-family\n      backgroundImage: selectedColorSet.backgroundImage,\n      backgroundSize: \"cover\",\n      backgroundPosition: \"center\",\n    },\n    mazeContainer: {\n      marginBottom: \"10px\",\n      borderRadius: \"5px\",\n      overflow: \"hidden\",\n      width: \"fit-content\",\n      border: `3px solid ${selectedColorSet.pathColor}`,\n    },\n    mazeRow: {\n      display: \"flex\",\n    },\n    mazeCell: {\n      display: \"flex\",\n      flex: \"0 0 auto\", // Fix the size of the cell\n      width: \"40px\",\n      height: \"40px\",\n      border: `1px solid ${selectedColorSet.nonPathColor}`,\n      justifyContent: \"center\",\n      alignItems: \"center\",\n      fontSize: \"24px\", // Adjust the font size of the emojis\n      padding: \"5px\", // Add padding for better visual appearance\n    },\n    playerCell: {\n      position: \"relative\", // Ensure the player is positioned relative to its parent\n      width: \"40px\",\n      height: \"40px\",\n      justifyContent: \"center\",\n      alignItems: \"center\",\n      fontSize: \"24px\",\n      backgroundColor: \"transparent\",\n    },\n    playerMoveUp: {\n      transform: \"rotate(-90deg)\",\n    },\n    playerMoveDown: {\n      transform: \"rotate(90deg)\",\n    },\n    playerMoveLeft: {\n      transform: \"scaleX(-1)\",\n    },\n    playerMoveRight: {\n      transform: \"\",\n    },\n    playerActive: {\n      zIndex: 1, // Ensure the active player appears above other elements\n    },\n    debugInfo: {\n      display: \"none\", // Hide debug info by default\n    },\n    gameInfo: {\n      display: \"flex\",\n      justifyContent: \"space-between\",\n      width: \"200px\",\n    },\n    gameOver: {\n      fontSize: \"15px\",\n      fontWeight: \"bold\",\n      color: hasExit ? \"green\" : \"red\",\n    },\n  };\n\n  // Render the maze cells\n  // Function to render the maze cells\n  // Function to render the maze cells with blur effect\n  const renderMaze = () => {\n    // Check if the game has started for the first time\n    const gameStarted = playerPosition !== null;\n\n    // Check if the player position has changed\n    const playerMoved =\n      gameStarted &&\n      (lastCellX !== playerPosition.x || lastCellY !== playerPosition.y);\n\n    // Update last player position\n    setLastCellX(playerPosition.x);\n    setLastCellY(playerPosition.y);\n\n    return mazeData.map((row, rowIndex) => (\n      <div key={rowIndex} style={styles.mazeRow}>\n        {row.map((cell, colIndex) => {\n          const blurRadius = playerMoved\n            ? calculateBlurRadius(colIndex, rowIndex)\n            : 0;\n          const applyBlur = blurRadius > 0; // Determine if blur should be applied\n\n          // Define cell content based on cell type\n          let cellContent = \"\";\n          if (cell.hasCheese) cellContent = \"\ud83e\uddc0\";\n          else if (cell.hasEnemy) cellContent = \"\ud83d\udc7e\";\n          else if (cell.hasExit) cellContent = \"\ud83d\udeaa\";\n          else if (cell.hasCartel) cellContent = \"\ud83e\udd2e\";\n          else if (cell.enemyWon) cellContent = \"\ud83d\udca2\";\n\n          return (\n            <div\n              key={colIndex}\n              id={`cell-${rowIndex}-${colIndex}`}\n              style={{\n                ...styles.mazeCell,\n                backgroundColor: cell.isPath\n                  ? selectedColorSet.pathColor\n                  : selectedColorSet.backgroundColor,\n                filter: applyBlur ? `blur(${blurRadius}px)` : \"none\", // Apply blur conditionally\n                position: \"relative\", // Ensure relative positioning for absolute positioning of icons\n              }}\n              onClick={handleMouseClick}\n            >\n              {/* Dynamic content based on cell */}\n              {cellContent && (\n                <span\n                  role=\"img\"\n                  aria-label={cellContent}\n                  className=\"static-icon\"\n                  style={{ position: \"absolute\" }}\n                >\n                  {cellContent}\n                </span>\n              )}\n\n              {/* Player icon */}\n              {playerPosition.x === colIndex &&\n                playerPosition.y === rowIndex && (\n                  <div\n                    className={`player-icon ${direction}`} // Apply dynamic CSS class based on the direction\n                    style={{\n                      ...styles.mazeCell,\n                      ...styles.playerCell,\n                      ...styles[\n                        `playerMove${\n                          direction.charAt(0).toUpperCase() + direction.slice(1)\n                        }`\n                      ], // Applying the direction style dynamically\n                      backgroundSize: \"cover\",\n                      backgroundRepeat: \"no-repeat\",\n                      backgroundPosition: \"center\",\n                      backgroundSize: \"70%\",\n                      position: \"relative\",\n                      zIndex: \"2\", // Ensure player is in the forefront\n                      backgroundImage:\n                        cell.enemyWon || cell.hasCartel || cell.hasExit\n                          ? \"none\"\n                          : \"url('https://lh3.googleusercontent.com/d/114_RLl18MAzX035svMyvNJpE3ArfLNCF=w500')\",\n                    }}\n                  ></div>\n                )}\n            </div>\n          );\n        })}\n      </div>\n    ));\n  };\n\n  // Inside the Maze component return statement\n  // Inside the Maze component return statement\n  return (\n    <div style={styles.gameContainer}>\n      <h1>Cheddar Maze</h1>\n      <div style={styles.gameInfo}>\n        <div>Score: {score}</div>\n        <div>\n          Time:{\" \"}\n          {remainingMinutes < 10 ? \"0\" + remainingMinutes : remainingMinutes}:\n          {remainingSeconds < 10 ? \"0\" + remainingSeconds : remainingSeconds}\n        </div>\n      </div>\n      <div style={styles.gameOver}>{gameOverMessage}</div>\n      {gameOverFlag && (\n        <button onClick={restartGame} style={{ fontSize: \"18px\" }}>\n          Restart Game\n        </button>\n      )}\n\n      <div\n        style={styles.mazeContainer}\n        tabIndex=\"0\"\n        onKeyDown={handleKeyPress}\n        onTouchMove={handleTouchMove}\n        onClick={handleMouseClick}\n      >\n        {renderMaze()}\n      </div>\n      {!timerStarted && !gameOverFlag && (\n        <div className=\"py-2 d-flex justify-content-center\">\n          <button onClick={() => setShowStartModal(true)}>Start Game</button>\n        </div>\n      )}\n      <Modal\n        open={showStartModal}\n        title={\"Start a game\"}\n        onOpenChange={setShowStartModal}\n        toggle={setShowStartModal}\n      >\n        <h6>Requirements to be an eligible player:</h6>\n        <ol>\n          <li>\n            Minimum balance of 555 Cheddar{\" \"}\n            {isFulfilled(parseFloat(parsedCheddarBalance) >= 555)}\n          </li>\n          <li>NADA bot Verified {isFulfilled(isUserNadaVerified)}</li>\n        </ol>\n        <h6>Steps:</h6>\n        <ol>\n          <li>Click on board to start the game</li>\n          <li>Navigate with Arrows or Tap</li>\n          <li>Collect Cheddar\ud83e\uddc0</li>\n          <li>Battle Cartel to protect your Bag</li>\n          <li>Find the Hidden Door\ud83d\udeaa to Win!</li>\n        </ol>\n\n        <div className=\"d-flex justify-content-center\">\n          <button\n            disabled={!userAllowedGame}\n            onClick={() => {\n              setShowStartModal(false);\n            }}\n          >\n            Start\n          </button>\n        </div>\n      </Modal>\n    </div>\n  );\n};\n\n// Function to select a random color set, background image, and rarity\nconst selectRandomColorSet = () => {\n  const colorSets = [\n    {\n      backgroundColor: \"#333333\",\n      pathColor: \"#9d67ef\",\n      nonPathColor: \"white\",\n      textColor: \"#000000\",\n      rarity: \"common\",\n      backgroundImage:\n        \"url('https://cheddar.farm/newFarmBackground.c6905a5e.png')\",\n    },\n    {\n      backgroundColor: \"#333333\",\n      pathColor: \"gold\",\n      nonPathColor: \"white\",\n      textColor: \"#333333\",\n      rarity: \"rare\",\n      backgroundImage:\n        \"url('https://ipfs.near.social/ipfs/bafkreihpddbzbioe7kctes25rr52klcs5we4pocwiwbmwldqf4acdarpcm')\",\n    },\n    {\n      backgroundColor: \"#20d3fc\",\n      pathColor: \"#ff00ff\",\n      nonPathColor: \"#6600ff\",\n      textColor: \"#333333\",\n      rarity: \"rare\",\n      backgroundImage:\n        \"url('https://ipfs.near.social/ipfs/bafkreihpddbzbioe7kctes25rr52klcs5we4pocwiwbmwldqf4acdarpcm')\",\n    },\n    // Add more color sets as needed\n  ];\n\n  return colorSets[Math.floor(Math.random() * colorSets.length)];\n};\n\n// Define a new useEffect hook to manage the timer\nuseEffect(() => {\n  let intervalId;\n  if (timerStarted && !gameOverFlag) {\n    intervalId = setInterval(() => {\n      setRemainingTime((prevTime) => {\n        if (prevTime === 0) {\n          clearInterval(intervalId);\n          gameOver(\"\u23f0 Time's up! Game Over!\");\n          return prevTime;\n        }\n        return prevTime - 1;\n      });\n    }, 1000);\n  } else {\n    clearInterval(intervalId);\n  }\n\n  return () => clearInterval(intervalId); // Cleanup function to clear interval on unmount or when timer conditions change\n}, [timerStarted, gameOverFlag]);\n\nuseEffect(() => {\n  const minutes = Math.floor(remainingTime / 60);\n  const seconds = remainingTime % 60;\n  setRemainingMinutes(minutes);\n  setRemainingSeconds(seconds);\n}, [remainingTime]);\n\nuseEffect(() => {\n  // Clear timer when component unmounts\n  return () => {\n    clearInterval(timerId);\n  };\n}, [timerId]);\n\nconst getRandomPathCell = (mazeData) => {\n  const pathCells = [];\n  mazeData.map((row, rowIndex) => {\n    row.map((cell, colIndex) => {\n      if (cell.isPath) {\n        pathCells.push({ x: colIndex, y: rowIndex });\n      }\n    });\n  });\n\n  if (pathCells.length === 0) {\n    console.error(\"No path cells found!\"); // Log an error if no path cells are found\n    return null;\n  }\n\n  return pathCells[Math.floor(Math.random() * pathCells.length)];\n};\n\n// Function to restart the game\nconst restartGame = () => {\n  clearInterval(timerId);\n  setScore(0);\n  setTimeLimitInSeconds(120);\n  setRemainingTime(120);\n  setCheeseCooldown(false);\n  setEnemyCooldown(false);\n  setMoves(0);\n  setGameOverFlag(false);\n  setWon(false);\n  setGameOverMessage(\"\");\n  setDirection(\"right\");\n\n  // Regenerate maze data\n  const mazeRows = 11;\n  const mazeCols = 9;\n  const newMazeData = generateMazeData(mazeRows, mazeCols);\n\n  // Set the maze data with the new maze and player's starting position\n  setMazeData(newMazeData);\n\n  const playerStartCell = getRandomPathCell(newMazeData);\n  console.log(playerStartCell.x + \" \" + playerStartCell.y);\n  setPlayerPosition({ x: playerStartCell.x, y: playerStartCell.y });\n  setLastCellX(null);\n  setLastCellY(null);\n\n  startTimer(); // Start the timer again after resetting the game\n};\n\n// Function to generate maze data\nconst generateMazeData = (rows, cols) => {\n  const maze = Array.from({ length: rows }, () =>\n    Array.from({ length: cols }, () => ({\n      isPath: false,\n      isActive: false,\n      hasCheese: false,\n      hasEnemy: false,\n      hasExit: false,\n      enemyWon: false,\n      hasCartel: false,\n    }))\n  );\n\n  // Choose a random starting position on the outer border\n  const startEdge = Math.floor(Math.random() * 4); // 0: top, 1: right, 2: bottom, 3: left\n  let x, y;\n\n  switch (startEdge) {\n    case 0: // Top edge\n      x = Math.floor(Math.random() * (cols - 2)) + 1;\n      y = 0;\n      break;\n    case 1: // Right edge\n      x = cols - 1;\n      y = Math.floor(Math.random() * (rows - 2)) + 1;\n      break;\n    case 2: // Bottom edge\n      x = Math.floor(Math.random() * (cols - 2)) + 1;\n      y = rows - 1;\n      break;\n    case 3: // Left edge\n      x = 0;\n      y = Math.floor(Math.random() * (rows - 2)) + 1;\n      break;\n  }\n\n  maze[y][x].isPath = true;\n  const stack = [[x, y]];\n\n  while (stack.length) {\n    const [cx, cy] = stack[stack.length - 1];\n    const directions = [];\n\n    // Check all possible directions\n    [\n      [2, 0], // Increase step to 2 for wider paths\n      [-2, 0], // Increase step to 2 for wider paths\n      [0, 2], // Increase step to 2 for wider paths\n      [0, -2], // Increase step to 2 for wider paths\n    ].forEach(([dx, dy]) => {\n      const nx = cx + dx,\n        ny = cy + dy;\n      if (\n        nx >= 0 &&\n        nx < cols &&\n        ny >= 0 &&\n        ny < rows &&\n        !maze[ny][nx].isPath\n      ) {\n        directions.push([nx, ny, cx + dx / 2, cy + dy / 2]); // Adjust coordinates for wider paths\n      }\n    });\n\n    if (directions.length) {\n      const [nx, ny, px, py] =\n        directions[Math.floor(Math.random() * directions.length)];\n      maze[ny][nx].isPath = true;\n      maze[py][px].isPath = true;\n      stack.push([nx, ny]);\n    } else {\n      stack.pop();\n    }\n  }\n\n  return maze;\n};\n\n// Inside the component where you're using the Maze component\nuseEffect(() => {\n  // Generate maze data and set it to the state\n  const mazeRows = 11;\n  const mazeCols = 9;\n  const newMazeData = generateMazeData(mazeRows, mazeCols);\n  setMazeData(newMazeData);\n\n  const randomColorSet = selectRandomColorSet();\n  setSelectedColorSet(randomColorSet);\n  setBackgroundImage(randomColorSet.backgroundImage);\n  setRarity(randomColorSet.rarity);\n\n  const playerStartCell = getRandomPathCell(newMazeData);\n  setPlayerPosition({ x: playerStartCell.x, y: playerStartCell.y });\n}, []); // Empty dependency array to run this effect only once on component mount\n\nconst movePlayer = (newX, newY) => {\n  if (!mazeData[newY][newX].isPath) {\n    return; // Player cannot move to non-path cells\n  }\n\n  // Start the timer if it hasn't started yet\n  if (!timerStarted) {\n    startTimer();\n    setTimerStarted(true);\n  }\n\n  const newMazeData = mazeData.map((row, rowIndex) =>\n    row.map((cell, colIndex) => ({\n      ...cell,\n      isActive: rowIndex === newY && colIndex === newX,\n    }))\n  );\n\n  // Reset isActive for the previous player position\n  newMazeData[playerPosition.y][playerPosition.x].isActive = false;\n\n  // Update player position state\n  setPlayerPosition({ x: newX, y: newY });\n\n  // Update mazeData state\n  setMazeData(newMazeData);\n\n  // Increment moves count\n  setMoves(moves + 1);\n  setCoveredCells(coveredCells + 1);\n\n  // Periodically add artifacts to the board based on cooldowns and randomness\n  addArtifacts(newX, newY, newMazeData, moves);\n\n  // Set lastCellX and lastCellY to the new player position\n  // Update last cell coordinates\n  setLastCellX(playerPosition.x);\n  setLastCellY(playerPosition.y);\n};\n\nconst addArtifacts = (newX, newY, newMazeData, moves) => {\n  if (\n    !gameOverFlag &&\n    !newMazeData[newY][newX].hasEnemy &&\n    !newMazeData[newY][newX].hasCheese &&\n    moves >= 10\n  ) {\n    if (!enemyCooldown && Math.random() < 0.3) {\n      // 30% chance of encountering an enemy\n      // Code for adding enemy artifact...\n\n      // Add logic for the enemy defeating the player\n      if (Math.random() < 0.1) {\n        // 10% chance of the enemy winning\n        console.log(\"enemy won\");\n        const updatedMazeData = newMazeData.map((row, rowIndex) =>\n          row.map((mazeCell, colIndex) => {\n            const isPlayerPosition = rowIndex === newY && colIndex === newX;\n            if (isPlayerPosition) {\n              return {\n                ...mazeCell,\n                enemyWon: true, // Update enemyWon flag\n                isActive: false, // Update isActive flag\n              };\n            }\n            return mazeCell;\n          })\n        );\n        setMazeData(updatedMazeData);\n        setScore(0); // Set score to zero\n        gameOver(\"Enemy won! Game Over!\");\n        stopTimer();\n      } else {\n        const updatedMazeData = newMazeData.map((row, rowIndex) =>\n          row.map((mazeCell, colIndex) => {\n            const isPlayerPosition = rowIndex === newY && colIndex === newX;\n            if (isPlayerPosition) {\n              return {\n                ...mazeCell,\n                hasEnemy: true, // Update enemyWon flag\n              };\n            }\n            return mazeCell;\n          })\n        );\n        setMazeData(updatedMazeData);\n        setEnemyCooldown(true);\n        setTimeout(() => {\n          setEnemyCooldown(false);\n        }, Math.floor(Math.random() * 5000) + 1000);\n      }\n    } else if (!cheeseCooldown && Math.random() < 0.055) {\n      // 5.5% chance of winning cheese\n      const updatedMazeData = newMazeData.map((row, rowIndex) =>\n        row.map((cell, colIndex) => {\n          if (rowIndex === newY && colIndex === newX) {\n            return {\n              ...cell,\n              hasCheese: true,\n            };\n          }\n          return cell;\n        })\n      );\n      setMazeData(updatedMazeData);\n      setScore(score + 1);\n      setCheeseCooldown(true);\n      setTimeout(() => {\n        setCheeseCooldown(false);\n      }, Math.floor(Math.random() * 5000) + 1000);\n    } else if (Math.random() < 0.002) {\n      // 0.2% chance of hitting the \"cartel\" event\n      const updatedMazeData = newMazeData.map((row, rowIndex) =>\n        row.map((cell, colIndex) => {\n          if (rowIndex === newY && colIndex === newX) {\n            return {\n              ...cell,\n              hasCartel: true,\n            };\n          }\n          return cell;\n        })\n      );\n      setMazeData(updatedMazeData);\n      setScore(0);\n      gameOver(\"You ran into the cartel! Game Over!\");\n      stopTimer();\n    } else if (Math.random() < 0.33 && coveredCells >= 0.75 * totalCells) {\n      // 33% chance of finding the exit when 75% of the maze is covered\n      const updatedMazeData = newMazeData.map((row, rowIndex) =>\n        row.map((cell, colIndex) => {\n          if (rowIndex === newY && colIndex === newX) {\n            return {\n              ...cell,\n              hasExit: true,\n            };\n          }\n          return cell;\n        })\n      );\n    }\n  } else if (newMazeData[newY][newX].hasExit) {\n    gameOver(\"Congrats! You found the Hidden Door.\");\n    stopTimer();\n  }\n};\n\n// Function to handle key press events\nconst handleKeyPress = (event) => {\n  if (gameOverFlag) return; // If game over, prevent further movement\n\n  const key = event.key;\n  let newX = playerPosition.x;\n  let newY = playerPosition.y;\n\n  switch (key) {\n    case \"ArrowUp\":\n      newY--;\n      setDirection(\"up\");\n      break;\n    case \"ArrowDown\":\n      newY++;\n      setDirection(\"down\");\n      break;\n    case \"ArrowLeft\":\n      newX--;\n      setDirection(\"left\");\n      break;\n    case \"ArrowRight\":\n      newX++;\n      setDirection(\"right\");\n      break;\n    default:\n      return;\n  }\n\n  movePlayer(newX, newY);\n  // Update last cell coordinates\n  setLastCellX(playerPosition.x);\n  setLastCellY(playerPosition.y);\n};\n\nconst isMobile = () => {\n  const userAgent = navigator.userAgent;\n  return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(\n    userAgent\n  );\n};\n\nconst cellSize = isMobile() ? 30 : 40;\n\nconst handleContainerClick = () => {\n  startTimerOnTap(); // Start the timer when the user clicks on the maze container\n};\n\nlet isMouseDown = false;\n\nconst handleMouseClick = (event) => {\n  if (gameOverFlag) return; // If game over, prevent further movement\n\n  // Extract cell coordinates from the id attribute\n  const id = event.target.id;\n  const [_, y, x] = id.split(\"-\");\n  const newX = parseInt(x);\n  const newY = parseInt(y);\n\n  // Calculate the direction based on the clicked cell's position relative to the player's current position\n  let newDirection = direction; // Initialize newDirection with the current direction\n  if (newY < playerPosition.y) {\n    newDirection = \"up\";\n  } else if (newY > playerPosition.y) {\n    newDirection = \"down\";\n  } else if (newX < playerPosition.x) {\n    newDirection = \"left\";\n  } else if (newX > playerPosition.x) {\n    newDirection = \"right\";\n  }\n\n  // Update the direction state\n  setDirection(newDirection);\n\n  // Call movePlayer to move the player to the clicked cell\n  movePlayer(newX, newY);\n};\n\n// Function to calculate the path from the current position to the target position\nconst calculatePath = (currentX, currentY, targetX, targetY) => {\n  console.log(\n    `Calculating path from (${currentX}, ${currentY}) to (${targetX}, ${targetY})`\n  );\n  const path = [];\n\n  let deltaX = Math.sign(targetX - currentX);\n  let deltaY = Math.sign(targetY - currentY);\n\n  let x = currentX;\n  let y = currentY;\n\n  console.log(\"Delta X:\", deltaX);\n  console.log(\"Delta Y:\", deltaY);\n\n  // Ensure that both x and y are not equal to their respective target values\n  while (x !== targetX || y !== targetY) {\n    path.push([x, y]);\n\n    // Move along the x-axis towards the target\n    if (x !== targetX) x += deltaX;\n\n    // Move along the y-axis towards the target\n    if (y !== targetY) y += deltaY;\n  }\n\n  // Add the target position to the path\n  path.push([targetX, targetY]);\n\n  console.log(\"Calculated path:\", path);\n\n  return path;\n};\n\n// Function to move the player along the calculated path\nconst moveAlongPath = (path) => {\n  console.log(\"Moving along path:\", path);\n  path.forEach(([x, y]) => {\n    console.log(`Moving to cell (${x}, ${y})`);\n    movePlayer(x, y);\n  });\n};\n\n// Function to extract cell coordinates from the id attribute\nconst getCellCoordinates = (id) => {\n  const [_, y, x] = id.split(\"-\");\n  return { newX: parseInt(x), newY: parseInt(y) };\n};\n\nconst handleTouchMove = (event) => {\n  event.preventDefault(); // Prevent default touch move behavior\n\n  if (!mazeContainerRef || !isMouseDown) return;\n\n  const { newX, newY } = getCellCoordinates(event.target.id);\n\n  // Update last cell coordinates\n  setLastCellX(playerPosition.x);\n  setLastCellY(playerPosition.y);\n\n  // Call movePlayerDirection to move the player based on touch direction\n  const deltaX = newX - touchStart.x;\n  const deltaY = newY - touchStart.y;\n  let direction = \"\";\n\n  if (Math.abs(deltaX) > Math.abs(deltaY)) {\n    direction = deltaX > 0 ? \"right\" : \"left\";\n  } else {\n    direction = deltaY > 0 ? \"down\" : \"up\";\n  }\n\n  // Move the player in the determined direction\n  for (let i = 0; i < Math.abs(cellsMovedX); i++) {\n    movePlayerDirection(direction);\n  }\n\n  for (let i = 0; i < Math.abs(cellsMovedY); i++) {\n    movePlayerDirection(direction);\n  }\n\n  // Update touch start position for next move\n  setTouchStart({ x: touch.clientX, y: touch.clientY });\n};\n\nconst calculateBlurRadius = (cellX, cellY) => {\n  // Check if lastCellX and lastCellY are null or undefined\n  if (lastCellX === null || lastCellY === null) {\n    // Initialize lastCellX and lastCellY with initial player position\n    setLastCellX(playerPosition.x);\n    setLastCellY(playerPosition.y);\n  }\n\n  // Calculate distance between current cell and last cell\n  const distance = Math.sqrt(\n    Math.pow(cellX - lastCellX, 2) + Math.pow(cellY - lastCellY, 2)\n  );\n\n  // Define max blur radius and adjust based on distance\n  const maxBlurRadius = 10; // Adjust as needed\n  return Math.min(maxBlurRadius, distance);\n};\n\nconst ControlPad = ({ movePlayerDirection }) => {\n  return (\n    <div\n      style={{ display: \"flex\", flexDirection: \"column\", alignItems: \"center\" }}\n    >\n      <button\n        disabled={userAllowedGame}\n        onClick={() => movePlayerDirection(\"up\")}\n      >\n        Up\n      </button>\n      <div style={{ display: \"flex\", justifyContent: \"center\" }}>\n        <button\n          disabled={userAllowedGame}\n          onClick={() => movePlayerDirection(\"left\")}\n        >\n          Left\n        </button>\n        <button\n          disabled={userAllowedGame}\n          onClick={() => movePlayerDirection(\"down\")}\n        >\n          Down\n        </button>\n        <button\n          disabled={userAllowedGame}\n          onClick={() => movePlayerDirection(\"right\")}\n        >\n          Right\n        </button>\n      </div>\n    </div>\n  );\n};\n\n// Function to handle directional button inputs\nconst movePlayerDirection = (direction) => {\n  if (gameOverFlag) return;\n\n  let newX = playerPosition.x;\n  let newY = playerPosition.y;\n\n  switch (direction) {\n    case \"up\":\n      newY--;\n      break;\n    case \"down\":\n      newY++;\n      break;\n    case \"left\":\n      newX--;\n      break;\n    case \"right\":\n      newX++;\n      break;\n    default:\n      return;\n  }\n\n  setDirection(direction); // Optionally update the direction if needed\n  handleMove(newX, newY);\n};\n\n// Example handler for touch or click events where path calculation is desired\nconst handleMove = (event) => {\n  const { newX, newY } = getCellCoordinates(event.target.id);\n  const path = calculatePath(playerPosition.x, playerPosition.y, newX, newY);\n  moveAlongPath(path);\n};\n\n// Function to start the timer\nconst startTimer = () => {\n  if (!timerStarted && !gameOverFlag) {\n    setTimerStarted(true);\n  }\n};\n\nconst startTimerOnTap = () => {\n  if (!timerStarted) {\n    startTimer();\n  }\n};\n\nconst stopTimer = () => {\n  clearInterval(timerId);\n  setTimerStarted(false);\n};\n\n// Function to handle game over\nconst gameOver = (message) => {\n  setGameOverFlag(true);\n  setGameOverMessage(message);\n  stopTimer();\n};\n\nconst initialized = () => {\n  // Check if all necessary state variables are not null or undefined\n  return (\n    selectedColorSet !== null &&\n    mazeData !== null &&\n    playerPosition !== null &&\n    score !== null &&\n    remainingTime !== null &&\n    gameOverFlag !== null &&\n    gameOverMessage !== null &&\n    startTimer !== null &&\n    handleKeyPress !== null &&\n    handleTouchMove !== null &&\n    handleMouseClick !== null &&\n    restartGame !== null\n  );\n};\n\nconst handleEvent = (e, eventType) => {\n  if (!userAllowedGame) {\n    e.preventDefault();\n    return;\n  }\n\n  switch (eventType) {\n    case \"touch\":\n      handleTouchMove(e);\n      break;\n    case \"click\":\n      handleMouseClick(e);\n      break;\n    case \"keydown\":\n      handleKeyPress(e);\n      break;\n    default:\n      break;\n  }\n};\n\nreturn (\n  <div>\n    {initialized() && ( // Replace `condition` with your actual condition\n      <Maze\n        mazeData={mazeData}\n        playerPosition={playerPosition}\n        score={score}\n        remainingMinutes={Math.floor(remainingTime / 60)}\n        remainingSeconds={remainingTime % 60}\n        gameOverFlag={gameOverFlag}\n        gameOverMessage={gameOverMessage}\n        startTimerOnTap={startTimer}\n        handleKeyPress={(e) => handleEvent(e, \"keydown\")}\n        handleTouchMove={(e) => handleEvent(e, \"touch\")}\n        handleMouseClick={(e) => handleEvent(e, \"click\")}\n        restartGame={restartGame}\n        selectedColorSet={selectedColorSet}\n        hasExit={hasExit}\n      />\n    )}\n  </div>\n);\n", "metadata": {"fork_of": "blaze.near/widget/CheddarMazeReactV1@118304447"}, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/megha19.near/widget/CheddarMazeReactV1", "fact_widget_deployments_id": "948c4d824b0b266992485497c81284e9", "inserted_timestamp": "2024-05-06T09:38:52.108Z", "modified_timestamp": "2024-05-06T09:38:52.108Z", "__row_index": 13}