{"tx_hash": "6CWXeLnZ8DDWFLDWKUTn9yJ2h6ZyVwioRaGsLVp7XqQL", "action_id_social": "DvPJUX3zKH8rCb51ktDMejBmELYYhYFWEcK7uGcGt4d8-0-widget", "block_id": 108236176, "block_timestamp": "2023-12-18T08:19:16.761Z", "signer_id": "megha19.near", "widget_name": "core.lib.struct", "source_code": "/**\n * Deeply updates an object's field based on the given path and transformation function.\n *\n * @param {Object} target - The target object to update.\n * @param {Array} path - The path to the field to update.\n * @param {Function} transform - The transformation function to apply.\n * @returns {Object} - The updated object.\n */\nconst deepFieldUpdate = (target, path, transform) => {\n  if (path.length === 0) {\n    return transform(target);\n  }\n\n  const [nextNodeKey, ...remainingPath] = path;\n\n  return {\n    ...target,\n    [nextNodeKey]: deepFieldUpdate(\n      target[nextNodeKey] ?? {},\n      remainingPath,\n      transform\n    ),\n  };\n};\n\n/**\n * Checks if two inputs (objects or arrays) are deeply equal.\n *\n * @param {Object|Array} input1 - The first input.\n * @param {Object|Array} input2 - The second input.\n * @returns {boolean} - True if the inputs are deeply equal, false otherwise.\n */\nconst isEqual = (input1, input2) => {\n  const input1Str = JSON.stringify(input1);\n  const input2Str = JSON.stringify(input2);\n  return input1Str === input2Str;\n};\n\n/**\n * Creates a new object with sorted keys based on the input object.\n *\n * @param {Object} input - The input object.\n * @returns {Object} - A new object with sorted keys.\n */\nconst toOrdered = (input) => {\n  if (typeof input !== \"object\" || input === null) {\n    return {};\n  }\n\n  return Object.keys(input)\n    .sort()\n    .reduce((output, key) => ({ ...output, [key]: input[key] }), {});\n};\n\n/**\n * Picks specified keys from an object and returns a new object with those keys.\n *\n * @param {Object} sourceObject - The source object to pick keys from.\n * @param {Array} keysToPick - An array of keys to pick.\n * @returns {Object} - A new object containing the selected keys.\n */\nconst pick = (sourceObject, keysToPick) => {\n  if (typeof sourceObject !== \"object\" || sourceObject === null) {\n    return {};\n  }\n\n  return Object.fromEntries(\n    Object.entries(sourceObject).filter(([key, _]) => keysToPick.includes(key))\n  );\n};\n\n/**\n * Checks if the input matches the expected type.\n *\n * @param {Object} input - The input to check.\n * @returns {boolean} - True if the input is an object and not an array or null, false otherwise.\n */\nconst typeMatch = (input) =>\n  input !== null && typeof input === \"object\" && !Array.isArray(input);\n\nreturn { deepFieldUpdate, isEqual, pick, toOrdered, typeMatch };\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/megha19.near/widget/core.lib.struct", "fact_widget_deployments_id": "cc3c5f3272a3c165353f47e6ce0b150b", "inserted_timestamp": "2023-12-18T10:23:35.740Z", "modified_timestamp": "2023-12-20T03:22:11.422Z", "__row_index": 0}