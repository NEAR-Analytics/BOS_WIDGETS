{"tx_hash": "5FUoxDbmPJCRo6g4UcyVrTa7dmW9dA5SBd6dYev8qJ3V", "action_id_social": "96cXEmfYEnYBsNk5isHC63XunCnigvV6LhJANSx8grRk-0-widget", "block_id": 116868634, "block_timestamp": "2024-04-15T02:36:24.635Z", "signer_id": "devs.near", "widget_name": "widget.everything.sdk", "source_code": "const isPrimitiveType = (type) =>\n  [\"string\", \"number\", \"boolean\", \"date\", \"md\"].includes(type);\nconst isComplexType = (type) =>\n  Array.isArray(type)\n    ? \"typesArray\" // I don't know if we still need to handle this\n    : type === \"array\"\n    ? \"array\"\n    : typeof type === \"object\"\n    ? \"object\"\n    : typeof type === \"string\" && !isPrimitiveType(type)\n    ? \"custom\"\n    : null;\nconst getDefaultForPrimitive = (type, defaultValue) => {\n  if (defaultValue !== undefined) {\n    return defaultValue;\n  }\n  switch (type) {\n    case \"string\":\n      return \"\";\n    case \"number\":\n      return null; // should this be 0?\n    case \"boolean\":\n      return null; // do we want this to be false?\n    case \"date\":\n      return null; // do we want this to be today?\n    case \"md\":\n      return null;\n  }\n};\nconst typeToEmptyData = (typeDef) => {\n  const obj = {};\n  Object.keys(typeDef.properties).forEach((key) => {\n    const fieldSchema = typeDef.properties[key];\n    const type = fieldSchema.type;\n    if (isPrimitiveType(type)) {\n      obj[key] = getDefaultForPrimitive(type, fieldSchema.defaultValue);\n    } else if (isComplexType(type) === \"array\") {\n      obj[key] = fieldSchema.defaultValue ? [...fieldSchema.defaultValue] : [];\n    } else if (isComplexType(type) === \"object\") {\n      obj[key] = typeToEmptyData({ properties: type.properties });\n    } else {\n      console.log(\"edge case not handled for type: \" + type);\n      obj[key] = fieldSchema.defaultValue ?? null;\n    }\n  });\n  return obj;\n};\nfunction checkProps(props, typeDef, prefix) {\n  if (!prefix) {\n    prefix = \"\";\n  }\n  const missingProps = [];\n  for (const [key, value] of Object.entries(typeDef.properties)) {\n    const fullKey = prefix ? `${prefix}.${key}` : key;\n    if (!props.hasOwnProperty(key)) {\n      missingProps.push(`${fullKey}`);\n      continue;\n    }\n    const propValue = props[key];\n    if (value.type === \"object\" && value.properties) {\n      missingProps.push(...checkProps(propValue, value, fullKey));\n    }\n    if (value.validation && value.validation.required && propValue == null) {\n      missingProps.push(`${fullKey} (required)`);\n    }\n  }\n  return missingProps;\n}\nfunction MissingPropsWarning({ props, typeDef, WarningElement }) {\n  const missingProps = checkProps(props, typeDef);\n  return (\n    missingProps.length > 0 && (\n      <>\n        {WarningElement ? (\n          <WarningElement missingProps={missingProps} />\n        ) : (\n          <div\n            className=\"card border-warning mb-3 shadow\"\n            style={{ maxWidth: \"30rem\", margin: \"auto\" }}\n          >\n            <div className=\"card-header text-white bg-warning\">\n              <h4 className=\"card-title mb-0\">Attention!</h4>\n            </div>\n            <div className=\"card-body text-danger\">\n              <p className=\"card-text\">\n                {`There ${missingProps.length === 1 ? \"is\" : \"are\"} ${\n                  missingProps.length\n                } missing or invalid prop${\n                  missingProps.length === 1 ? \"\" : \"s\"\n                }:`}\n              </p>\n              <ul className=\"list-group list-group-flush\">\n                {missingProps.map((prop) => (\n                  <li key={prop} className=\"list-group-item\">\n                    <pre className=\"m-0\">{prop}</pre>\n                  </li>\n                ))}\n              </ul>\n            </div>\n          </div>\n        )}\n      </>\n    )\n  );\n}\nfunction filterByType(data, targetType) {\n  return Object.keys(data || {}).reduce((result, key) => {\n    if (data[key].metadata?.type === targetType) {\n      result[key] = data[key];\n    }\n    return result;\n  }, {});\n}\nfunction deepMerge(obj1, obj2) {\n  return Object.keys({ ...obj1, ...obj2 }).reduce((acc, key) => {\n    if (\n      obj1[key] &&\n      obj2[key] &&\n      typeof obj1[key] === \"object\" &&\n      typeof obj2[key] === \"object\"\n    ) {\n      acc[key] = deepMerge(obj1[key], obj2[key]);\n    } else {\n      acc[key] = obj2[key] !== undefined ? obj2[key] : obj1[key];\n    }\n    return acc;\n  }, {});\n}\nfunction getAllThings(type, accounts, blockHeight) {\n  let paths;\n  if (!blockHeight) {\n    blockHeight = \"final\";\n  }\n  if (Array.isArray(accounts) && accounts.length) {\n    // We could change this to get all metadata, metadata includes type\n    // and then we have all we need in order to show on screens. Anything else can be fetched separately.\n    paths = accounts.map((account) => `${account}/thing/*/metadata/*`);\n  } else {\n    paths = [\"*/thing/*/metadata/*\"];\n  }\n  const things = Social.get(paths, blockHeight);\n  return filterByType(things, type) ?? {};\n}\nfunction getThing(id, accountIds, blockHeight) {\n  let paths;\n  if (!blockHeight) {\n    blockHeight = \"final\";\n  }\n  if (Array.isArray(accountIds) && accountIds.length) {\n    paths = accountIds.map((accountId) => `${accountId}/thing/${id}/**`);\n  } else {\n    paths = [`*/thing/${id}/**`];\n  }\n  const thing = Social.get(paths, blockHeight) || {};\n  return thing;\n}\nfunction deleteThing(id) {\n  Social.set({\n    thing: {\n      [id]: null,\n    },\n  });\n}\nfunction createThing(type, data, metadata) {\n  // Temporary small id\n  const id = UUID.generate(\"xxxxxxx\");\n  return {\n    [id]: {\n      // I think there may be some value in stringify-ing the data and storing in empty key, but I'm not sure\n      // Maybe it's for published data? Data that has no relations?\n      // It's more space efficient for the social contract if we limit the number of keys\n      \"\": JSON.stringify(data),\n      data, // so I'm just gonna do both for right now :)\n      metadata: { ...metadata, type },\n    },\n  };\n}\nreturn {\n  filterByType,\n  getThing,\n  getAllThings,\n  deepMerge,\n  deleteThing,\n  createThing,\n  isPrimitiveType,\n  isComplexType,\n  getDefaultForPrimative,\n  typeToEmptyData,\n  checkProps,\n  MissingPropsWarning,\n};\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/devs.near/widget/widget.everything.sdk", "fact_widget_deployments_id": "9a0164b4c8025e99aad1fbd8f1420470", "inserted_timestamp": "2024-04-15T04:38:44.803Z", "modified_timestamp": "2024-04-15T05:22:37.742Z", "__row_index": 0}