{"tx_hash": "DUJZ28S8GBjKTwxyQKbURrSVuEyB6rrQYQtoqW74zux2", "action_id_social": "JAMo47D54xF3PsRHjHhDen2PhL63JS8v9Y45G1DiEq6P-0-widget", "block_id": 111893918, "block_timestamp": "2024-02-02T00:52:57.388Z", "signer_id": "devs.near", "widget_name": "PR.MergedIndexFeed", "source_code": "if (!props.index) {\n  return \"props.index is not defined\";\n}\nconst indices = JSON.parse(\n  JSON.stringify(Array.isArray(props.index) ? props.index : [props.index])\n);\nconst requiredIndices = indices.filter((index) => index.required);\n\nconst filter = props.filter;\n\nconst renderItem =\n  props.renderItem ??\n  ((item) => (\n    <div key={JSON.stringify(item)}>\n      #{item.blockHeight}: {JSON.stringify(item)}\n    </div>\n  ));\nconst cachedRenderItem = (item, i) => {\n  const key = JSON.stringify(item);\n\n  if (!(key in state.cachedItems)) {\n    state.cachedItems[key] = renderItem(item, i);\n    State.update();\n  }\n  return state.cachedItems[key];\n};\n\nconst initialRenderLimit = props.initialRenderLimit ?? 10;\nconst addDisplayCount = props.nextLimit ?? initialRenderLimit;\nconst reverse = !!props.reverse;\n\nconst computeFetchFrom = (items, limit, desc) => {\n  if (!items || items.length < limit) {\n    return false;\n  }\n  const blockHeight = items[items.length - 1].blockHeight;\n  return desc ? blockHeight - 1 : blockHeight + 1;\n};\n\nfunction mergeItems(iIndex, oldItems, newItems, desc) {\n  const itemMap = new Map();\n\n  const generateKey = (item) => ({\n    accountId: item.accountId,\n    blockHeight: item.blockHeight,\n  });\n\n  // Add old items to the map\n  oldItems.forEach((item) => {\n    const key = generateKey(item);\n    itemMap.set(key, item);\n  });\n\n  newItems.forEach((item) => {\n    const key = generateKey(item);\n    if (!itemMap.has(key)) {\n      itemMap.set(key, {\n        ...item,\n        index: iIndex,\n      });\n    }\n  });\n\n  // Convert the Map values to an array\n  let mergedItems = Array.from(itemMap.values());\n\n  // Sort items by blockHeight, ascending or descending based on the `desc` flag\n  mergedItems.sort((a, b) =>\n    desc ? b.blockHeight - a.blockHeight : a.blockHeight - b.blockHeight\n  );\n\n  return mergedItems;\n}\n\nconst jIndices = JSON.stringify(indices);\nif (jIndices !== state.jIndices) {\n  State.update({\n    jIndices,\n    feeds: indices.map(() => ({})),\n    items: [],\n    displayCount: initialRenderLimit,\n    cachedItems: {},\n  });\n}\n\nlet stateChanged = false;\nfor (let iIndex = 0; iIndex < indices.length; ++iIndex) {\n  const index = indices[iIndex];\n  const feed = state.feeds[iIndex];\n  let feedChanged = false;\n  index.options = index.options || {};\n  index.options.limit = Math.min(\n    Math.max(initialRenderLimit + addDisplayCount * 2, index.options.limit),\n    100\n  );\n  const desc = index.options.order === \"desc\";\n\n  const initialItems = Social.index(\n    index.action,\n    index.key,\n    index.options,\n    index.cacheOptions\n  );\n  if (initialItems === null) {\n    continue;\n  }\n\n  const jInitialItems = JSON.stringify(initialItems);\n  const nextFetchFrom = computeFetchFrom(\n    initialItems,\n    index.options.limit,\n    desc\n  );\n  if (feed.jInitialItems !== jInitialItems) {\n    feed.jInitialItems = jInitialItems;\n    feedChanged = true;\n    if (nextFetchFrom !== feed.initialNextFetchFrom) {\n      feed.fetchFrom = false;\n      feed.items = mergeItems(iIndex, [], initialItems, desc);\n      feed.initialNextFetchFrom = nextFetchFrom;\n      feed.nextFetchFrom = nextFetchFrom;\n    } else {\n      feed.items = mergeItems(iIndex, feed.items, initialItems, desc);\n    }\n  }\n\n  feed.usedCount = 0;\n\n  if (feedChanged) {\n    state.feeds[iIndex] = feed;\n    stateChanged = true;\n  }\n}\n\nlet itemsByRequiredIndex = [];\nlet commonUniqueIdentifiers = [];\n\n// If there are required indices, filter mergedItems to include only items that appear in all required feeds\nif (requiredIndices.length > 0) {\n  for (let iIndex = 0; iIndex < indices.length; ++iIndex) {\n    const index = indices[iIndex];\n    if (index.required) {\n      const feed = state.feeds[iIndex];\n      if (!feed.items) {\n        continue;\n      } else {\n        itemsByRequiredIndex.push(\n          feed.items.map((item) =>\n            JSON.stringify({\n              blockHeight: item.blockHeight,\n              accountId: item.accountId,\n            })\n          )\n        );\n      }\n    } else {\n      continue;\n    }\n  }\n  // Compute the intersection of uniqueIdentifiers across all required indices\n  commonUniqueIdentifiers =\n    itemsByRequiredIndex.length &&\n    itemsByRequiredIndex.reduce((a, b) => a.filter((c) => b.includes(c)));\n}\n\n// Construct merged feed and compute usage per feed.\n\nconst filteredItems = [];\nwhile (filteredItems.length < state.displayCount) {\n  let bestItem = null;\n  for (let iIndex = 0; iIndex < indices.length; ++iIndex) {\n    const index = indices[iIndex];\n    const feed = state.feeds[iIndex];\n    const desc = index.options.order === \"desc\";\n    if (!feed.items) {\n      continue;\n    }\n    const item = feed.items[feed.usedCount];\n    if (!item) {\n      continue;\n    }\n    if (\n      bestItem === null ||\n      (desc\n        ? item.blockHeight > bestItem.blockHeight\n        : item.blockHeight < bestItem.blockHeight)\n    ) {\n      bestItem = item;\n    }\n  }\n  if (!bestItem) {\n    break;\n  }\n  state.feeds[bestItem.index].usedCount++;\n  if (filter) {\n    if (filter.ignore) {\n      if (bestItem.accountId in filter.ignore) {\n        continue;\n      }\n    }\n  }\n\n  if (requiredIndices.length > 0) {\n    const uniqueIdentifier = JSON.stringify({\n      blockHeight: bestItem.blockHeight,\n      accountId: bestItem.accountId,\n    });\n\n    if (!commonUniqueIdentifiers.includes(uniqueIdentifier)) {\n      continue;\n    }\n  }\n  // remove duplicate posts\n  const existingItemIndex = filteredItems.findIndex(\n    (item) =>\n      item.blockHeight === bestItem.blockHeight &&\n      item.accountId === bestItem.accountId\n  );\n\n  if (existingItemIndex === -1) {\n    filteredItems.push(bestItem);\n  }\n}\n\n// Fetch new items for feeds that don't have enough items.\nfor (let iIndex = 0; iIndex < indices.length; ++iIndex) {\n  const index = indices[iIndex];\n  const feed = state.feeds[iIndex];\n  const desc = index.options.order === \"desc\";\n  let feedChanged = false;\n\n  if (\n    (feed.items.length || 0) - feed.usedCount < addDisplayCount * 2 &&\n    !feed.fetchFrom &&\n    feed.nextFetchFrom &&\n    feed.nextFetchFrom !== feed.fetchFrom\n  ) {\n    feed.fetchFrom = feed.nextFetchFrom;\n    feedChanged = true;\n  }\n\n  if (feed.fetchFrom) {\n    const limit = addDisplayCount;\n    const newItems = Social.index(\n      index.action,\n      index.key,\n      Object.assign({}, index.options, {\n        from: feed.fetchFrom,\n        subscribe: undefined,\n        limit,\n      })\n    );\n    if (newItems !== null) {\n      feed.items = mergeItems(iIndex, feed.items, newItems, desc);\n      feed.fetchFrom = false;\n      feed.nextFetchFrom = computeFetchFrom(newItems, limit, desc);\n      feedChanged = true;\n    }\n  }\n\n  if (feedChanged) {\n    state.feeds[iIndex] = feed;\n    stateChanged = true;\n  }\n}\n\nif (stateChanged) {\n  State.update();\n}\n\nconst makeMoreItems = () => {\n  State.update({\n    displayCount: state.displayCount + addDisplayCount,\n  });\n};\n\nconst loader = (\n  <div className=\"loader\" key={\"loader\"}>\n    <span\n      className=\"spinner-grow spinner-grow-sm me-1\"\n      role=\"status\"\n      aria-hidden=\"true\"\n    />\n    Loading ...\n  </div>\n);\n\nconst fetchMore =\n  props.manual &&\n  (state.feeds.some((f) => !!f.fetchFrom) &&\n  filteredItems.length < state.displayCount\n    ? loader\n    : state.displayCount < filteredItems.length && (\n        <div key={\"loader more\"}>\n          <a href=\"javascript:void\" onClick={(e) => makeMoreItems()}>\n            {props.loadMoreText ?? \"Load more...\"}\n          </a>\n        </div>\n      ));\n\nconst items = filteredItems ? filteredItems.slice(0, state.displayCount) : [];\nif (reverse) {\n  items.reverse();\n}\n\nconst renderedItems = items.map(cachedRenderItem);\nconst Layout = props.Layout;\n\nreturn props.manual ? (\n  <>\n    {reverse && fetchMore}\n    {renderedItems}\n    {!reverse && fetchMore}\n  </>\n) : (\n  <InfiniteScroll\n    pageStart={0}\n    loadMore={makeMoreItems}\n    hasMore={state.displayCount <= filteredItems.length}\n    loader={loader}\n  >\n    {Layout ? <Layout>{renderedItems}</Layout> : <>{renderedItems}</>}\n  </InfiniteScroll>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/devs.near/widget/PR.MergedIndexFeed", "fact_widget_deployments_id": "27782f4279f53837aaf02fb56a5cfcde", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 1}