{"tx_hash": "FNQBwaZ7t4DojmyYy42NQmhjwjeGg4sDbjfQqr3ASijj", "action_id_social": "2xiByiditSEpzCuvzA9tWtcBMEHyX3vGPzcH7ybzkpSS-0-widget", "block_id": 104392484, "block_timestamp": "2023-10-28T14:21:20.430Z", "signer_id": "ranjan-026.near", "widget_name": "probchain.builder", "source_code": "State.init({\n  clientId: props.clientId ? props.clientId : null,\n  clientName: props.clientName ? props.clientName : \"\",\n  quizName: props.name ? props.name : \"\",\n  coursework: props.coursework ? props.coursework : [],\n  blueprint: props.blueprint ? props.blueprint : [],\n  cMethod: props.abi ? props.abi : [],\n  rpcUrl: \"https://rpc.near.org/\",\n  archivalRpc: \"https://archival-rpc.mainnet.near.org\",\n  nearBlockRpc: \"https://api.nearblocks.io/\",\n  fName,\n  fAction: \"view\",\n  fLabel,\n  cMerr,\n  res,\n  cAerr,\n  messProccses: \"\",\n  totalProcess: 0,\n  endprocess: 1,\n});\n\nconst header = {\n  \"Content-Type\": \"application/json\",\n};\nconst saveClientConfig = {\n  clientId: state.clientId,\n  clientName: state.clientName,\n  clientContract: state.quizName,\n  abi: state.cMethod,\n};\nconst opGet = {\n  headers: header,\n  method: \"GET\",\n};\nconst asyncIntervals = [];\n\nconst runAsyncInterval = (cb, interval, intervalIndex) => {\n  cb();\n  if (asyncIntervals[intervalIndex].run) {\n    asyncIntervals[intervalIndex].id = setTimeout(\n      () => runAsyncInterval(cb, interval, intervalIndex),\n      interval\n    );\n  }\n};\nconst setAsyncInterval = (cb, interval) => {\n  if (cb && typeof cb === \"function\") {\n    const intervalIndex = asyncIntervals.length;\n    asyncIntervals.push({ run: true, id: id });\n    runAsyncInterval(cb, interval, intervalIndex);\n    return intervalIndex;\n  } else {\n    throw new Error(\"Callback must be a function\");\n  }\n};\nconst clearAsyncInterval = (intervalIndex) => {\n  if (asyncIntervals[intervalIndex].run) {\n    clearTimeout(asyncIntervals[intervalIndex].id);\n    asyncIntervals[intervalIndex].run = false;\n    State.update({\n      endprocess: state.endprocess++,\n    });\n  }\n};\nconst updatequizName = (e) => {\n  State.update({ quizName: data.toLowerCase() });\n};\n\nconst updateCoursework = (e) => {\n  State.update({ coursework: data });\n};\n\nconst updateBlueprint = (e) => {\n  State.update({ blueprint: data });\n};\n\nconst cFunc = (e, type) => {\n  const data = e.target.value;\n  if (type == \"name\") State.update({ fName: data });\n  if (type == \"label\") State.update({ fLabel: data });\n  if (type == \"action\") State.update({ fAction: data });\n  if (type == \"quiz\") State.update({ quizName: data.toLowerCase() });\n  if (type == \"coursework\") State.update({ coursework: data });\n  if (type == \"blueprint\") State.update({ blueprint: data });\n};\nconst cep = \"magicbuild.near\";\nconst onCreateArgs = (fName, fIndex) => {\n  State.update({ cAerr: { [fName]: null } });\n  const arg = {\n    name: \"\",\n    label: \"\",\n    button: \"\",\n    className: \"\",\n    classButton: \"\",\n    type_schema: {\n      type: \"string\",\n    },\n    value: \"\",\n  };\n  const abiMethod = state.cMethod;\n  abiMethod[fIndex].params.args.push(arg);\n  State.update({ cMethod: abiMethod });\n};\nconst cMLabel = (e, fIdx, type) => {\n  const value = e.target.value;\n  const a = state.cMethod;\n  if (type == \"method\") a[fIdx].label = value;\n  if (type == \"className\") a[fIdx].className = value;\n  if (type == \"classButton\") a[fIdx].classButton = value;\n  if (type == \"button\") a[fIdx].button = value;\n  if (type == \"gas\") a[fIdx].gas = parseInt(value) || 0;\n  if (type == \"deposit\") a[fIdx].deposit = parseInt(value) || 0;\n  if (type == \"remove\") a.splice(fIdx, 1);\n  console.log(\"a\", a);\n  State.update({ cMethod: a });\n};\nconst cAD = (e, fIdx, aIdx, type) => {\n  const value = e.target.value;\n  const a = state.cMethod;\n  if (type == \"name\") a[fIdx].params.args[aIdx].name = value;\n  if (type == \"label\") a[fIdx].params.args[aIdx].label = value;\n  if (type == \"className\") a[fIdx].params.args[aIdx].className = value;\n  if (type == \"type\") a[fIdx].params.args[aIdx].type_schema.type = value;\n  if (type == \"value\") {\n    if (a[fIdx].params.args[aIdx].type_schema.type == \"integer\") {\n      a[fIdx].params.args[aIdx].value = parseInt(value);\n    }\n    if (a[fIdx].params.args[aIdx].type_schema.type == \"array\") {\n      a[fIdx].params.args[aIdx].value = value.split(\"|\"); //check valid\n    }\n    if (a[fIdx].params.args[aIdx].type_schema.type == \"boolean\") {\n      a[fIdx].params.args[aIdx].value = Boolean(value);\n    }\n    if (a[fIdx].params.args[aIdx].type_schema.type == \"json\") {\n      a[fIdx].params.args[aIdx].value = JSON.parse(value); //check valid\n    }\n    if (a[fIdx].params.args[aIdx].type_schema.type == \"string\") {\n      a[fIdx].params.args[aIdx].value = value; //check valid\n    }\n    if (a[fIdx].params.args[aIdx].type_schema.type == \"enum\") {\n      a[fIdx].params.args[aIdx].value = value; //check valid\n    }\n    if (a[fIdx].params.args[aIdx].type_schema.type == \"$ref\") {\n      a[fIdx].params.args[aIdx].value = value; //check account valid\n    }\n  }\n  if (type == \"remove\") a[fIdx].params.args.splice(aIdx, 1);\n  State.update({ cMethod: a });\n};\nconst onCreateMethod = () => {\n  if (state.fName.length > 0) {\n    State.update({ cMerr: null });\n    const method = {\n      name: state.fName,\n      kind: state.fAction,\n      label: state.fLabel,\n      button: \"\",\n      className: \"\",\n      classButton: \"\",\n      export: true,\n      params: {\n        serialization_type: \"json\",\n        args: [],\n      },\n      deposit: 0,\n      gas: 30000000000000,\n    };\n    const abiMethod = state.cMethod;\n    const isExistFunction = false;\n    abiMethod.forEach((item) => {\n      if (item.name == state.fName) {\n        isExistFunction = true;\n      }\n    });\n    if (!isExistFunction) {\n      abiMethod.push(method);\n      State.update({ cMethod: abiMethod });\n    } else {\n      State.update({ cMerr: \"Method Exist!\" });\n    }\n  } else {\n    State.update({ cMerr: \"Please Input Method Name!\" });\n  }\n};\nconst getMethodFromSource = () => {\n  const res = fetch(state.rpcUrl, {\n    body: JSON.stringify({\n      method: \"POST\",\n      params: {\n        request_type: \"view_code\",\n        account_id: state.quizName,\n        finality: \"final\",\n      },\n      id: 154,\n      jsonrpc: \"2.0\",\n    }),\n    headers: header,\n    method: \"POST\",\n  });\n  State.update({ cMerr: null });\n  State.update({ totalProcess: 0 });\n  State.update({ endprocess: 1 });\n  let abiMethod = [];\n  State.update({ cMethod: [] });\n  const resb = res.body;\n  if (resb.result.code_base64) {\n    const data = Buffer(resb.result.code_base64, \"base64\").toString(\"ascii\");\n    const fist = data.indexOf(\"memory\u0002\");\n    let second =\n      data.indexOf(\"__data_end\") !== -1\n        ? data.indexOf(\"__data_end\")\n        : data.indexOf(\"\u0003P]\");\n    if (fist !== -1 && second !== -1) {\n      const functionsData = data\n        .substring(fist, second)\n        .replace(/[^\\w ]/g, \" \")\n        .split(\" \");\n      const filterFunction = [];\n      functionsData.forEach((item, index) => {\n        if (index > 0 && item.length > 1) {\n          if (!/^[A-Z]+(?:_[A-Z]+)*$/m.test(item) && !/^[0-9]*$/.test(string)) {\n            filterFunction.push(item);\n          }\n        }\n      });\n\n      filterFunction.forEach((item) => {\n        const res = fetch(\n          `${state.nearBlockRpc}v1/account/${state.quizName}/txns?method=${item}&order=desc&page=1&per_page=25`,\n          opGet\n        );\n        const method = {\n          name: item,\n          kind: \"view\",\n          export: true,\n          params: {\n            serialization_type: \"json\",\n            args: [],\n          },\n          deposit: 0,\n          gas: 30000000000000,\n        };\n        if (res.body.txns.length > 0) {\n          const isScs = false;\n          res.body.txns.forEach((item) => {\n            if (item.outcomes.status) {\n              isScs = true;\n            }\n          });\n          if (isScs) {\n            method.kind = \"call\";\n          }\n        }\n        abiMethod.push(method);\n      });\n      State.update({ cMethod: abiMethod });\n      abiMethod.forEach((item, index) => {\n        getArgsFromMethod(item.name, index);\n      });\n\n      State.update({ totalProcess: filterFunction.length });\n    } else {\n      State.update({ cMerr: \"Unable to detect Method!\" });\n    }\n  }\n};\nconst getArgsFromMethod = (fName, fIndex) => {\n  asyncFetch(\n    `${state.nearBlockRpc}v1/account/${state.quizName}/txns?method=${fName}&order=desc&page=1&per_page=1`,\n    opGet\n  )\n    .then((res) => {\n      const restxns = res.body.txns[0];\n      if (restxns.outcomes.status && restxns.logs.length > 0) {\n        const argsData = JSON.parse(\n          restxns.logs[0].replace(\"EVENT_JSON:\", \"\").replaceAll(\"\\\\\", \"\")\n        );\n\n        const args = argsData.data[0] || argsData;\n        const abiMethod = state.cMethod;\n\n        abiMethod[fIndex].params.args = [];\n        if (Object.keys(args).length > 0) {\n          Object.keys(args).forEach((item) => {\n            const arg = {\n              name: item,\n              type_schema: {\n                type:\n                  typeof args[item] == \"number\"\n                    ? \"integer\"\n                    : typeof args[item] == \"object\"\n                    ? \"json\"\n                    : typeof args[item],\n              },\n              value: \"\",\n            };\n            abiMethod[fIndex].kind = \"call\";\n            abiMethod[fIndex].params.args.push(arg);\n            State.update({ cMethod: abiMethod });\n          });\n        }\n        State.update({\n          endprocess: state.endprocess++,\n        });\n      } else {\n        let countLoop = 0;\n        const getArg = setAsyncInterval(() => {\n          const abiMethod = state.cMethod;\n          const argsArr = abiMethod[fIndex].params.args;\n          const argMap = argsArr.map(({ name, value }) => ({ [name]: value }));\n          const args = {};\n          argMap.forEach((item) => {\n            Object.assign(args, item);\n          });\n          asyncFetch(state.rpcUrl, {\n            body: JSON.stringify({\n              method: \"query\",\n              params: {\n                request_type: \"call_function\",\n                account_id: state.quizName,\n                method_name: fName,\n                args_base64: new Buffer.from(JSON.stringify(args)).toString(\n                  \"base64\"\n                ),\n                finality: \"final\",\n              },\n              id: 154,\n              jsonrpc: \"2.0\",\n            }),\n            headers: header,\n            method: \"POST\",\n          }).then((res) => {\n            const strErr = res.body.result.error;\n            if (strErr && strErr.includes(\"missing field\")) {\n              const argName = strErr.substring(\n                strErr.indexOf(\"`\") + 1,\n                strErr.lastIndexOf(\"`\")\n              );\n              const checkType = [\n                { value: \"\", type: \"string\" },\n                { value: 0, type: \"integer\" },\n                { value: [], type: \"array\" },\n                { value: true, type: \"boolean\" },\n                { value: {}, type: \"json\" },\n                { value: state.quizName, type: \"$ref\" },\n              ];\n              const isCheck = false;\n              checkType.forEach((typeItem) => {\n                if (isCheck == false) {\n                  asyncFetch(state.rpcUrl, {\n                    body: JSON.stringify({\n                      method: \"query\",\n                      params: {\n                        request_type: \"call_function\",\n                        account_id: state.quizName,\n                        method_name: fName,\n                        args_base64: new Buffer.from(\n                          JSON.stringify({\n                            [argName]: typeItem.value,\n                          })\n                        ).toString(\"base64\"),\n                        finality: \"final\",\n                      },\n                      id: 154,\n                      jsonrpc: \"2.0\",\n                    }),\n                    headers: header,\n                    method: \"POST\",\n                  }).then((res) => {\n                    const isExist = false;\n                    const uS = (argName, type, value) => {\n                      const arg = {\n                        name: argName,\n                        type_schema: {\n                          type: type,\n                        },\n                        value: type == \"enum\" ? value[0] : value,\n                      };\n                      if (type == \"enum\") {\n                        arg.enum = value;\n                      }\n                      abiMethod[fIndex].params.args.forEach((item) => {\n                        if (item.name == argName) {\n                          isExist = true;\n                        }\n                      });\n                      if (isExist == false) {\n                        abiMethod[fIndex].params.args.push(arg);\n                        State.update({ cMethod: abiMethod });\n                      }\n                      if (isCheck && isExist) {\n                        //  clearInterval(getArg);\n                      }\n                      isCheck = true;\n                    };\n                    if (res.body.result.result) {\n                      clearAsyncInterval(getArg);\n                    }\n                    const ftch = res.body.result.error;\n\n                    if (ftch) {\n                      if (ftch.includes(\"Option::unwrap()`\")) {\n                        uS(argName, typeItem.type, typeItem.value);\n                        abiMethod[fIndex].kind = \"call\";\n                        State.update({ cMethod: abiMethod });\n                        clearAsyncInterval(getArg);\n                      }\n                      if (ftch.includes(\"the account ID\")) {\n                        uS(argName, \"$ref\", state.quizName);\n                      }\n                      if (\n                        ftch.includes(\"invalid type: sequence, expected u64\")\n                      ) {\n                        uS(argName, \"number\", 300);\n                      }\n                      if (ftch.includes(\"invalid digit found\")) {\n                        uS(argName, \"string\", \"300\");\n                      }\n                      if (\n                        ftch.includes(\n                          \"invalid type: sequence, expected a string\"\n                        )\n                      ) {\n                        if (isExist) {\n                          uS(argName, \"string\", \"wrap.near\");\n                        } else {\n                          uS(argName, \"string\", \"30\");\n                        }\n                        // clearInterval(getArg);\n                      }\n                      if (\n                        ftch.includes(\n                          \"data did not match any variant of untagged enum\"\n                        )\n                      ) {\n                        uS(argName, typeItem.type, [\"300\", \"300\"]);\n                        clearAsyncInterval(getArg);\n                      }\n\n                      if (ftch.includes(\"not implemented\")) {\n                        uS(argName, typeItem.type, [\"300\", \"300\"]);\n                        // clearInterval(getArg);\n                      }\n                      if (ftch.includes(\"invalid token id\")) {\n                        uS(argName, \"$ref\", \"wrap.near\");\n                      }\n                      if (ftch.includes(\"integer from empty string\")) {\n                        uS(argName, typeItem.type, \"300\");\n                      }\n                      if (ftch.includes(\"unknown variant\")) {\n                        isCheck = true;\n                        const getEnum = ftch.match(/\\`(.*?)\\`/g);\n\n                        const enumList = [];\n                        getEnum.forEach((item, index) => {\n                          if (index !== 0) {\n                            enumList.push(item.replaceAll(\"`\", \"\"));\n                          }\n                        });\n                        uS(argName, \"enum\", enumList);\n                      }\n                      if (ftch.includes(\"missing field\")) {\n                        uS(argName, typeItem.type, typeItem.value);\n                      }\n\n                      if (ftch.includes(\"attached deposit\")) {\n                        uS(argName, typeItem.type, typeItem.value);\n                        abiMethod[fIndex].kind = \"call\";\n                        abiMethod[fIndex].deposit = parseInt(\n                          strErr.match(/\\d+/)[0]\n                        );\n                        State.update({ cMethod: abiMethod });\n                        clearAsyncInterval(getArg);\n                      }\n                    } else {\n                      uS(argName, typeItem.type, typeItem.value);\n                      clearAsyncInterval(getArg);\n                    }\n                  });\n                }\n              });\n            }\n            if (res.body.result.result) {\n              clearAsyncInterval(getArg);\n            }\n            if (strErr) {\n              if (strErr.includes(\"Invalid register\")) {\n                abiMethod[fIndex].kind = \"call\";\n                State.update({ cMethod: abiMethod });\n                clearAsyncInterval(getArg);\n              }\n              if (strErr.includes(\"not implemented\")) {\n                clearAsyncInterval(getArg);\n              }\n              if (strErr.includes(\"Option::unwrap()`\")) {\n                abiMethod[fIndex].kind = \"call\";\n                State.update({ cMethod: abiMethod });\n                clearAsyncInterval(getArg);\n              }\n              if (strErr.includes(\"been initialized\")) {\n                abiMethod[fIndex].kind = \"call\";\n                State.update({ cMethod: abiMethod });\n                clearAsyncInterval(getArg);\n              }\n              if (strErr.includes(\"No token\")) {\n                abiMethod[fIndex].kind = \"call\";\n                State.update({ cMethod: abiMethod });\n                clearAsyncInterval(getArg);\n              }\n              if (strErr.includes(\"MethodNotFound\")) {\n                clearAsyncInterval(getArg);\n              }\n              if (\n                strErr.includes(\"storage_write\") ||\n                strErr.includes(\"predecessor_account_id\")\n              ) {\n                abiMethod[fIndex].kind = \"call\";\n                State.update({ cMethod: abiMethod });\n                clearAsyncInterval(getArg);\n              }\n              if (strErr.includes(\"attached deposit\")) {\n                abiMethod[fIndex].kind = \"call\";\n                abiMethod[fIndex].deposit = parseInt(strErr.match(/\\d+/)[0]);\n                State.update({ cMethod: abiMethod });\n                clearAsyncInterval(getArg);\n              }\n\n              if (strErr.includes(\"assertion failed: `(left == right)\")) {\n                abiMethod[fIndex].kind = \"call\";\n                State.update({ cMethod: abiMethod });\n                clearAsyncInterval(getArg);\n              }\n              if (strErr.includes(\"valid type: sequence, expected u64\")) {\n                abiMethod[fIndex].params.arg = 0;\n                State.update({ cMethod: abiMethod });\n                clearAsyncInterval(getArg);\n              }\n            }\n          });\n          countLoop++;\n          if (countLoop == 20) {\n            clearAsyncInterval(getArg);\n          }\n          State.update({\n            messProccses: `Scanning Method : \"${fName}\"`,\n          });\n        }, 1000);\n      }\n    })\n    .catch((err) => {\n      if (err) {\n        State.update({\n          endprocess: state.endprocess++,\n        });\n      }\n    });\n};\nconst onBtnClickCall = (fName, action, fIndex) => {\n  const abiMethod = state.cMethod;\n  const argMap = abiMethod[fIndex].params.args.map(({ name, value }) => ({\n    [name]: value,\n  }));\n  const args = {};\n  argMap.forEach((item) => {\n    Object.assign(args, item);\n  });\n  if (action === \"view\") {\n    asyncFetch(state.rpcUrl, {\n      body: JSON.stringify({\n        method: \"query\",\n        params: {\n          request_type: \"call_function\",\n          account_id: state.quizName,\n          method_name: abiMethod[fIndex].name,\n          args_base64: new Buffer.from(JSON.stringify(args)).toString(\"base64\"),\n          finality: \"final\",\n        },\n        id: 154,\n        jsonrpc: \"2.0\",\n      }),\n      headers: header,\n      method: \"POST\",\n    }).then((res) => {\n      const resb = res.body.result;\n      if (resb.result) {\n        const result = new Buffer.from(resb.result).toString();\n        State.update({\n          res: {\n            [fName]: { value: result, error: false },\n          },\n        });\n      }\n      if (resb.error) {\n        const error = resb.error;\n        State.update({\n          res: {\n            [fName]: { value: error, error: true },\n          },\n        });\n      }\n    });\n  }\n  if (action === \"call\") {\n    if (\n      abiMethod[fIndex].deposit == 0 &&\n      abiMethod[fIndex].gas == 30000000000000\n    ) {\n      Near.call(state.quizName, abiMethod[fIndex].name, args);\n    }\n    if (\n      abiMethod[fIndex].deposit > 0 ||\n      abiMethod[fIndex].gas > 30000000000000\n    ) {\n      Near.call(\n        state.quizName,\n        abiMethod[fIndex].name,\n        args,\n        abiMethod[fIndex].gas,\n        abiMethod[fIndex].deposit\n      );\n    }\n  }\n};\n\nconst QuizContainer = styled.div`\n  width: 100%;\n  max-width: 1100px;\n  min-height: 100vh;\n  margin: 0 auto;\n  padding: 0 20px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n`;\n\nreturn (\n  <>\n    <div class=\"container border rounded p-5 border border-dark\">\n      <h3 class=\"text-center mb-3\">Welcome to Probchain Quiz</h3>\n      <h5 class=\"mb-4\">Quiz Details</h5>\n      <div class=\"mb-3\">\n        <div class=\"form-group mt-3\">\n          <h6 class=\"mb-2\">Name</h6>\n          <input\n            class=\"form-control\"\n            value={state.quizName}\n            placeholder=\"Quiz Names\"\n            onChange={(e) => cFunc(e, \"name\")}\n          />\n          <br />\n          <h6 class=\"mb-2\">Coursework:</h6>\n          <input\n            type=\"file\"\n            class=\"form-control\"\n            value={state.coursework}\n            placeholder=\"Upload Coursework\"\n            onChange={(e) => cFunc(e, \"coursework\")}\n          />\n          <br />\n          <h6 class=\"mb-2\">Blueprint:</h6>\n          <input\n            type=\"file\"\n            class=\"form-control\"\n            value={state.blueprint}\n            placeholder=\"Upload Blueprint\"\n            onChange={(e) => cFunc(e, \"blueprint\")}\n          />\n          <br />\n          <label for=\"difficulty\">Difficulty:</label>\n          <select id=\"difficulty\" class=\"form-control\" name=\"difficulty\">\n            <option value=\"easy\">Easy</option>\n            <option value=\"medium\">Medium</option>\n            <option value=\"hard\">Hard</option>\n          </select>\n          <br />\n          <label for=\"trueFalse\">Number of True/False Questions:</label>\n          <input\n            type=\"number\"\n            class=\"form-control\"\n            id=\"trueFalse\"\n            name=\"trueFalse\"\n            min=\"0\"\n          />\n          <br />\n          <label for=\"mcqSingleSelect\">\n            Number of MCQ (Single Select) Questions:\n          </label>\n          <input\n            type=\"number\"\n            class=\"form-control\"\n            id=\"mcqSingleSelect\"\n            name=\"mcqSingleSelect\"\n            min=\"0\"\n          />\n          <br />\n          <label for=\"mcqMultiSelect\">\n            Number of MCQ (Multi Select) Questions:\n          </label>\n          <input\n            type=\"number\"\n            class=\"form-control\"\n            id=\"mcqMultiSelect\"\n            name=\"mcqMultiSelect\"\n            min=\"0\"\n          />\n          <br />\n          <button type=\"submit\">Start Quiz</button>\n        </div>\n      </div>\n    </div>\n  </>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/ranjan-026.near/widget/probchain.builder", "fact_widget_deployments_id": "4e0554627d732385fee1d4d64b98b636", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 0}