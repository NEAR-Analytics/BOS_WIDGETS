{"tx_hash": "CkebR6eh1kxvQro84dqDCmBnLLue2zPqrNAhqfX6H7dy", "action_id_social": "ASV9id4rYStdGDVe8RC4G9xtRyAfraLhWNc1qSL8VrwN-0-widget", "block_id": 107298873, "block_timestamp": "2023-12-06T17:58:54.435Z", "signer_id": "hack.near", "widget_name": "CreateQuest.index", "source_code": "// -- Read and process types from SocialDB + helper functions\n\nconst isPrimitiveType = (type) =>\n    [\"string\", \"number\", \"boolean\"].includes(type);\n\nconst isComplexType = (type) =>\n    Array.isArray(type)\n        ? \"typesArray\"\n        : type === \"array\"\n        ? \"array\"\n        : typeof type === \"object\"\n        ? \"object\"\n        : typeof type === \"string\" && !isPrimitiveType(type)\n        ? \"custom\"\n        : null;\n\nconst rawTypes = Social.get(\"astraplusplus.ndctools.near/type/*\", \"final\");\nif (rawTypes === null) return null;\n\nconst types = {};\n// It finds custom types in the type definitions and fetches them from SocialDB.\nfunction getCustomTypes(type, depth) {\n    depth = depth || 0;\n    if (depth > 10) {\n        throw {\n            message: `Maximum type depth exceeded, please check your type definitions.`,\n            depth,\n            current: type,\n            types\n        };\n    }\n\n    type.properties.forEach((prop) => {\n        (Array.isArray(prop.type) ? prop.type : [prop.type]).forEach((type) => {\n            if (isComplexType(type) === \"custom\" && !types[type]) {\n                const rawType = Social.get(`${type}`, \"final\");\n                if (rawType) {\n                    types[type] = JSON.parse(rawType);\n                    getCustomTypes(types[type], depth + 1);\n                }\n            }\n        });\n    });\n}\n\nObject.keys(rawTypes).forEach((key) => {\n    const type = JSON.parse(rawTypes[key]);\n    types[\"astraplusplus.ndctools.near/type/\" + key] = type;\n    getCustomTypes(type);\n});\n\nconst PRIMITIVE_VALIDATIONS = {\n    string: (value, { min, max, pattern }) => {\n        if (typeof value !== \"string\")\n            return `Expected a string, got ${typeof value}.`;\n\n        if (min && value.length < min)\n            return `Must be at least ${min} characters long.`;\n\n        if (max && value.length > max)\n            return `Must be at most ${max} characters long.`;\n        // waiting for regexp\n        // if (pattern && !value.match(pattern))\n        //   return `The value \"${value}\" does not match expected pattern: ${pattern}`;\n    },\n    number: (value, { min, max }) => {\n        if (typeof value !== \"number\")\n            return `Expected a number, got ${typeof value}.`;\n\n        if (min && value < min) return `Must be at least ${min}.`;\n\n        if (max && value > max) return `Must be at most ${max}.`;\n    },\n    boolean: (value) => {\n        if (typeof value !== \"boolean\")\n            return `Expected a boolean, got ${typeof value}.`;\n    }\n};\n\nfunction validatePrimitiveType(type, value, constraints) {\n    if (!isPrimitiveType(type))\n        throw {\n            message: `Unknown primitive type: ${type}`,\n            type,\n            value\n        };\n\n    return PRIMITIVE_VALIDATIONS[type](value, constraints);\n}\n\nfunction validateType(type, value, parent) {\n    if (value === undefined || value === \"\" || value === null) {\n        if (parent.required) {\n            return `This field is required but missing.`;\n        }\n        return;\n    }\n\n    if (isPrimitiveType(type))\n        return validatePrimitiveType(type, value, parent[type].validation);\n\n    if (isComplexType(type) === \"typesArray\") {\n        const errors = [];\n        for (const subType of type) {\n            const error = validateType(subType, value, parent[subType]);\n            if (!error) return; // Stop if a valid type is found\n            errors.push(error);\n        }\n        if (errors.length === type.length) {\n            // only return the deepest error\n            for (const error of errors) {\n                if (typeof error === \"object\") return error;\n            }\n            return errors[errors.length - 1];\n        }\n    }\n\n    if (isComplexType(type) === \"array\") {\n        if (!Array.isArray(value)) {\n            return `Expected an array, got ${typeof value}.`;\n        }\n\n        if (\n            parent[\"array\"].validation.min &&\n            value.length < parent[\"array\"].validation.min\n        ) {\n            return `Must have at least ${parent[\"array\"].validation.min} items.`;\n        }\n\n        if (\n            parent[\"array\"].validation.max &&\n            value.length > parent[\"array\"].validation.max\n        ) {\n            return `Must have at most ${parent[\"array\"].validation.max} items.`;\n        }\n\n        for (const item of value) {\n            const error = validateType(\n                parent[\"array\"].type,\n                item,\n                parent[\"array\"]\n            );\n            if (error)\n                return {\n                    [value.indexOf(item)]: error\n                };\n        }\n    }\n\n    if (isComplexType(type) === \"object\") {\n        if (typeof value !== \"object\" || Array.isArray(value)) {\n            return `Expected an object, got ${typeof value}.`;\n        }\n\n        // Validate properties of the object\n        for (const property of type.properties) {\n            const propName = property.name;\n            const propType = property.type;\n            const propValue = value[propName];\n\n            if (property.required && propValue === undefined) {\n                return `Property ${propName} is required but missing.`;\n            }\n\n            if (propValue !== undefined) {\n                const error = validateType(propType, propValue, property);\n                if (error)\n                    return {\n                        [propName]: error\n                    };\n            }\n        }\n    }\n\n    if (isComplexType(type) === \"custom\") {\n        return validateType(types[type], value);\n    }\n}\n\nconst typeToEmptyData = (type) => {\n    if (isPrimitiveType(type)) {\n        switch (type) {\n            case \"string\":\n                return \"\";\n            case \"number\":\n                return null;\n            case \"boolean\":\n                return null;\n        }\n    }\n    if (isComplexType(type) === \"array\") {\n        return [];\n    }\n    if (isComplexType(type) === \"typesArray\") {\n        return typeToEmptyData(type[0]);\n    }\n    if (isComplexType(type) === \"object\") {\n        const obj = {};\n\n        type.properties.forEach((prop) => {\n            const propType =\n                isComplexType(prop.type) === \"typesArray\"\n                    ? prop.type[0]\n                    : prop.type;\n\n            if (isPrimitiveType(propType)) {\n                obj[prop.name] = typeToEmptyData(propType);\n            } else if (isComplexType(propType) === \"array\") {\n                obj[prop.name] = typeToEmptyData(propType);\n            } else if (isComplexType(propType) === \"object\") {\n                obj[prop.name] = typeToEmptyData(prop[propType]);\n            } else if (isComplexType(propType) === \"custom\") {\n                obj[prop.name] = typeToEmptyData(types[propType]);\n            }\n        });\n\n        return obj;\n    }\n    if (isComplexType(type) === \"custom\") {\n        return typeToEmptyData(types[type]);\n    }\n};\n\nreturn (\n    <Widget\n        src=\"astraplusplus.ndctools.near/widget/CreateDAO.form\"\n        props={{\n            validateType,\n            typeToEmptyData,\n            types\n        }}\n    />\n);\n", "metadata": {"downstream": "hack.near/widget/CreateQuest.index", "upstream": "astraplusplus.ndctools.near/widget/CreateDAO.index"}, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/hack.near/widget/CreateQuest.index", "fact_widget_deployments_id": "d70e72f0befa2ee4ee3091ea35e7fb40", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 0}