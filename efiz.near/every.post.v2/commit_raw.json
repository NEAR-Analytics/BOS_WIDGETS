{"tx_hash": "HhPBS8eK3sLunvt6tz2WYebTWD66eGyVpSSdxwt4kduo", "action_id_social": "BKP99cFXRubVq3NtoM9h1fimESaf26Q9Wda4waAgJLAp-0-widget", "block_id": 95873653, "block_timestamp": "2023-07-06T23:47:01.731Z", "signer_id": "efiz.near", "widget_name": "every.post.v2", "source_code": "const sources = props.sources;\nconst typeWhitelist = props.typeWhitelist;\nconst hashtagWhitelist = props.hashtagWhitelist;\nconst accountWhitelist = props.accountWhitelist;\nconst accountBlacklist = props.accountBlacklist;\nconst feedOrder = props.feedOrder || \"desc\";\nconst disableCaching = props.disableCaching || false;\n\nconst { Test } = VM.require(\"efiz.near/widget/test.template\");\n\nif (hashtagBlacklist.length) {\n  hashtagBlacklist = hashtagBlacklist.map((it) => it.toLowerCase());\n}\n\nlet index = [];\nconst options = {\n  limit: 10,\n  order: feedOrder,\n  accountId: accountWhitelist.length ? accountWhitelist : undefined,\n};\n// posts indexed via a hashtag are saved differently\n// than posts indexed via a domain/action\nif (hashtagWhitelist.length) {\n  // get all posts saved under the hashtags\n  // and we will filter domains and keys later\n  index = hashtagWhitelist.map((it) => ({\n    action: \"hashtag\",\n    key: it.toLowerCase(),\n    options,\n  }));\n} else {\n  // else, get all posts saved under the domain/action key pairs\n  index = sources?.map((it) => ({\n    action: it.domain,\n    key: it.key,\n    options,\n  }));\n}\n\nconst Post = styled.div`\n  border-bottom: 1px solid #eceef0;\n  padding: 24px 0 12px;\n\n  @media (max-width: 1200px) {\n    padding: 12px 0 0;\n  }\n`;\n\nfunction extractPath(a) {\n  let path;\n  if (hashtagWhitelist.length) {\n    // May want to revisit this again\n    // The path doesn't represent where this came from\n    // For example, a comment is indexed under the parent post's key\n    // but is saved under a regular post/comment path\n    path = a.value.path;\n  } else {\n    if (a.value.type === \"md\") {\n      path = `${a.accountId}/${a.action}/${a.key}`;\n    } else {\n      path = a.value.path;\n    }\n  }\n  return path;\n}\n\nconst extractHashtags = (text) => {\n  const hashtagRegex = /#(\\w+)/gi;\n  hashtagRegex.lastIndex = 0;\n  const hashtags = new Set();\n  for (const match of text.matchAll(hashtagRegex)) {\n    if (\n      !/[\\w`]/.test(match.input.charAt(match.index - 1)) &&\n      !/[/\\w`]/.test(match.input.charAt(match.index + match[0].length))\n    ) {\n      hashtags.add(match[1].toLowerCase());\n    }\n  }\n  return [...hashtags];\n};\n\nconst renderItem = (a) => {\n  // Filter out post if account is in blacklist\n  if (accountBlacklist.length && accountBlacklist.includes(a.accountId)) {\n    return <></>;\n  }\n\n  const path = extractPath(a);\n  const blockHeight = a.blockHeight;\n  // Filter out post if type is not in whitelist\n  if (hashtagWhitelist.length) {\n    // although you can't really do this for hashtags... cuz the type is always \"social\"\n    // so we're just gonna return for now...\n    return <Test path={path} blockHeight={blockHeight} />;\n\n    // It would be great if I could pass the necessary\n  } else {\n    if (typeWhitelist.includes(a.value.type)) {\n      return <Test path={path} blockHeight={blockHeight} />;\n    } else {\n      return <></>;\n    }\n  }\n};\n\nreturn (\n  <Widget\n    src=\"efiz.near/widget/MergedIndexFeed\"\n    props={{ index, renderItem, disableCaching }}\n  />\n);\n", "metadata": {"platform": "Components.gg"}, "branch": {"draft": null}, "widget_modules_used": null, "widget_url": "https://near.social/#/efiz.near/widget/every.post.v2", "fact_widget_deployments_id": "60cc2c847f2c445175c012dc9f211c35", "inserted_timestamp": "2000-01-01T00:00:00.000Z", "modified_timestamp": "2000-01-01T00:00:00.000Z", "__row_index": 0}