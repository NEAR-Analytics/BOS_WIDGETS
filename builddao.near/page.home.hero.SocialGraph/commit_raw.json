{"tx_hash": "Z32Sv46hT4VsudVzovYVy29ZzQMXnXJWCQN3D4Y5TbU", "action_id_social": "2k1jzsAuWKUMmypyvQREhYZ8tbSdEYgdNg5z2zgd3HhJ-0-widget", "block_id": 121158209, "block_timestamp": "2024-06-14T16:44:44.261Z", "signer_id": "builddao.near", "widget_name": "page.home.hero.SocialGraph", "source_code": "const accountId = props.accountId ?? context.accountId ?? \"buildcommons.near\";\nconst GraphContainer = styled.div`\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  width: 100%;\n  height: ${(props) => props.height || \"325px\"};\n  overflow: hidden;\n  iframe {\n    overflow: hidden;\n    transform: scale(2.1);\n  }\n`;\nconst ProfileContainer = styled.div`\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  flex-direction: row;\n  gap: 19px;\n  width: 100%;\n`;\nconst [accountIds, setAccountIds] = useState(\n  props.accountIds || [\n    accountId,\n    \"every.near\",\n    \"hack.near\",\n    \"buildcommons.near\",\n  ]\n);\nconst graphId = props.graphId ?? \"commons\";\nconst generatePaths = () => {\n  return (\n    props.paths ??\n    accountIds.map((accountId) => {\n      return `${accountId}/graph/${graphId}`;\n    })\n  );\n};\nconst paths = generatePaths();\nconst data = Social.getr(paths, \"final\");\nconst [nodesState, setNodesState] = useState(null);\nconst [focus, setFocus] = useState(null);\nconst debug = false;\nuseEffect(() => {\n  setNodesState(data);\n}, [data]);\nif (!nodesState) {\n  return <GraphContainer></GraphContainer>;\n}\nconst [selectedAccountId, setSelectedAccountId] = useState(accountId);\nconst [message, setMessage] = useState(null);\nuseEffect(() => {\n  if (!nodesState) {\n    return;\n  }\n  const nodes = {};\n  const edges = [];\n  const createNodesAndEdges = (accountId, graphData) => {\n    if (!(accountId in nodes)) {\n      nodes[accountId] = {\n        id: accountId,\n        size: 139,\n      };\n    }\n    Object.values(graphData).forEach((links) => {\n      console.log(graphData);\n      Object.keys(links).forEach((memberId) => {\n        if (!(memberId in nodes)) {\n          nodes[memberId] = {\n            id: memberId,\n            size: 139,\n          };\n        }\n        edges.push({\n          source: accountId,\n          target: memberId,\n          value: 1,\n        });\n      });\n    });\n  };\n  if (accountIds.length === 1) {\n    const accountId = accountIds[0];\n    createNodesAndEdges(accountId, { [graphId]: nodesState });\n  } else if (accountIds.length > 1) {\n    Object.entries(nodesState).forEach(([accountId, graphData]) => {\n      createNodesAndEdges(accountId, graphData.graph);\n    });\n  }\n  console.log(\"nodes\", nodes);\n  console.log(\"edges\", edges);\n  setMessage({\n    nodes: Object.values(nodes),\n    edges,\n  });\n}, [nodesState, accountIds]);\nuseEffect(() => {\n  if (selectedAccountId) {\n    if (accountIds.includes(selectedAccountId)) {\n      setAccountIds(accountIds.filter((it) => it !== selectedAccountId));\n    } else {\n      setAccountIds([...accountIds, selectedAccountId]);\n    }\n  }\n}, [selectedAccountId]);\nconst commons = Social.getr(`${accountId}/graph/commons`);\nconst graphEdge = Social.keys(\n  `${context.accountId}/graph/${graphId}/${accountId}`,\n  undefined,\n  {\n    values_only: true,\n  }\n);\nconst inverseEdge = Social.keys(\n  `${accountId}/graph/${graphId}/${context.accountId}`,\n  undefined,\n  {\n    values_only: true,\n  }\n);\nconst loading = graphEdge === null || inverseEdge === null;\nconst attested = graphEdge && Object.keys(graphEdge).length;\nconst inverse = inverseEdge && Object.keys(inverseEdge).length;\nconst type = attested ? \"undo\" : graphId;\nconst attestation = props.attestation ?? {\n  graph: { [graphId]: { [accountId]: attested ? null : \"\" } },\n};\nconst attest = () => {\n  Social.set(data);\n};\nlet height = props.height || 325;\nconst code = `\n<!DOCTYPE html>\n<meta charset=\"utf-8\">\n<!-- Load d3.js -->\n<script src=\"https://d3js.org/d3.v6.js\"></script>\n<div class=\"container\">\n  <svg id=\"graph\" width=\"100%\" height=\"auto\" viewBox=\"0 0 650 325\" preserveAspectRatio=\"xMidYMid meet\" style=\"display: block; margin: auto;\">\n</div>\n<style>\n    .container {\n        display: flex;\n        justify-content: center;\n        align-items: center;\n        height: 95vh;\n        width: 100%;\n    }\n    #graph {\n        background: #1e1e1e;\n    }\n</style>\n<script>\nconst run = (data) => {\n  const width = 650;\n  const height = \\`${height}\\`;\n  let dragIsOn = false;\n  // The force simulation mutates links and nodes, so create a copy\n  // so that re-evaluating this cell produces the same result.\n  const links = data.edges.map(d => ({...d}));\n  const nodes = data.nodes.map(d => ({...d}));\n  // Create a simulation with several forces.\n  const simulation = d3.forceSimulation(nodes)\n      .force(\"link\", d3.forceLink(links).id(d => d.id))\n      .force(\"charge\", d3.forceManyBody().strength(-500))\n      .force(\"collide\", d3.forceCollide().radius(d => Math.sqrt(d.size) ))\n      .force(\"center\", d3.forceCenter(width / 2, height / 2))\n      .on(\"tick\", ticked);\n  simulation.force(\"collide\")\n        .strength(.7)\n        .radius(d => Math.sqrt(d.size))\n        .iterations(1);\n  // Create the SVG container.\n  const svg = d3.select(\"#graph\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, height])\n      .attr(\"style\", \"max-width: 100%; height: auto;\");\n  // Add a line for each link, and a circle for each node.\n  const link = svg.append(\"g\")\n      .attr(\"stroke\", \"#999\")\n      .attr(\"stroke-opacity\", 0.6)\n    .selectAll()\n    .data(links)\n    .join(\"line\")\n      .attr(\"stroke-width\", 1);\nconst node = svg.append(\"g\")\n  .selectAll(\"g\")\n  .data(nodes)\n  .enter()\n  .append(\"g\");\n  node\n    .append(\"image\")\n    .attr(\"xlink:href\", (d) => \\`https://i.near.social/magic/thumbnail/https://near.social/magic/img/account/\\${d.id}\\`) // Set the image URL based on your data\n    .attr(\"x\", (d) => -Math.sqrt(d.size) - 5)\n    .attr(\"y\", (d) => -Math.sqrt(d.size) - 5)\n    .attr(\"clip-path\", d => \\`circle(\\${Math.sqrt(d.size) + 5}px at \\${Math.sqrt(d.size) + 5} \\${Math.sqrt(d.size) + 5})\\`)\n    .attr(\"width\", (d) => 2 * Math.sqrt(d.size) + 10);\n  node\n    .append(\"circle\")\n    .attr(\"r\", d => Math.sqrt(d.size) + 5)\n    .attr(\"fill\", \"none\");\n  node.append(\"title\")\n      .text(d => d.id);\n  // Add a drag behavior.\n  node.call(d3.drag()\n        .on(\"start\", dragstarted)\n        .on(\"drag\", dragged)\n        .on(\"end\", dragended));\n  node.on(\"mouseover\", handleMouseOver)\n     .on(\"mouseout\", handleMouseOut)\n     .on(\"click\", handleMouseClick);\n  function handleMouseClick(e) {\n    const d = e.target.__data__;\n    window.top.postMessage({ handler: \"click\", data:  d.id }, \"*\");\n  }\n  function handleMouseOver(d) {\n    d = d.target.__data__;\n    // Highlight connected edges\n    link.attr(\"stroke-opacity\", e => (e.source === d || e.target === d) ? 1 : 0.1);\n    // Highlight connected nodes\n    node.attr(\"opacity\", function (n) {\n        return n === d || isConnected(d, n) ? 1: 0.3;\n    });\n    window.top.postMessage({ handler: \"mouseover\", data:  d.id }, \"*\");\n}\nfunction handleMouseOut() {\n  if (dragIsOn) {\n    return;\n  }\n    // Reset edge and node styles\n    link\n      .attr(\"stroke-opacity\", 0.6);\n    node.attr(\"opacity\", 1);\n    window.top.postMessage({ handler: \"mouseout\", data:  \"out\" }, \"*\");\n}\nfunction isConnected(a, b) {\n    // Check if two nodes are connected\n    return links.some(function (link) {\n        return (link.source === a && link.target === b) || (link.source === b && link.target === a);\n    });\n}\n  // Set the position attributes of links and nodes each time the simulation ticks.\n  function ticked() {\n    link\n        .attr(\"x1\", d => d.source.x)\n        .attr(\"y1\", d => d.source.y)\n        .attr(\"x2\", d => d.target.x)\n        .attr(\"y2\", d => d.target.y);\n    node.attr(\"transform\", d => \\`translate(\\${d.x}, \\${d.y})\\`)\n  }\n  // Reheat the simulation when drag starts, and fix the subject position.\n  function dragstarted(event) {\n    dragIsOn = true;\n    if (!event.active) simulation.alphaTarget(0.3).restart();\n    event.subject.fx = event.subject.x;\n    event.subject.fy = event.subject.y;\n  }\n  // Update the subject (dragged node) position during drag.\n  function dragged(event) {\n    event.subject.fx = event.x;\n    event.subject.fy = event.y;\n  }\n  // Restore the target alpha so the simulation cools after dragging ends.\n  // Unfix the subject position now that it\u2019s no longer being dragged.\n  function dragended(event) {\n    if (!event.active) simulation.alphaTarget(0);\n    event.subject.fx = null;\n    event.subject.fy = null;\n    dragIsOn = false;\n    handleMouseOut();\n  }\n  // When this cell is re-run, stop the previous simulation. (This doesn\u2019t\n  // really matter since the target alpha is zero and the simulation will\n  // stop naturally, but it\u2019s a good practice.)\n  // invalidation.then(() => simulation.stop());\n  return simulation;\n};\nlet simulation = null;\nwindow.addEventListener(\"message\", (event) => {\n  if (simulation) {\n    simulation.stop();\n    d3.select(\"#graph\").selectAll(\"*\").remove();\n  }\n  if (event.data) {\n    simulation = run(event.data);\n  }\n});\n</script>\n`;\nconst [onMessage] = useState(() => {\n  return (data) => {\n    if (data) {\n      switch (data.handler) {\n        case \"click\":\n          setSelectedAccountId(data.data);\n          break;\n      }\n    }\n  };\n});\nreturn (\n  <>\n    <GraphContainer height={height}>\n      <iframe\n        className=\"w-100 h-100\"\n        style={{\n          display: \"flex\",\n          justifyContent: \"center\",\n          alignItems: \"center\",\n          minHeight: \"325px\",\n          maxWidth: \"888px\",\n          width: \"100%\",\n        }}\n        srcDoc={code}\n        message={message}\n        onMessage={onMessage}\n      />\n    </GraphContainer>\n    {/* <ProfileContainer>\n      {commons ? (\n        <Widget\n          src=\"hack.near/widget/profile.create\"\n          props={{ accountId: selectedAccountId ?? accountId }}\n        />\n      ) : (\n        <h5 style={{ fontFamily: \"Courier\" }} className=\"m-1\">\n          JOIN\n        </h5>\n      )}\n      <Widget\n        src=\"hack.near/widget/attest\"\n        props={{ accountId: selectedAccountId ?? accountId }}\n      />\n    </ProfileContainer> */}\n  </>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/builddao.near/widget/page.home.hero.SocialGraph", "fact_widget_deployments_id": "16626093ab83766ebc4c05a2a0d77746", "inserted_timestamp": "2024-06-14T17:55:46.860Z", "modified_timestamp": "2024-06-14T17:55:46.860Z", "__row_index": 0}