{"tx_hash": "7M4zsSA9ioXH76YDHoqCGWcPGkcHvsVqf6h4xg48hSu2", "action_id_social": "6RcXV2g66vChbmxnotgfTTS4iV536aGBfGnKsgAhmT9t-0-widget", "block_id": 126407182, "block_timestamp": "2024-08-23T19:26:04.160Z", "signer_id": "treasury-devdao.near", "widget_name": "lib.common", "source_code": "const treasuryDaoID = \"testing-astradao.sputnik-dao.near\";\nfunction getTransferApproversAndThreshold() {\n  const daoPolicy = Near.view(treasuryDaoID, \"get_policy\", {});\n  const groupWithTransferPermission = (daoPolicy.roles ?? []).filter((role) => {\n    const transferPermissions = [\n      \"*:*\",\n      \"transfer:*\",\n      \"transfer:VoteApprove\",\n      \"transfer:VoteReject\",\n      \"transfer:VoteRemove\",\n      \"*:VoteApprove\",\n      \"*:VoteReject\",\n      \"*:VoteRemove\",\n    ];\n    return (role?.permissions ?? []).some((i) =>\n      transferPermissions.includes(i)\n    );\n  });\n  let approversGroup = [];\n  let ratios = [];\n  groupWithTransferPermission.map((i) => {\n    approversGroup = approversGroup.concat(i.kind.Group ?? []);\n    if (i.vote_policy[\"transfer\"].weight_kind === \"RoleWeight\") {\n      ratios = ratios.concat(i.vote_policy[\"transfer\"].threshold);\n      ratios = ratios.concat(i.vote_policy[\"transfer\"].threshold);\n    }\n  });\n  let numerator = 0;\n  let denominator = 0;\n  if (ratios.length > 0) {\n    ratios.forEach((value, index) => {\n      if (index == 0 || index % 2 === 0) {\n        // Even index -> numerator\n        numerator += value;\n      } else {\n        // Odd index -> denominator\n        denominator += value;\n      }\n    });\n  } else {\n    numerator = 1;\n    denominator = 2;\n  }\n  return {\n    approverAccounts: Array.from(new Set(approversGroup)),\n    threshold: numerator / denominator,\n  };\n}\nfunction getPolicyApproverGroup() {\n  const daoPolicy = Near.view(treasuryDaoID, \"get_policy\", {});\n  const groupWithPermission = (daoPolicy.roles ?? []).filter((role) => {\n    const policyPermissions = [\n      \"*:*\",\n      \"policy:AddProposal\",\n      \"policy:*\",\n      \"policy:VoteApprove\",\n      \"policy:VoteReject\",\n      \"policy:VoteRemove\",\n      \"*:VoteApprove\",\n      \"*:VoteReject\",\n      \"*:VoteRemove\",\n    ];\n    return (role?.permissions ?? []).some((i) => policyPermissions.includes(i));\n  });\n  let approversGroup = [];\n  groupWithPermission.map((i) => {\n    approversGroup = approversGroup.concat(i.kind.Group ?? []);\n  });\n  return Array.from(new Set(approversGroup));\n}\nconst filterFunction = (item, filterStatusArray, filterKindArray) => {\n  const kind =\n    typeof item.kind === \"string\" ? item.kind : Object.keys(item.kind)[0];\n  if (filterStatusArray.length > 0 && filterKindArray.length > 0) {\n    return (\n      filterStatusArray.includes(item.status) && filterKindArray.includes(kind)\n    );\n  } else if (filterKindArray.length > 0) {\n    return filterKindArray.includes(kind);\n  } else if (filterStatusArray.length > 0) {\n    return filterStatusArray.includes(item.status);\n  }\n  return true;\n};\nfunction getFilteredProposalsByStatusAndKind({\n  resPerPage,\n  isPrevPageCalled,\n  filterKindArray,\n  filterStatusArray,\n  offset,\n  lastProposalId,\n  currentPage,\n}) {\n  let newLastProposalId = typeof offset === \"number\" ? offset : lastProposalId;\n  let filteredProposals = [];\n  const limit = 30;\n  const promiseArray = [];\n  if (isPrevPageCalled) {\n    let startIndex = newLastProposalId;\n    while (startIndex < lastProposalId) {\n      promiseArray.push(\n        Near.asyncView(treasuryDaoID, \"get_proposals\", {\n          from_index: startIndex,\n          limit: limit,\n        })\n      );\n      startIndex += limit;\n    }\n  } else {\n    while (newLastProposalId > 0) {\n      promiseArray.push(\n        Near.asyncView(treasuryDaoID, \"get_proposals\", {\n          from_index:\n            newLastProposalId - limit > 0 ? newLastProposalId - limit : 0,\n          limit: offset > 0 && offset < limit ? offset - 1 : limit,\n        })\n      );\n      newLastProposalId -= limit;\n    }\n  }\n  return Promise.all(promiseArray).then((res) => {\n    const proposals = [].concat(...res);\n    filteredProposals = proposals.filter((item) =>\n      filterFunction(item, filterStatusArray, filterKindArray)\n    );\n    const uniqueFilteredProposals = Array.from(\n      new Map(filteredProposals.map((item) => [item.id, item])).values()\n    );\n    const sortedProposals = uniqueFilteredProposals.sort((a, b) => b.id - a.id);\n    const start = isPrevPageCalled ? currentPage * resPerPage : 0;\n    const end = isPrevPageCalled\n      ? currentPage * resPerPage + resPerPage\n      : resPerPage;\n    const newArray = sortedProposals.slice(start, end);\n    return {\n      filteredProposals: newArray,\n      totalLength: sortedProposals.length,\n    };\n  });\n}\nconst data = fetch(`https://httpbin.org/headers`);\nconst gatewayOrigin = data?.body?.headers?.Origin ?? \"\";\nconst isNearSocial =\n  gatewayOrigin.includes(\"near.social\") ||\n  gatewayOrigin.includes(\"127.0.0.1:8080\") ||\n  gatewayOrigin.includes(\"treasury-devdao.testnet.page\") ||\n  gatewayOrigin.includes(\"treasury-devdao.near.page\");\nfunction getMembersAndPermissions() {\n  return Near.asyncView(treasuryDaoID, \"get_policy\", {}).then((daoPolicy) => {\n    const memberData = [];\n    if (Array.isArray(daoPolicy.roles)) {\n      // Use a map to collect permissions and role names for each member\n      const memberMap = new Map();\n      daoPolicy.roles.forEach((role) => {\n        (role.kind.Group ?? []).forEach((member) => {\n          if (!memberMap.has(member)) {\n            memberMap.set(member, {\n              member: member,\n              permissions: [],\n              roles: [],\n            });\n          }\n          // Add permissions and role names\n          memberMap.get(member).permissions.push(...role.permissions);\n          memberMap.get(member).roles.push(role.name);\n        });\n      });\n      // Convert map to array and remove duplicates\n      return Array.from(memberMap.values()).map((data) => ({\n        member: data.member,\n        permissions: Array.from(new Set(data.permissions)), // Remove duplicate permissions\n        roles: Array.from(new Set(data.roles)), // Remove duplicate role names\n      }));\n    }\n    return memberData;\n  });\n}\nfunction getDaoRoles() {\n  const daoPolicy = Near.view(treasuryDaoID, \"get_policy\", {});\n  if (Array.isArray(daoPolicy.roles)) {\n    return daoPolicy.roles.map((role) => role.name);\n  }\n  return [];\n}\nfunction hasPermission(accountId, kindName, actionType) {\n  if (!accountId) {\n    return false;\n  }\n  const isAllowed = false;\n  const daoPolicy = Near.view(treasuryDaoID, \"get_policy\", {});\n  if (Array.isArray(daoPolicy.roles)) {\n    const permissions = daoPolicy.roles.map((role) => {\n      if (\n        Array.isArray(role.kind.Group) &&\n        role.kind.Group.includes(accountId)\n      ) {\n        return (\n          role.permissions.includes(`${kindName}:${actionType.toString()}`) ||\n          role.permissions.includes(`${kindName}:*`) ||\n          role.permissions.includes(`*:${actionType.toString()}`) ||\n          role.permissions.includes(\"*:*\")\n        );\n      }\n    });\n    isAllowed = permissions.some((element) => element === true);\n  }\n  return isAllowed;\n}\nfunction getPermissionsText(type) {\n  switch (type) {\n    case \"Create Requests\": {\n      return \"Enables users to initiate payment requests.\";\n    }\n    case \"Manage Members\": {\n      return \"Allows users to control treasury adminis and their access levels.\";\n    }\n    case \"Vote\": {\n      return \"Allows users to approve or request proposed payment requests.\";\n    }\n    default:\n      return \"\";\n  }\n}\nreturn {\n  hasPermission,\n  getTransferApproversAndThreshold,\n  getFilteredProposalsByStatusAndKind,\n  isNearSocial,\n  getMembersAndPermissions,\n  getDaoRoles,\n  getPolicyApproverGroup,\n  getPermissionsText,\n};\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/treasury-devdao.near/widget/lib.common", "fact_widget_deployments_id": "73429d6486fc11a63e57b8fb721be559", "inserted_timestamp": "2024-08-23T20:53:29.250Z", "modified_timestamp": "2024-08-23T20:53:29.250Z", "__row_index": 2}