{"tx_hash": "25vbzM2VTkEHUFF55Q9utz6EQ5UC7gytqbELadkYdx7n", "action_id_social": "AXMcsiTEfwsw9EL3UEo6ATFjNFBrAU29pSSDddV1X3VM-0-widget", "block_id": 125920808, "block_timestamp": "2024-08-16T20:03:39.499Z", "signer_id": "treasury-devdao.near", "widget_name": "lib.common", "source_code": "const treasuryDaoID = \"testing-astradao.sputnik-dao.near\";\nfunction getTransferApproversAndThreshold() {\n  const daoPolicy = Near.view(treasuryDaoID, \"get_policy\", {});\n  const groupWithTransferPermission = (daoPolicy.roles ?? []).filter((role) => {\n    const transferPermissions = [\n      \"*:*\",\n      \"transfer:*\",\n      \"transfer:VoteApprove\",\n      \"transfer:VoteReject\",\n      \"transfer:VoteRemove\",\n      \"*:VoteApprove\",\n      \"*:VoteReject\",\n      \"*:VoteRemove\",\n    ];\n    return (role?.permissions ?? []).some((i) =>\n      transferPermissions.includes(i)\n    );\n  });\n  let approversGroup = [];\n  let ratios = [];\n  groupWithTransferPermission.map((i) => {\n    approversGroup = approversGroup.concat(i.kind.Group ?? []);\n    if (i.vote_policy[\"transfer\"].weight_kind === \"RoleWeight\") {\n      ratios = ratios.concat(i.vote_policy[\"transfer\"].threshold);\n      ratios = ratios.concat(i.vote_policy[\"transfer\"].threshold);\n    }\n  });\n  let numerator = 0;\n  let denominator = 0;\n  if (ratios.length > 0) {\n    ratios.forEach((value, index) => {\n      if (index == 0 || index % 2 === 0) {\n        // Even index -> numerator\n        numerator += value;\n      } else {\n        // Odd index -> denominator\n        denominator += value;\n      }\n    });\n  } else {\n    numerator = 1;\n    denominator = 2;\n  }\n  return {\n    approverAccounts: Array.from(new Set(approversGroup)),\n    threshold: numerator / denominator,\n  };\n}\nfunction getPolicyApproverGroup() {\n  const daoPolicy = Near.view(treasuryDaoID, \"get_policy\", {});\n  const groupWithPermission = (daoPolicy.roles ?? []).filter((role) => {\n    const policyPermissions = [\n      \"*:*\",\n      \"policy:AddProposal\",\n      \"policy:*\",\n      \"policy:VoteApprove\",\n      \"policy:VoteReject\",\n      \"policy:VoteRemove\",\n      \"*:VoteApprove\",\n      \"*:VoteReject\",\n      \"*:VoteRemove\",\n    ];\n    return (role?.permissions ?? []).some((i) => policyPermissions.includes(i));\n  });\n  let approversGroup = [];\n  groupWithPermission.map((i) => {\n    approversGroup = approversGroup.concat(i.kind.Group ?? []);\n  });\n  return Array.from(new Set(approversGroup));\n}\nconst filterFunction = (item, filterStatusArray, filterKindArray) => {\n  const kind =\n    typeof item.kind === \"string\" ? item.kind : Object.keys(item.kind)[0];\n  if (filterStatusArray.length > 0 && filterKindArray.length > 0) {\n    return (\n      filterStatusArray.includes(item.status) && filterKindArray.includes(kind)\n    );\n  } else if (filterKindArray.length > 0) {\n    return filterKindArray.includes(kind);\n  } else if (filterStatusArray.length > 0) {\n    return filterStatusArray.includes(item.status);\n  }\n  return true;\n};\nfunction getFilteredProposalsByStatusAndkind({\n  resPerPage,\n  reverse,\n  filterKindArray,\n  filterStatusArray,\n  offset,\n  lastProposalId,\n}) {\n  let newLastProposalId = offset ?? 0;\n  let filteredProposals = [];\n  const limit = 30;\n  if (reverse && !offset) {\n    newLastProposalId = lastProposalId;\n  }\n  const promiseArray = [];\n  while (\n    (reverse && newLastProposalId > 0) ||\n    (!reverse && newLastProposalId < lastProposalId)\n  ) {\n    promiseArray.push(\n      Near.asyncView(treasuryDaoID, \"get_proposals\", {\n        from_index:\n          newLastProposalId - limit > 0 ? newLastProposalId - limit : 0,\n        limit: limit,\n      })\n    );\n    if (reverse) {\n      newLastProposalId -= limit;\n    } else {\n      newLastProposalId += limit;\n    }\n  }\n  return Promise.all(promiseArray).then((res) => {\n    const proposals = [].concat(...res);\n    filteredProposals = proposals.filter((item) =>\n      filterFunction(item, filterStatusArray, filterKindArray)\n    );\n    const uniqueFilteredProposals = Array.from(\n      new Map(filteredProposals.map((item) => [item.id, item])).values()\n    );\n    const newArray = uniqueFilteredProposals.slice(0, resPerPage);\n    if (reverse) {\n      newArray.reverse();\n    }\n    return {\n      filteredProposals: newArray,\n      totalLength: filteredProposals.length,\n    };\n  });\n}\nconst data = fetch(`https://httpbin.org/headers`);\nconst gatewayOrigin = data?.body?.headers?.Origin ?? \"\";\nconst isNearSocial =\n  gatewayOrigin.includes(\"near.social\") ||\n  gatewayOrigin.includes(\"127.0.0.1:8080\");\nfunction getMembersAndPermissions() {\n  return Near.asyncView(treasuryDaoID, \"get_policy\", {}).then((daoPolicy) => {\n    const memberData = [];\n    if (Array.isArray(daoPolicy.roles)) {\n      // Use a map to collect permissions and role names for each member\n      const memberMap = new Map();\n      daoPolicy.roles.forEach((role) => {\n        (role.kind.Group ?? []).forEach((member) => {\n          if (!memberMap.has(member)) {\n            memberMap.set(member, {\n              member: member,\n              permissions: [],\n              roles: [],\n            });\n          }\n          // Add permissions and role names\n          memberMap.get(member).permissions.push(...role.permissions);\n          memberMap.get(member).roles.push(role.name);\n        });\n      });\n      // Convert map to array and remove duplicates\n      return Array.from(memberMap.values()).map((data) => ({\n        member: data.member,\n        permissions: Array.from(new Set(data.permissions)), // Remove duplicate permissions\n        roles: Array.from(new Set(data.roles)), // Remove duplicate role names\n      }));\n    }\n    return memberData;\n  });\n}\nfunction getDaoRoles() {\n  const daoPolicy = Near.view(treasuryDaoID, \"get_policy\", {});\n  if (Array.isArray(daoPolicy.roles)) {\n    return daoPolicy.roles.map((role) => role.name);\n  }\n  return [];\n}\nfunction hasPermission(accountId, kindName, actionType) {\n  if (!accountId) {\n    return false;\n  }\n  const isAllowed = false;\n  const daoPolicy = Near.view(treasuryDaoID, \"get_policy\", {});\n  if (Array.isArray(daoPolicy.roles)) {\n    const permissions = daoPolicy.roles.map((role) => {\n      if (\n        Array.isArray(role.kind.Group) &&\n        role.kind.Group.includes(accountId)\n      ) {\n        return (\n          role.permissions.includes(`${kindName}:${actionType.toString()}`) ||\n          role.permissions.includes(`${kindName}:*`) ||\n          role.permissions.includes(`*:${actionType.toString()}`) ||\n          role.permissions.includes(\"*:*\")\n        );\n      }\n    });\n    isAllowed = permissions.some((element) => element === true);\n  }\n  return isAllowed;\n}\nreturn {\n  hasPermission,\n  getTransferApproversAndThreshold,\n  getFilteredProposalsByStatusAndkind,\n  isNearSocial,\n  getMembersAndPermissions,\n  getDaoRoles,\n  getPolicyApproverGroup,\n};\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/treasury-devdao.near/widget/lib.common", "fact_widget_deployments_id": "1325b92e9012a7c1a4ff8f2a4d4d5907", "inserted_timestamp": "2024-08-16T21:53:56.165Z", "modified_timestamp": "2024-08-16T21:53:56.165Z", "__row_index": 1}