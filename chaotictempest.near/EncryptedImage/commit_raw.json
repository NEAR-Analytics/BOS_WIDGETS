{"tx_hash": "DS3jKryw2jpyvLcmdiiMdac2yA5s6iN92esUy1JgRWu2", "action_id_social": "C8anTPw1qgmZuVAMgctFKDfxBgC2iMwEFbRzpSDRasyd-0-widget", "block_id": 107341244, "block_timestamp": "2023-12-07T07:02:15.883Z", "signer_id": "chaotictempest.near", "widget_name": "EncryptedImage", "source_code": "// Image component that allows to show encrypted images, given a password.\nconst image = props.image;\nconst className = props.className;\nconst style = props.style;\nconst alt = props.alt ?? \"Not set\";\nconst fallbackUrl = props.fallbackUrl;\nconst ipfsUrl =\n  props.ipfsUrl ?? ((cid) => `https://ipfs.near.social/ipfs/${cid}`);\nconst hashedPassword = props.hashedPassword;\nconst determineFileType = props.determineFileType;\nconst fileType = props.fileType;\n\nState.init({\n  image,\n});\n\nconst thumb = (imageUrl) =>\n  thumbnail && imageUrl && !imageUrl.startsWith(\"data:image/\")\n    ? `https://i.near.social/${thumbnail}/${imageUrl}`\n    : imageUrl;\n\nconst str2array = (str) => {\n  return new Uint8Array(Array.from(str).map((letter) => letter.charCodeAt(0)));\n};\n\nconst recover_sk = () => {\n  const defaultPassword = \"ipfs-files-encrypted-upload-supplied-password\";\n  const hashed_id = nacl.hash(str2array(context.accountId));\n  const hashed_pw = hashedPassword ?? nacl.hash(str2array(defaultPassword));\n  const sk = new Uint8Array(nacl.secretbox.keyLength);\n  for (var i = 0; i < hashed_id.length; i++) {\n    const sk_i = i % sk.length;\n    if (i >= sk.length) {\n      sk[sk_i] = sk[sk_i] + (hashed_id[i] + hashed_pw[i]);\n    } else {\n      sk[sk_i] = hashed_id[i] + hashed_pw[i];\n    }\n  }\n  return sk;\n};\n\nconst [storageSk, _] = useState(() => {\n  if (props.decryptSk) {\n    return props.decryptSk;\n  }\n  const localSk = Storage.privateGet(\"storage_secret\");\n  if (localSk && !props.hashedPassword) {\n    return localSk;\n  }\n  const sk = recover_sk();\n  console.log(\"recovered decryption sk to local storage\");\n  Storage.privateSet(\"storage_secret\", sk);\n  return sk;\n});\n\nconst decrypt = (nonce, sealed) => {\n  return nacl.secretbox.open(sealed, nonce, storageSk);\n};\n\nconst check = (headers) => {\n  return (buffers) =>\n    headers.every((header, index) => header === buffers[index]);\n};\n\n// Only define common image types. User can supply their own determine filetype check if they want.\nconst isPng = check([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a]);\nconst isJpg = check([0xff, 0xd8, 0xff]);\nconst isGif = check([0x47, 0x49, 0x46, 0x38]);\nconst isBmp = check([0x42, 0x4d]);\n\nconst getFileType =\n  determineFileType ??\n  ((u8buf) => {\n    if (isPng(u8buf)) {\n      return \"png\";\n    }\n    if (isJpg(u8buf)) {\n      return \"jpg\";\n    }\n    if (isGif(u8buf)) {\n      return \"gif\";\n    }\n    if (isBmp(u8buf)) {\n      return \"bmp\";\n    }\n  });\n\nfunction fetchImage(cid) {\n  asyncFetch(ipfsUrl(cid)).then((file) => {\n    if (!file.ok) {\n      console.log(\"IPFS fetch not ok\", file);\n      return;\n    }\n\n    const ciphertext = new Uint8Array(file.body.ciphertext);\n    const nonce = new Uint8Array(file.body.nonce);\n    const bytes = decrypt(nonce, ciphertext);\n\n    if (bytes) {\n      const fileType = fileType ?? `image/${getFileType(bytes)}`;\n      State.update({\n        imageUrl: URL.createObjectURL(new Blob([bytes], { type: fileType })),\n      });\n    } else {\n      console.log(`could not decrypt '${file.body.name}'`);\n    }\n  });\n}\n\nuseEffect(() => {\n  if (image.ipfs_cid) {\n    fetchImage(image.ipfs_cid);\n  }\n}, [image]);\n\nreturn (\n  <img\n    className={className}\n    style={style}\n    src={state.imageUrl ?? thumb(fallbackUrl)}\n    alt={alt}\n    onError={() => {\n      if (state.imageUrl !== fallbackUrl) {\n        State.update({\n          imageUrl: fallbackUrl,\n        });\n      }\n    }}\n  />\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/chaotictempest.near/widget/EncryptedImage", "fact_widget_deployments_id": "18e8abad2ce81252a391ce38198c708d", "inserted_timestamp": "2023-12-07T08:52:36.881Z", "modified_timestamp": "2023-12-20T03:22:11.422Z", "__row_index": 0}