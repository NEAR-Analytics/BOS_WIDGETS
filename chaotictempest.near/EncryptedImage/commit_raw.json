{"tx_hash": "HETFQrb4MUiRVmc2A2Z6UZBdKtUCd3ZoKR5sZn9hKgBV", "action_id_social": "Go7gneh9DP6o1c5668DAPvHEBusYXJa39i2Gz8rdWEkH-0-widget", "block_id": 107380746, "block_timestamp": "2023-12-07T19:11:33.709Z", "signer_id": "chaotictempest.near", "widget_name": "EncryptedImage", "source_code": "/* Image component that allows to show encrypted images, given a password. */\n\nconst image = props.image;\nconst className = props.className;\nconst style = props.style;\nconst alt = props.alt ?? \"Not set\";\nconst fallbackUrl = props.fallbackUrl;\nconst determineFileType = props.determineFileType;\nconst fileType = props.fileType;\nconst ipfsUrl =\n  props.ipfsUrl ?? ((cid) => `https://ipfs.near.social/ipfs/${cid}`);\n\n// Optional: will load from local storage or recover from account id and password.\nconst decryptSk = props.decryptSk;\n\n/// Required to pass in.\nconst password = props.password;\n\nif (!password) {\n  return <> \"props.password is required for EncryptedImage\" </>;\n}\n\nState.init({\n  image,\n});\n\nconst thumb = (imageUrl) =>\n  thumbnail && imageUrl && !imageUrl.startsWith(\"data:image/\")\n    ? `https://i.near.social/${thumbnail}/${imageUrl}`\n    : imageUrl;\n\nconst str2array = (str) => {\n  return new Uint8Array(Array.from(str).map((letter) => letter.charCodeAt(0)));\n};\n\nconst recover_sk = () => {\n  const hashed_id = nacl.hash(str2array(context.accountId));\n  const hashed_pw = nacl.hash(str2array(password));\n  const sk = new Uint8Array(nacl.secretbox.keyLength);\n  for (var i = 0; i < hashed_id.length; i++) {\n    const sk_i = i % sk.length;\n    if (i >= sk.length) {\n      sk[sk_i] = sk[sk_i] + (hashed_id[i] + hashed_pw[i]);\n    } else {\n      sk[sk_i] = hashed_id[i] + hashed_pw[i];\n    }\n  }\n  return sk;\n};\n\nconst [storageSk, _] = useState(() => {\n  if (decryptSk) {\n    // decryptSk is available. use it instead of recovering\n    if (password) {\n      console.log(\"Utilizing decryptSk over password\");\n    }\n    return decryptSk;\n  }\n  const localSk = Storage.privateGet(\"storage_secret\");\n  if (localSk && !password) {\n    return localSk;\n  }\n  const sk = recover_sk();\n  console.log(\"recovered decryption sk to local storage\");\n  Storage.privateSet(\"storage_secret\", sk);\n  return sk;\n});\n\nconst decrypt = (nonce, sealed) => {\n  return nacl.secretbox.open(sealed, nonce, storageSk);\n};\n\nconst check = (headers) => {\n  return (buffers) =>\n    headers.every((header, index) => header === buffers[index]);\n};\n\n// Only define common image types. User can supply their own determine filetype check if they want.\nconst isPng = check([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a]);\nconst isJpg = check([0xff, 0xd8, 0xff]);\nconst isGif = check([0x47, 0x49, 0x46, 0x38]);\nconst isBmp = check([0x42, 0x4d]);\n\nconst getFileType =\n  determineFileType ??\n  ((u8buf) => {\n    if (isPng(u8buf)) {\n      return \"png\";\n    }\n    if (isJpg(u8buf)) {\n      return \"jpg\";\n    }\n    if (isGif(u8buf)) {\n      return \"gif\";\n    }\n    if (isBmp(u8buf)) {\n      return \"bmp\";\n    }\n  });\n\nfunction fetchImage(cid) {\n  asyncFetch(ipfsUrl(cid)).then((file) => {\n    if (!file.ok) {\n      console.log(\"IPFS fetch not ok\", file);\n      return;\n    }\n\n    const ciphertext = new Uint8Array(file.body.ciphertext);\n    const nonce = new Uint8Array(file.body.nonce);\n    const bytes = decrypt(nonce, ciphertext);\n\n    if (bytes) {\n      const fileType = fileType ?? `image/${getFileType(bytes)}`;\n      State.update({\n        imageUrl: URL.createObjectURL(new Blob([bytes], { type: fileType })),\n      });\n    } else {\n      console.log(`could not decrypt '${file.body.name}'`);\n    }\n  });\n}\n\nuseEffect(() => {\n  if (image.ipfs_cid) {\n    fetchImage(image.ipfs_cid);\n  }\n}, [image]);\n\nreturn (\n  <img\n    className={className}\n    style={style}\n    src={state.imageUrl ?? thumb(fallbackUrl)}\n    alt={alt}\n    onError={() => {\n      if (state.imageUrl !== fallbackUrl) {\n        State.update({\n          imageUrl: fallbackUrl,\n        });\n      }\n    }}\n  />\n);\n", "metadata": {"fork_of": "chaotictempest.near/widget/EncryptedImage@107341244"}, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/chaotictempest.near/widget/EncryptedImage", "fact_widget_deployments_id": "483fb287360bc418a8ad655e9b4da525", "inserted_timestamp": "2023-12-07T21:18:21.816Z", "modified_timestamp": "2023-12-20T03:22:11.422Z", "__row_index": 0}