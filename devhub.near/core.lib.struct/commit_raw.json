{"tx_hash": "E3gFX7FdpWWhU6SWVAFGzmvYCX269f58tYh3LpdD2r5s", "action_id_social": "DT5T7yeJsfo2Zh7a1FdhzxFdUPFKwFiwmwHXUJomqQaw-0-widget", "block_id": 109639865, "block_timestamp": "2024-01-05T08:42:46.193Z", "signer_id": "devhub.near", "widget_name": "core.lib.struct", "source_code": "/**\n * Deeply updates an object's field based on the given path and transformation function.\n *\n * @param {Object} target - The target object to update.\n * @param {Array} path - The path to the field to update.\n * @param {Function} transform - The transformation function to apply.\n * @returns {Object} - The updated object.\n */\nconst deepFieldUpdate = (target, path, transform) => {\n  if (path.length === 0) {\n    return transform(target);\n  }\n\n  const [nextNodeKey, ...remainingPath] = path;\n\n  return {\n    ...target,\n    [nextNodeKey]: deepFieldUpdate(\n      target[nextNodeKey] ?? {},\n      remainingPath,\n      transform\n    ),\n  };\n};\n\n/**\n * Checks if two inputs (objects or arrays) are deeply equal.\n *\n * @param {Object|Array} input1 - The first input.\n * @param {Object|Array} input2 - The second input.\n * @returns {boolean} - True if the inputs are deeply equal, false otherwise.\n */\nconst isEqual = (input1, input2) => {\n  const input1Str = JSON.stringify(input1);\n  const input2Str = JSON.stringify(input2);\n  return input1Str === input2Str;\n};\n\n/**\n * Creates a new object with sorted keys based on the input object.\n *\n * @param {Object} input - The input object.\n * @returns {Object} - A new object with sorted keys.\n */\nconst toOrdered = (input) => {\n  if (typeof input !== \"object\" || input === null) {\n    return {};\n  }\n\n  return Object.keys(input)\n    .sort()\n    .reduce((output, key) => ({ ...output, [key]: input[key] }), {});\n};\n\n/**\n * Picks specified keys from an object and returns a new object with those keys.\n *\n * @param {Object} sourceObject - The source object to pick keys from.\n * @param {Array} keysToPick - An array of keys to pick.\n * @returns {Object} - A new object containing the selected keys.\n */\nconst pick = (sourceObject, keysToPick) => {\n  if (typeof sourceObject !== \"object\" || sourceObject === null) {\n    return {};\n  }\n\n  return Object.fromEntries(\n    Object.entries(sourceObject).filter(([key, _]) => keysToPick.includes(key))\n  );\n};\n\n/**\n * Checks if the input matches the expected type.\n *\n * @param {Object} input - The input to check.\n * @returns {boolean} - True if the input is an object and not an array or null, false otherwise.\n */\nconst typeMatch = (input) =>\n  input !== null && typeof input === \"object\" && !Array.isArray(input);\n\nconst defaultFieldUpdate = ({\n  input,\n  lastKnownValue,\n  params: { arrayDelimiter },\n}) => {\n  switch (typeof input) {\n    case \"boolean\":\n      return input;\n\n    case \"object\": {\n      if (Array.isArray(input) && typeof lastKnownValue === \"string\") {\n        return input.join(arrayDelimiter ?? \",\");\n      } else {\n        return Array.isArray(lastKnownValue)\n          ? [...lastKnownValue, ...input]\n          : { ...lastKnownValue, ...input };\n      }\n    }\n\n    case \"string\":\n      return Array.isArray(lastKnownValue)\n        ? input.split(arrayDelimiter ?? \",\").map((string) => string.trim())\n        : input;\n\n    default: {\n      if ((input ?? null) === null) {\n        switch (typeof lastKnownValue) {\n          case \"boolean\":\n            return !lastKnownValue;\n\n          default:\n            return lastKnownValue;\n        }\n      } else return input;\n    }\n  }\n};\n\nreturn {\n  deepFieldUpdate,\n  isEqual,\n  pick,\n  toOrdered,\n  typeMatch,\n  defaultFieldUpdate,\n};\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/devhub.near/widget/core.lib.struct", "fact_widget_deployments_id": "ecc28308fe3101995bbd07129dbc562c", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 4}