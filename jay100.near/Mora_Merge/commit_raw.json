{"tx_hash": "6A7vtbCyLPYD8wu3tJXhbuHfYggUderVwxUdk7DqXKbZ", "action_id_social": "4ngZ6wMgmk95KXP1QXnotsgKYTP4w93WTciKZJopByFJ-0-widget", "block_id": 107764001, "block_timestamp": "2023-12-12T13:45:44.904Z", "signer_id": "jay100.near", "widget_name": "Mora_Merge", "source_code": "State.init({\r\n  score: 0,\r\n});\r\n\r\nconst Game_Box = () => {\r\n  const code = `\r\n  <head>\r\n      <link rel=\"preconnect\" href=\"https://fonts.googleapis.com\">\r\n<link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin>\r\n<link href=\"https://fonts.googleapis.com/css2?family=Lugrasimo&family=VT323&display=swap\" rel=\"stylesheet\">\r\n  </head>\r\n<style>\r\n   body {\r\n    margin: 0;\r\n    display: flex;\r\n    align-items: center;\r\n    height: 80vh;\r\n    flex-direction: column;\r\n    overflow: hidden;\r\n   }\r\n\r\n   .score{\r\n    padding: 1rem;\r\n    font-size: 1.5rem;\r\n   }\r\n\r\n</style>\r\n<body>\r\n</body>\r\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js\" integrity=\"sha512-2r+xZ/Dm8+HI0I8dsj1Jlfchv4O3DGfWbqRalmSGtgdbVQrZyGRqHp9ek8GKk1x8w01JsmDZRrJZ4DzgXkAU+g==\" crossorigin=\"anonymous\" referrerpolicy=\"no-referrer\"></script>\r\n<script>\r\n\r\nlet circleOptions = [];\r\nlet droppedCircles = [];\r\nlet groundY;\r\nlet hoveredCircle = null;\r\nlet gameStarted = false;\r\nconst sizes = [10, 20, 40];\r\nlet gameScore = 0;\r\nlet canDropCircle = true;\r\nlet allCircles = [];\r\nlet timer = 60;\r\nlet timerInterval;\r\nlet backgroundImage; // Declare a variable to hold the image\r\nlet bestScore = 0;\r\n\r\nlet imgArr = ['https://upload.wikimedia.org/wikipedia/en/d/d0/Dogecoin_Logo.png','https://cdn.iconscout.com/icon/free/png-256/free-ethereum-8-645838.png','https://www.iconpacks.net/icons/2/free-bitcoin-icon-2207-thumb.png']\r\n\r\nfunction preload() {\r\n  for (let i = 0; i < imgArr.length; i++) {\r\n        const img = loadImage(imgArr[i]);\r\n        const circleSize = sizes[i];\r\n        const circle = new Circle(0, 0, circleSize, img, imgArr[i]);\r\n        circleOptions.push(circle); // Add the circle to the options array\r\n    }\r\n}\r\n\r\nfunction resetGame() {\r\n    timer = 60;\r\n    gameScore = 0;\r\n    canDropCircle = true;\r\n    allCircles = [];\r\n    droppedCircles = [];\r\n    gameStarted = false;\r\n}\r\n\r\nfunction setup() {\r\n    createCanvas(350, windowHeight);\r\n    groundY = height - 5; // Ground position\r\n    timerInterval = setInterval(() => {\r\n        if (timer > 0) {\r\n            timer--;\r\n        } else {\r\n            // If the timer reaches 0, stop the timer and prevent circle dropping\r\n            if(gameScore > bestScore){\r\n                bestScore = gameScore;\r\n            }\r\n            clearInterval(timerInterval);\r\n            canDropCircle = false;\r\n            resetGame();\r\n        }\r\n    }, 1000); // Update the timer every second (1000 milliseconds)\r\n}\r\n\r\nfunction draw() {\r\n    background(220);\r\n\r\n    textFont(\"VT323\");\r\n\r\n    if(!gameStarted){\r\n        textSize(32);\r\n        textAlign(CENTER, CENTER);\r\n        text(\"Click to Start\", width / 2, height / 2);\r\n        text(\"Best Score: \" + bestScore, width / 2, height / 3);\r\n    } else {\r\n\r\n    textSize(30);\r\n    fill(0);\r\n    text(\"Time: \" + timer, 300, 20);\r\n\r\n    textSize(30);\r\n    fill(0, 0, 0);\r\n    text(\"Score: \" + gameScore, 60, 20);\r\n\r\n    if (hoveredCircle) {\r\n        hoveredCircle.x = mouseX;\r\n        hoveredCircle.y = 45; // Adjust the y position as needed\r\n        image(hoveredCircle.texture, hoveredCircle.x - hoveredCircle.radius, hoveredCircle.y - hoveredCircle.radius, hoveredCircle.radius * 2, hoveredCircle.radius * 2);\r\n    }\r\n\r\n    for (let i = 0; i < droppedCircles.length; i++) {\r\n        droppedCircles[i].display();\r\n        droppedCircles[i].fall();\r\n        droppedCircles[i].checkBounds();\r\n\r\n        for (let j = i + 1; j < droppedCircles.length; j++) {\r\n            droppedCircles[i].checkCircleCollision(droppedCircles[j]);\r\n        }\r\n    }\r\n    }\r\n \r\n}\r\n\r\nfunction mouseClicked() {\r\n     if (!gameStarted) {\r\n        // Transition to the game screen upon clicking\r\n        gameStarted = true;\r\n        timer = 60; // Reset the timer when the game starts\r\n        canDropCircle = true; // Reset circle dropping ability\r\n        droppedCircles = []; // Clear dropped circles\r\n\r\n          clearInterval(timerInterval);\r\n\r\n        // Start a new timer interval\r\n        timerInterval = setInterval(() => {\r\n            if (timer > 0) {\r\n                timer--;\r\n            } else {\r\n                // If the timer reaches 0, stop the timer and prevent circle dropping\r\n                if(gameScore > bestScore){\r\n                    bestScore = gameScore;\r\n                }\r\n                clearInterval(timerInterval);\r\n                canDropCircle = false;\r\n                resetGame();\r\n            }\r\n        }, 1000); \r\n    }\r\n\r\n    if (canDropCircle && timer > 0) {\r\n\r\n        if (!hoveredCircle) {\r\n            const pos = Math.floor(Math.random() * imgArr.length);\r\n            hoveredCircle = circleOptions[pos];\r\n            hoveredCircle.x = mouseX;\r\n            hoveredCircle.y = 45;\r\n        } else {\r\n            let newDroppedCircle = new Circle(hoveredCircle.x, hoveredCircle.y, hoveredCircle.radius, hoveredCircle.texture, hoveredCircle.imageUrl);\r\n\r\n            droppedCircles.push(newDroppedCircle); // Add the new dropped circle\r\n            allCircles.push(newDroppedCircle);\r\n            hoveredCircle = null; // Reset hoveredCircle\r\n\r\n            canDropCircle = false; // Prevent dropping a new circle immediately\r\n            setTimeout(() => {\r\n                const newPos = Math.floor(Math.random() * imgArr.length);\r\n                hoveredCircle = circleOptions[newPos];\r\n                hoveredCircle.x = mouseX;\r\n                hoveredCircle.y = 45;\r\n                canDropCircle = true; // Allow dropping a new circle after the delay\r\n            }, 250); // Adjust the delay duration in milliseconds (here, it's 1 second)\r\n        }\r\n    }\r\n}\r\n\r\nclass Circle {\r\n    constructor(x, y, radius, img, imgUrl) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.radius = radius;\r\n        this.speed = 6;\r\n        this.isFalling = true;\r\n        this.xSpeed = random(0, 0); // Initial random horizontal speed\r\n        this.ySpeed = 5;\r\n        this.texture = img; // Use the image as texture\r\n        this.imageUrl = imgUrl;\r\n        this.isMerged = false; // Track whether the circle is merged or not\r\n    }\r\n\r\n    display() {\r\n       if (this.texture) {\r\n        image(this.texture, this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);\r\n    } else {\r\n        // Optionally, draw something else or just the circle without an image\r\n        ellipse(this.x, this.y, this.radius * 2);\r\n      }\r\n    }\r\n\r\n    fall() {\r\n    if (this.isFalling) {\r\n          this.y += this.ySpeed;\r\n          this.ySpeed += 0.2; // Simulate gravity\r\n          this.x += this.xSpeed;\r\n   \r\n          // Bounce off walls\r\n          if (this.x + this.radius >= width || this.x - this.radius <= 0) {\r\n            this.xSpeed *= -0.1; // Reduce x speed upon wall impact\r\n          }\r\n\r\n          \r\n          // Check for hitting the ground\r\n          if (this.y + this.radius >= groundY) {\r\n            this.y = groundY - this.radius;\r\n            this.ySpeed *= -0.1; // Reduce y speed upon ground impact (dampening)\r\n            this.xSpeed *= 0.6; // Reduce x speed upon ground impact\r\n          }\r\n    }\r\n}\r\n\r\n    intersects(other) {\r\n        // Check collision between circles\r\n        let distance = dist(this.x, this.y, other.x, other.y);\r\n        return distance < this.radius + other.radius;\r\n    }\r\n\r\n    checkBounds() {\r\n        if (this.x - this.radius < 0 || this.x + this.radius > width) {\r\n          this.x = constrain(this.x, this.radius, width - this.radius);\r\n        }\r\n        if (this.y - this.radius < 0 || this.y + this.radius > height) {\r\n          this.y = constrain(this.y, this.radius, height - this.radius);\r\n        }\r\n      }\r\n\r\n\r\n    checkCircleCollision(otherCircle) {\r\n        let dx = this.x - otherCircle.x;\r\n        let dy = this.y - otherCircle.y;\r\n        let distanceSquared = dx * dx + dy * dy;\r\n        let minDistanceSquared = (this.radius + otherCircle.radius) * (this.radius + otherCircle.radius);\r\n\r\n        if (distanceSquared <= minDistanceSquared) {\r\n            let radiusDifference = abs(this.radius - otherCircle.radius);\r\n            let mergeThreshold = 3; // Set your threshold for merging circles\r\n\r\n            // Check conditions for merging circles\r\n            if (this.imageUrl === otherCircle.imageUrl && radiusDifference <= mergeThreshold) {\r\n                // Merge circles if they touch and have similar radius\r\n                let newRadius = this.radius + otherCircle.radius;\r\n\r\n                // Increment game score based on the merged circle radius\r\n                if (newRadius === 20) {\r\n                    gameScore += 2;\r\n                    let newCircleOption = circleOptions.filter(circle => circle.radius === newRadius);\r\n                    console.log(newCircleOption);\r\n                    this.texture = newCircleOption[0].texture;\r\n                    this.radius = newCircleOption[0].radius;\r\n                    this.imageUrl = newCircleOption[0].imageUrl;\r\n                    otherCircle.removeFromArrays();\r\n                } else if (newRadius === 40) {\r\n                    gameScore += 4;\r\n                    let newCircleOption = circleOptions.filter(circle => circle.radius === newRadius);\r\n                    console.log(newCircleOption);\r\n                    this.texture = newCircleOption[0].texture;\r\n                    this.radius = newCircleOption[0].radius;\r\n                    this.imageUrl = newCircleOption[0].imageUrl;\r\n                    otherCircle.removeFromArrays();\r\n                } else if (newRadius === 80) {\r\n                    gameScore += 8;\r\n                }\r\n\r\n                // Create a new merged circle if the radius exceeds a certain threshold\r\n                if (newRadius >= 160) {\r\n                    gameScore += 16;\r\n                    let mergedCircle = new Circle(this.x, this.y, newRadius, this.texture, this.imageUrl);\r\n                    allCircles = allCircles.filter(circle => circle !== this && circle !== otherCircle);\r\n                    allCircles.push(mergedCircle);\r\n                    this.removeFromArrays();\r\n                    otherCircle.removeFromArrays();\r\n                } else {\r\n                    this.radius = newRadius;\r\n                   otherCircle.removeFromArrays();\r\n                }\r\n            } else {\r\n                // Resolve collision as a bounce\r\n                this.resolveCollision(otherCircle);\r\n            }\r\n        }\r\n    }\r\n\r\n    removeFromArrays() {\r\n        // Remove this circle from both arrays\r\n        const droppedIndex = droppedCircles.indexOf(this);\r\n        if (droppedIndex !== -1) {\r\n            droppedCircles.splice(droppedIndex, 1);\r\n        }\r\n\r\n        const allIndex = allCircles.indexOf(this);\r\n        if (allIndex !== -1) {\r\n            allCircles.splice(allIndex, 1);\r\n        }\r\n    }\r\n\r\n     removeImage() {\r\n        this.texture = null; // or this.texture = ''; depending on your implementation\r\n    }\r\n\r\n    resolveCollision(other) {\r\n        let dx = other.x - this.x;\r\n        let dy = other.y - this.y;\r\n        let distance = sqrt(dx * dx + dy * dy);\r\n   \r\n        // Calculate the minimum translation distance to separate droppedCircles\r\n        let minDistance = this.radius + other.radius;\r\n        let separationX = dx / distance * (minDistance - distance);\r\n        let separationY = dy / distance * (minDistance - distance);\r\n\r\n   \r\n        // Move droppedCircles apart to avoid overlap\r\n        this.x -= separationX / 2;\r\n        this.y -= separationY / 2;\r\n        other.x += separationX / 2;\r\n        other.y += separationY / 2;\r\n\r\n\r\n        // Update velocities for a bounce effect with mass consideration\r\n\r\n         // let massFactor = 0.03;\r\n        // let forceFactor = (this.radius - other.radius) * massFactor;\r\n\r\n    // Update velocities for a bounce effect with mass consideration\r\n    // Modify this part accordingly to suit your specific behavior\r\n\r\n    let angle = atan2(dy, dx);\r\n    let thisSpeed = sqrt(this.xSpeed * this.xSpeed + this.ySpeed * this.ySpeed);\r\n    let otherSpeed = sqrt(other.xSpeed * other.xSpeed + other.ySpeed * other.ySpeed);\r\n    let thisDirection = atan2(this.ySpeed, this.xSpeed);\r\n    let otherDirection = atan2(other.ySpeed, other.xSpeed);\r\n\r\n\r\n    // this(thisSpeed - forceFactor)\r\n    // other(thisSpeed + forceFactor)\r\n    let newThisXSpeed = otherSpeed * cos(otherDirection - angle) * cos(angle) + (thisSpeed) * sin(thisDirection - angle) * cos(angle + HALF_PI);\r\n    let newThisYSpeed = otherSpeed * cos(otherDirection - angle) * sin(angle) + (thisSpeed) * sin(thisDirection - angle) * sin(angle + HALF_PI);\r\n    let newOtherXSpeed = (thisSpeed) * cos(thisDirection - angle) * cos(angle) + otherSpeed * sin(otherDirection - angle) * cos(angle + HALF_PI);\r\n    let newOtherYSpeed = (thisSpeed) * cos(thisDirection - angle) * sin(angle) + otherSpeed * sin(otherDirection - angle) * sin(angle + HALF_PI);\r\n\r\n    this.xSpeed = newThisXSpeed;\r\n    this.ySpeed = newThisYSpeed;\r\n    other.xSpeed = newOtherXSpeed;\r\n    other.ySpeed = newOtherYSpeed;\r\n\r\n      }\r\n\r\n}\r\n\r\n</script>\r\n`;\r\n\r\n  return (\r\n    <div\r\n      style={{ height: \"85%\", display: \"flex\", flexDirection: \"column\" }}\r\n      className=\"mx-auto\"\r\n    >\r\n      {\" \"}\r\n      <iframe className=\"w-100 h-100\" srcDoc={code} />\r\n    </div>\r\n  );\r\n};\r\n\r\nreturn (\r\n  <div style={{ width: \"100%\", height: \"100%\", background: \"blue\" }}>\r\n    <Game_Box />\r\n  </div>\r\n);\r\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/jay100.near/widget/Mora_Merge", "fact_widget_deployments_id": "cf0d9e9f1171302f1d1a8eec6523276c", "inserted_timestamp": "2023-12-12T15:51:43.362Z", "modified_timestamp": "2023-12-20T03:22:11.422Z", "__row_index": 37}