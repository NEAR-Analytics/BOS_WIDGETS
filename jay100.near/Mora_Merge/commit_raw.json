{"tx_hash": "BJjHXJosVNQdtZq24ZnqbYQwQbQU8zYCfvH81f9RK5mz", "action_id_social": "6FUTp52a34bKFuYr39Du6n9m8VTaGe15m2mHAQHhS1SC-0-widget", "block_id": 107799197, "block_timestamp": "2023-12-13T00:16:03.733Z", "signer_id": "jay100.near", "widget_name": "Mora_Merge", "source_code": "const gameImgArr = [\n  \"https://upload.wikimedia.org/wikipedia/en/d/d0/Dogecoin_Logo.png\",\n  \"https://cdn.iconscout.com/icon/free/png-256/free-ethereum-8-645838.png\",\n  \"https://icons.iconarchive.com/icons/cjdowner/cryptocurrency-flat/512/Tether-USDT-icon.png\",\n  \"https://cdn-icons-png.flaticon.com/512/6001/6001527.png\",\n  \"https://upload.wikimedia.org/wikipedia/commons/thumb/5/58/Bitcoin_Cash.png/600px-Bitcoin_Cash.png?20210403103340\",\n];\n\nconst Game_Box = () => {\n  const code = `\n  <head>\n      <link rel=\"preconnect\" href=\"https://fonts.googleapis.com\">\n<link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin>\n<link href=\"https://fonts.googleapis.com/css2?family=Lugrasimo&family=VT323&display=swap\" rel=\"stylesheet\">\n  </head>\n<style>\n   body {\n    margin: 0;\n    display: flex;\n    align-items: center;\n    height: 80vh;\n    flex-direction: column;\n    overflow: hidden;\n   }\n\n   .score{\n    padding: 1rem;\n    font-size: 1.5rem;\n   }\n\n</style>\n<body>\n</body>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js\" integrity=\"sha512-2r+xZ/Dm8+HI0I8dsj1Jlfchv4O3DGfWbqRalmSGtgdbVQrZyGRqHp9ek8GKk1x8w01JsmDZRrJZ4DzgXkAU+g==\" crossorigin=\"anonymous\" referrerpolicy=\"no-referrer\"></script>\n<script>\n\nlet circleOptions = [];\nlet droppedCircles = [];\nlet groundY;\nlet hoveredCircle = null;\nlet gameStarted = false;\nconst sizes = [10, 20, 40, 80, 100];\nlet gameScore = 0;\nlet canDropCircle = true;\nlet allCircles = [];\nlet timer = 60;\nlet timerInterval;\nlet backgroundImage; // Declare a variable to hold the image\nlet bestScore = 0;\n\nlet imgArr = ['https://upload.wikimedia.org/wikipedia/en/d/d0/Dogecoin_Logo.png','https://cdn.iconscout.com/icon/free/png-256/free-ethereum-8-645838.png', 'https://cdn-icons-png.flaticon.com/512/6001/6001566.png', 'https://cdn-icons-png.flaticon.com/512/6001/6001527.png', 'https://upload.wikimedia.org/wikipedia/commons/thumb/5/58/Bitcoin_Cash.png/600px-Bitcoin_Cash.png?20210403103340']\n\nfunction preload() {\n  for (let i = 0; i < imgArr.length; i++) {\n        const img = loadImage(imgArr[i]);\n        const circleSize = sizes[i];\n        const circle = new Circle(0, 0, circleSize, img, imgArr[i]);\n        circleOptions.push(circle); // Add the circle to the options array\n    }\n}\n\nfunction resetGame() {\n    timer = 60;\n    gameScore = 0;\n    canDropCircle = true;\n    allCircles = [];\n    droppedCircles = [];\n    gameStarted = false;\n}\n\nfunction setup() {\n    createCanvas(350, windowHeight);\n    groundY = height - 5; // Ground position\n    timerInterval = setInterval(() => {\n        if (timer > 0) {\n            timer--;\n        } else {\n            // If the timer reaches 0, stop the timer and prevent circle dropping\n            if(gameScore > bestScore){\n                bestScore = gameScore;\n            }\n            clearInterval(timerInterval);\n            canDropCircle = false;\n            resetGame();\n        }\n    }, 1000); // Update the timer every second (1000 milliseconds)\n}\n\nfunction draw() {\n    background(220);\n\n    textFont(\"VT323\");\n\n    if(!gameStarted){\n        textSize(32);\n        textAlign(CENTER, CENTER);\n        text(\"Click to Start\", width / 2, height / 2);\n        text(\"Best Score: \" + bestScore, width / 2, height / 3);\n    } else {\n\n    textSize(30);\n    fill(0);\n    text(\"Time: \" + timer, 300, 20);\n\n    textSize(30);\n    fill(0, 0, 0);\n    text(\"Score: \" + gameScore, 60, 20);\n\n    if (hoveredCircle) {\n        hoveredCircle.x = mouseX;\n        hoveredCircle.y = 45; // Adjust the y position as needed\n        image(hoveredCircle.texture, hoveredCircle.x - hoveredCircle.radius, hoveredCircle.y - hoveredCircle.radius, hoveredCircle.radius * 2, hoveredCircle.radius * 2);\n    }\n\n    for (let i = 0; i < droppedCircles.length; i++) {\n        droppedCircles[i].display();\n        droppedCircles[i].fall();\n        droppedCircles[i].checkBounds();\n\n        for (let j = i + 1; j < droppedCircles.length; j++) {\n            droppedCircles[i].checkCircleCollision(droppedCircles[j]);\n        }\n    }\n    }\n \n}\n\nfunction mouseClicked() {\n     if (!gameStarted) {\n        // Transition to the game screen upon clicking\n        gameStarted = true;\n        timer = 60; // Reset the timer when the game starts\n        canDropCircle = true; // Reset circle dropping ability\n        droppedCircles = []; // Clear dropped circles\n\n          clearInterval(timerInterval);\n\n        // Start a new timer interval\n        timerInterval = setInterval(() => {\n            if (timer > 0) {\n                timer--;\n            } else {\n                // If the timer reaches 0, stop the timer and prevent circle dropping\n                if(gameScore > bestScore){\n                    bestScore = gameScore;\n                }\n                clearInterval(timerInterval);\n                canDropCircle = false;\n                resetGame();\n            }\n        }, 1000); \n    }\n\n    if (canDropCircle && timer > 0) {\n\n        if (!hoveredCircle) {\n            const pos = Math.floor(Math.random() * 2);\n            hoveredCircle = circleOptions[pos];\n            hoveredCircle.x = mouseX;\n            hoveredCircle.y = 45;\n        } else {\n            let newDroppedCircle = new Circle(hoveredCircle.x, hoveredCircle.y, hoveredCircle.radius, hoveredCircle.texture, hoveredCircle.imageUrl);\n\n            droppedCircles.push(newDroppedCircle); // Add the new dropped circle\n            allCircles.push(newDroppedCircle);\n            hoveredCircle = null; // Reset hoveredCircle\n\n            canDropCircle = false; // Prevent dropping a new circle immediately\n            setTimeout(() => {\n                const newPos = Math.floor(Math.random() * 2);\n                hoveredCircle = circleOptions[newPos];\n                hoveredCircle.x = mouseX;\n                hoveredCircle.y = 45;\n                canDropCircle = true; // Allow dropping a new circle after the delay\n            }, 250); // Adjust the delay duration in milliseconds (here, it's 1 second)\n        }\n    }\n}\n\nclass Circle {\n    constructor(x, y, radius, img, imgUrl) {\n        this.x = x;\n        this.y = y;\n        this.radius = radius;\n        this.speed = 6;\n        this.isFalling = true;\n        this.xSpeed = random(-0.05, 0.05); // Initial random horizontal speed\n        this.ySpeed = 5;\n        this.texture = img; // Use the image as texture\n        this.imageUrl = imgUrl;\n        this.isMerged = false; // Track whether the circle is merged or not\n    }\n\n    display() {\n       if (this.texture) {\n        image(this.texture, this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);\n    } else {\n        // Optionally, draw something else or just the circle without an image\n        ellipse(this.x, this.y, this.radius * 2);\n      }\n    }\n\n    fall() {\n    if (this.isFalling) {\n          this.y += this.ySpeed;\n          this.ySpeed += 0.2; // Simulate gravity\n          this.x += this.xSpeed;\n   \n          // Bounce off walls\n          if (this.x + this.radius >= width || this.x - this.radius <= 0) {\n            this.xSpeed *= -0.1; // Reduce x speed upon wall impact\n          }\n\n          \n          // Check for hitting the ground\n          if (this.y + this.radius >= groundY) {\n            this.y = groundY - this.radius;\n            this.ySpeed *= -0.1; // Reduce y speed upon ground impact (dampening)\n            this.xSpeed *= 0.6; // Reduce x speed upon ground impact\n          }\n    }\n}\n\n    intersects(other) {\n        // Check collision between circles\n        let distance = dist(this.x, this.y, other.x, other.y);\n        return distance < this.radius + other.radius;\n    }\n\n    checkBounds() {\n        if (this.x - this.radius < 0 || this.x + this.radius > width) {\n          this.x = constrain(this.x, this.radius, width - this.radius);\n        }\n        if (this.y - this.radius < 0 || this.y + this.radius > height) {\n          this.y = constrain(this.y, this.radius, height - this.radius);\n        }\n      }\n\n\n    checkCircleCollision(otherCircle) {\n        let dx = this.x - otherCircle.x;\n        let dy = this.y - otherCircle.y;\n        let distanceSquared = dx * dx + dy * dy;\n        let minDistanceSquared = (this.radius + otherCircle.radius) * (this.radius + otherCircle.radius);\n\n        if (distanceSquared <= minDistanceSquared) {\n            let radiusDifference = abs(this.radius - otherCircle.radius);\n            let mergeThreshold = 3; // Set your threshold for merging circles\n\n            // Check conditions for merging circles\n            if (this.imageUrl === otherCircle.imageUrl && radiusDifference <= mergeThreshold) {\n                // Merge circles if they touch and have similar radius\n                let newRadius = this.radius + otherCircle.radius;\n\n                // Increment game score based on the merged circle radius\n                if (newRadius === 20) {\n                    gameScore += 2;\n                    let newCircleOption = circleOptions.filter(circle => circle.radius === newRadius);\n                    this.texture = newCircleOption[0].texture;\n                    this.radius = newCircleOption[0].radius;\n                    this.imageUrl = newCircleOption[0].imageUrl;\n                    otherCircle.removeFromArrays();\n                } else if (newRadius === 40) {\n                    gameScore += 4;\n                    let newCircleOption = circleOptions.filter(circle => circle.radius === newRadius);\n                    this.texture = newCircleOption[0].texture;\n                    this.radius = newCircleOption[0].radius;\n                    this.imageUrl = newCircleOption[0].imageUrl;\n                    otherCircle.removeFromArrays();\n                } else if (newRadius === 80) {\n                    gameScore += 8;\n                     let newCircleOption = circleOptions.filter(circle => circle.radius === newRadius);\n                    this.texture = newCircleOption[0].texture;\n                    this.radius = newCircleOption[0].radius;\n                    this.imageUrl = newCircleOption[0].imageUrl;\n                    otherCircle.removeFromArrays();\n                }\n\n                // Create a new merged circle if the radius exceeds a certain threshold\n                if (newRadius == 160) {\n                    gameScore += 16;\n                    let newCircleOption = circleOptions.filter(circle => circle.radius === 100);\n                    this.texture = newCircleOption[0].texture;\n                    this.radius = newCircleOption[0].radius;\n                    this.imageUrl = newCircleOption[0].imageUrl;\n                    otherCircle.removeFromArrays();\n                    \n                }\n\n                if(newRadius > 160){\n                  gameScore += 32;\n                    let mergedCircle = new Circle(this.x, this.y, newRadius, this.texture, this.imageUrl);\n                    allCircles = allCircles.filter(circle => circle !== this && circle !== otherCircle);\n                    allCircles.push(mergedCircle);\n                    this.removeFromArrays();\n                    otherCircle.removeFromArrays();\n                }\n\n\n            } else {\n                // Resolve collision as a bounce\n                this.resolveCollision(otherCircle);\n            }\n        }\n    }\n\n    removeFromArrays() {\n        // Remove this circle from both arrays\n        const droppedIndex = droppedCircles.indexOf(this);\n        if (droppedIndex !== -1) {\n            droppedCircles.splice(droppedIndex, 1);\n        }\n\n        const allIndex = allCircles.indexOf(this);\n        if (allIndex !== -1) {\n            allCircles.splice(allIndex, 1);\n        }\n    }\n\n     removeImage() {\n        this.texture = null; // or this.texture = ''; depending on your implementation\n    }\n\n    resolveCollision(other) {\n        let dx = other.x - this.x;\n        let dy = other.y - this.y;\n        let distance = sqrt(dx * dx + dy * dy);\n   \n        // Calculate the minimum translation distance to separate droppedCircles\n        let minDistance = this.radius + other.radius;\n        let separationX = dx / distance * (minDistance - distance);\n        let separationY = dy / distance * (minDistance - distance);\n\n   \n        // Move droppedCircles apart to avoid overlap\n        this.x -= separationX / 2;\n        this.y -= separationY / 2;\n        other.x += separationX / 2;\n        other.y += separationY / 2;\n\n\n        // Update velocities for a bounce effect with mass consideration\n\n         // let massFactor = 0.03;\n        // let forceFactor = (this.radius - other.radius) * massFactor;\n\n    // Update velocities for a bounce effect with mass consideration\n    // Modify this part accordingly to suit your specific behavior\n\n    let angle = atan2(dy, dx);\n    let thisSpeed = sqrt(this.xSpeed * this.xSpeed + this.ySpeed * this.ySpeed);\n    let otherSpeed = sqrt(other.xSpeed * other.xSpeed + other.ySpeed * other.ySpeed);\n    let thisDirection = atan2(this.ySpeed, this.xSpeed);\n    let otherDirection = atan2(other.ySpeed, other.xSpeed);\n\n\n    // this(thisSpeed - forceFactor)\n    // other(thisSpeed + forceFactor)\n    let newThisXSpeed = otherSpeed * cos(otherDirection - angle) * cos(angle) + (thisSpeed) * sin(thisDirection - angle) * cos(angle + HALF_PI);\n    let newThisYSpeed = otherSpeed * cos(otherDirection - angle) * sin(angle) + (thisSpeed) * sin(thisDirection - angle) * sin(angle + HALF_PI);\n    let newOtherXSpeed = (thisSpeed) * cos(thisDirection - angle) * cos(angle) + otherSpeed * sin(otherDirection - angle) * cos(angle + HALF_PI);\n    let newOtherYSpeed = (thisSpeed) * cos(thisDirection - angle) * sin(angle) + otherSpeed * sin(otherDirection - angle) * sin(angle + HALF_PI);\n\n    this.xSpeed = newThisXSpeed;\n    this.ySpeed = newThisYSpeed;\n    other.xSpeed = newOtherXSpeed;\n    other.ySpeed = newOtherYSpeed;\n\n      }\n\n}\n\n</script>\n`;\n\n  return (\n    <div\n      style={{\n        width: \"100%\",\n        height: \"85%\",\n        display: \"flex\",\n        flexDirection: \"column\",\n      }}\n      className=\"mx-3\"\n    >\n      {\" \"}\n      <iframe className=\"w-100 h-100\" srcDoc={code} />\n    </div>\n  );\n};\n\nreturn (\n  <div\n    style={{\n      height: \"100vh\",\n      display: \"flex\",\n      alignItems: \"center\",\n      justifyContent: \"space-evenly\",\n      flexDirection: \"column\",\n      margin: \"auto\",\n    }}\n    className=\"w-100\"\n  >\n    <Game_Box />\n    <div\n      style={{\n        width: \"100%\",\n        display: \"flex\",\n        flexDirection: \"column\",\n        justifyContent: \"space-evenly\",\n        alignItems: \"center\",\n      }}\n    >\n      <h1>Mora Merge</h1>\n      <span>\n        <img src={gameImgArr[0]} style={{ width: \"30px\" }} /> {\">\"}{\" \"}\n        <img src={gameImgArr[1]} style={{ width: \"30px\" }} /> {\">\"}{\" \"}\n        <img src={gameImgArr[2]} style={{ width: \"30px\" }} /> {\">\"}{\" \"}\n        <img src={gameImgArr[3]} style={{ width: \"30px\" }} /> {\">\"}{\" \"}\n        <img src={gameImgArr[4]} style={{ width: \"30px\" }} /> {\" \"}\n      </span>\n      <p>\n        Mora Merge, is a Tetris like game inspired by the popular Suika Game aka Watermelon Game. Players must stack and combine the\n        various coins before the time runs out, Coins of the same kind can\n        combine and become larger coins, which increase the player's score.\n      </p>\n    </div>\n  </div>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/jay100.near/widget/Mora_Merge", "fact_widget_deployments_id": "376117676457aeed25f432b7d432370e", "inserted_timestamp": "2023-12-13T02:11:05.028Z", "modified_timestamp": "2023-12-20T03:22:11.422Z", "__row_index": 2}