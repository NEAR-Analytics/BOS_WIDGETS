{"tx_hash": "FZEKFHCWANAZaBjbBXXcyEpeMch9UxNbtMyTX9fkvuBS", "action_id_social": "FzD1LLQvC8kgUEubvNFTFAcf5wBYajTE17Uac9C3A4Ap-0-widget", "block_id": 107567023, "block_timestamp": "2023-12-10T03:20:07.389Z", "signer_id": "jay100.near", "widget_name": "Mora_Merge", "source_code": "State.init({\n  score: 0,\n});\n\nconst Game_Box = () => {\n  const code = `\n  <head>\n      <link rel=\"preconnect\" href=\"https://fonts.googleapis.com\">\n<link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin>\n<link href=\"https://fonts.googleapis.com/css2?family=Lugrasimo&family=VT323&display=swap\" rel=\"stylesheet\">\n  </head>\n<style>\n   body {\n   margin: 0;\n   display: flex;\n   align-items: center;\n   height: 80vh;\n   flex-direction: column;\n   }\n\n   .score{\n    padding: 1rem;\n    font-size: 1.5rem;\n   }\n\n</style>\n<body>\n</body>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js\" integrity=\"sha512-2r+xZ/Dm8+HI0I8dsj1Jlfchv4O3DGfWbqRalmSGtgdbVQrZyGRqHp9ek8GKk1x8w01JsmDZRrJZ4DzgXkAU+g==\" crossorigin=\"anonymous\" referrerpolicy=\"no-referrer\"></script>\n<script>\n\n\nlet droppedCircles = [];\nlet groundY;\nlet hoveredCircle = null;\nconst sizes = [10, 20, 40];\nlet gameScore = 0;\nlet canDropCircle = true;\nlet allCircles = [];\nlet timer = 60;\nlet timerInterval;\nlet backgroundImage; // Declare a variable to hold the image\n\nlet imgArr = ['https://coinpush.app/wp-content/uploads/2023/03/bitcoin-png-1.png', 'https://cdn.iconscout.com/icon/free/png-256/free-ethereum-8-645838.png', 'https://upload.wikimedia.org/wikipedia/en/d/d0/Dogecoin_Logo.png']\n\nfunction preload() {\n    // Load your image before the program starts\n    const randPos = Math.floor(Math.random() * imgArr.length);\n    backgroundImage = loadImage(imgArr[randPos]); // Replace 'path_to_your_image.jpg' with your image file\n}\n\nfunction setup() {\n    createCanvas(350, windowHeight * 0.95);\n    groundY = height - 5; // Ground position\n    timerInterval = setInterval(() => {\n        if (timer > 0) {\n            timer--;\n        } else {\n            // If the timer reaches 0, stop the timer and prevent circle dropping\n            clearInterval(timerInterval);\n            canDropCircle = false;\n        }\n    }, 1000); // Update the timer every second (1000 milliseconds)\n}\n\nfunction draw() {\n    background(220);\n\n    textFont(\"VT323\");\n\n    textSize(30);\n    fill(0);\n    text(\"Time: \" + timer, 250, 20);\n\n    textSize(30);\n    fill(0, 0, 0);\n    text(\"Score: \" + gameScore, 20, 20);\n\n    if (hoveredCircle) {\n        hoveredCircle.x = mouseX;\n        hoveredCircle.y = 45; // Adjust the y position as needed\n        image(hoveredCircle.texture, hoveredCircle.x - hoveredCircle.radius, hoveredCircle.y - hoveredCircle.radius, hoveredCircle.radius * 2, hoveredCircle.radius * 2);\n    }\n\n    for (let i = 0; i < droppedCircles.length; i++) {\n        droppedCircles[i].display();\n        droppedCircles[i].fall();\n        droppedCircles[i].checkBounds();\n\n        for (let j = i + 1; j < droppedCircles.length; j++) {\n            droppedCircles[i].checkCircleCollision(droppedCircles[j]);\n        }\n    }\n}\n\nfunction mouseClicked() {\n    if (canDropCircle && timer > 0) {\n        const randSizePos = Math.floor(Math.random() * 3);\n\n        if (!hoveredCircle) {\n            const randImg = loadImage(imgArr[Math.floor(Math.random() * imgArr.length)]);\n            hoveredCircle = new Circle(mouseX, 45, sizes[randSizePos], randImg);\n        } else {\n            let newDroppedCircle = new Circle(hoveredCircle.x, hoveredCircle.y, hoveredCircle.radius, hoveredCircle.texture);\n\n            droppedCircles.push(newDroppedCircle); // Add the new dropped circle\n            allCircles.push(newDroppedCircle);\n            hoveredCircle = null; // Reset hoveredCircle\n\n            canDropCircle = false; // Prevent dropping a new circle immediately\n            setTimeout(() => {\n                const newRandSizePos = Math.floor(Math.random() * 3);\n                const newBackImg = loadImage(imgArr[Math.floor(Math.random() * imgArr.length)]);\n                hoveredCircle = new Circle(mouseX, 45, sizes[newRandSizePos], newBackImg);\n                canDropCircle = true; // Allow dropping a new circle after the delay\n            }, 500); // Adjust the delay duration in milliseconds (here, it's 1 second)\n        }\n    }\n}\n\nclass Circle {\n    constructor(x, y, radius, img) {\n        this.x = x;\n        this.y = y;\n        this.radius = radius;\n        this.speed = 6;\n        this.isFalling = true;\n        this.xSpeed = random(0, 0); // Initial random horizontal speed\n        this.ySpeed = 5;\n        this.texture = img; // Use the image as texture\n        this.isMerged = false; // Track whether the circle is merged or not\n    }\n\n    display() {\n        image(this.texture, this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);\n    }\n\n    fall() {\n    if (this.isFalling) {\n          this.y += this.ySpeed;\n          this.ySpeed += 0.2; // Simulate gravity\n          this.x += this.xSpeed;\n   \n          // Bounce off walls\n          if (this.x + this.radius >= width || this.x - this.radius <= 0) {\n            this.xSpeed *= -0.1; // Reduce x speed upon wall impact\n          }\n\n          \n          // Check for hitting the ground\n          if (this.y + this.radius >= groundY) {\n            this.y = groundY - this.radius;\n            this.ySpeed *= -0.1; // Reduce y speed upon ground impact (dampening)\n            this.xSpeed *= 0.6; // Reduce x speed upon ground impact\n          }\n    }\n}\n\n    intersects(other) {\n        // Check collision between circles\n        let distance = dist(this.x, this.y, other.x, other.y);\n        return distance < this.radius + other.radius;\n    }\n\n    checkBounds() {\n        if (this.x - this.radius < 0 || this.x + this.radius > width) {\n          this.x = constrain(this.x, this.radius, width - this.radius);\n        }\n        if (this.y - this.radius < 0 || this.y + this.radius > height) {\n          this.y = constrain(this.y, this.radius, height - this.radius);\n        }\n      }\n\n\n    checkCircleCollision(otherCircle) {\n        let dx = this.x - otherCircle.x;\n        let dy = this.y - otherCircle.y;\n        let distanceSquared = dx * dx + dy * dy;\n        let minDistanceSquared = (this.radius + otherCircle.radius) * (this.radius + otherCircle.radius);\n\n        if (distanceSquared <= minDistanceSquared) {\n            let radiusDifference = abs(this.radius - otherCircle.radius);\n            let mergeThreshold = 3; // Set your threshold for merging circles\n\n            // Check conditions for merging circles\n            console.log('this', this);\n            console.log('other', otherCircle);\n            if (this.texture.src === otherCircle.texture.src && radiusDifference <= mergeThreshold) {\n                // Merge circles if they touch and have similar radius\n                let newRadius = this.radius + otherCircle.radius;\n\n                // Increment game score based on the merged circle radius\n                if (newRadius === 20) {\n                    gameScore += 2;\n                } else if (newRadius === 40) {\n                    gameScore += 4;\n                } else if (newRadius === 80) {\n                    gameScore += 8;\n                } else if (newRadius === 160) {\n                    gameScore += 16;\n                }\n\n                // Create a new merged circle if the radius exceeds a certain threshold\n                if (newRadius >= 160) {\n                    let mergedCircle = new Circle(this.x, this.y, newRadius, backgroundImage);\n                    allCircles = allCircles.filter(circle => circle !== this && circle !== otherCircle);\n                    allCircles.push(mergedCircle);\n                    this.radius = 0; // Set current circle's radius to zero\n                    otherCircle.radius = 0; // Set other circle's radius to zero\n                } else {\n                    this.radius = newRadius;\n                    otherCircle.radius = 0;\n                    allCircles = allCircles.filter(circle => circle !== otherCircle);\n                }\n            } else {\n                // Resolve collision as a bounce\n                this.resolveCollision(otherCircle);\n            }\n        }\n    }\n\n    resolveCollision(other) {\n        let dx = other.x - this.x;\n        let dy = other.y - this.y;\n        let distance = sqrt(dx * dx + dy * dy);\n   \n        // Calculate the minimum translation distance to separate droppedCircles\n        let minDistance = this.radius + other.radius;\n        let separationX = dx / distance * (minDistance - distance);\n        let separationY = dy / distance * (minDistance - distance);\n\n   \n        // Move droppedCircles apart to avoid overlap\n        this.x -= separationX / 2;\n        this.y -= separationY / 2;\n        other.x += separationX / 2;\n        other.y += separationY / 2;\n\n\n        // Update velocities for a bounce effect with mass consideration\n\n         // let massFactor = 0.03;\n        // let forceFactor = (this.radius - other.radius) * massFactor;\n\n    // Update velocities for a bounce effect with mass consideration\n    // Modify this part accordingly to suit your specific behavior\n\n    let angle = atan2(dy, dx);\n    let thisSpeed = sqrt(this.xSpeed * this.xSpeed + this.ySpeed * this.ySpeed);\n    let otherSpeed = sqrt(other.xSpeed * other.xSpeed + other.ySpeed * other.ySpeed);\n    let thisDirection = atan2(this.ySpeed, this.xSpeed);\n    let otherDirection = atan2(other.ySpeed, other.xSpeed);\n\n\n    // this(thisSpeed - forceFactor)\n    // other(thisSpeed + forceFactor)\n    let newThisXSpeed = otherSpeed * cos(otherDirection - angle) * cos(angle) + (thisSpeed) * sin(thisDirection - angle) * cos(angle + HALF_PI);\n    let newThisYSpeed = otherSpeed * cos(otherDirection - angle) * sin(angle) + (thisSpeed) * sin(thisDirection - angle) * sin(angle + HALF_PI);\n    let newOtherXSpeed = (thisSpeed) * cos(thisDirection - angle) * cos(angle) + otherSpeed * sin(otherDirection - angle) * cos(angle + HALF_PI);\n    let newOtherYSpeed = (thisSpeed) * cos(thisDirection - angle) * sin(angle) + otherSpeed * sin(otherDirection - angle) * sin(angle + HALF_PI);\n\n    this.xSpeed = newThisXSpeed;\n    this.ySpeed = newThisYSpeed;\n    other.xSpeed = newOtherXSpeed;\n    other.ySpeed = newOtherYSpeed;\n\n      }\n\n}\n\n</script>\n`;\n\n  return (\n    <div\n      style={{ height: \"35rem\", display: \"flex\", flexDirection: \"column\" }}\n      className=\"mx-auto\"\n    >\n      {\" \"}\n      <iframe className=\"w-100 h-100\" srcDoc={code} />\n    </div>\n  );\n};\n\nreturn (\n  <div style={{ width: \"100%\", height: \"100%\", background: \"blue\" }}>\n    <Game_Box />\n  </div>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/jay100.near/widget/Mora_Merge", "fact_widget_deployments_id": "89dfb18d874d6e5a6c4d59e66d95682a", "inserted_timestamp": "2023-12-10T05:22:53.925Z", "modified_timestamp": "2023-12-20T03:22:11.422Z", "__row_index": 28}