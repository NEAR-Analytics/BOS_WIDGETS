{"tx_hash": "8Pfu9ByiTLtqgLY4ZPeF42ks59yAxQjHoAVDWM5f3B5r", "action_id_social": "VPViRJKoQwj9WgtVYVpseTnvgzbBaCntczNX18wV9Wk-0-widget", "block_id": 107626574, "block_timestamp": "2023-12-10T21:06:17.450Z", "signer_id": "jay100.near", "widget_name": "Mora_Merge", "source_code": "State.init({\r\n  score: 0,\r\n});\r\n\r\nconst Game_Box = () => {\r\n  const code = `\r\n  <head>\r\n      <link rel=\"preconnect\" href=\"https://fonts.googleapis.com\">\r\n<link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin>\r\n<link href=\"https://fonts.googleapis.com/css2?family=Lugrasimo&family=VT323&display=swap\" rel=\"stylesheet\">\r\n  </head>\r\n<style>\r\n   body {\r\n   margin: 0;\r\n   display: flex;\r\n   align-items: center;\r\n   height: 80vh;\r\n   flex-direction: column;\r\n   }\r\n\r\n   .score{\r\n    padding: 1rem;\r\n    font-size: 1.5rem;\r\n   }\r\n\r\n</style>\r\n<body>\r\n</body>\r\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js\" integrity=\"sha512-2r+xZ/Dm8+HI0I8dsj1Jlfchv4O3DGfWbqRalmSGtgdbVQrZyGRqHp9ek8GKk1x8w01JsmDZRrJZ4DzgXkAU+g==\" crossorigin=\"anonymous\" referrerpolicy=\"no-referrer\"></script>\r\n<script>\r\n\r\n\r\nlet droppedCircles = [];\r\nlet groundY;\r\nlet hoveredCircle = null;\r\nconst sizes = [10, 20, 40];\r\nlet gameScore = 0;\r\nlet canDropCircle = true;\r\nlet allCircles = [];\r\nlet timer = 60;\r\nlet timerInterval;\r\nlet backgroundImage; // Declare a variable to hold the image\r\n\r\nlet imgArr = ['https://coinpush.app/wp-content/uploads/2023/03/bitcoin-png-1.png', 'https://cdn.iconscout.com/icon/free/png-256/free-ethereum-8-645838.png', 'https://upload.wikimedia.org/wikipedia/en/d/d0/Dogecoin_Logo.png']\r\n\r\nfunction preload() {\r\n    // Load your image before the program starts\r\n    const randPos = Math.floor(Math.random() * imgArr.length);\r\n    backgroundImage = loadImage(imgArr[randPos]); // Replace 'path_to_your_image.jpg' with your image file\r\n}\r\n\r\nfunction setup() {\r\n    createCanvas(350, windowHeight * 0.95);\r\n    groundY = height - 5; // Ground position\r\n    timerInterval = setInterval(() => {\r\n        if (timer > 0) {\r\n            timer--;\r\n        } else {\r\n            // If the timer reaches 0, stop the timer and prevent circle dropping\r\n            clearInterval(timerInterval);\r\n            canDropCircle = false;\r\n        }\r\n    }, 1000); // Update the timer every second (1000 milliseconds)\r\n}\r\n\r\nfunction draw() {\r\n    background(220);\r\n\r\n    textFont(\"VT323\");\r\n\r\n    textSize(30);\r\n    fill(0);\r\n    text(\"Time: \" + timer, 250, 20);\r\n\r\n    textSize(30);\r\n    fill(0, 0, 0);\r\n    text(\"Score: \" + gameScore, 20, 20);\r\n\r\n    if (hoveredCircle) {\r\n        hoveredCircle.x = mouseX;\r\n        hoveredCircle.y = 45; // Adjust the y position as needed\r\n        image(hoveredCircle.texture, hoveredCircle.x - hoveredCircle.radius, hoveredCircle.y - hoveredCircle.radius, hoveredCircle.radius * 2, hoveredCircle.radius * 2);\r\n    }\r\n\r\n    for (let i = 0; i < droppedCircles.length; i++) {\r\n        droppedCircles[i].display();\r\n        droppedCircles[i].fall();\r\n        droppedCircles[i].checkBounds();\r\n\r\n        for (let j = i + 1; j < droppedCircles.length; j++) {\r\n            droppedCircles[i].checkCircleCollision(droppedCircles[j]);\r\n        }\r\n    }\r\n}\r\n\r\nfunction mouseClicked() {\r\n\r\n    if (canDropCircle && timer > 0) {\r\n        const randSizePos = Math.floor(Math.random() * 3);\r\n\r\n        if (!hoveredCircle) {\r\n            const pos = Math.floor(Math.random() * imgArr.length);\r\n            const randImg = loadImage(imgArr[pos]);\r\n            console.log(imgArr[pos]);\r\n            hoveredCircle = new Circle(mouseX, 45, sizes[randSizePos], randImg, imgArr[pos]);\r\n            console.log(hoveredCircle);\r\n        } else {\r\n            let newDroppedCircle = new Circle(hoveredCircle.x, hoveredCircle.y, hoveredCircle.radius, hoveredCircle.texture, hoveredCircle.imageUrl);\r\n\r\n            droppedCircles.push(newDroppedCircle); // Add the new dropped circle\r\n            allCircles.push(newDroppedCircle);\r\n            hoveredCircle = null; // Reset hoveredCircle\r\n\r\n            canDropCircle = false; // Prevent dropping a new circle immediately\r\n            setTimeout(() => {\r\n                const newRandSizePos = Math.floor(Math.random() * 3);\r\n                const newPos = Math.floor(Math.random() * imgArr.length);\r\n                const newBackImg = loadImage(imgArr[newPos]);\r\n                hoveredCircle = new Circle(mouseX, 45, sizes[newRandSizePos], newBackImg, imgArr[newPos]);\r\n                canDropCircle = true; // Allow dropping a new circle after the delay\r\n            }, 500); // Adjust the delay duration in milliseconds (here, it's 1 second)\r\n        }\r\n    }\r\n}\r\n\r\nclass Circle {\r\n    constructor(x, y, radius, img, imgUrl) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.radius = radius;\r\n        this.speed = 6;\r\n        this.isFalling = true;\r\n        this.xSpeed = random(0, 0); // Initial random horizontal speed\r\n        this.ySpeed = 5;\r\n        this.texture = img; // Use the image as texture\r\n        this.imageUrl = imgUrl;\r\n        this.isMerged = false; // Track whether the circle is merged or not\r\n    }\r\n\r\n    display() {\r\n       if (this.texture) {\r\n        image(this.texture, this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);\r\n    } else {\r\n        // Optionally, draw something else or just the circle without an image\r\n        ellipse(this.x, this.y, this.radius * 2);\r\n    }\r\n    }\r\n\r\n    fall() {\r\n    if (this.isFalling) {\r\n          this.y += this.ySpeed;\r\n          this.ySpeed += 0.2; // Simulate gravity\r\n          this.x += this.xSpeed;\r\n   \r\n          // Bounce off walls\r\n          if (this.x + this.radius >= width || this.x - this.radius <= 0) {\r\n            this.xSpeed *= -0.1; // Reduce x speed upon wall impact\r\n          }\r\n\r\n          \r\n          // Check for hitting the ground\r\n          if (this.y + this.radius >= groundY) {\r\n            this.y = groundY - this.radius;\r\n            this.ySpeed *= -0.1; // Reduce y speed upon ground impact (dampening)\r\n            this.xSpeed *= 0.6; // Reduce x speed upon ground impact\r\n          }\r\n    }\r\n}\r\n\r\n    intersects(other) {\r\n        // Check collision between circles\r\n        let distance = dist(this.x, this.y, other.x, other.y);\r\n        return distance < this.radius + other.radius;\r\n    }\r\n\r\n    checkBounds() {\r\n        if (this.x - this.radius < 0 || this.x + this.radius > width) {\r\n          this.x = constrain(this.x, this.radius, width - this.radius);\r\n        }\r\n        if (this.y - this.radius < 0 || this.y + this.radius > height) {\r\n          this.y = constrain(this.y, this.radius, height - this.radius);\r\n        }\r\n      }\r\n\r\n\r\n    checkCircleCollision(otherCircle) {\r\n        let dx = this.x - otherCircle.x;\r\n        let dy = this.y - otherCircle.y;\r\n        let distanceSquared = dx * dx + dy * dy;\r\n        let minDistanceSquared = (this.radius + otherCircle.radius) * (this.radius + otherCircle.radius);\r\n\r\n        if (distanceSquared <= minDistanceSquared) {\r\n            let radiusDifference = abs(this.radius - otherCircle.radius);\r\n            let mergeThreshold = 3; // Set your threshold for merging circles\r\n\r\n            // Check conditions for merging circles\r\n            console.log('this', this);\r\n            console.log('other', otherCircle);\r\n            if (this.imageUrl === otherCircle.imageUrl && radiusDifference <= mergeThreshold && this.radius === otherCircle.radius) {\r\n                // Merge circles if they touch and have similar radius\r\n                let newRadius = this.radius + otherCircle.radius;\r\n\r\n                // Increment game score based on the merged circle radius\r\n                if (newRadius === 20) {\r\n                    gameScore += 2;\r\n                } else if (newRadius === 40) {\r\n                    gameScore += 4;\r\n                } else if (newRadius === 80) {\r\n                    gameScore += 8;\r\n                } else if (newRadius === 160) {\r\n                    gameScore += 16;\r\n                }\r\n\r\n                // Create a new merged circle if the radius exceeds a certain threshold\r\n                if (newRadius >= 160) {\r\n                    let mergedCircle = new Circle(this.x, this.y, newRadius, backgroundImage, this.imageUrl);\r\n                    allCircles = allCircles.filter(circle => circle !== this && circle !== otherCircle);\r\n                    allCircles.push(mergedCircle);\r\n                    this.radius = 0; // Set current circle's radius to zero\r\n                    this.removeImage();\r\n                    otherCircle.radius = 0;// Set other circle's radius to zero\r\n                    otherCircle.removeImage(); \r\n                } else {\r\n                    this.radius = newRadius;\r\n                    otherCircle.radius = 0;\r\n                    otherCircle.removeImage();\r\n                    allCircles = allCircles.filter(circle => circle !== otherCircle);\r\n                }\r\n            } else {\r\n                // Resolve collision as a bounce\r\n                this.resolveCollision(otherCircle);\r\n            }\r\n        }\r\n    }\r\n\r\n     removeImage() {\r\n        this.texture = null; // or this.texture = ''; depending on your implementation\r\n    }\r\n\r\n    resolveCollision(other) {\r\n        let dx = other.x - this.x;\r\n        let dy = other.y - this.y;\r\n        let distance = sqrt(dx * dx + dy * dy);\r\n   \r\n        // Calculate the minimum translation distance to separate droppedCircles\r\n        let minDistance = this.radius + other.radius;\r\n        let separationX = dx / distance * (minDistance - distance);\r\n        let separationY = dy / distance * (minDistance - distance);\r\n\r\n   \r\n        // Move droppedCircles apart to avoid overlap\r\n        this.x -= separationX / 2;\r\n        this.y -= separationY / 2;\r\n        other.x += separationX / 2;\r\n        other.y += separationY / 2;\r\n\r\n\r\n        // Update velocities for a bounce effect with mass consideration\r\n\r\n         // let massFactor = 0.03;\r\n        // let forceFactor = (this.radius - other.radius) * massFactor;\r\n\r\n    // Update velocities for a bounce effect with mass consideration\r\n    // Modify this part accordingly to suit your specific behavior\r\n\r\n    let angle = atan2(dy, dx);\r\n    let thisSpeed = sqrt(this.xSpeed * this.xSpeed + this.ySpeed * this.ySpeed);\r\n    let otherSpeed = sqrt(other.xSpeed * other.xSpeed + other.ySpeed * other.ySpeed);\r\n    let thisDirection = atan2(this.ySpeed, this.xSpeed);\r\n    let otherDirection = atan2(other.ySpeed, other.xSpeed);\r\n\r\n\r\n    // this(thisSpeed - forceFactor)\r\n    // other(thisSpeed + forceFactor)\r\n    let newThisXSpeed = otherSpeed * cos(otherDirection - angle) * cos(angle) + (thisSpeed) * sin(thisDirection - angle) * cos(angle + HALF_PI);\r\n    let newThisYSpeed = otherSpeed * cos(otherDirection - angle) * sin(angle) + (thisSpeed) * sin(thisDirection - angle) * sin(angle + HALF_PI);\r\n    let newOtherXSpeed = (thisSpeed) * cos(thisDirection - angle) * cos(angle) + otherSpeed * sin(otherDirection - angle) * cos(angle + HALF_PI);\r\n    let newOtherYSpeed = (thisSpeed) * cos(thisDirection - angle) * sin(angle) + otherSpeed * sin(otherDirection - angle) * sin(angle + HALF_PI);\r\n\r\n    this.xSpeed = newThisXSpeed;\r\n    this.ySpeed = newThisYSpeed;\r\n    other.xSpeed = newOtherXSpeed;\r\n    other.ySpeed = newOtherYSpeed;\r\n\r\n      }\r\n\r\n}\r\n\r\n</script>\r\n`;\r\n\r\n  return (\r\n    <div\r\n      style={{ height: \"35rem\", display: \"flex\", flexDirection: \"column\" }}\r\n      className=\"mx-auto\"\r\n    >\r\n      {\" \"}\r\n      <iframe className=\"w-100 h-100\" srcDoc={code} />\r\n    </div>\r\n  );\r\n};\r\n\r\nreturn (\r\n  <div style={{ width: \"100%\", height: \"100%\", background: \"blue\" }}>\r\n    <Game_Box />\r\n  </div>\r\n);\r\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/jay100.near/widget/Mora_Merge", "fact_widget_deployments_id": "3c2b5442ae0eb052ae072c1c446ae461", "inserted_timestamp": "2023-12-10T22:53:26.673Z", "modified_timestamp": "2023-12-20T03:22:11.422Z", "__row_index": 29}