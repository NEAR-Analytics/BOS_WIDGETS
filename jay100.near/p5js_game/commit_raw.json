{"tx_hash": "7yitNiGZ5i6UChY7PqsLyBmUiuby2PcEmBCaQSCEgWiv", "action_id_social": "E8KrkHhtQUTWwRm33wZS4oPwmVX4SL81fARMu1jBSogL-0-widget", "block_id": 107314049, "block_timestamp": "2023-12-06T22:39:38.414Z", "signer_id": "jay100.near", "widget_name": "p5js_game", "source_code": "const Game_Box = () => {\nconst code = `\n<style>\n   body {\n   margin: 0;\n   display: flex;\n   align-items: center;\n   justify-content: center;\n   height: 80vh;\n   }\n</style>\n<body>\n</body>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js\" integrity=\"sha512-2r+xZ/Dm8+HI0I8dsj1Jlfchv4O3DGfWbqRalmSGtgdbVQrZyGRqHp9ek8GKk1x8w01JsmDZRrJZ4DzgXkAU+g==\" crossorigin=\"anonymous\" referrerpolicy=\"no-referrer\"></script>\n<script>\n\n    let circles = [];\n   let droppedCircles = [];\n   let groundY;\n   let nextCircleColor = { r: 255, g: 0, b: 0 }; // Color of the next circle to be dropped\n   let lastDroppedCircleColor = { r: 255, g: 0, b: 0 }; // Color of the last dropped circle\n   let hoveredCircle = null;\n   \n   \n   // console.log('nxt', nextCircleColor);\n   // console.log('lst', lastDroppedCircleColor);\n   // console.log('hovCircle', hoveredCircle);\n   \n   const generateRandColor = () => {\n    let circleColors = [{r: 255, g: 0, b: 0},{r: 0, g: 255, b: 0},{r: 0, g: 0, b: 255}]\n   \n     let randPos = Math.floor(Math.random() * circleColors.length)\n   \n    return circleColors[randPos]\n   }\n   \n   const generateGameCircles = () => {\n    const sizes = [15, 20, 25]\n   \n    const gameCircles = sizes.map((size) => {\n      const circle = new Circle(mouseX, 100, {r: 255, b: 0, g: 0});\n   \n      circle.radius = size;\n   \n      return circle;\n    })\n    return gameCircles;\n    }\n   \n   \n   function setup() {\n      createCanvas(windowWidth, windowHeight);\n      groundY = height; // Ground position\n    }\n   \n    function draw() {\n      background(220);\n   \n      let mouseYPos = mouseY;\n      stroke(0);\n      line(mouseX, 0, mouseX, windowHeight);\n   \n      if (hoveredCircle) {\n          fill(hoveredCircle.color.r, hoveredCircle.color.g, hoveredCircle.color.b);\n          ellipse(mouseX, 90, 50, 50); // Display the hovered circle at the top of the box\n      }      \n   \n      for (let i = 0; i < droppedCircles.length; i++) {\n        droppedCircles[i].display();\n        droppedCircles[i].fall();\n        droppedCircles[i].checkBounds();\n   \n        // Check for collision with other droppedCircles\n        droppedCircles[i].checkCollision();\n   \n         for (let j = i + 1; j < droppedCircles.length; j++) {\n            droppedCircles[i].checkCircleCollision(droppedCircles[j]);\n        }\n      }\n    }\n   \n    function mouseClicked() {\n        if (!hoveredCircle) {\n          hoveredCircle = new Circle(mouseX, 90, generateRandColor());\n          console.log('createHoveredCircle', hoveredCircle);\n        } else {\n   \n          let newCircle = new Circle(mouseX, 100, hoveredCircle.color); // Create a new circle with the color of the last hovered circle\n          console.log('newCircle', newCircle);\n   \n          droppedCircles.push(newCircle);\n          console.log('circArr', droppedCircles);\n   \n          hoveredCircle = new Circle(mouseX, 90, generateRandColor()); // Generate a new color for the hovered circle\n          // console.log('update Hovered', hoveredCircle);\n   \n        }\n     }\n   \n     class Circle {\n      constructor(x, y, color) {\n        this.x = x;\n        this.y = y;\n        this.radius = 25;\n        this.speed = 6;\n        this.isFalling = true;\n        this.xSpeed = random(-0.5, 0.5); // Initial random horizontal speed\n        this.ySpeed = 0;\n        this.color = color;\n      }\n   \n      display() {\n        fill(this.color.r, this.color.b, this.color.g);\n        ellipse(this.x, this.y, this.radius * 2);\n      }\n   \n      fall() {\n        if (this.isFalling) {\n          this.y += this.ySpeed;\n          this.ySpeed += 0.1; // Simulate gravity\n          this.x += this.xSpeed;\n   \n          // Bounce off walls\n          if (this.x + this.radius >= width || this.x - this.radius <= 0) {\n            this.xSpeed *= -0.8; // Reduce x speed upon wall impact\n          }\n   \n           // Check for hitting another circle\n          for (let j = 0; j < droppedCircles.length; j++) {\n            if (this !== droppedCircles[j] && this.intersects(droppedCircles[j])) {\n              this.resolveCollision(droppedCircles[j]);\n            }\n          }\n   \n          // Check for hitting the ground\n          if (this.y + this.radius >= groundY) {\n            this.y = groundY - this.radius;\n            this.ySpeed *= -0.1; // Reduce y speed upon ground impact (dampening)\n            this.xSpeed *= 0.6; // Reduce x speed upon ground impact\n          }\n        }\n      }\n   \n      checkCollision() {\n        for (let j = 0; j < droppedCircles.length; j++) {\n          if (this !== droppedCircles[j] && this.intersects(droppedCircles[j])) {\n            this.checkCircleCollision(droppedCircles[j]);\n          }\n        }\n      }\n   \n      checkBounds() {\n        if (this.x - this.radius < 0 || this.x + this.radius > width) {\n          this.x = constrain(this.x, this.radius, width - this.radius);\n        }\n        if (this.y - this.radius < 0 || this.y + this.radius > height) {\n          this.y = constrain(this.y, this.radius, height - this.radius);\n        }\n      }\n   \n      intersects(other) {\n        let distance = dist(this.x, this.y, other.x, other.y);\n        return distance < this.radius + other.radius;\n      }\n   \n      stopFalling() {\n        this.isFalling = false;\n      }\n   \n      checkCircleCollision(otherCircle) {\n            let dx = this.x - otherCircle.x;\n            let dy = this.y - otherCircle.y;\n            let distanceSquared = dx * dx + dy * dy;\n   \n            let minDistanceSquared = (this.radius + otherCircle.radius) * (this.radius + otherCircle.radius);\n   \n            if (distanceSquared <= minDistanceSquared) {\n                if (this.color.r === otherCircle.color.r &&\n                    this.color.g === otherCircle.color.g &&\n                    this.color.b === otherCircle.color.b &&\n                    this.radius === otherCircle.radius) {\n                        // Merge droppedCircles if they touch and have the same color and radius\n                          let newRadius = sqrt(sq(this.radius) + sq(otherCircle.radius));\n                          this.radius = newRadius;\n                          otherCircle.radius = 0; // Make the other circle disappear\n                        } else {\n                            // Resolve collision as a bounce\n                            this.resolveCollision(otherCircle);\n                  }\n            }\n      }\n   \n      resolveCollision(other) {\n        let dx = other.x - this.x;\n        let dy = other.y - this.y;\n        let distance = sqrt(dx * dx + dy * dy);\n   \n        // Calculate the minimum translation distance to separate droppedCircles\n        let minDistance = this.radius + other.radius;\n        let separationX = dx / distance * (minDistance - distance);\n        let separationY = dy / distance * (minDistance - distance);\n   \n        // Move droppedCircles apart to avoid overlap\n        this.x -= separationX / 2;\n        this.y -= separationY / 2;\n        other.x += separationX / 2;\n        other.y += separationY / 2;\n   \n        // Update velocities for a bounce effect\n        let angle = atan2(dy, dx);\n        let thisSpeed = sqrt(this.xSpeed * this.xSpeed + this.ySpeed * this.ySpeed);\n        let otherSpeed = sqrt(other.xSpeed * other.xSpeed + other.ySpeed * other.ySpeed);\n        let thisDirection = atan2(this.ySpeed, this.xSpeed);\n        let otherDirection = atan2(other.ySpeed, other.xSpeed);\n   \n        let newThisXSpeed = otherSpeed * cos(otherDirection - angle) * cos(angle) + thisSpeed * sin(thisDirection - angle) * cos(angle + HALF_PI);\n        let newThisYSpeed = otherSpeed * cos(otherDirection - angle) * sin(angle) + thisSpeed * sin(thisDirection - angle) * sin(angle + HALF_PI);\n        let newOtherXSpeed = thisSpeed * cos(thisDirection - angle) * cos(angle) + otherSpeed * sin(otherDirection - angle) * cos(angle + HALF_PI);\n        let newOtherYSpeed = thisSpeed * cos(thisDirection - angle) * sin(angle) + otherSpeed * sin(otherDirection - angle) * sin(angle + HALF_PI);\n   \n        this.xSpeed = newThisXSpeed;\n        this.ySpeed = newThisYSpeed;\n        other.xSpeed = newOtherXSpeed;\n        other.ySpeed = newOtherYSpeed;\n      }\n    }\n</script>\n`;\nreturn <iframe className=\"w-100 h-100\" srcDoc={code} />;\n};\nreturn (\n<div style={{ width: \"400px\", height: \"90%\" }} className=\"mx-auto\">\n<Game_Box />\n</div>\n);", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/jay100.near/widget/p5js_game", "fact_widget_deployments_id": "c372edda975f38115e92a0c61fb940e4", "inserted_timestamp": "2023-12-07T00:39:02.421Z", "modified_timestamp": "2023-12-20T03:22:11.422Z", "__row_index": 6}