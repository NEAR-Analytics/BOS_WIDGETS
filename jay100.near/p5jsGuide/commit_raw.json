{"tx_hash": "5AAtdFwQinEv9JqZcQdy81SkaVo3T7x7PAaaou4iMJU8", "action_id_social": "DoLWAQimMbAMaLn9sLiFmSbjw4PZUspxxiNeerEk1eAo-0-widget", "block_id": 108483748, "block_timestamp": "2023-12-21T13:57:25.585Z", "signer_id": "jay100.near", "widget_name": "p5jsGuide", "source_code": "const GameContainer = () => {\n  const code = `\n    <head>\n<link href=\"https://fonts.googleapis.com/css2?family=Lugrasimo&family=VT323&display=swap\" rel=\"stylesheet\">\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js\" integrity=\"sha512-2r+xZ/Dm8+HI0I8dsj1Jlfchv4O3DGfWbqRalmSGtgdbVQrZyGRqHp9ek8GKk1x8w01JsmDZRrJZ4DzgXkAU+g==\" crossorigin=\"anonymous\" referrerpolicy=\"no-referrer\"></script>\n  </head>\n<style>\n   body {\n   margin: 0;\n   display: flex;\n   align-items: center;\n   flex-direction: column;\n   overflow: hidden;\n   }\n\n</style>\n<body>\n</body>\n<script>\n\n  let circle = null;\n  let groundHeight;\n  let gameCircles = [];\n  const sizes = [10, 20, 40];\n  let circleColors = [{r: 255, g: 0, b: 0},{r: 0, g: 255, b: 0},{r: 0, g: 0, b: 255}]\n  let gameScore = 0;\n  let timer = 30;\n\nfunction setup() {\n    createCanvas(350, windowHeight);\n    groundHeight = height; // Ground position\n\n  setInterval(() => {\n        if (timer > 0) {\n            timer--;\n        }\n    }, 1000);\n}\n\n   \n    function draw() {\n      background(220);\n\n      textFont(\"VT323\");\n\n      textSize(30);\n      fill(0);\n      text(\"Time: \" + timer, 250, 20);\n\n      textSize(30);\n      fill(0)\n      text(\"Score: \" + gameScore, 20, 20);\n\n     for(let i = 0; i < gameCircles.length; i++){\n      gameCircles[i].display();\n      gameCircles[i].fall();\n      gameCircles[i].checkBounds();\n         for (let j = i + 1; j < gameCircles.length; j++) {\n            gameCircles[i].handleCircleCollision(gameCircles[j]);\n        }\n     }\n\n    }\n   \n    function mouseClicked() {\n\n      if(timer > 0){\n      const randPos = Math.floor(Math.random() * sizes.length);\n        \n      let newCircle = new Circle(mouseX, 50, circleColors[randPos]);\n      newCircle.radius = sizes[randPos];\n      newCircle.isFalling = true;\n      gameCircles.push(newCircle);\n      }\n    }\n\n    class Circle {\n       constructor(x, y, color) {\n        this.x = x;\n        this.y = y;\n        this.radius = 25;\n        this.color = color;\n        this.isFalling = false;\n        this.xSpeed = 0;\n        this.ySpeed = 0;\n      }\n\n      \n   \n      display() {\n        fill(this.color.r, this.color.g, this.color.b);\n        ellipse(this.x, this.y, this.radius * 2);\n      }\n\n      fall() {\n        if (this.isFalling) {\n          this.y += this.ySpeed;\n          this.ySpeed += 0.2; // Simulate gravity\n          this.x += this.xSpeed;\n          }\n      }\n\n      checkBounds() {\n        if (this.x - this.radius < 0 || this.x + this.radius > width) {\n          this.x = constrain(this.x, this.radius, width - this.radius);\n\n            // Bounce off walls\n          if (this.x + this.radius >= width || this.x - this.radius <= 0) {\n            this.xSpeed *= -0.1; // Reduce x speed upon wall impact\n          }\n        }\n        if (this.y - this.radius < 0 || this.y + this.radius > height) {\n          this.y = constrain(this.y, this.radius, height - this.radius);\n\n          // Check for hitting the ground\n          if (this.y + this.radius >= groundHeight) {\n            this.y = groundHeight - this.radius;\n            this.ySpeed *= -0.1; // Reduce y speed upon ground impact (dampening)\n            this.xSpeed *= 0.6; // Reduce x speed upon ground impact\n          }\n\n        }\n      }\n\n  handleCircleCollision(otherCircle) {\n    // Calculate the differences in x and y positions between the circles\n    let dx = this.x - otherCircle.x;\n    let dy = this.y - otherCircle.y;\n\n    // Calculate the squared distance between the centers of the circles\n    let distanceSquared = dx * dx + dy * dy;\n\n    // Calculate the squared minimum distance at which the circles should collide\n    let minDistanceSquared = (this.radius + otherCircle.radius) * (this.radius + otherCircle.radius);\n\n    // Check if the squared distance is less than or equal to the squared minimum distance\n    if (distanceSquared <= minDistanceSquared) {\n      if (\n            this.color.r === otherCircle.color.r &&\n            this.color.g === otherCircle.color.g &&\n            this.color.b === otherCircle.color.b &&\n            this.radius === otherCircle.radius\n        ){\n                // Merge circles if they touch and have similar color and radius\n                let newRadius = (this.radius) + (otherCircle.radius);\n                this.radius = newRadius;\n                otherCircle.radius = 0;\n                gameCircles = gameCircles.filter(circle => circle !== otherCircle);\n\n                if(newRadius > 100){\n                  gameScore += 10;\n                  gameCircles = gameCircles.filter(circle => circle !== this && circle !== otherCircle);\n                } else {\n                  gameScore += 5;\n                }\n      }else{\n        // If the circles are colliding, resolve the collision between them\n        this.handleCollisionBounce(otherCircle);\n      }\n       \n    }\n}\n\n\nhandleCollisionBounce(other) {\n    // Calculate the difference in positions between the two circles\n    let dx = other.x - this.x;\n    let dy = other.y - this.y;\n    let distance = sqrt(dx * dx + dy * dy); // Calculate the distance between the circles\n\n    // Calculate the minimum distance needed to separate the circles without overlap\n    let minDistance = this.radius + other.radius;\n    let separationX = dx / distance * (minDistance - distance);\n    let separationY = dy / distance * (minDistance - distance);\n\n    // Move circles apart to prevent overlap\n    this.x -= separationX / 2;\n    this.y -= separationY / 2;\n    other.x += separationX / 2;\n    other.y += separationY / 2;\n\n    // Calculate collision angles and speeds for bouncing effect\n    let angle = atan2(dy, dx); // Calculate angle of collision\n    let thisSpeed = sqrt(this.xSpeed * this.xSpeed + this.ySpeed * this.ySpeed); // Calculate speed of this circle\n    let otherSpeed = sqrt(other.xSpeed * other.xSpeed + other.ySpeed * other.ySpeed); // Calculate speed of other circle\n    let thisDirection = atan2(this.ySpeed, this.xSpeed); // Calculate direction of this circle's movement\n    let otherDirection = atan2(other.ySpeed, other.xSpeed); // Calculate direction of other circle's movement\n\n    // Calculate new velocities after collision\n    let newThisXSpeed = otherSpeed * cos(otherDirection - angle) * cos(angle) + (thisSpeed) * sin(thisDirection - angle) * cos(angle + HALF_PI);\n    let newThisYSpeed = otherSpeed * cos(otherDirection - angle) * sin(angle) + (thisSpeed) * sin(thisDirection - angle) * sin(angle + HALF_PI);\n    let newOtherXSpeed = (thisSpeed) * cos(thisDirection - angle) * cos(angle) + otherSpeed * sin(otherDirection - angle) * cos(angle + HALF_PI);\n    let newOtherYSpeed = (thisSpeed) * cos(thisDirection - angle) * sin(angle) + otherSpeed * sin(otherDirection - angle) * sin(angle + HALF_PI);\n\n    // Update velocities to reflect the new directions and speeds after collision\n    this.xSpeed = newThisXSpeed;\n    this.ySpeed = newThisYSpeed;\n    other.xSpeed = newOtherXSpeed;\n    other.ySpeed = newOtherYSpeed;\n}\n\n\n\n\n\n}\n   \n\n</script>\n  `;\n\n  return (\n    <div\n      style={{\n        width: \"100%\",\n        height: \"80%\",\n        display: \"flex\",\n        flexDirection: \"column\",\n      }}\n      className=\"mx-auto\"\n    >\n      <iframe className=\"w-100 h-100\" srcDoc={code} />\n    </div>\n  );\n};\n\nreturn (\n  <div style={{ width: \"100%\", height: \"100%\", background: \"blue\" }}>\n    <GameContainer />\n  </div>\n);\n", "metadata": {"platform": "jutsu.ai"}, "branch": {"draft": null}, "widget_modules_used": null, "widget_url": "https://near.social/#/jay100.near/widget/p5jsGuide", "fact_widget_deployments_id": "824332cad2f74165db04461f89c9b8f0", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 0}