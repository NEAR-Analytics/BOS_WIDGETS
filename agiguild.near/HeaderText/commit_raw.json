{"tx_hash": "6fbNx8CLUY1ACrJJgL8qAbKpzGcXnPskXfr8tVH5uGLb", "action_id_social": "ETujEs82bdteLFD6YSZshLc44ezJyaEM24EtgQHFMWQu-0-widget", "block_id": 116080025, "block_timestamp": "2024-04-04T00:26:37.755Z", "signer_id": "agiguild.near", "widget_name": "HeaderText", "source_code": "const { text, color, alpha } = props;\n\nconst colorToVec3 = (hexStr, alpha) => {\n  if (/^#([0-9A-F]{3}){1,2}$/i.test(hexStr)) {\n    const rbg = [hexStr.slice(1, 3), hexStr.slice(3, 5), hexStr.slice(5, 7)].map(\n      (x) => Math.round((parseInt(x, 16) / 255) * 1000) / 1000,\n    );\n    return rbg.join(\",\") + (alpha ? \",\" + alpha : \",0.05\");\n  }\n  return \"0.067,0.094,0.11,0.05\";\n};\n\nlet src = `\n<div id=\"scene\"></div>\n<div class=\"playground\"></div>\n<style>\nhtml, body { \n  \n  margin: 0;\n  height: 100%;\n  overflow: hidden;\n  color: black;\n  font-size: 9px;\n}\n\n#scene {\n  position: fixed;\n  width: 100%;\n  height: 100vh;\n  display: block;\n  top: 0;\n  left: 0;\n  z-index: -9999;\n}\n\n.playground{\n  position: fixed;\n  width: 100%;\n  height: 100vh;\n  display: block;\n  top: 0;\n  left: 0;\n  display: flex;\n  flex-wrap: nowrap;\n  flex-direction: column;\n  justify-content: flex-end;\n  align-items: center;\n}\n</style>\n<script type=\"x-shader/x-vertex\" id=\"vertexshader\">\n\n  attribute float size;\n  attribute vec3 customColor;\n  varying vec3 vColor;\n\n  void main() {\n\n    vColor = customColor;\n    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n    gl_PointSize = size * ( 300.0 / -mvPosition.z );\n    gl_Position = projectionMatrix * mvPosition;\n  }\n\n</script>\n<script type=\"x-shader/x-fragment\" id=\"fragmentshader\">\n\n uniform vec3 color;\n uniform sampler2D pointTexture;\n\n varying vec3 vColor;\n\n void main() {\n   gl_FragColor = vec4(COLOR_PROPERTY); //;vec4( color * vColor, 1.0 ); // for changing colors\n   gl_FragColor = gl_FragColor * texture2D( pointTexture, gl_PointCoord );\n }\n</script>\n\t\n<script type=\"text/javascript\" src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/r125/three.min.js\"></script>\n\t\t<script type=\"module\">\n\t\t\nconst preload = () => {\n  let manager = new THREE.LoadingManager();\n  manager.onLoad = function() { \n    const environment = new Environment( typo, particle );\n  }\n\n  var typo = null;\n  const loader = new THREE.FontLoader( manager );\n  const font = loader.load('https://res.cloudinary.com/dydre7amr/raw/upload/v1612950355/font_zsd4dr.json', function ( font ) { typo = font; });\n  const particle = new THREE.TextureLoader( manager ).load( 'https://res.cloudinary.com/dfvtkoboz/image/upload/v1605013866/particle_a64uzf.png');\n}\n\nif ( document.readyState === \"complete\" || (document.readyState !== \"loading\" && !document.documentElement.doScroll))\n  preload ();\nelse\n  document.addEventListener(\"DOMContentLoaded\", preload ); \n\nclass Environment {\n\n  constructor( font, particle ){ \n\n    this.font = font;\n    this.particle = particle;\n    this.container = document.querySelector( '#scene' );\n    this.scene = new THREE.Scene();\n    this.scene.background = new THREE.Color( 'white' );\n    this.createCamera();\n    this.createRenderer();\n    this.setup()\n    this.bindEvents();\n  }\n\n  bindEvents(){\n    window.addEventListener( 'resize', this.onWindowResize.bind( this ));\n  }\n\n  setup(){\n    this.createParticles = new CreateParticles( this.scene, this.font,             this.particle, this.camera, this.renderer );\n  }\n\n  render() {\n     this.createParticles.render()\n     this.renderer.render( this.scene, this.camera )\n  }\n\n  createCamera() {\n    this.camera = new THREE.PerspectiveCamera( 65, this.container.clientWidth /  this.container.clientHeight, 1, 10000 );\n    this.camera.position.set( 0,0, 50 );\n\n  }\n\n  createRenderer() {\n    this.renderer = new THREE.WebGLRenderer();\n    this.renderer.setSize( this.container.clientWidth, this.container.clientHeight );\n\n    this.renderer.setPixelRatio( Math.min( window.devicePixelRatio, 2));\n\n    this.renderer.outputEncoding = THREE.sRGBEncoding;\n    this.container.appendChild( this.renderer.domElement );\n\n    this.renderer.setAnimationLoop(() => { this.render() })\n  }\n\n  onWindowResize(){\n    this.camera.aspect = this.container.clientWidth / this.container.clientHeight;\n    this.camera.updateProjectionMatrix();\n    this.renderer.setSize( this.container.clientWidth, this.container.clientHeight );\n  }\n}\n\nclass CreateParticles {\n\t\n\tconstructor( scene, font, particleImg, camera, renderer ) {\n\t\tthis.scene = scene;\n\t\tthis.font = font;\n\t\tthis.particleImg = particleImg;\n\t\tthis.camera = camera;\n\t\tthis.renderer = renderer;\n\t\t\n\t\tthis.raycaster = new THREE.Raycaster();\n\t\tthis.mouse = new THREE.Vector2(-200, 200);\n\t\t\n\t\tthis.colorChange = new THREE.Color();\n\n\t\tthis.buttom = false;\n\t\tthis.data = {\n\t\t\ttext: \"TEXT_PROPERTY\",\n\t\t\tamount: 500,\n\t\t\tparticleSize: 0.8,\n\t\t\ttextSize: 30,\n\t\t\tarea: 250,\n\t\t\tease: 1, // 1 reduces the initial distortion\n\t\t}\n\n\t\tthis.setup();\n\t\tthis.bindEvents();\n\t}\n\n\n\tsetup(){\n\t\tconst geometry = new THREE.PlaneGeometry( this.visibleWidthAtZDepth( 100, this.camera ), this.visibleHeightAtZDepth( 100, this.camera ));\n\t\tconst material = new THREE.MeshBasicMaterial( { color: 0xffffff, transparent: true } );\n\t\tthis.planeArea = new THREE.Mesh( geometry, material );\n\t\tthis.planeArea.visible = false;\n\t\tthis.createText();\n\t}\n\n\tbindEvents() {\n\t\tdocument.addEventListener( 'mousedown', this.onMouseDown.bind( this ));\n\t\tdocument.addEventListener( 'mousemove', this.onMouseMove.bind( this ));\n\t\tdocument.addEventListener( 'mouseup', this.onMouseUp.bind( this ));\n\t\tdocument.addEventListener( 'touchstart', this.onMouseDown.bind( this ));\n\t\tdocument.addEventListener( 'touchmove', this.onMouseMove.bind( this ));\n\t\tdocument.addEventListener( 'touchend', this.onMouseUp.bind( this ));\n\t}\n\n\tonMouseDown(){\n\t\tthis.mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;\n\t\tthis.mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;\n\n\t\tconst vector = new THREE.Vector3( this.mouse.x, this.mouse.y, 0.5);\n\t\tvector.unproject( this.camera );\n\t\tconst dir = vector.sub( this.camera.position ).normalize();\n\t\tconst distance = - this.camera.position.z / dir.z;\n\t\tthis.currenPosition = this.camera.position.clone().add( dir.multiplyScalar( distance ) );\n\t\t\n\t\tconst pos = this.particles.geometry.attributes.position;\n\t\tthis.buttom = true;\n\t\tthis.data.ease = .01;\n\t}\n\n\tonMouseUp(){\n\t\tthis.buttom = false;\n\t\tthis.data.ease = .05;\n\t}\n\n\tonMouseMove( ) {\n\t    this.mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;\n\t    this.mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;\n\t}\n\n\trender( level ){\n\t\tconst time = ((.001 * performance.now())%12)/12;\n\t\tconst zigzagTime = (1 + (Math.sin( time * 2 * Math.PI )))/6;\n\n\t\tthis.raycaster.setFromCamera( this.mouse, this.camera );\n\n\t\tconst intersects = this.raycaster.intersectObject( this.planeArea );\n\t\tif ( intersects.length > 0 ) {\n            if(this.data.ease === 1 && intersects[0].distance !== 0) {\n                this.data.ease = .05;\n            }\n\t\t\tconst pos = this.particles.geometry.attributes.position;\n\t\t\tconst copy = this.geometryCopy.attributes.position;\n\t\t\tconst coulors = this.particles.geometry.attributes.customColor;\n\t\t\tconst size = this.particles.geometry.attributes.size;\n\n\t\t    const mx = intersects[ 0 ].point.x;\n\t\t    const my = intersects[ 0 ].point.y;\n\t\t    const mz = intersects[ 0 ].point.z;\n\n\t\t    for ( var i = 0, l = pos.count; i < l; i++) {\n\n\t\t    \tconst initX = copy.getX(i);\n\t\t    \tconst initY = copy.getY(i);\n\t\t    \tconst initZ = copy.getZ(i);\n\n\t\t    \tlet px = pos.getX(i);\n\t\t    \tlet py = pos.getY(i);\n\t\t    \tlet pz = pos.getZ(i);\n\n\t\t    \tthis.colorChange.setHSL( .5, 1 , 1 )\n\t\t    \tcoulors.setXYZ( i, this.colorChange.r, this.colorChange.g, this.colorChange.b )\n\t\t    \tcoulors.needsUpdate = true;\n\n\t\t    \tsize.array[ i ]  = this.data.particleSize;\n\t\t    \tsize.needsUpdate = true;\n\n\t\t    \tlet dx = mx - px;\n\t\t    \tlet dy = my - py;\n\t\t    \tconst dz = mz - pz;\n\n\t\t    \tconst mouseDistance = this.distance( mx, my, px, py )\n\t\t    \tlet d = ( dx = mx - px ) * dx + ( dy = my - py ) * dy;\n\t\t    \tconst f = - this.data.area/d;\n\n\t\t    \tif( this.buttom ){ \n\n\t\t    \t\tconst t = Math.atan2( dy, dx );\n\t\t    \t\tpx -= f * Math.cos( t );\n\t\t    \t\tpy -= f * Math.sin( t );\n\n\t\t    \t\tthis.colorChange.setHSL( .5 + zigzagTime, 1.0 , .5 )\n\t\t    \t\tcoulors.setXYZ( i, this.colorChange.r, this.colorChange.g, this.colorChange.b )\n\t\t    \t\tcoulors.needsUpdate = true;\n\n\t\t    \t\tif ((px > (initX + 70)) || ( px < (initX - 70)) || (py > (initY + 70) || ( py < (initY - 70)))){\n\n\t\t    \t\t\tthis.colorChange.setHSL( .15, 1.0 , .5 )\n\t\t    \t\t\tcoulors.setXYZ( i, this.colorChange.r, this.colorChange.g, this.colorChange.b )\n\t\t    \t\t\tcoulors.needsUpdate = true;\n\n\t\t    \t\t}\n\n\t\t    \t}else{\n\t\t    \t\n\t\t\t    \tif( mouseDistance < this.data.area ){\n\n\t\t\t    \t\tif(i%5==0){\n\t\t\t    \t\t\tconst t = Math.atan2( dy, dx );\n\t\t\t    \t\t\tpx -= .03 * Math.cos( t );\n\t\t\t    \t\t\tpy -= .03 * Math.sin( t );\n\n\t\t\t    \t\t\tthis.colorChange.setHSL( .15 , 1.0 , .5 )\n\t\t\t    \t\t\tcoulors.setXYZ( i, this.colorChange.r, this.colorChange.g, this.colorChange.b )\n\t\t\t    \t\t\tcoulors.needsUpdate = true;\n\n\t\t\t\t\t\t\tsize.array[ i ]  =  this.data.particleSize /1.2;\n\t\t\t\t\t\t\tsize.needsUpdate = true;\n\n\t\t\t    \t\t}else{\n\n\t\t\t\t\t    \tconst t = Math.atan2( dy, dx );\n\t\t\t\t\t    \tpx += f * Math.cos( t );\n\t\t\t\t\t    \tpy += f * Math.sin( t );\n\n\t\t\t\t\t    \tpos.setXYZ( i, px, py, pz );\n\t\t\t\t\t    \tpos.needsUpdate = true;\n\n\t\t\t\t\t    \tsize.array[ i ]  = this.data.particleSize * 1.3 ;\n\t\t\t\t\t    \tsize.needsUpdate = true;\n\t\t\t\t    \t}\n\n\t\t\t    \t\tif ((px > (initX + 10)) || ( px < (initX - 10)) || (py > (initY + 10) || ( py < (initY - 10)))){\n\n\t\t\t    \t\t\tthis.colorChange.setHSL( .15, 1.0 , .5 )\n\t\t\t    \t\t\tcoulors.setXYZ( i, this.colorChange.r, this.colorChange.g, this.colorChange.b )\n\t\t\t    \t\t\tcoulors.needsUpdate = true;\n\n\t\t\t    \t\t\tsize.array[ i ]  = this.data.particleSize /1.8;\n\t\t\t    \t\t\tsize.needsUpdate = true;\n\n\t\t\t    \t\t}\n\t\t\t    \t}\n\n\t\t    \t}\n\n\t\t    \tpx += ( initX  - px ) * this.data.ease;\n\t\t    \tpy += ( initY  - py ) * this.data.ease;\n\t\t    \tpz += ( initZ  - pz ) * this.data.ease;\n\n\t\t    \tpos.setXYZ( i, px, py, pz );\n\t\t    \tpos.needsUpdate = true;\n\t\t    }\n\t\t}\n\t}\n\n\tcreateText(){\n\t\tlet thePoints = [];\n\n\t\tlet shapes = this.font.generateShapes( this.data.text , this.data.textSize  );\n\t\tlet geometry = new THREE.ShapeGeometry( shapes );\n\t\tgeometry.computeBoundingBox();\n\t\n\t\tconst xMid = - 0.5 * ( geometry.boundingBox.max.x - geometry.boundingBox.min.x );\n\t\tconst yMid = -10; //  (geometry.boundingBox.max.y - geometry.boundingBox.min.y)/6;\n\n\t\tgeometry.center();\n\n\t\tlet holeShapes = [];\n\n\t\tfor ( let q = 0; q < shapes.length; q ++ ) {\n\t\t\tlet shape = shapes[ q ];\n\t\t\tif ( shape.holes && shape.holes.length > 0 ) {\n\t\t\t\tfor ( let  j = 0; j < shape.holes.length; j ++ ) {\n\t\t\t\t\tlet  hole = shape.holes[ j ];\n\t\t\t\t\tholeShapes.push( hole );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tshapes.push.apply( shapes, holeShapes );\n\n\t\tlet colors = [];\n\t\tlet sizes = [];\n\t\t\t\t\t\n\t\tfor ( let  x = 0; x < shapes.length; x ++ ) {\n\t\t\tlet shape = shapes[ x ];\n\t\t\tconst amountPoints = ( shape.type == 'Path') ? this.data.amount/2 : this.data.amount;\n\t\t\tlet points = shape.getSpacedPoints( amountPoints ) ;\n\n\t\t\tpoints.forEach( ( element, z ) => {\n\t\t\t\tconst a = new THREE.Vector3( element.x, element.y, 0 );\n\t\t\t\tthePoints.push( a );\n\t\t\t\tcolors.push( this.colorChange.r, this.colorChange.g, this.colorChange.b);\n\t\t\t\tsizes.push( 1 )\n\t\t\t\t});\n\t\t}\n\n\t\tlet geoParticles = new THREE.BufferGeometry().setFromPoints( thePoints );\n\t\tgeoParticles.translate( xMid, yMid, 0 );\n\t\t\t\t\n\t\tgeoParticles.setAttribute( 'customColor', new THREE.Float32BufferAttribute( colors, 3 ) );\n\t\tgeoParticles.setAttribute( 'size', new THREE.Float32BufferAttribute( sizes, 1) );\n\n\t\tconst material = new THREE.ShaderMaterial( {\n\t\t\tuniforms: {\n\t\t\t\tcolor: { value: new THREE.Color( 'white' ) },\n\t\t\t\tpointTexture: { value: this.particleImg }\n\t\t\t},\n\t\t\tvertexShader: document.getElementById( 'vertexshader' ).textContent,\n\t\t\tfragmentShader: document.getElementById( 'fragmentshader' ).textContent,\n\n\t\t\tblending: THREE.NormalBlending, // originally AdditiveBlending\n\t\t\tdepthTest: false,\n\t\t\ttransparent: true,\n\t\t} );\n\n\t\tthis.particles = new THREE.Points( geoParticles, material );\n\t\tthis.scene.add( this.particles );\n\n\t\tthis.geometryCopy = new THREE.BufferGeometry();\n\t\tthis.geometryCopy.copy( this.particles.geometry );\n\t\t\n\t}\n\n\tvisibleHeightAtZDepth ( depth, camera ) {\n\t  const cameraOffset = camera.position.z;\n\t  if ( depth < cameraOffset ) depth -= cameraOffset;\n\t  else depth += cameraOffset;\n\n\t  const vFOV = camera.fov * Math.PI / 180; \n\n\t  return 2 * Math.tan( vFOV / 2 ) * Math.abs( depth );\n\t}\n\n\tvisibleWidthAtZDepth( depth, camera ) {\n\t  const height = this.visibleHeightAtZDepth( depth, camera );\n\t  return height * camera.aspect;\n\t}\n\n\tdistance (x1, y1, x2, y2){\n\t    return Math.sqrt(Math.pow((x1 - x2), 2) + Math.pow((y1 - y2), 2));\n\t}\n}\n// Adapted from https://codepen.io/sanprieto/details/XWNjBdb under MIT LICENSE\n</script>`;\n\nsrc = src.replace(\"TEXT_PROPERTY\", text);\nsrc = src.replace(\"COLOR_PROPERTY\", colorToVec3(color, alpha));\n\nreturn (\n  <div className=\"iframeContainer container\">\n    <iframe\n      className=\"w-100\"\n      style={{ height: \"8vh\", overflow: \"hidden\" }}\n      srcDoc={src}\n    />\n  </div>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/agiguild.near/widget/HeaderText", "fact_widget_deployments_id": "361fd7c7bc213fce0ae1fafa9edd8707", "inserted_timestamp": "2024-04-04T02:49:43.816Z", "modified_timestamp": "2024-04-04T02:49:43.816Z", "__row_index": 1}