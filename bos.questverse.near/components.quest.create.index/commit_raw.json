{"tx_hash": "13XBrMRMjtWxehEnfJ3huAeFzFWAA5AtLQ5aJ6TLdbJS", "action_id_social": "HtU9xqwSTCA3NnAWAedq5KSPb1JWdqbMCEnnfkigbSeF-0-widget", "block_id": 107453461, "block_timestamp": "2023-12-08T17:41:29.415Z", "signer_id": "bos.questverse.near", "widget_name": "components.quest.create.index", "source_code": "// -- Read and process types from SocialDB + helper functions\n\nconst isPrimitiveType = (type) =>\n    [\"string\", \"number\", \"boolean\"].includes(type);\n\nconst isComplexType = (type) =>\n    Array.isArray(type)\n        ? \"typesArray\"\n        : type === \"array\"\n        ? \"array\"\n        : typeof type === \"object\"\n        ? \"object\"\n        : typeof type === \"string\" && !isPrimitiveType(type)\n        ? \"custom\"\n        : null;\n\nconst PRIMITIVE_VALIDATIONS = {\n    string: (value, { min, max, pattern }) => {\n        if (typeof value !== \"string\")\n            return `Expected a string, got ${typeof value}.`;\n\n        if (min && value.length < min)\n            return `Must be at least ${min} characters long.`;\n\n        if (max && value.length > max)\n            return `Must be at most ${max} characters long.`;\n        // waiting for regexp\n        // if (pattern && !value.match(pattern))\n        //   return `The value \"${value}\" does not match expected pattern: ${pattern}`;\n    },\n    number: (value, { min, max }) => {\n        if (typeof value !== \"number\")\n            return `Expected a number, got ${typeof value}.`;\n\n        if (min && value < min) return `Must be at least ${min}.`;\n\n        if (max && value > max) return `Must be at most ${max}.`;\n    },\n    boolean: (value) => {\n        if (typeof value !== \"boolean\")\n            return `Expected a boolean, got ${typeof value}.`;\n    }\n};\n\nfunction validatePrimitiveType(type, value, constraints) {\n    if (!isPrimitiveType(type))\n        throw {\n            message: `Unknown primitive type: ${type}`,\n            type,\n            value\n        };\n\n    return PRIMITIVE_VALIDATIONS[type](value, constraints);\n}\n\nfunction validateType(type, value, parent) {\n    if (value === undefined || value === \"\" || value === null) {\n        if (parent.required) {\n            return `This field is required but missing.`;\n        }\n        return;\n    }\n\n    if (isPrimitiveType(type))\n        return validatePrimitiveType(type, value, parent[type].validation);\n\n    if (isComplexType(type) === \"typesArray\") {\n        const errors = [];\n        for (const subType of type) {\n            const error = validateType(subType, value, parent[subType]);\n            if (!error) return; // Stop if a valid type is found\n            errors.push(error);\n        }\n        if (errors.length === type.length) {\n            // only return the deepest error\n            for (const error of errors) {\n                if (typeof error === \"object\") return error;\n            }\n            return errors[errors.length - 1];\n        }\n    }\n\n    if (isComplexType(type) === \"array\") {\n        if (!Array.isArray(value)) {\n            return `Expected an array, got ${typeof value}.`;\n        }\n\n        if (\n            parent[\"array\"].validation.min &&\n            value.length < parent[\"array\"].validation.min\n        ) {\n            return `Must have at least ${parent[\"array\"].validation.min} items.`;\n        }\n\n        if (\n            parent[\"array\"].validation.max &&\n            value.length > parent[\"array\"].validation.max\n        ) {\n            return `Must have at most ${parent[\"array\"].validation.max} items.`;\n        }\n\n        for (const item of value) {\n            const error = validateType(\n                parent[\"array\"].type,\n                item,\n                parent[\"array\"]\n            );\n            if (error)\n                return {\n                    [value.indexOf(item)]: error\n                };\n        }\n    }\n\n    if (isComplexType(type) === \"object\") {\n        if (typeof value !== \"object\" || Array.isArray(value)) {\n            return `Expected an object, got ${typeof value}.`;\n        }\n\n        // Validate properties of the object\n        for (const property of type.properties) {\n            const propName = property.name;\n            const propType = property.type;\n            const propValue = value[propName];\n\n            if (property.required && propValue === undefined) {\n                return `Property ${propName} is required but missing.`;\n            }\n\n            if (propValue !== undefined) {\n                const error = validateType(propType, propValue, property);\n                if (error)\n                    return {\n                        [propName]: error\n                    };\n            }\n        }\n    }\n\n    if (isComplexType(type) === \"custom\") {\n        return validateType(types[type], value);\n    }\n}\n\nconst typeToEmptyData = (type) => {\n    if (isPrimitiveType(type)) {\n        switch (type) {\n            case \"string\":\n                return \"\";\n            case \"number\":\n                return null;\n            case \"boolean\":\n                return null;\n        }\n    }\n    if (isComplexType(type) === \"array\") {\n        return [];\n    }\n    if (isComplexType(type) === \"typesArray\") {\n        return typeToEmptyData(type[0]);\n    }\n    if (isComplexType(type) === \"object\") {\n        const obj = {};\n\n        type.properties.forEach((prop) => {\n            const propType =\n                isComplexType(prop.type) === \"typesArray\"\n                    ? prop.type[0]\n                    : prop.type;\n\n            if (isPrimitiveType(propType)) {\n                obj[prop.name] = typeToEmptyData(propType);\n            } else if (isComplexType(propType) === \"array\") {\n                obj[prop.name] = typeToEmptyData(propType);\n            } else if (isComplexType(propType) === \"object\") {\n                obj[prop.name] = typeToEmptyData(prop[propType]);\n            } else if (isComplexType(propType) === \"custom\") {\n                obj[prop.name] = typeToEmptyData(types[propType]);\n            }\n        });\n\n        return obj;\n    }\n    if (isComplexType(type) === \"custom\") {\n        return typeToEmptyData(types[type]);\n    }\n};\n\nreturn (\n    <Widget\n        src=\"bos.questverse.near/widget/components.quest.create.form\"\n        props={{\n            validateType,\n            typeToEmptyData,\n            types: {\n                \"hack.near/type/quest\": {\n                    properties: []\n                }\n            }\n        }}\n    />\n);", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/bos.questverse.near/widget/components.quest.create.index", "fact_widget_deployments_id": "d967440fc5678e9ee362925ccb0260f0", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 0}