{"tx_hash": "7WY91zaE1PpCt1BaJGYw4WwHUofQXELYU5RHZt5oYYeP", "action_id_social": "8x8CF6FjhvW2KtFMmTuxXo192qBrbZoLeX3NbQji7KYY-0-widget", "block_id": 110723142, "block_timestamp": "2024-01-18T15:35:54.011Z", "signer_id": "bos.dapplets.near", "widget_name": "Tipping.Main", "source_code": "let accountId;\nlet itemGlobalId;\n\nif (props.accountGId && props.itemGId) {\n  accountId = props.accountGId;\n  itemGlobalId = props.itemGId;\n} else if ((props.accountId || props.notifyAccountId) && (props.blockHeight || props.item?.blockHeight)) {\n  accountId = props.accountId || props.notifyAccountId;\n  const blockHeight = props.blockHeight || props.item?.blockHeight;\n  itemGlobalId = `bos/${blockHeight}/${accountId}/post/main`;\n} else if (props.context && props.context.id && props.context.authorUsername) {\n  accountId = props.context.authorUsername + '/twitter';\n  itemGlobalId = 'tweet/' + props.context.id;\n} else {\n  console.error('The context should provide accountGId with itemGId or accountId with blockHeight props.');\n  return <></>;\n}\n\nconst MAX_AMOUNT_PER_ITEM = '10000000000000000000000000'; // 10 NEAR\nconst MAX_AMOUNT_PER_TIP = '1000000000000000000000000'; // 1 NEAR\nconst TIPPING_CONTRACT_NAME = \"v2.tipping.near\";\n\nconst STEP = 0.05\nconst DELAY = 2;\n\nState.update({\n  totalTipsByItemId: Near.view(TIPPING_CONTRACT_NAME, \"getTotalTipsByItemId\", {\n    itemId: itemGlobalId\n  }, \"final\", true) || '0'\n})\n\n/**\n * From near-api-js/packages/near-api-js/src/utils/format.ts\n */\nconst NEAR_NOMINATION_EXP = 24;\nconst NEAR_NOMINATION = new BN('10', 10).pow(new BN(NEAR_NOMINATION_EXP, 10));\nconst ROUNDING_OFFSETS = [];\nconst BN10 = new BN(10);\n\nfor (let i = 0, offset = new BN(5); i < NEAR_NOMINATION_EXP; i++) {\n  ROUNDING_OFFSETS[i] = offset;\n  offset = offset.mul(BN10)\n}\n\nfunction trimTrailingZeroes(value) {\n  return value.replace(/\\.?0*$/, '');\n}\n\nfunction formatWithCommas(value) {\n  const pattern = /(-?\\d+)(\\d{3})/;\n  while (pattern.test(value)) {\n    value = value.replace(pattern, '$1,$2');\n  }\n  return value;\n}\n\nfunction formatNearAmount(balance, fracDigitsExternal) {\n  const fracDigits = fracDigitsExternal || NEAR_NOMINATION\n\n  const balanceBN = new BN(balance, 10);\n  if (fracDigits !== NEAR_NOMINATION_EXP) {\n    const roundingExp = NEAR_NOMINATION_EXP - fracDigits - 1;\n    if (roundingExp > 0) {\n      balanceBN.iadd(ROUNDING_OFFSETS[roundingExp]);\n    }\n  }\n\n  balance = balanceBN.toString();\n  const wholeStr = balance.substring(0, balance.length - NEAR_NOMINATION_EXP) || '0';\n  const fractionStr = balance\n    .substring(balance.length - NEAR_NOMINATION_EXP)\n    .padStart(NEAR_NOMINATION_EXP, '0')\n    .substring(0, fracDigits);\n\n  return trimTrailingZeroes(`${formatWithCommas(wholeStr)}.${fractionStr}`);\n}\n\nfunction cleanupAmount(amount) {\n  return amount.replace(/,/g, '').trim();\n}\n\nfunction trimLeadingZeroes(value) {\n  value = value.replace(/^0+/, '');\n  if (value === '') {\n      return '0';\n  }\n  return value;\n}\n\nfunction parseNearAmount(amt) {\n  if (!amt) { return null; }\n  amt = cleanupAmount(amt);\n  const split = amt.split('.');\n  const wholePart = split[0];\n  const fracPart = split[1] || '';\n  if (split.length > 2 || fracPart.length > NEAR_NOMINATION_EXP) {\n      throw new Error(`Cannot parse '${amt}' as NEAR amount`);\n  }\n  return trimLeadingZeroes(wholePart + fracPart.padEnd(NEAR_NOMINATION_EXP, '0'));\n}\n\nfunction formatNear(amount) {\n  return Number(formatNearAmount(amount, 4)).toFixed(2);\n}\n/**\n * End\n */\n\n// Sum of 2 or 3 values!!!\nconst sum = (value1, value2, value3) => {\n  let _sum = Big('0');\n  const values = value3 ? [value1, value2, value3] : [value1, value2]\n\n  for (const v of values) {\n    const _a = Big(_sum);\n    const _b = Big(v);\n    _sum = _a.plus(_b);\n  }\n\n  return _sum.toFixed();\n}\n\nconst lte = (a, b) => {\n  const _a = Big(a);\n  const _b = Big(b);\n  return _a.lte(_b);\n}\n\nconst gte = (a, b) => {\n  const _a = Big(a);\n  const _b = Big(b);\n  return _a.gte(_b);\n}\n\nconst equals = (a, b) => {\n  const _a = Big(a);\n  const _b = Big(b);\n  return _a.eq(_b);\n}\n\nfunction getMilliseconds(seconds) {\n  return seconds * 1000;\n}\n\nfunction debounce(func, timeout, id) {\n  return () => {\n    state[`debounceTimer#${id}`] && clearTimeout(state[`debounceTimer#${id}`]);\n    const timer = setTimeout(func, timeout);\n    State.update({ [`debounceTimer#${id}`]: timer })\n  };\n}\n\nfunction calculateFee(num) {\n  Big.PE = 40\n  const _num = Big(num)\n  const a = _num.times(3)\n  const b = a.div(100)\n  return b.toString()\n}\n\nconst limitPerItem = Number(formatNear(MAX_AMOUNT_PER_ITEM));\n\nuseEffect(() => {\n  if (equals(state.totalTipsByItemId, '0')) {\n    State.update({\n      accountId,\n      disabled: false,\n      loading: false,\n      label: 'Tip',\n      tooltip: 'Send donation',\n      donationsAmount: state.totalTipsByItemId,\n      amount: state.amount || '0',\n    })\n  } else if (Number(formatNear(state.totalTipsByItemId)) === limitPerItem) {\n    State.update({\n      accountId,\n      disabled: true,\n      loading: false,\n      label: formatNear(state.totalTipsByItemId) + ' NEAR',\n      tooltip: `The ${limitPerItem} NEAR limit for this content has been exceeded`,\n      donationsAmount: state.totalTipsByItemId,\n      amount: state.amount || '0',\n    })\n  } else {\n    State.update({\n      accountId,\n      disabled: false,\n      loading: false,\n      label: formatNear(state.totalTipsByItemId) + ' NEAR',\n      tooltip: 'Send donation',\n      donationsAmount: state.totalTipsByItemId,\n      amount: state.amount || '0',\n    })\n  }\n}, [accountId, state.totalTipsByItemId]);\n\nconst onDebounceDonate = () => {\n  try {\n    State.update({\n      loading: true,\n      disabled: true,\n    })\n    const fee = calculateFee(state.amount);\n    const total = sum(state.amount, fee);\n    Near.call(\n      TIPPING_CONTRACT_NAME,\n      \"sendTips\",\n      {\n        accountGId: accountId,\n        itemId: itemGlobalId,\n      },\n      '50000000000000',\n      total,\n    );\n    setTimeout(() => State.update({\n      disabled: false,\n      loading: false,\n      label: equals(state.donationsAmount, '0') ? 'Tip' : formatNear(state.donationsAmount) + ' NEAR',\n      donationsAmount: state.totalTipsByItemId,\n      amount: '0',\n    }), 3000)\n  } catch (e) {\n    console.error(e);\n    State.update({\n      disabled: false,\n      loading: false,\n      label: equals(state.donationsAmount, '0') ? 'Tip' : formatNear(state.donationsAmount) + ' NEAR',\n      donationsAmount: state.totalTipsByItemId,\n      amount: '0',\n    });\n  }\n};\n\nconst stepYocto = parseNearAmount(STEP.toString());\nconst debounceDelay = getMilliseconds(DELAY);\nconst debouncedDonate = debounce(onDebounceDonate, debounceDelay, 'donate')\n\nconst onClick = () => {\n  const donationsAmountStr = formatNear(state.donationsAmount)\n  const donationsAmount = Number(donationsAmountStr);\n  const donation = Number(formatNear(state.amount));\n  const result = Number((donationsAmount + donation + STEP).toFixed(2));\n  if (result > limitPerItem) {\n    if (donation === 0) {\n      State.update({\n        disabled: true,\n        label: donationsAmountStr + ' + ' + STEP + ' NEAR',\n        tooltip: `The ${limitPerItem} NEAR limit for this content has been exceeded`,\n      })\n      setTimeout(() => State.update({\n        disabled: false,\n        label: donationsAmountStr + ' NEAR',\n        tooltip: 'Send donation',\n      }), 3000)\n      return \n    }\n    State.update({\n      disabled: true,\n      tooltip: `The ${limitPerItem} NEAR limit for this content has been exceeded`,\n    })\n    return\n  }\n  const expectedItemAmount = sum(state.donationsAmount, state.amount, stepYocto)\n  const expectedExpenses = sum(state.amount, stepYocto)\n  if (lte(expectedItemAmount, MAX_AMOUNT_PER_ITEM) && lte(expectedExpenses, MAX_AMOUNT_PER_TIP)) {\n    const newLabel = formatNear(state.donationsAmount) + ' + ' + formatNear(expectedExpenses) + ' NEAR'\n    State.update({\n      disabled: result === limitPerItem,\n      label: newLabel,\n      amount: expectedExpenses,\n    })\n  }\n  debouncedDonate();\n};\n\n// styles\nconst LikeButton = styled.button`\n  line-height: 20px;\n  min-height: 20px;\n  display: inline-flex;\n  align-items: center;\n  justify-content: left;\n  background: inherit;\n  color: inherit;\n  font-size: 16px;\n  user-select: none;\n  border: none;\n  margin: 0;\n  padding: 0;\n  .icon {\n    position: relative;\n    &:before {\n      margin: -8px;\n      content: \"\";\n      position: absolute;\n      top: 0;\n      left: 0;\n      bottom: 0;\n      right: 0;\n      border-radius: 50%;\n    }\n  }\n\n  .count {\n    margin-left: 8px;\n  }\n\n  &:not([disabled]) {\n    cursor: pointer;\n  }\n\n  &:not([disabled]):hover {\n    opacity: 1 !important;\n    color: green;\n\n    .icon:before {\n      background: rgba(0, 255, 0, 0.1);\n    }\n  }\n\n  .loading {\n    @keyframes scaleAnimation {\n     0%, 100% {\n        transform: scale(1) rotate(0deg);\n      }\n      25% {\n        transform: scale(1.2) rotate(-15deg);\n      }\n      50% {\n        transform: scale(1) rotate(0deg);\n      }\n      75% {\n        transform: scale(1.2) rotate(15deg);\n      }\n    }\n\n    transform-origin: center;\n    animation: scaleAnimation 1s ease-in-out infinite;\n  }\n`;\n\nreturn (\n  <div className=\"d-inline-flex align-items-center\">\n    <LikeButton\n      disabled={state.disabled}\n      title={state.tooltip}\n      onClick={onClick}\n    >\n      <span className={`icon ${state.loading ? \"loading \" : \"\"}`}>\n        <Widget src=\"bos.dapplets.near/widget/Tipping.TipIcon\" />\n      </span>\n      <span className={`count`}>\n        {state.label}\n      </span>\n    </LikeButton>\n  </div>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/bos.dapplets.near/widget/Tipping.Main", "fact_widget_deployments_id": "dd01b385b50b5ba819ebbb5582b4dd89", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 30}