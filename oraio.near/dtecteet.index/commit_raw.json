{"tx_hash": "6XrKdwAmQbUk7yRCVSh5MwRC9ub836pGJd1nxBieMX5c", "action_id_social": "GKELFWxK2PoUkLPKTDKprPfjwj57XcqrECtX7Uh1GePG-0-widget", "block_id": 111117635, "block_timestamp": "2024-01-23T12:35:22.013Z", "signer_id": "oraio.near", "widget_name": "dTecteet.index", "source_code": "const font = fetch(\n  \"https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap\"\n).body;\n\nif (!font) {\n  return null;\n}\n\nState.init({\n  theme: Storage.privateGet(\"theme\") || \"light\",\n  component: null,\n  near: null,\n  ether: null,\n  external: null,\n});\n\nconst detectExternalAPI = (componentCode) => {\n  const externalAPICallRegex =\n    /fetch\\(|asyncFetch\\(|useCache\\(|State\\.[a-zA-Z]+\\.?\\w*\\(|Social\\.[a-zA-Z]+\\.?\\w*\\(|Storage\\.[a-zA-Z]+\\.?\\w*\\(|clipboard\\.[a-zA-Z]+\\.?\\w*\\(/g;\n  return componentCode.match(externalAPICallRegex);\n};\n\nconst detectNearAPI = (componentCode) => {\n  const nearAPICallRegex = /Near\\.[a-zA-Z]+\\.?\\w*\\(/g;\n  return componentCode.match(nearAPICallRegex);\n};\n\nconst detectEtherAPI = (componentCode) => {\n  const etherAPICallRegex = /ethers\\.[a-zA-Z]+\\.?\\w*\\(/g;\n  return componentCode.match(etherAPICallRegex);\n};\n\nconst cleanUp = (htmlText) => {\n  // get the code from the first noscript in body\n  const startRgx = /<noscript/;\n  const endRgx = /<\\/noscript>/;\n  const startTwoRgx = />/;\n  let start, end, code;\n\n  start = htmlText.match(startRgx).index;\n  end = htmlText.match(endRgx).index;\n  code = htmlText.substring(start, end + endRgx.toString().length);\n\n  // isolate from the noscript tags\n  start = code.match(startTwoRgx).index;\n  end = code.match(endRgx).index;\n  code = code.substring(start + 1, end);\n\n  return code;\n};\n\nconst getDependencyComponents = (htmlCode) => {\n  const srcValues = [];\n  const regex = /&lt;Widget\\s*src\\s*=\\s*[\"']([^\"']+)[\"']/g;\n  let match;\n\n  while ((match = regex.exec(htmlCode)) !== null) srcValues.push(match[1]);\n\n  return srcValues;\n};\n\nconst wrappedAsyncFetch = (url, callback) => {\n  asyncFetch(url)\n    .then((result) => {\n      callback(null, result);\n    })\n    .catch((error) => {\n      callback(error, null);\n    });\n};\n\nconst search = (component, hasNear, hasEther, hasExternal) => {\n  const urlPrefix = \"https://near.social/mob.near/widget/WidgetSource?src=\";\n  const response = {\n    external: {},\n    near: {},\n    ether: {},\n  };\n  const componentSrcQueue = [component];\n\n  const handleClassAPI = (htmlCode, apiClass, component, apiDetector) => {\n    const classAPICalls = apiDetector(htmlCode);\n    const classMap = response[apiClass];\n\n    if (classAPICalls.length) {\n      if (component in classMap) classMap[component].push(...classAPICalls);\n      else classMap[component] = [...classAPICalls];\n    }\n  };\n\n  const processComponentQueue = (index) => {\n    if (index < componentSrcQueue.length) {\n      const componentSrcPageUrl = urlPrefix + componentSrcQueue[index];\n\n      wrappedAsyncFetch(componentSrcPageUrl, (error, result) => {\n        if (error) {\n          console.error(\"Error fetching component source:\", error.message);\n        } else {\n          const htmlCode = cleanUp(result.body);\n\n          if (htmlCode !== \"The source code is not available.\") {\n            if (hasNear)\n              handleClassAPI(\n                htmlCode,\n                \"near\",\n                componentSrcQueue[index],\n                detectNearAPI\n              );\n            if (hasEther)\n              handleClassAPI(\n                htmlCode,\n                \"ether\",\n                componentSrcQueue[index],\n                detectEtherAPI\n              );\n            if (hasExternal)\n              handleClassAPI(\n                htmlCode,\n                \"external\",\n                componentSrcQueue[index],\n                detectExternalAPI\n              );\n          }\n\n          // Enqueue all dependency component src\n          componentSrcQueue.push(...getDependencyComponents(htmlCode));\n\n          // Continue processing the queue recursively\n          processComponentQueue(index + 1);\n        }\n      });\n    } else {\n      // Finished processing the queue\n      const { near, ether, external } = response;\n      State.update({\n        near,\n        ether,\n        external,\n      });\n    }\n  };\n\n  // Start processing the queue from index 0\n  processComponentQueue(0);\n};\n\nconst dark = {\n  name: \"dark\",\n  bg: \"#28282b\",\n  color: \"#e6eaee\",\n  border: \"#748094\",\n  hover: {\n    bg: \"#39393c\",\n    border: \"#4e5460\",\n  },\n  text: {\n    fontSize: \"16px\",\n  },\n  heading: {\n    fontSize: \"18px\",\n    fontWeight: \"600\",\n  },\n};\n\nconst light = {\n  name: \"light\",\n  bg: \"#e3e8ef\",\n  color: \"#1b202b\",\n  border: \"#748094\",\n  hover: {\n    bg: \"#eef2f6\",\n    border: \"#d8dfe7\",\n  },\n  text: {\n    fontSize: \"16px\",\n  },\n  heading: {\n    fontSize: \"18px\",\n    fontWeight: \"600\",\n  },\n};\n\nconst useTheme = (light, dark) => {\n  return state.theme === \"light\" ? light : dark;\n};\n\nconst switchTheme = () => {\n  const themeToChange = useTheme(\"dark\", \"light\");\n  State.update({\n    theme: themeToChange,\n  });\n  Storage.privateSet(\"theme\", themeToChange);\n};\n\nconst localStorageTheme = Storage.privateGet(\"theme\");\nif (localStorageTheme)\n  State.update({\n    theme: localStorageTheme,\n  });\n\nconst GlobalStyle = styled.div`\n  * {\n    font-family: \"Source Code Pro\", cursive;\n  }\n  ${font}\n`;\n\nconst Main = styled.div`\n  width: 100%;\n  display: flex;\n  flex-direction: column;\n  color: ${useTheme(light.color, dark.color)};\n  background-color: ${useTheme(light.bg, dark.bg)};\n  overflow-y: auto;\n  padding-bottom: 80px;\n  min-height: 100vh;\n\n  @media only screen and (max-width: 750px) {\n    padding-bottom: 160px;\n  }\n`;\n\nconst Stack = styled.div`\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  gap: 30px;\n`;\n\nconst HStack = styled.div`\n  display: flex;\n  flex-direction: row;\n  justify-content: center;\n  align-items: center;\n  gap: 15px;\n`;\n\nconst SearchStack = styled.div`\n  display: flex;\n  flex-direction: row;\n  justify-content: center;\n  align-items: center;\n  gap: 15px;\n\n  @media only screen and (max-width: 750px) {\n    flex-direction: column;\n    gap: 30px;\n  }\n`;\n\nconst Content = styled.div`\n  padding-top: 80px;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  gap: 30px;\n`;\nconst handleSubmit = (value) => {\n  search(value, true, true, true);\n};\n\nconst pages = {\n  main: (\n    <>\n      <SearchStack>\n        <Widget\n          src=\"oraio.near/widget/dtecteet.ComponentSearch\"\n          props={{\n            placeholder: \"Account ID\",\n            theme: useTheme(light, dark),\n            handleSubmit: handleSubmit,\n          }}\n        />\n      </SearchStack>\n      <Widget\n        src=\"oraio.near/widget/dTecteet.Result\"\n        props={{\n          theme: useTheme(light, dark),\n          near: state.near,\n          ether: state.ether,\n          external: state.external,\n        }}\n      />\n    </>\n  ),\n\n  blog: <a href=\"#\"></a>,\n  docs: (\n    <Widget\n      src=\"oraio.near/widget/dTecteet.Docs\"\n      props={{\n        theme: useTheme(light, dark),\n      }}\n    />\n  ),\n};\n\nreturn (\n  <GlobalStyle>\n    <Main>\n      <Widget\n        src=\"oraio.near/widget/dTecteet.Navbar\"\n        props={{\n          theme: useTheme(light, dark),\n          switchTheme: switchTheme,\n        }}\n      />\n      <Content>{pages[props.page] ? pages[props.page] : pages.main}</Content>\n    </Main>\n  </GlobalStyle>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/oraio.near/widget/dTecteet.index", "fact_widget_deployments_id": "8b6c4d7975f1cd991ee39d9a899b27dc", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 1}