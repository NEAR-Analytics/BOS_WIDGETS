{"tx_hash": "2CykLLccTYcUDVTW49NSLMv4xcsjJ1FhLRQyHxk43gnQ", "action_id_social": "ESYaA36st83dxRtzPedyRPnCYgf2N88UZzvzYYZ3BPnX-0-widget", "block_id": 112698817, "block_timestamp": "2024-02-12T19:51:32.683Z", "signer_id": "box_factory.near", "widget_name": "MysteryBox", "source_code": "const widget_owner_id = \"box_factory.near\";\nconst rpc_endpoint = \"https://rpc.mainnet.near.org\";\n\nconst account_id = context.accountId;\nconst contract_id = props.contract_id;\n\nconst createRewardsKey = (rarity) => `${rarity}_rewards`;\n\nState.init({\n  showVerificationScreen: false,\n  showClaimAnimationScreen: false,\n  boxes: {},\n  [createRewardsKey(\"rare\")]: [],\n  [createRewardsKey(\"epic\")]: [],\n  [createRewardsKey(\"legendary\")]: [],\n  totalSupply: \"0\",\n  lastClaimedBoxReward: null,\n  lastClaimedBoxRarity: null,\n});\n\n// TODO: view spec to make sure it's appropriate contract\nif (!contract_id) {\n  return (\n    <Widget\n      src={`${widget_owner_id}/widget/MysteryBox.Screens.InvalidContract`}\n    />\n  );\n}\n\n// TODO: remove styled containers for components to make them importable (only pages may contain containers)\nif (!account_id) {\n  return (\n    <Widget\n      src={`${widget_owner_id}/widget/MysteryBox.Screens.AuthenticationRequired`}\n      props={{\n        url: \"https://near.org/signin\",\n      }}\n    />\n  );\n}\n\nconst fetchRewards = (contract_id) => {\n  fetchAndUpdateRewardsByRarity(contract_id, \"rare\");\n  fetchAndUpdateRewardsByRarity(contract_id, \"epic\");\n  fetchAndUpdateRewardsByRarity(contract_id, \"legendary\");\n};\n\nconst fetchAvailableRewardsByRarity = (contract_id, rarity) => {\n  const data = Near.view(contract_id, \"available_rewards\", {\n    rarity: rarity,\n    pagination: {\n      page: 1,\n      size: 3,\n    },\n  });\n\n  if (data === undefined) throw `No ${rarity} rewards returned :(`;\n\n  return data || [];\n};\n\nconst fetchAndUpdateRewardsByRarity = (contract_id, rarity) => {\n  const key = createRewardsKey(rarity);\n\n  if (state[key].length !== 0) return;\n\n  const rewards = fetchAvailableRewardsByRarity(contract_id, rarity);\n\n  if (rewards.length === 0) return;\n\n  const updated_rewards = [...state[key], ...rewards];\n\n  State.update({\n    [key]: updated_rewards,\n  });\n};\n\nconst fetchUserBoxes = (contract_id, account_id) => {\n  const boxes = Near.view(contract_id, \"boxes_for_owner\", {\n    account_id: account_id,\n    pagination: {\n      page: 1,\n      size: 20,\n    },\n  });\n\n  if (boxes === undefined) throw `No boxes returned :(`;\n\n  const entries = (boxes || []).map((box) => [box.id, box]);\n\n  const updated_boxes = Object.assign(\n    {},\n    state.boxes,\n    Object.fromEntries(entries)\n  );\n\n  State.update({\n    boxes: updated_boxes,\n  });\n};\n\nconst fetchTotalSupply = (contract_id) => {\n  const totalSupply = Near.view(contract_id, \"total_supply\", {});\n\n  if (totalSupply === undefined) throw `No supply returned :(`;\n\n  State.update({\n    totalSupply,\n  });\n};\n\nconst fetchTransactionByHash = (hash, sender_id) => {\n  return fetch(rpc_endpoint, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({\n      jsonrpc: \"2.0\",\n      id: \"dontcare\",\n      method: \"tx\",\n      params: [hash, sender_id],\n    }),\n  });\n};\n\nconst parseResultFromClaimTransactionResponse = (response) => {\n  if (!response?.body) throw `Response is missing body`;\n\n  if (response.body.error) throw response.body.error.data || \"Unknown error\";\n\n  const result = response.body.result;\n\n  if (!result) throw `Body is missing result field`;\n\n  const responseValue = result?.status?.SuccessValue;\n\n  if (!responseValue) return null;\n\n  console.log(\"result\", result);\n\n  return JSON.parse(Buffer.from(responseValue, \"base64\").toString());\n};\n\nconst fetchClaimTransactionResult = (hash, account_id) => {\n  try {\n    const response = fetchTransactionByHash(hash, account_id);\n\n    const result = parseResultFromClaimTransactionResponse(response);\n\n    console.log(\"claim result\", result);\n\n    if (!result) return;\n\n    Storage.set(hash, 1);\n\n    State.update({\n      showClaimAnimationScreen: true,\n      lastClaimedBoxRarity: result[1],\n    });\n\n    setTimeout(() => {\n      State.update({\n        lastClaimedBoxReward: result[2],\n      });\n    }, 2_000);\n  } catch (error) {\n    console.warn(`Caught error during fetch claim tx result`, error);\n\n    State.update({\n      showClaimAnimationScreen: false,\n    });\n  }\n};\n\ntry {\n  fetchRewards(contract_id);\n  fetchUserBoxes(contract_id, account_id);\n  fetchTotalSupply(contract_id);\n} catch (err) {\n  console.log(\"caught error on fetch rewards:\", err);\n  return (\n    <Widget\n      src={`${widget_owner_id}/widget/MysteryBox.Screens.InvalidContract`}\n    />\n  );\n}\n\nif (state.showVerificationScreen === true) {\n  return (\n    <Widget\n      src={`${widget_owner_id}/widget/MysteryBox.Screens.VerificationRequired`}\n      props={{\n        url: \"https://i-am-human.app?community=nearukraine&vertical=regionalcommunities\",\n      }}\n    />\n  );\n}\n\nconst value = Storage.get(props.transactionHashes);\nconst hashExistInStorage = value !== null && value !== undefined;\nconsole.log(\"hashExistInStorage\", hashExistInStorage);\n\ntry {\n  if (props.transactionHashes && !hashExistInStorage) {\n    fetchClaimTransactionResult(props.transactionHashes, account_id);\n  }\n} catch (err) {\n  console.warn(\"caught error on fetch claim transaction result:\", err);\n}\n\nif (state.showClaimAnimationScreen === true) {\n  const onBack = () => {\n    State.update({\n      showClaimAnimationScreen: false,\n    });\n  };\n\n  return (\n    <Widget\n      src={`${widget_owner_id}/widget/MysteryBox.Screens.ClaimAnimation`}\n      props={{\n        reward: state.lastClaimedBoxReward,\n        rarity: state.lastClaimedBoxRarity,\n        onBack,\n      }}\n    />\n  );\n}\n\nconst boxes = Object.values(state.boxes).map((box) => ({\n  ...box,\n  rewards: state[createRewardsKey(box.rarity)],\n}));\n\nif (boxes.length === 0) {\n  return (\n    <Widget src={`${widget_owner_id}/widget/MysteryBox.Screens.NoBoxesFound`} />\n  );\n}\n\nconst getRegistryIAHContract = (currect_contract_id) => {\n  if (currect_contract_id.endsWith(\".near\")) return \"registry.i-am-human.near\";\n\n  return `registry-v2.i-am-human.testnet`;\n};\n\nconst getIssuerIAHContract = (currect_contract_id) => {\n  if (currect_contract_id.endsWith(\".near\")) return \"fractal.i-am-human.near\";\n\n  return `fractal-v2.i-am-human.testnet`;\n};\n\nconst checkVerification = (account_id) => {\n  const view = Near.view(\n    getRegistryIAHContract(widget_owner_id),\n    \"sbt_tokens_by_owner\",\n    {\n      account: account_id,\n      issuer: getIssuerIAHContract(widget_owner_id),\n    }\n  );\n\n  const sbtToken = view?.[0]?.[1]?.[0];\n\n  return sbtToken !== undefined && sbtToken !== null;\n};\n\nconst isVerified = checkVerification(account_id);\n\nconst redirectToVerification = () => {\n  State.update({\n    showVerificationScreen: true,\n  });\n};\n\nconst onClaim = (box_id) => {\n  if (!isVerified) {\n    return redirectToVerification();\n  }\n\n  const gas = Big(100e12).toString(); // 100 TGas\n\n  return Near.call(\n    contract_id,\n    \"claim\",\n    {\n      box_id,\n    },\n    gas,\n    1 // exactly 1 yocto\n  );\n};\n\nreturn (\n  <Widget\n    src={`${widget_owner_id}/widget/MysteryBox.Screens.Claim`}\n    props={{\n      onClaim,\n      boxes,\n      totalSupply: state.totalSupply,\n    }}\n  />\n);\n", "metadata": {"description": "Randomly distribute NEAR & NFT rewards among users", "image": {"ipfs_cid": "bafkreibi3zqtnrvfwenl3v6reqfynzrz2fmmrac52s434bpwa2joiawfne"}, "name": "Mystery Box", "tags": {"app": ""}}, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/box_factory.near/widget/MysteryBox", "fact_widget_deployments_id": "101c538472388469b5ff248a3405f0a2", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 0}