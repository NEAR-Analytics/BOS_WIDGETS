{"tx_hash": "A38PWeK1pv85hzQRrEyFbBz2NRZrfSHGf7Lrjzf362r4", "action_id_social": "CZGRnoQgjz6j6fD8cK875vKvGPHdjxhkGQVhJ2djGoKS-0-widget", "block_id": 112275463, "block_timestamp": "2024-02-07T02:17:08.307Z", "signer_id": "thalesb.near", "widget_name": "compound-requests", "source_code": "const POSITION_STORAGE_KEY = \"POSITION_STATE\";\n\nconst abi = fetch(\n  \"https://docs.compound.finance/public/files/comet-interface-abi-98f438b.json\"\n);\n\nif (!abi) return \"Loading...\";\n\nfunction getUserPosition({ userAddress, cometAddress, rpcUrl, force }) {\n  return new Promise((resolve, reject) => {\n    const stored = Storage.get(POSITION_STORAGE_KEY + cometAddress);\n\n    if (!userAddress) return reject(\"No user address provided\");\n\n    if (!cometAddress) return reject(\"No contract address provided\");\n\n    if (stored && !force) return resolve(stored);\n\n    const contract = new ethers.Contract(\n      cometAddress,\n      abi.body,\n      new ethers.providers.JsonRpcProvider(rpcUrl)\n    );\n\n    const promisesAssets = [];\n    const promisesCollaterals = [];\n    const promisesPrices = [];\n\n    getMinimumBorrowAmount({ cometAddress, rpcUrl }).then((minBorrowAmount) => {\n      contract.numAssets().then((numAssets) => {\n        for (let i = 0; i < numAssets; i++) {\n          promisesAssets.push(contract.getAssetInfo(i));\n        }\n\n        Promise.all(promisesAssets)\n          .then((infos) => {\n            for (let i = 0; i < numAssets; i++) {\n              const assetInfo = infos[i];\n\n              const asset = assetInfo[1];\n              const priceFeed = assetInfo[2];\n\n              promisesCollaterals.push(\n                contract.collateralBalanceOf(userAddress, asset)\n              );\n\n              promisesPrices.push(contract.getPrice(priceFeed));\n            }\n\n            return infos;\n          })\n          .then((infos) => {\n            contract.baseTokenPriceFeed().then((baseTokenPriceFeed) => {\n              contract.getPrice(baseTokenPriceFeed).then((price) => {\n                const basePrice = price.toString() / 1e8;\n\n                contract.decimals().then((decimals) => {\n                  const baseDecimals = decimals.toString();\n\n                  let collateralValueUsd = 0;\n                  let totalBorrowCapacityUsd = 0;\n                  let borrowCapacityUsd = 0;\n                  let borrowCapacityBase = 0;\n                  let borrowedInUsd = 0;\n                  let borrowedInBase = 0;\n\n                  Promise.all(promisesCollaterals).then(\n                    (collateralBalances) => {\n                      Promise.all(promisesPrices).then((collateralPrices) => {\n                        for (let i = 0; i < numAssets; i++) {\n                          const balance =\n                            Number(collateralBalances[i].toString()) /\n                            Number(infos[i][3].toString());\n\n                          const price =\n                            Number(collateralPrices[i].toString()) / 1e8;\n\n                          collateralValueUsd += balance * price;\n\n                          totalBorrowCapacityUsd +=\n                            balance *\n                            price *\n                            (Number(infos[i][4].toString()) / 1e18);\n\n                          contract\n                            .borrowBalanceOf(userAddress)\n                            .then((borrowBalance) => {\n                              const balance = borrowBalance.toString();\n\n                              borrowedInUsd =\n                                (balance / Math.pow(10, baseDecimals)) *\n                                basePrice;\n\n                              borrowCapacityUsd =\n                                totalBorrowCapacityUsd - borrowedInUsd;\n\n                              borrowCapacityBase =\n                                borrowCapacityUsd / basePrice;\n\n                              borrowedInBase = borrowedInUsd / basePrice;\n\n                              const data = {\n                                collaterals: infos,\n                                baseTokenPriceFeed,\n                                numAssets,\n                                basePrice,\n                                baseDecimals,\n                                collateralValueUsd,\n                                totalBorrowCapacityUsd,\n                                borrowCapacityUsd,\n                                borrowCapacityBase:\n                                  Math.floor(\n                                    (borrowCapacityBase + Number.EPSILON) * 100\n                                  ) / 100,\n                                borrowedInUsd,\n                                borrowedInBase,\n                                minBorrowAmount,\n                              };\n\n                              resolve(data);\n                              Storage.set(\n                                POSITION_STORAGE_KEY + cometAddress,\n                                data\n                              );\n                            });\n                        }\n                      });\n                    }\n                  );\n                });\n              });\n            });\n          });\n      });\n    });\n  });\n}\n\nconst secondsPerYear = 60 * 60 * 24 * 365;\n\nfunction getApr({ cometAddress, rpcUrl }) {\n  const contract = new ethers.Contract(\n    cometAddress,\n    abi.body,\n    new ethers.providers.JsonRpcProvider(rpcUrl)\n  );\n\n  return new Promise((resolve, reject) => {\n    asyncFetch(\n      \"https://v3-api.compound.finance/market/all-networks/all-contracts/rewards/dapp-data\"\n    ).then((res) => {\n      const rewards = JSON.parse(res.body);\n\n      const rewardsByCometAddress = rewards.reduce((acc, item) => {\n        if (!acc[item.comet.address]) {\n          acc[item.comet.address] = [item];\n        } else {\n          acc[item.comet.address].push(item);\n        }\n        return acc;\n      }, {});\n\n      contract.baseTokenPriceFeed().then((baseTokenPriceFeed) => {\n        contract.getPrice(baseTokenPriceFeed).then((price) => {\n          const basePrice = price.toString() / 1e8;\n\n          contract.decimals().then((decimals) => {\n            contract.totalBorrow().then((res) => {\n              const totalBorrow =\n                Number(ethers.utils.formatUnits(res.toString(), decimals)) *\n                basePrice;\n\n              contract.getUtilization().then((res) => {\n                const utilization = Number(res.toString());\n                const parsedUtilization = (utilization / 1e18) * 100;\n\n                contract.totalSupply().then((res) => {\n                  const totalEarning =\n                    Number(ethers.utils.formatUnits(res.toString(), decimals)) *\n                    basePrice;\n\n                  contract.getSupplyRate(utilization.toString()).then((res) => {\n                    const rate = Number(res.toString());\n\n                    const supplyApr = (rate / 1e18) * secondsPerYear * 100;\n\n                    contract\n                      .getBorrowRate(utilization.toString())\n                      .then((res) => {\n                        const borrowRate = Number(res.toString());\n\n                        const borrowApr =\n                          (borrowRate / 1e18) * secondsPerYear * 100;\n\n                        resolve({\n                          totalBorrow,\n                          utilization: parsedUtilization,\n                          totalEarning,\n                          supplyApr,\n                          borrowApr,\n                          borrowRate,\n                          rewards: rewardsByCometAddress[cometAddress][0] || [],\n                        });\n                      });\n                  });\n                });\n              });\n            });\n          });\n        });\n      });\n    });\n  });\n}\n\nfunction getMinimumBorrowAmount({ cometAddress, rpcUrl }) {\n  const contract = new ethers.Contract(\n    cometAddress,\n    abi.body,\n    new ethers.providers.JsonRpcProvider(rpcUrl)\n  );\n\n  return new Promise((resolve, reject) => {\n    contract\n      .decimals()\n      .catch(reject)\n      .then((decimals) => {\n        contract\n          .baseBorrowMin()\n          .catch(reject)\n          .then((res) => {\n            const minimumBorrowAmount = Number(\n              ethers.utils.formatUnits(res.toString(), decimals)\n            );\n\n            resolve(minimumBorrowAmount);\n          });\n      });\n  });\n}\n\nreturn { getUserPosition, getApr };\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/thalesb.near/widget/compound-requests", "fact_widget_deployments_id": "8f9b731d0f1c633b7567da59c38c89ab", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 0}