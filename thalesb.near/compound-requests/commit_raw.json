{"tx_hash": "5i5Qx9kW1WbXAkTvsf7JGoWdki2jgco7Dy9rpYwNBbRU", "action_id_social": "8qBaPVPGCmeAVGA2DQ6vKFFbAXCZsN4MntsH76QEPy2M-0-widget", "block_id": 114152883, "block_timestamp": "2024-03-05T16:49:11.139Z", "signer_id": "thalesb.near", "widget_name": "compound-requests", "source_code": "const POSITION_STORAGE_KEY = \"POSITION_STATE\";\nconst COLLATERAL_STORAGE_KEY = \"COLLATERAL_STATE\";\n\nconst abi = fetch(\n  \"https://docs.compound.finance/public/files/comet-interface-abi-98f438b.json\",\n);\n\nif (!abi) return \"Loading...\";\n\nconst secondsPerYear = 60 * 60 * 24 * 365;\n\n/**\n * Calculates the Annual Percentage Rate (APR) for a given Compound contract.\n * @param {Object} options - The options for calculating the APR.\n * @param {string} options.cometAddress - The address of the Compound contract.\n * @param {string} options.rpcUrl - The URL of the JSON-RPC provider.\n * @returns {Promise<Object>} - A promise that resolves to an object containing the APR and other related information.\n */\nfunction getApr({ cometAddress, rpcUrl }) {\n  const contract = new ethers.Contract(\n    cometAddress,\n    abi.body,\n    new ethers.providers.JsonRpcProvider(rpcUrl),\n  );\n\n  return new Promise((resolve, reject) => {\n    asyncFetch(\n      \"https://v3-api.compound.finance/market/all-networks/all-contracts/rewards/dapp-data\",\n    ).then((res) => {\n      const rewards = JSON.parse(res.body);\n\n      const rewardsByCometAddress = rewards.reduce((acc, item) => {\n        const address = item.comet.address.toLowerCase();\n\n        if (!acc[address]) {\n          acc[address] = [item];\n        } else {\n          acc[address].push(item);\n        }\n        return acc;\n      }, {});\n\n      contract.baseTokenPriceFeed().then((baseTokenPriceFeed) => {\n        contract.getPrice(baseTokenPriceFeed).then((price) => {\n          const basePrice = price.toString() / 1e8;\n\n          contract.decimals().then((decimals) => {\n            contract.totalBorrow().then((res) => {\n              const totalBorrow =\n                Number(ethers.utils.formatUnits(res.toString(), decimals)) *\n                basePrice;\n\n              contract.getUtilization().then((res) => {\n                const utilization = Number(res.toString());\n                const parsedUtilization = (utilization / 1e18) * 100;\n\n                contract.totalSupply().then((res) => {\n                  const totalEarning =\n                    Number(ethers.utils.formatUnits(res.toString(), decimals)) *\n                    basePrice;\n\n                  contract.getSupplyRate(utilization.toString()).then((res) => {\n                    const rate = Number(res.toString());\n\n                    const supplyApr = (rate / 1e18) * secondsPerYear * 100;\n\n                    contract\n                      .getBorrowRate(utilization.toString())\n                      .then((res) => {\n                        const borrowRate = Number(res.toString());\n\n                        const borrowApr =\n                          (borrowRate / 1e18) * secondsPerYear * 100;\n\n                        resolve({\n                          totalBorrow,\n                          utilization: parsedUtilization,\n                          totalEarning,\n                          supplyApr,\n                          borrowApr,\n                          borrowRate,\n                          rewards:\n                            rewardsByCometAddress[\n                              cometAddress.toLowerCase()\n                            ][0] || [],\n                        });\n                      });\n                  });\n                });\n              });\n            });\n          });\n        });\n      });\n    });\n  });\n}\n\n/**\n * Retrieves the minimum borrow amount from a compound contract.\n *\n * @param {Object} options - The options object.\n * @param {string} options.cometAddress - The address of the compound contract.\n * @param {string} options.rpcUrl - The RPC URL for the provider.\n * @returns {Promise<number>} A promise that resolves to the minimum borrow amount.\n */\nfunction getMinimumBorrowAmount({ cometAddress, rpcUrl }) {\n  const contract = new ethers.Contract(\n    cometAddress,\n    abi.body,\n    new ethers.providers.JsonRpcProvider(rpcUrl),\n  );\n\n  return new Promise((resolve, reject) => {\n    return contract\n      .decimals()\n      .catch(reject)\n      .then((decimals) => {\n        return contract\n          .baseBorrowMin()\n          .catch(reject)\n          .then((res) => {\n            const minimumBorrowAmount = Number(\n              ethers.utils.formatUnits(res.toString(), decimals),\n            );\n\n            resolve(minimumBorrowAmount);\n          });\n      });\n  });\n}\n\n/**\n * Retrieves collateral assets information for a user.\n *\n * @param {Object} options - The options for retrieving collateral assets.\n * @param {string} options.cometAddress - The contract address.\n * @param {string} options.userAddress - The user address.\n * @param {string} options.rpcUrl - The RPC URL.\n * @returns {Promise<Object>} A promise that resolves to the collateral assets information.\n * @throws {Error} If no contract address, RPC URL, or user address is provided.\n */\nfunction getCollateralAssets({ cometAddress, userAddress, rpcUrl }) {\n  if (!cometAddress) throw new Error(\"No contract address provided\");\n\n  if (!rpcUrl) throw new Error(\"No rpc url provided\");\n\n  if (!userAddress) throw new Error(\"No user address provided\");\n\n  const contract = new ethers.Contract(\n    cometAddress,\n    abi.body,\n    new ethers.providers.JsonRpcProvider(rpcUrl),\n  );\n\n  function getAssetsPromises(numAssets) {\n    const collateralsPromises = [];\n\n    for (let i = 0; i < numAssets; i++) {\n      collateralsPromises.push(contract.getAssetInfo(i));\n    }\n\n    return Promise.all(collateralsPromises);\n  }\n\n  function getAssetInfo(assets) {\n    const pricesPromises = [];\n\n    for (let i = 0; i < assets.length; i++) {\n      const asset = assets[i];\n      const priceFeed = asset[2];\n\n      pricesPromises.push(\n        contract.getPrice(priceFeed).then((price) => {\n          const assetContract = new ethers.Contract(\n            asset[1],\n            [\"function decimals() view returns (uint8)\"],\n            new ethers.providers.JsonRpcProvider(rpcUrl),\n          );\n\n          return assetContract.decimals().then((decimals) => {\n            return {\n              asset: asset[1],\n              price: price.toString() / 1e8,\n              decimals: decimals.toString(),\n            };\n          });\n        }),\n      );\n    }\n\n    return Promise.all(pricesPromises).then((prices) => {\n      const pricesHash = prices.reduce((acc, item) => {\n        acc[item.asset] = item;\n        return acc;\n      }, {});\n\n      return {\n        assets,\n        prices: pricesHash,\n      };\n    });\n  }\n\n  function getAssetsBalance(data) {\n    const balancesPromises = [];\n\n    for (let i = 0; i < data.assets.length; i++) {\n      const asset = data.assets[i][1];\n\n      balancesPromises.push(\n        contract.userCollateral(userAddress, asset).then((balance) => {\n          return contract.borrowBalanceOf(userAddress).then((borrowBalance) => {\n            return {\n              asset,\n              balance: ethers.utils.formatUnits(\n                balance[0],\n                data.prices[asset].decimals,\n              ),\n              borrowBalance: ethers.utils.formatUnits(\n                borrowBalance,\n                data.prices[asset].decimals,\n              ),\n            };\n          });\n        }),\n      );\n    }\n\n    return Promise.all(balancesPromises).then((balances) => {\n      const balancesHash = balances.reduce((acc, item) => {\n        acc[item.asset] = item;\n        return acc;\n      }, {});\n\n      return {\n        ...data,\n        balances: balancesHash,\n      };\n    });\n  }\n\n  function formatCollateralData(data) {\n    const formattedAssets = data.assets.map((asset) => {\n      return {\n        offset: asset[0],\n        address: asset[1],\n        priceFeed: asset[2],\n        scale: asset[3],\n        borrowCollateralFactor: asset[4] / 1e18,\n        liquidateCollateralFactor: asset[5] / 1e18,\n        liquidationFactor: asset[6] / 1e18,\n        supplyCap: ethers.utils.formatUnits(\n          asset[7],\n          data.prices[asset[1]].decimals,\n        ),\n        decimals: data.prices[asset[1]].decimals,\n        price: data.prices[asset[1]].price,\n        balance: data.balances[asset[1]].balance,\n        borrowBalance: data.balances[asset[1]].borrowBalance,\n      };\n    });\n\n    let collateralValueUsd = 0;\n    let totalBorrowCapacityUsd = 0;\n\n    return contract.baseTokenPriceFeed().then((baseTokenPriceFeed) => {\n      return contract.getPrice(baseTokenPriceFeed).then((price) => {\n        return contract.borrowBalanceOf(userAddress).then((borrowBalance) => {\n          return contract.decimals().then((decimals) => {\n            const balance = borrowBalance.toString();\n            const baseDecimals = decimals.toString();\n            const basePrice = price.toString() / 1e8;\n\n            for (let i = 0; i < formattedAssets.length; i++) {\n              const asset = formattedAssets[i];\n\n              collateralValueUsd += asset.balance * asset.price;\n\n              totalBorrowCapacityUsd +=\n                asset.balance * asset.price * asset.borrowCollateralFactor;\n            }\n\n            const borrowedInUsd =\n              (balance / Math.pow(10, baseDecimals)) * basePrice;\n\n            const borrowCapacityUsd = totalBorrowCapacityUsd - borrowedInUsd;\n\n            const borrowCapacityBase = borrowCapacityUsd / basePrice;\n\n            const borrowedInBase = borrowedInUsd / basePrice;\n\n            return {\n              assets: formattedAssets,\n              baseTokenPriceFeed,\n              basePrice,\n              collateralValueUsd,\n              totalBorrowCapacityUsd,\n              borrowCapacityBase,\n              borrowedInUsd,\n              borrowedInBase,\n              borrowBalance: ethers.utils.formatUnits(\n                borrowBalance,\n                baseDecimals,\n              ),\n            };\n          });\n        });\n      });\n    });\n  }\n\n  return new Promise((resolve, reject) => {\n    if (stored) return resolve(stored);\n\n    contract\n      .numAssets()\n      .catch(reject)\n      .then(getAssetsPromises)\n      .then(getPricesPromises)\n      .then(getAssetInfo)\n      .then(getAssetsBalance)\n      .then(formatCollateralData)\n      .then((data) => {\n        resolve(data);\n      });\n  });\n}\n\n/**\n * Calculates the liquidation data for a user's collaterals.\n *\n * @param {Object} options - The options for calculating liquidation data.\n * @param {string} options.cometAddress - The address of the Compound contract.\n * @param {string} options.rpcUrl - The RPC URL for connecting to the blockchain.\n * @param {string} options.userAddress - The address of the user.\n * @returns {Promise<Object>} A promise that resolves to the liquidation data.\n */\nfunction getCollateralsWithLiquidationData({\n  cometAddress,\n  rpcUrl,\n  userAddress,\n}) {\n  function calculateLiquidationCapacity(data) {\n    const assets = data.assets;\n\n    const liquidation = assets.reduce(\n      (acc, asset) => {\n        const liquidationValue =\n          asset.balance * asset.price * asset.liquidateCollateralFactor;\n\n        const borrowValue =\n          asset.balance * asset.price * asset.borrowCollateralFactor;\n\n        return {\n          liquidationCapacity: acc.liquidationCapacity + liquidationValue,\n          borrowCapacity: acc.borrowCapacity + borrowValue,\n        };\n      },\n      {\n        liquidationCapacity: 0,\n        borrowCapacity: 0,\n      },\n    );\n\n    const liquidationRisk = Math.round(\n      (data.borrowBalance / liquidation.liquidationCapacity) * 100,\n    );\n\n    return {\n      liquidationRisk,\n      liquidationPoint:\n        (data.collateralValueUsd * Math.min(100, liquidationRisk)) / 100,\n      ...data,\n    };\n  }\n\n  return new Promise((resolve, reject) => {\n    getCollateralAssets({ cometAddress, rpcUrl, userAddress })\n      .catch(reject)\n      .then(calculateLiquidationCapacity)\n      .then((data) => {\n        resolve(data);\n      });\n  });\n}\n\nreturn {\n  getApr,\n  getCollateralsWithLiquidationData,\n  getMinimumBorrowAmount,\n};\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/thalesb.near/widget/compound-requests", "fact_widget_deployments_id": "d9ec4f6795ae64b473a424de72d16198", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 0}