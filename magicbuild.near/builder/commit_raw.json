{"tx_hash": "21GahRK4giJnshfuXFAggV1St4QFfEqsVffYymacFX2T", "action_id_social": "3iKfoRymC9BgdQEtC9CVy24UQrvFWoFSNTsjaB4GFR8q-0-widget", "block_id": 104049457, "block_timestamp": "2023-10-23T18:56:00.751Z", "signer_id": "magicbuild.near", "widget_name": "builder", "source_code": "State.init({\r\n  id: props.id ? props.id : null,\r\n  contractAddress: props.address ? props.address : \"\",\r\n  cMethod: props.abi.body.functions ? props.abi.body.functions : [],\r\n  rpcUrl: \"https://rpc.near.org/\",\r\n  archivalRpc: \"https://archival-rpc.mainnet.near.org\",\r\n  nearBlockRpc: \"https://api.nearblocks.io/\",\r\n  fName,\r\n  fAction: \"view\",\r\n  fLabel,\r\n  cMerr,\r\n  res,\r\n  cAerr,\r\n});\r\nconst header = {\r\n  \"Content-Type\": \"application/json\",\r\n};\r\nconst opGet = {\r\n  headers: header,\r\n  method: \"GET\",\r\n};\r\nconst asyncIntervals = [];\r\n\r\nconst runAsyncInterval = (cb, interval, intervalIndex) => {\r\n  cb();\r\n  if (asyncIntervals[intervalIndex].run) {\r\n    asyncIntervals[intervalIndex].id = setTimeout(\r\n      () => runAsyncInterval(cb, interval, intervalIndex),\r\n      interval\r\n    );\r\n  }\r\n};\r\nconst setAsyncInterval = (cb, interval) => {\r\n  if (cb && typeof cb === \"function\") {\r\n    const intervalIndex = asyncIntervals.length;\r\n    asyncIntervals.push({ run: true, id: id });\r\n    runAsyncInterval(cb, interval, intervalIndex);\r\n    return intervalIndex;\r\n  } else {\r\n    throw new Error(\"Callback must be a function\");\r\n  }\r\n};\r\nconst clearAsyncInterval = (intervalIndex) => {\r\n  if (asyncIntervals[intervalIndex].run) {\r\n    clearTimeout(asyncIntervals[intervalIndex].id);\r\n    asyncIntervals[intervalIndex].run = false;\r\n  }\r\n};\r\nconst cFunc = (e, type) => {\r\n  const data = e.target.value;\r\n  if (type == \"name\") State.update({ fName: data });\r\n  if (type == \"label\") State.update({ fLabel: data });\r\n  if (type == \"action\") State.update({ fAction: data });\r\n  if (type == \"address\") State.update({ contractAddress: data.toLowerCase() });\r\n};\r\nconst cep = \"magicbuild.near\";\r\nconst onCreateArgs = (fName, fIndex) => {\r\n  State.update({ cAerr: { [fName]: null } });\r\n  const arg = {\r\n    name: \"\",\r\n    label: \"\",\r\n    type_schema: {\r\n      type: \"string\",\r\n    },\r\n    value: \"\",\r\n  };\r\n  const abiMethod = state.cMethod;\r\n  abiMethod[fIndex].params.args.push(arg);\r\n  State.update({ cMethod: abiMethod });\r\n};\r\nconst cMLabel = (e, fIdx, type) => {\r\n  const value = e.target.value;\r\n  const a = state.cMethod;\r\n  if (type == \"method\") a[fIdx].label = value;\r\n  if (type == \"button\") a[fIdx].button = value;\r\n  if (type == \"gas\") a[fIdx].gas = parseInt(value);\r\n  if (type == \"deposit\") a[fIdx].deposit = parseInt(value);\r\n  if (type == \"remove\") a.splice(fIdx, 1);\r\n  State.update({ cMethod: a });\r\n};\r\nconst cAD = (e, fIdx, aIdx, type) => {\r\n  const value = e.target.value;\r\n  const a = state.cMethod;\r\n  if (type == \"name\") a[fIdx].params.args[aIdx].name = value;\r\n  if (type == \"label\") a[fIdx].params.args[aIdx].label = value;\r\n  if (type == \"type\") a[fIdx].params.args[aIdx].type_schema.type = value;\r\n  if (type == \"value\") {\r\n    if (a[fIdx].params.args[aIdx].type_schema.type == \"integer\") {\r\n      a[fIdx].params.args[aIdx].value = parseInt(value);\r\n    }\r\n    if (a[fIdx].params.args[aIdx].type_schema.type == \"array\") {\r\n      a[fIdx].params.args[aIdx].value = value.split(\"|\"); //check valid\r\n    }\r\n    if (a[fIdx].params.args[aIdx].type_schema.type == \"boolean\") {\r\n      a[fIdx].params.args[aIdx].value = Boolean(value);\r\n    }\r\n    if (a[fIdx].params.args[aIdx].type_schema.type == \"json\") {\r\n      a[fIdx].params.args[aIdx].value = JSON.parse(value); //check valid\r\n    }\r\n    if (a[fIdx].params.args[aIdx].type_schema.type == \"string\") {\r\n      a[fIdx].params.args[aIdx].value = value; //check valid\r\n    }\r\n    if (a[fIdx].params.args[aIdx].type_schema.type == \"enum\") {\r\n      a[fIdx].params.args[aIdx].value = value; //check valid\r\n    }\r\n    if (a[fIdx].params.args[aIdx].type_schema.type == \"$ref\") {\r\n      a[fIdx].params.args[aIdx].value = value; //check account valid\r\n    }\r\n  }\r\n  if (type == \"remove\") a[fIdx].params.args.splice(aIdx, 1);\r\n  State.update({ cMethod: a });\r\n};\r\nconst onCreateMethod = () => {\r\n  if (state.fName.length > 0) {\r\n    State.update({ cMerr: null });\r\n    const method = {\r\n      name: state.fName,\r\n      kind: state.fAction,\r\n      label: state.fLabel,\r\n      button: \"\",\r\n      export: true,\r\n      params: {\r\n        serialization_type: \"json\",\r\n        args: [],\r\n      },\r\n      deposit: 0,\r\n      gas: 30000000000000,\r\n    };\r\n    const abiMethod = state.cMethod;\r\n    const isExistFunction = false;\r\n    abiMethod.forEach((item) => {\r\n      if (item.name == state.fName) {\r\n        isExistFunction = true;\r\n      }\r\n    });\r\n    if (!isExistFunction) {\r\n      abiMethod.push(method);\r\n      State.update({ cMethod: abiMethod });\r\n    } else {\r\n      State.update({ cMerr: \"Method Exist!\" });\r\n    }\r\n  } else {\r\n    State.update({ cMerr: \"Please Input Method Name!\" });\r\n  }\r\n};\r\nconst getMethodFromSource = () => {\r\n  State.update({ cMerr: null, cMethod: [] });\r\n  asyncFetch(state.rpcUrl, {\r\n    body: JSON.stringify({\r\n      method: \"query\",\r\n      params: {\r\n        request_type: \"view_code\",\r\n        account_id: state.contractAddress,\r\n        finality: \"final\",\r\n      },\r\n      id: 154,\r\n      jsonrpc: \"2.0\",\r\n    }),\r\n    headers: header,\r\n    method: \"POST\",\r\n  }).then((res) => {\r\n    let abiMethod = [];\r\n    const resb = res.body;\r\n    if (resb.result) {\r\n      const data = Buffer(resb.result.code_base64, \"base64\").toString(\"ascii\");\r\n      const fist = data.indexOf(\"memory\u0002\");\r\n      let second =\r\n        data.indexOf(\"__data_end\") !== -1\r\n          ? data.indexOf(\"__data_end\")\r\n          : data.indexOf(\"\u0003P]\");\r\n      if (fist !== -1 && second !== -1) {\r\n        const functionsData = data\r\n          .substring(fist, second)\r\n          .replace(/[^\\w ]/g, \" \")\r\n          .split(\" \");\r\n        const filterFunction = [];\r\n        functionsData.forEach((item, index) => {\r\n          if (index > 0 && item.length > 1) {\r\n            if (\r\n              !/^[A-Z]+(?:_[A-Z]+)*$/m.test(item) &&\r\n              !/^[0-9]*$/.test(string)\r\n            ) {\r\n              filterFunction.push(item);\r\n            }\r\n          }\r\n        });\r\n        filterFunction.forEach((item) => {\r\n          const res = fetch(\r\n            `${state.nearBlockRpc}v1/account/${state.contractAddress}/txns?method=${item}&order=desc&page=1&per_page=25`,\r\n            opGet\r\n          );\r\n          const method = {\r\n            name: item,\r\n            kind: \"view\",\r\n            export: true,\r\n            params: {\r\n              serialization_type: \"json\",\r\n              args: [],\r\n            },\r\n            deposit: 0,\r\n            gas: 30000000000000,\r\n          };\r\n          if (res.body.txns.length > 0) {\r\n            const isScs = false;\r\n            res.body.txns.forEach((item) => {\r\n              if (item.outcomes.status) {\r\n                isScs = true;\r\n              }\r\n            });\r\n            if (isScs) {\r\n              method.kind = \"call\";\r\n            }\r\n          }\r\n          abiMethod.push(method);\r\n        });\r\n\r\n        State.update({ cMethod: abiMethod });\r\n        abiMethod.forEach((item, index) => {\r\n          getArgsFromMethod(item.name, index);\r\n        });\r\n      } else {\r\n        State.update({ cMerr: \"Unable to detect Method!\" });\r\n      }\r\n    } else {\r\n      State.update({ cMerr: \"Unable to detect Method!\" });\r\n    }\r\n  });\r\n};\r\nconst getArgsFromMethod = (fName, fIndex) => {\r\n  asyncFetch(\r\n    `${state.nearBlockRpc}v1/account/${state.contractAddress}/txns?method=${fName}&order=desc&page=1&per_page=1`,\r\n    opGet\r\n  ).then((res) => {\r\n    const restxns = res.body.txns[0];\r\n    if (restxns.outcomes.status && restxns.logs.length > 0) {\r\n      const argsData = JSON.parse(\r\n        restxns.logs[0].replace(\"EVENT_JSON:\", \"\").replaceAll(\"\\\\\", \"\")\r\n      );\r\n      const args = argsData.data[0] || argsData;\r\n      if (Object.keys(args).length > 0) {\r\n        const abiMethod = state.cMethod;\r\n        abiMethod[fIndex].params.args = [];\r\n        Object.keys(args).forEach((item) => {\r\n          const arg = {\r\n            name: item,\r\n            type_schema: {\r\n              type:\r\n                typeof args[item] == \"number\"\r\n                  ? \"integer\"\r\n                  : typeof args[item] == \"object\"\r\n                  ? \"json\"\r\n                  : typeof args[item],\r\n            },\r\n            value: \"\",\r\n          };\r\n          abiMethod[fIndex].kind = \"call\";\r\n          abiMethod[fIndex].params.args.push(arg);\r\n          State.update({ cMethod: abiMethod });\r\n        });\r\n      }\r\n    } else {\r\n      const getArg = setInterval(() => {\r\n        const abiMethod = state.cMethod;\r\n        const argsArr = abiMethod[fIndex].params.args;\r\n        const argMap = argsArr.map(({ name, value }) => ({ [name]: value }));\r\n        const args = {};\r\n        argMap.forEach((item) => {\r\n          Object.assign(args, item);\r\n        });\r\n\r\n        asyncFetch(state.rpcUrl, {\r\n          body: JSON.stringify({\r\n            method: \"query\",\r\n            params: {\r\n              request_type: \"call_function\",\r\n              account_id: state.contractAddress,\r\n              method_name: fName,\r\n              args_base64: new Buffer.from(JSON.stringify(args)).toString(\r\n                \"base64\"\r\n              ),\r\n              finality: \"final\",\r\n            },\r\n            id: 154,\r\n            jsonrpc: \"2.0\",\r\n          }),\r\n          headers: header,\r\n          method: \"POST\",\r\n        }).then((res) => {\r\n          const strErr = res.body.result.error;\r\n          if (strErr && strErr.includes(\"missing field\")) {\r\n            const argName = strErr.substring(\r\n              strErr.indexOf(\"`\") + 1,\r\n              strErr.lastIndexOf(\"`\")\r\n            );\r\n            const checkType = [\r\n              { value: \"\", type: \"string\" },\r\n              { value: 0, type: \"integer\" },\r\n              { value: [], type: \"array\" },\r\n              { value: true, type: \"boolean\" },\r\n              { value: {}, type: \"json\" },\r\n              { value: state.contractAddress, type: \"$ref\" },\r\n            ];\r\n            const isCheck = false;\r\n            checkType.forEach((typeItem) => {\r\n              if (isCheck == false) {\r\n                asyncFetch(state.rpcUrl, {\r\n                  body: JSON.stringify({\r\n                    method: \"query\",\r\n                    params: {\r\n                      request_type: \"call_function\",\r\n                      account_id: state.contractAddress,\r\n                      method_name: fName,\r\n                      args_base64: new Buffer.from(\r\n                        JSON.stringify({\r\n                          [argName]: typeItem.value,\r\n                        })\r\n                      ).toString(\"base64\"),\r\n                      finality: \"final\",\r\n                    },\r\n                    id: 154,\r\n                    jsonrpc: \"2.0\",\r\n                  }),\r\n                  headers: header,\r\n                  method: \"POST\",\r\n                }).then((res) => {\r\n                  const uS = (argName, type, value) => {\r\n                    isCheck = true;\r\n                    const arg = {\r\n                      name: argName,\r\n                      type_schema: {\r\n                        type: type,\r\n                      },\r\n                      value: type == \"enum\" ? value[0] : value,\r\n                    };\r\n                    if (type == \"enum\") {\r\n                      arg.enum = value;\r\n                    }\r\n                    const isExist = false;\r\n                    abiMethod[fIndex].params.args.forEach((item) => {\r\n                      if (item.name == argName) {\r\n                        isExist = true;\r\n                      }\r\n                    });\r\n                    if (isExist == false) {\r\n                      abiMethod[fIndex].params.args.push(arg);\r\n                      State.update({ cMethod: abiMethod });\r\n                    }\r\n                  };\r\n                  if (res.body.result.result) {\r\n                    clearInterval(getArg);\r\n                  }\r\n                  const ftch = res.body.result.error;\r\n\r\n                  if (ftch) {\r\n                    if (ftch.includes(\"Option::unwrap()`\")) {\r\n                      uS(argName, typeItem.type, typeItem.value);\r\n                      abiMethod[fIndex].kind = \"call\";\r\n                      State.update({ cMethod: abiMethod });\r\n                      clearInterval(getArg);\r\n                    }\r\n                    if (ftch.includes(\"the account ID\")) {\r\n                      uS(argName, \"$ref\", state.contractAddress);\r\n                    }\r\n                    if (ftch.includes(\"invalid type: sequence, expected u64\")) {\r\n                      uS(argName, \"number\", 300);\r\n                    }\r\n                    if (ftch.includes(\"invalid digit found\")) {\r\n                      uS(argName, \"string\", \"300\");\r\n                    }\r\n                    if (\r\n                      ftch.includes(\"invalid type: sequence, expected a string\")\r\n                    ) {\r\n                      uS(argName, \"string\", \"wrap.near\");\r\n                      clearInterval(getArg);\r\n                    }\r\n                    if (\r\n                      ftch.includes(\r\n                        \"data did not match any variant of untagged enum\"\r\n                      )\r\n                    ) {\r\n                      uS(argName, typeItem.type, [\"300\", \"300\"]);\r\n                      clearInterval(getArg);\r\n                    }\r\n\r\n                    if (ftch.includes(\"not implemented\")) {\r\n                      uS(argName, typeItem.type, [\"300\", \"300\"]);\r\n                      // clearInterval(getArg);\r\n                    }\r\n                    if (ftch.includes(\"invalid token id\")) {\r\n                      uS(argName, \"$ref\", \"wrap.near\");\r\n                    }\r\n                    if (ftch.includes(\"integer from empty string\")) {\r\n                      uS(argName, typeItem.type, \"300\");\r\n                    }\r\n                    if (ftch.includes(\"unknown variant\")) {\r\n                      isCheck = true;\r\n                      const getEnum = ftch.match(/\\`(.*?)\\`/g);\r\n\r\n                      const enumList = [];\r\n                      getEnum.forEach((item, index) => {\r\n                        if (index !== 0) {\r\n                          enumList.push(item.replaceAll(\"`\", \"\"));\r\n                        }\r\n                      });\r\n                      uS(argName, \"enum\", enumList);\r\n                    }\r\n                    if (ftch.includes(\"missing field\")) {\r\n                      uS(argName, typeItem.type, typeItem.value);\r\n                    }\r\n                    if (ftch.includes(\"Requires attached deposit\")) {\r\n                      uS(argName, typeItem.type, typeItem.value);\r\n                      abiMethod[fIndex].kind = \"call\";\r\n                      abiMethod[fIndex].deposit = parseInt(\r\n                        strErr.match(/\\d+/)[0]\r\n                      );\r\n                      State.update({ cMethod: abiMethod });\r\n                      clearInterval(getArg);\r\n                    }\r\n\r\n                    if (\r\n                      fetch.includes(\"missing field\") &&\r\n                      argName ==\r\n                        fetch.match(/\\`(.*?)\\`/g)[0].replaceAll(\"`\", \"\")\r\n                    ) {\r\n                      uS(argName, typeItem.type, typeItem.value);\r\n                      clearInterval(getArg);\r\n                    }\r\n                  } else {\r\n                    uS(argName, typeItem.type, typeItem.value);\r\n                    clearInterval(getArg);\r\n                  }\r\n                });\r\n              }\r\n            });\r\n          }", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/magicbuild.near/widget/builder", "fact_widget_deployments_id": "7d6e94485001af171784d8e4d8604a08", "inserted_timestamp": "2023-10-23T20:47:22.950Z", "modified_timestamp": "2023-10-23T20:47:22.950Z", "__row_index": 430}