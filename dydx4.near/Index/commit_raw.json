{"tx_hash": "QxkppxND7Yo8Pq4MESpFwKsxPFYNFXmM1vNzwZCAgXS", "action_id_social": "2HpEJqv88zwghGbAHyQAnoz3fcti64TCRzX4iSREZET4-0-widget", "block_id": 108253521, "block_timestamp": "2023-12-18T13:29:01.212Z", "signer_id": "dydx4.near", "widget_name": "Index", "source_code": "const etherProviderEnabled = !!Ethers?.provider();\n\nif (etherProviderEnabled) {\n  Ethers.provider()\n    .send(\"eth_chainId\", [])\n    .then((chainId) => {\n      chainId = parseInt(chainId, 16);\n      if (state.chainId !== chainId) {\n        console.log(\"Set chainId\", chainId);\n        State.update({ chainId });\n      }\n    });\n\n  Ethers.provider()\n    .send(\"eth_requestAccounts\", [])\n    .then((accounts) => {\n      if (accounts.length && state.sender !== accounts[0]) {\n        console.log(\"Set sender\", accounts[0]);\n        State.update({ sender: accounts[0] });\n      }\n    });\n}\n\nif (!state.sender) {\n  return (\n    <div class=\"mb-3\">\n      <Web3Connect connectLabel=\"Connect Web3 Wallet to continue\" />\n    </div>\n  );\n}\n\nconst stripHexPrefix = (input) => {\n  if (input.indexOf(\"0x\") === 0) {\n    return input.slice(2);\n  }\n\n  return input;\n};\n\nconst exportMnemonicAndPrivateKey = (entropy, path) => {\n  const mnemonic = ethers.utils.entropyToMnemonic(entropy);\n  // console.log(\"mnemonic\", mnemonic);\n  const seed = ethers.utils.mnemonicToSeed(mnemonic);\n  const hdNode = ethers.utils.HDNode.fromSeed(seed);\n\n  return {\n    mnemonic,\n    privateKey: hdNode.privateKey,\n    publicKey: hdNode.publicKey,\n  };\n};\n\nconst deriveHDKeyFromEthereumSignature = (signature) => {\n  const buffer = Buffer.from(stripHexPrefix(signature), \"hex\");\n\n  if (buffer.length !== 65) {\n    throw new Error(\"Signature must be 65 bytes\");\n  }\n\n  // Remove the 'v' value by taking only the first 64 bytes of the signature\n  const rsValues = buffer.subarray(0, 64);\n  // Hash the 'r' and 's' values down to 32 bytes (256 bits) using Keccak-256\n  const entropy = ethers.utils.keccak256(rsValues);\n\n  return exportMnemonicAndPrivateKey(entropy);\n};\n\nlet wallet;\n\nconst getWalletFromEvmSignature = (signature) => {\n  console.log(signature);\n  const { mnemonic, privateKey, publicKey } =\n    deriveHDKeyFromEthereumSignature(signature);\n  console.log(\"deriveHDKeyFromEthereumSignature\", {\n    mnemonic,\n    privateKey,\n    publicKey,\n  });\n\n  DirectSecp256k1HdWallet.fromMnemonic(mnemonic, {\n    prefix: \"dydx\",\n  }).then((_wallet) => {\n    wallet = new DirectSecp256k1HdWallet(mnemonic, {\n      prefix: \"dydx\",\n      seed: _wallet.seed,\n    });\n    console.log(\"derrived wallet\", wallet);\n\n    wallet.getAccounts().then(([dydx_account]) => {\n      console.log(\"dYdX account derived\", dydx_account);\n      State.update({\n        dydx_account: dydx_account.address,\n        wallet: wallet,\n        mnemonic,\n      });\n    });\n  });\n};\n\nconsole.log(\"state wallet\", state.wallet);\n\nconst apiUrl = \"https://indexer.v4testnet.dydx.exchange/v4\";\nconst accountId = state.dydx_account;\nconst headers = {\n  Accept: \"application/json\",\n};\n\nconst loadAccount = () => {\n  asyncFetch(`${apiUrl}/addresses/${accountId}`, { headers }).then((r) =>\n    State.update({ account: r?.body?.subaccounts[0], all_accounts: r?.body })\n  );\n\n  asyncFetch(\n    `${apiUrl}/orders?address=${accountId}&subaccountNumber=0&limit=100`,\n    {\n      headers,\n    }\n  ).then((r) => State.update({ orders: r?.body }));\n};\n\nconst myPlaceOrder = () => {\n  /*\n   {\"ETH-USD\":{\"market\":\"ETH-USD\",\"status\":\"OPEN\",\"side\":\"SHORT\",\"size\":\"-0.006\",\"maxSize\":\"-0.002\",\"entryPrice\":\"2314.53333333333333333333\",\"exitPrice\":null,\"realizedPnl\":\"0.011682\",\"unrealizedPnl\":\"0.99803070199999999999998\",\"createdAt\":\"2023-12-07T14:46:04.743Z\",\"createdAtHeight\":\"2985583\",\"closedAt\":null,\"sumOpen\":\"0.006\",\"sumClose\":\"0\",\"netFunding\":\"0.011682\"}}\n\n   {\n  \"clobPairId\": \"1\",\n  \"ticker\": \"ETH-USD\",\n  \"status\": \"ACTIVE\",\n  \"lastPrice\": \"0\",\n  \"oraclePrice\": \"2152.855895\",\n  \"priceChange24H\": \"-59.931317\",\n  \"volume24H\": \"416750.4603\",\n  \"trades24H\": 7805,\n  \"nextFundingRate\": \"0\",\n  \"initialMarginFraction\": \"0.05\",\n  \"maintenanceMarginFraction\": \"0.03\",\n  \"basePositionNotional\": \"1000000\",\n  \"openInterest\": \"1267.480\",\n  \"atomicResolution\": -9,\n  \"quantumConversionExponent\": -9,\n  \"tickSize\": \"0.1\",\n  \"stepSize\": \"0.001\",\n  \"stepBaseQuantums\": 1000000,\n  \"subticksPerTick\": 100000\n}\n\n   */\n  //let subaccountNumber = 0;\n  let marketId = \"BTC-USD\";\n  let type = \"LIMIT\";\n  let side = \"BUY\";\n  let price = 40_500;\n  let size = 0.0001;\n  let clientId = 1234;\n  let timeInForce = \"GTT\";\n  let execution = \"DEFAULT\";\n  let postOnly = false;\n  let reduceOnly = false;\n  console.log(\"state.all_accounts\", state.all_accounts);\n  console.log(\"state.wallet\", state.wallet);\n  console.log(\"state.account\", state.account);\n  /*LocalWallet.fromMnemonic(state.mnemonic, \"dydx\").then((localWallet) => {\n    console.log(\"localWallet\", localWallet);*/\n\n  //const subAccount = new SubaccountClient(localWallet, 0);\n  console.log(\"subAccount\", subAccount);\n  //console.log(\"compositeClient\", CompositeClient);\n  //console.log(\"Network\", Network);\n  //console.log(\"compositeClient\", CompositeClient.placeOrder);\n\n  let network_config = {\n    env: \"dydx-testnet-4\",\n    indexerConfig: {\n      restEndpoint: \"https://dydx-testnet.imperator.co\",\n      websocketEndpoint: \"wss://dydx-testnet.imperator.co/v4/ws\",\n    },\n    validatorConfig: {\n      restEndpoint: \"https://test-dydx.kingnodes.com\",\n      chainId: \"dydx-testnet-4\",\n      denoms: {\n        USDC_DENOM:\n          \"ibc/8E27BA2D5493AF5636760E354E46004562C46AB7EC0CC4C1CA14E9E20E2545B5\",\n        USDC_DECIMALS: 6,\n        USDC_GAS_DENOM: \"uusdc\",\n        CHAINTOKEN_DENOM: \"adv4tnt\",\n        CHAINTOKEN_DECIMALS: 18,\n      },\n      broadcastOptions: {\n        broadcastPollIntervalMs: 3000,\n        broadcastTimeoutMs: 60000,\n      },\n    },\n  };\n\n  let network = new Network(\n    network_config.env,\n    network_config.indexerConfig,\n    network_config.validatorConfig\n  );\n  console.log(\"network 333\", network);\n  //CompositeClient.connect(Network.testnet()).then((compositeClient) => {\n  //let _cc0 = await CompositeClient.connect(network);\n  //console.log(\"cco\", _cc0);\n\n  //let _cc = CompositeClient.connect(network).then((compositeClient) => {\n  console.log(\"subAccount\", subAccount);\n  let params = {\n    //subaccount: subAccount,\n    marketId,\n    type,\n    side,\n    price,\n    size,\n    clientId,\n    timeInForce,\n    goodTilTimeInSeconds: 0,\n    execution,\n    postOnly,\n    reduceOnly,\n    triggerPrice,\n  };\n\n  let _cc = placeOrder(network, state.mnemonic, \"dydx\", 0, params).then(\n    (placeOrderResp) => {\n      /*if (!compositeClient) return;\n    console.log(\"compositeClient\", compositeClient);\n    console.log(\"compositeClient.placeOrder\", compositeClient.placeOrder);\n    compositeClient\n      .placeOrder(\n        subAccount,\n        marketId,\n        type,\n        side,\n        price,\n        size,\n        clientId,\n        timeInForce,\n        goodTilTimeInSeconds ?? 0,\n        execution,\n        postOnly,\n        reduceOnly,\n        triggerPrice ?? undefined\n      )\n      .then((resp) => {\n        console.log(\"placeOrder resp \", resp);\n      });*/\n      console.log(\"placeOrder resp \", placeOrderResp);\n    }\n  );\n  console.log(\"_cc\", _cc);\n  //});\n};\n\nif (state.dydx_account == undefined) {\n  const toSign = {\n    domain: {\n      name: \"dYdX V4\",\n      chainId: 5,\n    },\n    primaryType: \"dYdX\",\n    types: {\n      dYdX: [{ name: \"action\", type: \"string\" }],\n    },\n    message: {\n      action: \"dYdX Chain Onboarding\",\n    },\n  };\n\n  /*\n  getWalletFromEvmSignature(\n    \"0xb33020bc2b4c2be8cf28dd6fcaf06dc94f856cd85041ca34afc648c0a1a12298361d3c494404c1b7a6cdec71305c81da8ad318434dac6d9a706c500a650391fa1b\"\n  );\n  */\n\n  Ethers.provider()\n    .getSigner()\n    ._signTypedData(toSign.domain, { dYdX: toSign.types.dYdX }, toSign.message)\n    .then((signature) => getWalletFromEvmSignature(signature));\n} else {\n  useEffect(() => {\n    loadAccount();\n  }, [state.account, state.orders, state.nonce]);\n\n  return (\n    <div>\n      {Test1}\n      <button\n        onClick={() => {\n          myPlaceOrder();\n        }}\n      >\n        Place Order\n      </button>\n      <ul>\n        <li>Address: {state.account.address}</li>\n        <li>Equity: {state.account.equity}</li>\n        <li>Free Collateral: {state.account.freeCollateral}</li>\n        <li>\n          Open Perpetual Positions:{\" \"}\n          {JSON.stringify(state.account.openPerpetualPositions)}\n        </li>\n\n        <li>\n          Orders:{\" \"}\n          <ol>\n            {(state.orders ?? []).map((order) => (\n              <li>\n                {order.side} {order.ticker} at {order.price}. Size: {order.size}\n                , filled: {order.totalFilled} . Updated: {order.updatedAt}\n                {/*JSON.stringify(order)*/}\n              </li>\n            ))}\n          </ol>\n        </li>\n      </ul>\n      <button\n        onClick={() => {\n          const nonce = state.nonce ?? 0;\n          State.update({ nonce: nonce + 1 });\n        }}\n      >\n        Refresh\n      </button>\n      <hr />\n      state:\n      {JSON.stringify(state)}\n    </div>\n  );\n}\n\nreturn (\n  <>\n    Ethereum Account: {state.sender}\n    <Web3Connect connectLabel=\"Connect Web3 Wallet to continue\" />\n  </>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/dydx4.near/widget/Index", "fact_widget_deployments_id": "b16536dc9591dc74433b8cb0beedd09d", "inserted_timestamp": "2023-12-18T15:23:23.951Z", "modified_timestamp": "2023-12-20T03:22:11.422Z", "__row_index": 202}