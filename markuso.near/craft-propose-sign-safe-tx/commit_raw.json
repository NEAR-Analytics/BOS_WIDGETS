{"tx_hash": "F12TVfqbg1TY6eAx6vh8F1nXBdGDcLNRBYrKnMm5KidG", "action_id_social": "4QQd9NPL6q9wWZ3dSEaokpBBL62XMff8qcCSMT2hPaGC-0-widget", "block_id": 97539244, "block_timestamp": "2023-07-28T15:22:38.881Z", "signer_id": "markuso.near", "widget_name": "craft-propose-sign-safe-tx", "source_code": "State.init({\r\n  chainId: null,\r\n  baseUrl: \"\",\r\n  safeAddress: null,\r\n  recipient: \"\",\r\n  value: Number(0), //initialized to 0 to avoid ethers complaints and enable valueless tx\r\n  data: new Uint8Array(0), //empty for now until crafting transaction calldata\r\n  operation: 0,\r\n  gasToken: \"0x0000000000000000000000000000000000000000\",\r\n  safeTxGas: 0,\r\n  baseGas: 0,\r\n  gasPrice: 0,\r\n  refundReceiver: \"0x0000000000000000000000000000000000000000\",\r\n  nonce: 0,\r\n  txHash: \"0x\",\r\n  sender: null,\r\n  signature: \"\",\r\n  origin: \"NEAR Blockchain Operating System\",\r\n});\r\n\r\n// connect account\r\nif (state.sender === null) {\r\n  const accounts = Ethers.send(\"eth_requestAccounts\", []);\r\n  const checksummedAddr = ethers.utils.getAddress(accounts[0]);\r\n  if (accounts.length) {\r\n    State.update({ sender: checksummedAddr });\r\n\r\n    Ethers.provider()\r\n      .getNetwork()\r\n      .then((chainIdData) => {\r\n        if (chainIdData?.chainId == 1) {\r\n          State.update({\r\n            chainId: \"mainnet\",\r\n          });\r\n        } else if (chainIdData?.chainId == 5) {\r\n          State.update({\r\n            chainId: \"goerli\",\r\n          });\r\n        } else if (chainIdData?.chainId == 100) {\r\n          State.update({\r\n            chainId: \"gnosis-chain\",\r\n          });\r\n        }\r\n      });\r\n  }\r\n}\r\n\r\nconst getNonce = (_addr, _to, _value) => {\r\n  const addr = ethers.utils.getAddress(_addr); // convert input addrs to checksum\r\n  const to = ethers.utils.getAddress(_to);\r\n  const value = Number(_value);\r\n\r\n  State.update({ safeAddress: addr });\r\n  State.update({ recipient: to });\r\n  State.update({ value: value });\r\n\r\n  const baseUrl = `https://safe-transaction-${state.chainId}.safe.global/api`;\r\n  const url = baseUrl + `/v1/safes/${addr}`;\r\n  State.update({ baseUrl: url });\r\n\r\n  // http options\r\n  const options = {\r\n    headers: {\r\n      accept: \"application/json\",\r\n    },\r\n    mode: \"no-cors\",\r\n  };\r\n\r\n  // get nonce\r\n  asyncFetch(url, options).then((res) => {\r\n    if (res.ok) {\r\n      State.update({ nonce: res.body.nonce + 1 });\r\n    }\r\n  });\r\n};\r\n\r\nconst getAndSignTxHash = () => {\r\n  // get txhash from contract\r\n  // The Gnosis Safe contract ABI\r\n  const safeAbi = fetch(\r\n    \"https://raw.githubusercontent.com/safe-global/safe-deployments/main/src/assets/v1.3.0/gnosis_safe_l2.json\"\r\n  ).body;\r\n  const abiJson = JSON.parse(safeAbi)[\"abi\"];\r\n  const signer = Ethers.provider().getSigner();\r\n  const safe = new ethers.Contract(state.safeAddress, abiJson, signer);\r\n\r\n  // obtain txHash\r\n  const txHash = safe\r\n    .getTransactionHash(\r\n      state.recipient,\r\n      state.value,\r\n      state.data,\r\n      state.operation,\r\n      state.safeTxGas,\r\n      state.baseGas,\r\n      state.gasPrice,\r\n      state.gasToken,\r\n      state.refundReceiver,\r\n      state.nonce\r\n    )\r\n    .then((res) => {\r\n      State.update({ txHash: res });\r\n      // sign contractTransactionHash using private key of Gnosis Safe owner (or deployer)\r\n      const signature = signer.signMessage(ethers.utils.arrayify(res));\r\n      console.log(signature);\r\n      return; // OWRKING\r\n      State.update({ signature: signature });\r\n    });\r\n};\r\n\r\nconst postToSafeApi = () => {\r\n  // craft transaction from state vars\r\n  const transaction = {\r\n    safe: state.safeAddress,\r\n    to: state.recipient,\r\n    value: state.value,\r\n    data: state.data,\r\n    operation: state.operation,\r\n    gasToken: state.gasToken,\r\n    safeTxGas: state.safeTxGas,\r\n    baseGas: state.baseGas,\r\n    gasPrice: state.gasPrice,\r\n    refundReceiver: state.refundReceiver,\r\n    nonce: state.nonce, // Nonce of the Safe, transaction cannot be executed until Safe's nonce is accurate\r\n    contractTransactionHash: state.txHash, // Contract transaction hash calculated from all the fields\r\n    sender: state.sender, // must be checksummed Owner of the Safe\r\n    signature: state.signature, // One or more ECDSA signatures of the `contractTransactionHash` as an hex string\r\n    origin: state.origin,\r\n  };\r\n\r\n  console.log(transaction);\r\n  return;\r\n\r\n  const transactionsUrl = state.baseUrl + `/multisig-transactions`;\r\n  const params = JSON.stringify({\r\n    data: transaction,\r\n    address: `${transaction.safe}`,\r\n  });\r\n  const proposalOptions = {\r\n    method: \"POST\",\r\n    headers: {\r\n      accept: \"application/json\",\r\n    },\r\n    mode: \"no-cors\",\r\n    body: params,\r\n  };\r\n  // post to gnosis API backend\r\n  const proposed = asyncFetch(transactionsUrl, proposalOptions);\r\n};\r\n\r\n// grab proposed transactions\r\n// const existingTransactions = () => {\r\n//       const txOptions = {\r\n//         headers: {\r\n//           accept: \"application/json\",\r\n//         },\r\n//         mode: \"no-cors\",\r\n//         body: JSON.stringify({ address: `${transaction.safe}` }),\r\n//       };\r\n//       asyncFetch(url + \"/all-transactions\", txOptions);\r\n//     })\r\n//     .then((res) => {\r\n//       if (res.ok) {\r\n//         console.log(res);\r\n//       }\r\n//     });\r\n// };\r\n\r\nconst proposeTx = (_addr, _to, _value) => {\r\n  getNonce(_addr, _to, _value);\r\n  /*.then(() => {\r\n    getAndSignTxHash();\r\n  });*/\r\n};\r\n\r\n//   const operation = 0; // enum where 0 == CALL, 1 == DELEGATE_CALL\r\n//   // refund payment parameters are irrelevant\r\n//   const gasToken = \"0x0000000000000000000000000000000000000000\";\r\n//   const baseGas = 0;\r\n//   const gasPrice = 0;\r\n//   const refundReceiver = \"0x0000000000000000000000000000000000000000\";\r\n//   const safeTxGas = 0;\r\n\r\n//   const data = new Uint8Array(0); // TODO !!!\r\n\r\n// transaction to propose\r\n//   const transaction = {\r\n//     safe: `${addr}`,\r\n//     to: `${to}`,\r\n//     value: value,\r\n//     data: data,\r\n//     operation: operation,\r\n//     gasToken: gasToken,\r\n//     safeTxGas: safeTxGas,\r\n//     baseGas: baseGas,\r\n//     gasPrice: gasPrice,\r\n//     refundReceiver: refundReceiver,\r\n//     nonce: 0, // Nonce of the Safe, transaction cannot be executed until Safe's nonce is accurate\r\n//     contractTransactionHash: \"\", // Contract transaction hash calculated from all the fields\r\n//     sender: state.sender, // must be checksummed Owner of the Safe\r\n//     signature: \"\", // One or more ECDSA signatures of the `contractTransactionHash` as an hex string\r\n//     origin: \"NEAR Blockchain Operating System\",\r\n//   };\r\n\r\nreturn (\r\n  <div>\r\n    <input\r\n      value={state.safeAddress}\r\n      onChange={(e) => State.update({ safeAddress: e.target.value })}\r\n      placeholder=\"Safe address\"\r\n      label=\"SafeAddressInput\"\r\n    />\r\n    <input\r\n      value={state.recipient}\r\n      onChange={(e) => State.update({ recipient: e.target.value })}\r\n      placeholder=\"Recipient address\"\r\n      label=\"RecipientAddressInput\"\r\n    />\r\n    <input\r\n      value={state.value}\r\n      onChange={(e) => State.update({ value: e.target.value })}\r\n      placeholder=\"ETH Amount\"\r\n      label=\"ETHValueInput\"\r\n    />\r\n    <button\r\n      onClick={() =>\r\n        getNonce(state.safeAddress, state.recipient, state.value).then(\r\n          getAndSignTxHash()\r\n        )\r\n      }\r\n      label=\"ProposeButton\"\r\n    >\r\n      <span>Propose Transaction</span>\r\n    </button>\r\n    <Web3Connect className=\"web3-connect\" connectLabel=\"Connect Wallet\" />\r\n  </div>\r\n);\r\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/markuso.near/widget/craft-propose-sign-safe-tx", "fact_widget_deployments_id": "ac734299935d0e47f3cf93b5d17f5a68", "inserted_timestamp": "2000-01-01T00:00:00.000Z", "modified_timestamp": "2000-01-01T00:00:00.000Z", "__row_index": 0}