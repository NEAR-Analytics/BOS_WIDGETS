{"tx_hash": "GbBbfdGNpTwzqBMQhP3QAfS7QKGWnvDa24i5QPuKKjsq", "action_id_social": "Hr9pESBEySLhHuv9jTPv1wkGfrJGdrjpzMJaGp7aJjWd-0-widget", "block_id": 97539929, "block_timestamp": "2023-07-28T15:35:30.906Z", "signer_id": "markuso.near", "widget_name": "craft-propose-sign-safe-tx", "source_code": "// Example addresses to use as props\r\n// \"gnosis-chain-safe\": \"0x6106FB94E31B83D0A15432FCA2927B838fB6D025\"\r\n// \"owner-recipient\": \"0x5d5d4d04B70BFe49ad7Aac8C4454536070dAf180\"\r\n// \"gnosis-chain-USDC\": \"0xDDAfbb505ad214D7b80b1f830fcCc89B60fb7A83\"\r\n// \"mainnet-safe\": \"0xf7b458443B6a3e2Cd12b315Ed703c98e030b9Bba\"\r\n\r\nState.init({\r\n  chainId: null,\r\n  baseUrl: \"\",\r\n  safeAddress: null,\r\n  recipient: \"\",\r\n  value: Number(0), //initialized to 0 to avoid ethers complaints and enable valueless tx\r\n  contract: \"\",\r\n  tokenDecimals: 0,\r\n  data: \"0x\", // transaction calldata\r\n  operation: 0,\r\n  gasToken: \"0x0000000000000000000000000000000000000000\",\r\n  safeTxGas: 0,\r\n  baseGas: 0,\r\n  gasPrice: 0,\r\n  refundReceiver: \"0x0000000000000000000000000000000000000000\",\r\n  nonce: 0,\r\n  txHash: \"0x\",\r\n  sender: null,\r\n  signature: \"\",\r\n  origin: \"NEAR Blockchain Operating System\",\r\n});\r\n\r\n// connect account\r\nif (state.sender === null) {\r\n  const accounts = Ethers.send(\"eth_requestAccounts\", []);\r\n  const checksummedAddr = ethers.utils.getAddress(accounts[0]);\r\n  if (accounts.length) {\r\n    State.update({ sender: checksummedAddr });\r\n\r\n    Ethers.provider()\r\n      .getNetwork()\r\n      .then((chainIdData) => {\r\n        if (chainIdData?.chainId == 1) {\r\n          State.update({\r\n            chainId: \"mainnet\",\r\n          });\r\n        } else if (chainIdData?.chainId == 5) {\r\n          State.update({\r\n            chainId: \"goerli\",\r\n          });\r\n        } else if (chainIdData?.chainId == 100) {\r\n          State.update({\r\n            chainId: \"gnosis-chain\",\r\n          });\r\n        }\r\n      });\r\n  }\r\n}\r\n\r\nconst getAbi = () => {\r\n  // fetch abi\r\n  const url =\r\n    \"https://gist.githubusercontent.com/veox/8800debbf56e24718f9f483e1e40c35c/raw/f853187315486225002ba56e5283c1dba0556e6f/erc20.abi.json\";\r\n  const erc20Abi = fetch(url);\r\n  let iface;\r\n  if (erc20Abi.ok) iface = new ethers.utils.Interface(erc20Abi.body);\r\n\r\n  // get token decimals, parse units via decimals\r\n  const encodedData = iface.encodeFunctionData(\"decimals\", []);\r\n\r\n  Ethers.provider()\r\n    .call({\r\n      to: state.contract,\r\n      data: encodedData,\r\n    })\r\n    .then((tokenDecimals) => {\r\n      State.update({ tokenDecimals: parseInt(Number(tokenDecimals)) });\r\n    });\r\n\r\n  const amount = ethers.utils.parseUnits(\r\n    state.value.toString(),\r\n    state.tokenDecimals\r\n  );\r\n\r\n  State.update({\r\n    data: iface.encodeFunctionData(\"transfer\", [\r\n      state.recipient.toString(),\r\n      amount,\r\n    ]),\r\n  });\r\n};\r\n\r\nconst getNonce = (_contract, _addr, _to, _value) => {\r\n  // support ERC20 tokens\r\n  const contract = _contract;\r\n  if (contract) getAbi();\r\n\r\n  const addr = ethers.utils.getAddress(_addr); // convert input addrs to checksum\r\n  const to = ethers.utils.getAddress(_to);\r\n  const value = Number(_value);\r\n\r\n  State.update({ safeAddress: addr });\r\n  State.update({ recipient: to });\r\n  State.update({ value: value });\r\n\r\n  const baseUrl = `https://safe-transaction-${state.chainId}.safe.global/api`;\r\n  const url = baseUrl + `/v1/safes/${addr}/`;\r\n  State.update({ baseUrl: url });\r\n\r\n  // http options\r\n  const options = {\r\n    headers: {\r\n      accept: \"application/json\",\r\n    },\r\n    mode: \"no-cors\",\r\n  };\r\n\r\n  // get nonce\r\n  const res = fetch(url, options);\r\n  State.update({ nonce: res.body.nonce });\r\n};\r\n\r\nconst getAndSignTxHash = () => {\r\n  // get txhash from contract\r\n  // The Gnosis Safe contract ABI\r\n  const safeAbi = fetch(\r\n    \"https://raw.githubusercontent.com/safe-global/safe-deployments/main/src/assets/v1.3.0/gnosis_safe_l2.json\"\r\n  ).body;\r\n  const abiJson = JSON.parse(safeAbi)[\"abi\"];\r\n  const signer = Ethers.provider().getSigner();\r\n  const safe = new ethers.Contract(state.safeAddress, abiJson, signer);\r\n\r\n  // obtain txHash\r\n  const txHash = safe\r\n    .getTransactionHash(\r\n      state.recipient,\r\n      state.value,\r\n      state.data,\r\n      state.operation,\r\n      state.safeTxGas,\r\n      state.baseGas,\r\n      state.gasPrice,\r\n      state.gasToken,\r\n      state.refundReceiver,\r\n      state.nonce\r\n    )\r\n    .then((res) => {\r\n      State.update({ txHash: res });\r\n      // sign contractTransactionHash using private key of Gnosis Safe owner (or deployer)\r\n      const signature = signer\r\n        .signMessage(ethers.utils.arrayify(res))\r\n        .then((sig) => {\r\n          const alterV = ethers.utils.hexDataSlice(sig, 0, 64) + \"1f\";\r\n          State.update({ signature: ethers.utils.hexlify(alterV) });\r\n        });\r\n    });\r\n};\r\n\r\nconst postToSafeApi = () => {\r\n  // craft transaction from state vars\r\n  const transaction = {\r\n    safe: state.safeAddress,\r\n    to: state.recipient,\r\n    value: state.value,\r\n    data: state.data,\r\n    operation: state.operation,\r\n    gasToken: state.gasToken,\r\n    safeTxGas: state.safeTxGas,\r\n    baseGas: state.baseGas,\r\n    gasPrice: state.gasPrice,\r\n    refundReceiver: state.refundReceiver,\r\n    nonce: state.nonce, // Nonce of the Safe, transaction cannot be executed until Safe's nonce is accurate\r\n    contractTransactionHash: state.txHash, // Contract transaction hash calculated from all the fields\r\n    sender: state.sender, // must be checksummed Owner of the Safe\r\n    signature: state.signature, // One or more ECDSA signatures of the `contractTransactionHash` as an hex string\r\n    origin: state.origin,\r\n  };\r\n\r\n  const transactionsUrl = state.baseUrl + `multisig-transactions/`;\r\n  const params = JSON.stringify(transaction);\r\n  const proposalOptions = {\r\n    method: \"POST\",\r\n    headers: {\r\n      \"Content-Type\": \"application/json\",\r\n    },\r\n    mode: \"no-cors\",\r\n    body: params,\r\n  };\r\n\r\n  // post to gnosis API backend\r\n  const proposed = asyncFetch(transactionsUrl, proposalOptions).then((res) =>\r\n    console.log(res)\r\n  );\r\n};\r\n\r\nreturn (\r\n  <div>\r\n    <p>\r\n      Leave ERC20 token address field blank if performing a native currency\r\n      (ETH, MATIC, xDAI) transfer\r\n    </p>\r\n    <input\r\n      value={state.contract}\r\n      onChange={(e) => State.update({ contract: e.target.value })}\r\n      placeholder=\"ERC20 address\"\r\n      label=\"TokenAddressInput\"\r\n    />\r\n    <input\r\n      value={state.safeAddress}\r\n      onChange={(e) => State.update({ safeAddress: e.target.value })}\r\n      placeholder=\"Safe address\"\r\n      label=\"SafeAddressInput\"\r\n    />\r\n    <input\r\n      value={state.recipient}\r\n      onChange={(e) => State.update({ recipient: e.target.value })}\r\n      placeholder=\"Recipient address\"\r\n      label=\"RecipientAddressInput\"\r\n    />\r\n    <input\r\n      value={state.value}\r\n      onChange={(e) => State.update({ value: e.target.value })}\r\n      placeholder=\"ETH Amount\"\r\n      label=\"ETHValueInput\"\r\n    />\r\n    <button\r\n      onClick={() =>\r\n        getNonce(\r\n          state.contract,\r\n          state.safeAddress,\r\n          state.recipient,\r\n          state.value\r\n        ).then(getAndSignTxHash())\r\n      }\r\n      label=\"SignButton\"\r\n    >\r\n      <span>Sign Transaction</span>\r\n    </button>\r\n    <button onClick={() => postToSafeApi()} label=\"ProposeButton\">\r\n      <span>Propose Transaction</span>\r\n    </button>\r\n    <Web3Connect className=\"web3-connect\" connectLabel=\"Connect Wallet\" />\r\n  </div>\r\n);\r\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/markuso.near/widget/craft-propose-sign-safe-tx", "fact_widget_deployments_id": "8afc06a0979d974e278429134d203362", "inserted_timestamp": "2000-01-01T00:00:00.000Z", "modified_timestamp": "2000-01-01T00:00:00.000Z", "__row_index": 1}