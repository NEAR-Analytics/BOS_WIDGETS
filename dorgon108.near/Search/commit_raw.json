{"tx_hash": "AtAKKq25ETJ2cEC3UKFnoEwSaLrY6LgnnafRnBT62JcX", "action_id_social": "3dyN42zq2UeFEP3JRHHZACvBdFNqgnWsMsSdGkMiApMv-0-widget", "block_id": 90113935, "block_timestamp": "2023-04-21T18:51:52.170Z", "signer_id": "dorgon108.near", "widget_name": "Search", "source_code": "const SEARCH_API_KEY = props.searchApiKey ?? \"0e42c01107b8f555a41bcc0fa7f2a4df\";\nconst APPLICATION_ID = props.appId ?? \"B6PI9UKKJT\";\nconst INDEX = props.index ?? \"prod_near-social-feed\";\nconst API_URL =\n  props.apiUrl ??\n  `https://${APPLICATION_ID}-dsn.algolia.net/1/indexes/${INDEX}/query?`;\nconst INITIAL_PAGE = props.initialPage ?? 0;\nconst facets = props.facets ?? [\"All\", \"Users\", \"Apps\", \"Components\", \"Posts\"];\nconst tab = props.tab ?? \"All\";\n\nconst showHeader = props.showHeader ?? true;\nconst showSearchBar = props.showSearchBar ?? true;\nconst showPagination = props.showPagination ?? true;\nconst userId = props.accountId ?? context.accountId;\n\nconst componentsUrl = `/#/near/widget/ComponentsPage`;\nconst peopleUrl = `/#/near/widget/PeoplePage`;\n\nState.init({\n  facet: tab,\n  isFiltersPanelVisible: false,\n  numColumns: 3,\n  selectedTags: [],\n  searchResults: [], // Assuming search results are stored here\n  allTags: [],\n  activeTags: [],\n\n  showFollowed: false,\n  showNotFollowed: false,\n});\n\nconst Wrapper = styled.div`\nborder-radius: 32px 32px 0px 0px;\n  display: flex;\n  flex-direction: column;\n  gap: 48px;\n  padding-bottom: 48px;\n  max-width: 800px;\n  margin: 0 auto;\n  \n`;\n\nconst SearchPageContainer = styled.div`\n  transition: transform 0.3s ease-in-out;\n  transform: ${({ isFiltersPanelOpen }) =>\n    isFiltersPanelOpen ? \"translateX(-250px)\" : \"translateX(0)\"};\n`;\n\nconst Header = styled.div`\n  display: flex;\n  flex-direction: column;\n  gap: 12px;\n`;\n\nconst TabsButton = styled.a`\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n  height: 100%;\n  font-weight: 600;\n  font-size: 12px;\n  padding: 0 12px;\n  position: relative;\n  color: ${(p) => (p.selected ? \"#11181C\" : \"#687076\")};\n  background: none;\n  border: none;\n  outline: none;\n  text-align: center;\n  text-decoration: none !important;\n  flex: 1;\n  border-bottom: 1px solid #ECEEF0\n\n  &:hover {\n    color: #11181C;\n    border-bottom: 4px solid #20A46C;\n\n  }\n\n  &::after {\n    content: \"\";\n    display: ${(p) => (p.selected ? \"block\" : \"none\")};\n    position: absolute;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    height: 3px;\n    background: #59e692;\n  }\n`;\n\nconst Search = styled.div``;\n\nconst Facets = styled.div`\n  overflow: auto;\n  width:100%;\n`;\n\nconst FacetContainer = styled.ul`\npadding: 16px 16px 0px;\nflex-direction: column;\njustify-content: center;\nalign-items: flex-start;    list-style-type: none;\n  width:100%;\nheight: 36px;\n\n  `;\n\nconst H1 = styled.h1`\nfont-style: normal; \nfont-weight: 400;\nfont-size: 36px;\n  line-height: 39px;\n  color: #11181c;\n  margin: 0;\n`;\n\nconst H2 = styled.h2`\n  font-weight: 400;\n  font-size: 20px;\n  line-height: 24px;\n  color: #687076;\n  margin: 0;\n`;\n\nconst H3 = styled.h3`\n  color: #11181C;\n  font-weight: 600;\n  font-size: 12px;\n  line-height: 15px;\n  margin: 0;\n  width: 188px;\nheight: 30px;\nfont-style: normal;\nfont-weight: 600;\nfont-size: 19px;\nline-height: 23px;\n`;\n\nconst Group = styled.div`\n  display: flex;\n  flex-direction: column;\n  gap: 12px;\n`;\n\nconst GroupHeader = styled.div`\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  gap: 12px;\n`;\nconst FiltersPanel = styled.div`\n  border-left: 1px solid #ECEEF0;\n  position: absolute;\n  top: 0;\n  right: 0;\n  width: 300px;\n  height: 100%;\n  background-color: white;\n  border-left: 1px solid #e6e6e6;\n  padding: 20px;\n  z-index: 1000;\n  box-sizing: border-box;\n  overflow-y: auto;\n  transition: transform 0.3s ease-in-out;\n`;\n\nconst Text = styled.p`\n  margin: 0;\n  line-height: 1.5rem;\n  color: ${(p) => (p.bold ? \"#11181C\" : \"#687076\")};\n  font-weight: ${(p) => (p.bold ? \"600\" : \"400\")};\n  font-size: ${(p) => (p.small ? \"12px\" : \"14px\")};\n  overflow: ${(p) => (p.ellipsis ? \"hidden\" : \"\")};\n  text-overflow: ${(p) => (p.ellipsis ? \"ellipsis\" : \"\")};\n  white-space: ${(p) => (p.ellipsis ? \"nowrap\" : \"\")};\n  overflow-wrap: anywhere;\n\n  b {\n    font-weight: 600;\n    color: #11181c;\n  }\n\n  &[href] {\n    color: #006adc;\n    outline: none;\n    font-weight: 600;\n\n    &:hover,\n    &:focus {\n      color: #006adc;\n      text-decoration: underline;\n    }\n  }\n`;\n\nconst Items = styled.div`\n  display: flex;\n  flex-direction: column;\n  align-items: stretch;\n  gap: 12px;\n`;\n\nconst PostsGridItems = styled.div`\n  display: grid;\n  grid-template-columns: repeat(3, 1fr);\n  grid-gap: 16px;\n`;\n\nconst Item = styled.div``;\n\n// Add the following styles to your CSS or a styled-component\nconst GridItems = styled.div`\n  display: grid;\n  grid-template-columns: ${({ numColumns }) =>\n    numColumns === 3 ? \"repeat(3, 1fr)\" : \"repeat(2, 1fr)\"};\n  grid-gap: 16px;\n    display: grid;\n  grid-template-columns: repeat(3, minmax(0, 1fr));\n  gap: 24px;\n\n  @media (max-width: 1200px) {\n    grid-template-columns: repeat(2, minmax(0, 1fr));\n  }\n\n  @media (max-width: 800px) {\n    grid-template-columns: minmax(0, 1fr);\n  }\n`;\n\nconst isUserFollowing = (accountId, contextAccountId) => {\n  const followEdge = Social.keys(\n    `${accountId}/graph/follow/${contextAccountId}`,\n    undefined,\n    {\n      values_only: true,\n    }\n  );\n  return Object.keys(followEdge || {}).length > 0;\n};\n\n// Here are the functions\nconst toggleFiltersPanel = () => {\n  State.update({\n    isFiltersPanelVisible: !state.isFiltersPanelVisible,\n    numColumns: state.numColumns === 3 ? 2 : 3,\n  });\n};\n\nconst resetSearcheHits = () => {\n  State.update({\n    currentPage: 0,\n    search: undefined,\n    paginate: undefined,\n    facet: undefined,\n  });\n};\n\nconst writeStateTerm = (term) => {\n  State.update({\n    term,\n  });\n\n  if (term === \"\") {\n    resetSearcheHits();\n  }\n};\n\nconst profiles = (records) => {\n  const profiles = [];\n  for (const [i, record] of records ?? []) {\n    profiles.push({\n      accountId: record.author,\n      searchPosition: i,\n    });\n  }\n  return profiles;\n};\n\nconst posts = (content, postType) => {\n  const posts = [];\n  for (const [i, post] of content || []) {\n    const accountId = post.author;\n    const blockHeight = post.objectID.split(\"/\").slice(-1)[0];\n\n    let snipContent = true;\n    let text = post.content;\n    if (post._highlightResult.content.matchLevel === \"full\") {\n      // Use algolia provided snipped content:\n      snipContent = false;\n      text = post._snippetResult.content.value\n        .replaceAll(\"<em>\", \"\")\n        .replaceAll(\"</em>\", \"\");\n    }\n\n    const postContent = {\n      type: \"md\",\n      text,\n    };\n\n    posts.push({\n      accountId,\n      blockHeight,\n      postContent,\n      postType,\n      snipContent,\n      searchPosition: i,\n    });\n  }\n  return posts;\n};\n\nconst components = (records) => {\n  const components = [];\n  for (const [i, component] of records || []) {\n    const idParts = component.objectID.split(\"/\");\n    const widgetName = idParts[idParts.length - 1];\n    const accountId = component.author;\n    components.push({\n      accountId,\n      widgetName,\n      searchPosition: i,\n    });\n  }\n  return components;\n};\n\nconst categorizeSearchHits = (rawResp) => {\n  const results = {};\n  for (const [i, result] of rawResp.hits?.entries()) {\n    const { categories: categories_raw } = result;\n    if (categories_raw.length > 1) {\n      categories_raw.sort();\n    }\n\n    const categories = categories_raw.join(\", \");\n    results[categories] = results[categories] || [];\n    results[categories].push([i + 1, result]);\n  }\n  return {\n    results,\n    hitsTotal: rawResp.nbHits,\n    hitsPerPage: rawResp.hitsPerPage,\n  };\n};\n\nconst debounce = (callable, timeout) => {\n  return (args) => {\n    clearTimeout(state.timer);\n    State.update({\n      timer: setTimeout(() => callable(args), timeout ?? 50),\n    });\n  };\n};\n\nconst fetchSearchHits = (query, { pageNumber, configs, optionalFilters }) => {\n  configs = configs ?? configsPerFacet(state.facet);\n  let body = {\n    query,\n    page: pageNumber ?? 0,\n    optionalFilters: optionalFilters ?? [\n      \"categories:profile<score=3>\",\n      \"categories:widget<score=2>\",\n      \"categories:post<score=1>\",\n      \"categories:comment<score=0>\",\n    ],\n    clickAnalytics: true,\n    ...configs,\n  };\n\n  return asyncFetch(API_URL, {\n    body: JSON.stringify(body),\n    headers: {\n      \"Content-Type\": \"application/json; charset=UTF-8\",\n      \"X-Algolia-Api-Key\": SEARCH_API_KEY,\n      \"X-Algolia-Application-Id\": APPLICATION_ID,\n    },\n    method: \"POST\",\n  });\n};\n\nconst toggleActiveTag = (tag) => {\n  const newActiveTags = state.activeTags.includes(tag)\n    ? state.activeTags.filter((t) => t !== tag)\n    : [...state.activeTags, tag];\n\n  State.update({ activeTags: newActiveTags });\n  emit(\"onTagClick\", { activeTags: newActiveTags });\n};\n\nconst updateSearchHits = debounce(({ term, pageNumber, configs }) => {\n  fetchSearchHits(term, { pageNumber, configs }).then((resp) => {\n    const { results, hitsTotal, hitsPerPage } = categorizeSearchHits(resp.body);\n    const combinedResults = [\n      ...profiles(results[\"profile\"]),\n      ...components(results[\"widget\"]),\n      ...posts(results[\"post\"], \"post\"),\n      ...posts(results[\"comment, post\"], \"post-comment\"),\n    ];\n\n    State.update({\n      search: {\n        profiles: profiles(results[\"profile\"]),\n        components: components(results[\"widget\"]),\n        postsAndComments: posts(results[\"post\"], \"post\").concat(\n          posts(results[\"comment, post\"], \"post-comment\")\n        ),\n      },\n      currentPage: pageNumber,\n      paginate: {\n        hitsTotal,\n        hitsPerPage,\n      },\n      queryID: resp.body.queryID,\n    });\n\n    getAllTagsFromSearchResults(combinedResults);\n  });\n});\nconst updateFilteredTags = (inputValue) => {\n  State.update({\n    filteredTags: tags.filter((tag) => tag.includes(inputValue)),\n  });\n};\n\nconst updateTags = () => {\n  let selectedTags = [];\n\n  if (state.facet === \"Users\") {\n    selectedTags = state.userTags;\n  } else if (state.facet === \"Components\") {\n    selectedTags = state.componentTags;\n  } else {\n    selectedTags = state.allTags;\n  }\n\n  tags = selectedTags ?? [];\n  updateFilteredTags(state.inputValue);\n};\n\nconst onSearchChange = ({ term }) => {\n  writeStateTerm(term);\n  updateSearchHits({ term, pageNumber: INITIAL_PAGE });\n};\n\nconst onPageChange = (pageNumber) => {\n  const algoliaPageNumber = pageNumber - 1;\n  if (algoliaPageNumber === state.currentPage) {\n    console.log(`Selected the same page number as before: ${pageNumber}`);\n    return;\n  }\n  // Need to clear out old search data otherwise we'll get multiple entries\n  // from the previous pages as well. Seems to be cache issue on near.social.\n  State.update({\n    search: undefined,\n    currentPage: algoliaPageNumber,\n  });\n  updateSearchHits({ term: state.term, pageNumber: algoliaPageNumber });\n};\n\nconst FACET_TO_CATEGORY = {\n  Users: \"profile\",\n  Apps: \"app\",\n  Components: \"widget\",\n  Posts: \"post\",\n};\n\nconst searchFilters = (facet) => {\n  const category = FACET_TO_CATEGORY[facet];\n  let filters = category ? `categories:${category}` : undefined;\n  if (category === \"post\") {\n    filters = `(${filters} OR categories:comment)`;\n  }\n  if (category === \"app\") {\n    filters = `(${filters} OR tags:app)`;\n  }\n  if (filters) {\n    filters = `${filters} AND `;\n  }\n  filters = `${filters}NOT author:hypefairy.near AND NOT _tags:hidden`;\n\n  return filters;\n};\n\nconst restrictSearchable = (facet) => {\n  const category = FACET_TO_CATEGORY[facet];\n  let restrictSearchableAttrs = undefined;\n  if (category === \"post\") {\n    // Only the content should be searchable when the posts facet is selected.\n    restrictSearchableAttrs = [\"content\"];\n  }\n  return restrictSearchableAttrs;\n};\n\nconst configsPerFacet = (facet) => {\n  return {\n    filters: searchFilters(facet),\n    restrictSearchableAttributes: restrictSearchable(facet),\n  };\n};\n\nconst onFacetClick = (facet) => {\n  if (facet === state.facet) {\n    return;\n  }\n\n  const sortByDateCreated = (data, sortingKey) => {\n    if (!sortByDate) return data;\n\n    return data.sort((a, b) => {\n      const blockHeightA = a[sortingKey];\n      const blockHeightB = b[sortingKey];\n\n      const blockA = Near.block(blockHeightA);\n      const blockB = Near.block(blockHeightB);\n\n      const timeMsA = parseFloat(blockA.header.timestamp_nanosec) / 1e6;\n      const timeMsB = parseFloat(blockB.header.timestamp_nanosec) / 1e6;\n\n      return timeMsA - timeMsB;\n    });\n  };\n\n  State.update({\n    facet,\n  });\n\n  updateSearchHits({\n    term: state.term,\n    configs: configsPerFacet(facet),\n  });\n};\n\nconst onSearchResultClick = ({ searchPosition, objectID, eventName }) => {\n  const position =\n    searchPosition + state.currentPage * state.paginate.hitsPerPage;\n  const event = {\n    type: \"clickedObjectIDsAfterSearch\",\n    data: {\n      eventName,\n      userToken: userId.replace(\".\", \"+\"),\n      queryID: state.queryID,\n      objectIDs: [objectID],\n      positions: [position],\n      timestamp: Date.now(),\n    },\n  };\n\n  // Deferred due to State.update causing multiple clicks to be needed\n  // before the browser redirect to the page the user clicks on.\n  setTimeout(() => {\n    // This will trigger the Insights widget:\n    State.update({ event });\n  }, 50);\n};\n\n{\n}\n\nconst getAllTagsFromSearchResults = (results) => {\n  const allTags = [];\n  const userTags = [];\n  const componentTags = [];\n\n  results.forEach((result) => {\n    if (result.widgetName) {\n      const metadata = Social.get(\n        `${result.accountId}/widget/${result.widgetName}/metadata/**`,\n        \"final\"\n      );\n      const widgetTags = Object.keys(metadata.tags || {});\n      componentTags.push(...widgetTags);\n      allTags.push(...widgetTags);\n    } else {\n      const profile = Social.get(`${result.accountId}/profile/**`, \"final\");\n      const profileTags = Object.keys(profile.tags || {});\n      userTags.push(...profileTags);\n      allTags.push(...profileTags);\n    }\n  });\n\n  // Filter out duplicates\n  const uniqueAllTags = [...new Set(allTags)];\n  const uniqueUserTags = [...new Set(userTags)];\n  const uniqueComponentTags = [...new Set(componentTags)];\n\n  // Update the state with the unique tags\n  State.update({\n    allTags: uniqueAllTags,\n    userTags: uniqueUserTags,\n    componentTags: uniqueComponentTags,\n  });\n};\n\nconst getComponentTags = (accountId, widgetName) => {\n  const metadata = Social.get(\n    `${accountId}/widget/${widgetName}/metadata/**`,\n    \"final\"\n  );\n  const tags = Object.keys(metadata.tags || {});\n  State.update({ selectedTags: tags });\n};\n\nconst handleClick = (tag) => {\n  // Your logic to update activeTags, e.g.:\n  const newActiveTags = state.activeTags.includes(tag)\n    ? state.activeTags.filter((t) => t !== tag)\n    : [...state.activeTags, tag];\n\n  // Call the callback function passed as a prop\n  props.onTagClick(newActiveTags);\n};\n\nconst updateSelectedTags = (tags) => {\n  State.update({\n    selectedTags: tags,\n  });\n  updateSearchHits();\n};\n\nfunction arraysIntersect(a, b) {\n  for (let i = 0; i < b.length; i++) {\n    if (a.includes(b[i])) {\n      return true;\n    }\n  }\n  return false;\n}\n\nconst handleCheckboxChange = (checkboxName, isChecked) => {\n  // Update the state based on the checkboxName and isChecked values\n  console.log(checkboxName, isChecked);\n  const updatedState = {};\n  updatedState[checkboxName] = isChecked;\n  State.update(updatedState);\n  console.log(`the ${checkboxName} check is`, state[checkboxName]);\n};\n\n// Here is the return.\nreturn (\n  <>\n    <div\n      style={{\n        transition: \"transform 0.3s ease-in-out\",\n        transform: state.isFiltersPanelVisible\n          ? \"translateX(-250px)\"\n          : \"translateX(0)\",\n      }}\n    >\n      <Wrapper>\n        {showHeader && (\n          <Header>\n            <H1>Search</H1>\n          </Header>\n        )}\n        {showSearchBar && (\n          <Search>\n            <div style={{ display: \"flex\", justifyContent: \"space-between\" }}>\n              <Widget\n                src=\"dorgon108.near/widget/SearchPill\"\n                props={{\n                  onChange: onSearchChange,\n                  term: props.term,\n                }}\n              />\n              <button onClick={toggleFiltersPanel}>Toggle Filters Panel</button>\n            </div>\n          </Search>\n        )}\n\n        {state.search && (\n          <Facets>\n            <Widget\n              src=\"dorgon108.near/widget/Facets\"\n              props={{\n                facets,\n                onFacetClick,\n                defaultFacet: facets[0],\n                initialFacet: tab,\n                tabButtonStyle: TabsButton,\n              }}\n            />\n          </Facets>\n        )}\n\n        {state.paginate?.hitsTotal == 0 && (\n          <H2>No matches were found for \"{state.term}\".</H2>\n        )}\n\n        {state.search?.components.length > 0 && (\n          <Group>\n            <GroupHeader>\n              {state.facet === \"Components\" || currentTab === \"Components\" ? (\n                <H3>Components</H3>\n              ) : (\n                <H3>Apps</H3>\n              )}\n\n              <Text as=\"a\" onClick={() => onFacetClick(\"Components\")} small>\n                View All\n              </Text>\n            </GroupHeader>\n            <GridItems numColumns={state.numColumns}>\n              {state.search.components\n                .filter((component, index) => {\n                  const metadata = Social.get(\n                    `${component.accountId}/widget/${component.widgetName}/metadata/**`,\n                    \"final\"\n                  );\n                  const tags = Object.keys(metadata.tags || {});\n\n                  const hasActiveTag =\n                    state.activeTags.length === 0 ||\n                    arraysIntersect(state.componentTags, tags);\n\n                  const displayCondition =\n                    state.facet === \"Components\" ||\n                    currentTab === \"Components\" ||\n                    ((state.facet === \"Apps\" || currentTab === \"Apps\") &&\n                      tags.includes(\"Apps\") &&\n                      index < 3) ||\n                    index < 3;\n\n                  const followingCondition = isUserFollowing(\n                    context.accountId,\n                    component.accountId\n                  );\n\n                  return (\n                    hasActiveTag &&\n                    displayCondition &&\n                    ((state.showFollowed && followingCondition) ||\n                      (state.showNotFollowed && !followingCondition) ||\n                      (!state.showFollowed && !state.showNotFollowed))\n                  );\n                })\n\n                .map((component, i) => {\n                  const tags = getComponentTags(\n                    component.accountId,\n                    component.widgetName\n                  );\n\n                  return (\n                    <Item key={component.accountId + component.widgetName}>\n                      <Widget\n                        src=\"near/widget/ComponentCard\"\n                        props={{\n                          src: `${component.accountId}/widget/${component.widgetName}`,\n                          blockHeight: component.blockHeight,\n                        }}\n                      />\n                    </Item>\n                  );\n                })}\n            </GridItems>\n          </Group>\n        )}\n\n        {state.search?.profiles.length > 0 && (\n          <Group>\n            <GroupHeader>\n              <H3>People</H3>\n              <Text as=\"a\" onClick={() => onFacetClick(\"Users\")} small>\n                View All\n              </Text>\n            </GroupHeader>\n            <GridItems numColumns={state.numColumns}>\n              {state.search.profiles\n                .filter((profile, index) => {\n                  const fetchedProfile = Social.get(\n                    `${profile.accountId}/profile/**`,\n                    \"final\"\n                  );\n                  const profileTags = Object.keys(fetchedProfile.tags || {});\n\n                  const hasActiveTag =\n                    state.activeTags.length === 0 ||\n                    arraysIntersect(state.activeTags, profileTags);\n\n                  const displayCondition =\n                    state.facet === \"Users\" ||\n                    currentTab === \"Users\" ||\n                    index < 3;\n\n                  const followingCondition = isUserFollowing(\n                    context.accountId,\n                    profile.accountId\n                  );\n\n                  return (\n                    hasActiveTag &&\n                    displayCondition &&\n                    ((state.showFollowed && followingCondition) ||\n                      (state.showNotFollowed && !followingCondition) ||\n                      (!state.showFollowed && !state.showNotFollowed))\n                  );\n                })\n\n                .map((profile, i) => (\n                  <Item key={profile.accountId}>\n                    <Widget\n                      src=\"dorgon108.near/widget/AccountProfileCard\"\n                      props={{\n                        accountId: profile.accountId,\n                        onClick: () =>\n                          onSearchResultClick({\n                            searchPosition: profile.searchPosition,\n                            objectID: `${profile.accountId}/profile`,\n                            eventName: \"Clicked Profile After Search\",\n                          }),\n                      }}\n                    />\n                  </Item>\n                ))}\n            </GridItems>\n          </Group>\n        )}\n\n        {state.search?.postsAndComments.length > 0 && (\n          <Group>\n            <GroupHeader>\n              <H3>Posts</H3>\n              <Text as=\"a\" onClick={() => onFacetClick(\"Posts\")} small>\n                View All\n              </Text>\n            </GroupHeader>\n            <PostsGridItems>\n              {state.search.postsAndComments\n                .filter((_, index) => {\n                  const displayCondition =\n                    state.facet === \"Posts\" || currentTab === \"Posts\"\n                      ? true\n                      : index < 3;\n\n                  const followingCondition = isUserFollowing(\n                    context.accountId,\n                    _.accountId\n                  );\n\n                  return (\n                    displayCondition &&\n                    ((state.showFollowed && followingCondition) ||\n                      (state.showNotFollowed && !followingCondition) ||\n                      (!state.showFollowed && !state.showNotFollowed))\n                  );\n                })\n\n                .map((post, i) => (\n                  <Item\n                    key={`${post.accountId}/${post.postType}/${post.blockHeight}`}\n                  >\n                    <Widget\n                      src=\"dorgon108.near/widget/SearchPost-SearchAll\"\n                      props={{\n                        accountId: post.accountId,\n                        blockHeight: post.blockHeight,\n                        content: post.postContent,\n                        snipContent: post.snipContent,\n                        postType: post.postType,\n                        onClick: () =>\n                          onSearchResultClick({\n                            searchPosition: post.searchPosition,\n                            objectID: `${post.accountId}/${post.postType}/${post.blockHeight}`,\n                            eventName: \"Clicked Post After Search\",\n                          }),\n                      }}\n                    />\n                  </Item>\n                ))}\n            </PostsGridItems>\n          </Group>\n        )}\n\n        {!props.disableInsights && (\n          <Widget\n            src=\"chaotictempest.near/widget/Insights\"\n            props={{\n              event: state.event,\n              searchApiKey: SEARCH_API_KEY,\n              appId: APPLICATION_ID,\n              index: INDEX,\n            }}\n          />\n        )}\n      </Wrapper>\n    </div>\n    {state.isFiltersPanelVisible && (\n      <FiltersPanel\n        style={{\n          transform: state.isFiltersPanelVisible\n            ? \"translateX(0)\"\n            : \"translateX(100%)\",\n        }}\n      >\n        <Widget\n          src={`dorgon108.near/widget/FIlterComponent`}\n          props={{\n            showFollowed: state.showFollowed,\n            showNotFollowed: state.showNotFollowed,\n            onCheckboxChange: handleCheckboxChange,\n            updateTags: updateTags,\n\n            selectedTags: state.allTags,\n            onTagClick: (tags) => {\n              // handle tag click\n              // Update the state with the new activeTags\n              State.update({ activeTags: tags });\n            },\n          }}\n        />\n      </FiltersPanel>\n    )}\n  </>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/dorgon108.near/widget/Search", "fact_widget_deployments_id": "f35344c6f8177953fd85e7dc72afd1f0", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 0}