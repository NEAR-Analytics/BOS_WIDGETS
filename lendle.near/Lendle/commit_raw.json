{"tx_hash": "DgGXuHvFmb2FhihRQLNptXUpxGaDsJvzeMCTLbpyNemq", "action_id_social": "EBoqtZoAoXivHwogcv1sFR91hCi7tSSFrECrqAQMp7rz-0-widget", "block_id": 100894910, "block_timestamp": "2023-09-11T16:10:23.319Z", "signer_id": "lendle.near", "widget_name": "Lendle", "source_code": "const ROUND_DOWN = 0;\nconst CONTRACT_ABI = {\n  wrappedTokenGatewayV3ABI:\n    \"https://raw.githubusercontent.com/lendle-xyz/lendle-bos/main/src/abi/WETHGateway.json\",\n  erc20Abi:\n    \"https://raw.githubusercontent.com/lendle-xyz/lendle-bos/main/src/abi/ERC20.json\",\n  aavePoolV3ABI:\n    \"https://raw.githubusercontent.com/lendle-xyz/lendle-bos/main/src/abi/LendingPool.json\",\n  variableDebtTokenABI:\n    \"https://raw.githubusercontent.com/lendle-xyz/lendle-bos/main/src/abi/VariableDebtToken.json\",\n  walletBalanceProviderABI:\n    \"https://raw.githubusercontent.com/lendle-xyz/lendle-bos/main/src/abi/WalletBalanceProvider.json\",\n};\nconst DEFAULT_CHAIN_ID = 5000;\nconst NATIVE_SYMBOL_ADDRESS_MAP_KEY = \"0x0\";\nconst ETH_TOKEN = { name: \"Mantle\", symbol: \"MNT\", decimals: 18 };\nconst WETH_TOKEN = { name: \"Wrapped Mantle\", symbol: \"WMNT\", decimals: 18 };\nconst ACTUAL_BORROW_AMOUNT_RATE = 0.99;\n\nconst GRAPHQL_URL =\n  \"https://subgraph.lendle.xyz/subgraphs/name/lendle-finance/lendle-finance-mantle\";\n\n// Get AAVE network config by chain id\nfunction getNetworkConfig(chainId) {\n  const abis = {\n    wrappedTokenGatewayV3ABI: fetch(CONTRACT_ABI.wrappedTokenGatewayV3ABI),\n    erc20Abi: fetch(CONTRACT_ABI.erc20Abi),\n    aavePoolV3ABI: fetch(CONTRACT_ABI.aavePoolV3ABI),\n    variableDebtTokenABI: fetch(CONTRACT_ABI.variableDebtTokenABI),\n    walletBalanceProviderABI: fetch(CONTRACT_ABI.walletBalanceProviderABI),\n  };\n\n  const constants = {\n    FIXED_LIQUIDATION_VALUE: \"1.0\",\n    MAX_UINT_256:\n      \"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\",\n    AAVE_API_BASE_URL: \"https://aave-data-service-7a85eea3aebe.herokuapp.com\",\n  };\n\n  switch (chainId) {\n    case 5000: // Mantle mainnet\n      return {\n        chainName: \"Mantle Mainnet\",\n        nativeCurrency: ETH_TOKEN,\n        nativeWrapCurrency: WETH_TOKEN,\n        rpcUrl: \"https://rpc.mantle.xyz\",\n        aavePoolV3Address: \"0xCFa5aE7c2CE8Fadc6426C1ff872cA45378Fb7cF3\",\n        wrappedTokenGatewayV3Address:\n          \"0xEc831f8710C6286a91a348928600157f07aC55c2\",\n        balanceProviderAddress: \"0x370bc6B2940A6927fFf2D64BA3D96C641579a01e\",\n        ...abis,\n        ...constants,\n      };\n    default:\n      throw new Error(\"unknown chain id\");\n  }\n}\n\nfunction switchEthereumChain(chainId) {\n  const chainIdHex = `0x${chainId.toString(16)}`;\n  const res = Ethers.send(\"wallet_switchEthereumChain\", [\n    { chainId: chainIdHex },\n  ]);\n  // If `res` === `undefined`, it means switch chain failed, which is very weird but it works.\n  // If `res` is `null` the function is either not called or executed successfully.\n  if (res === undefined) {\n    console.log(\n      `Failed to switch chain to ${chainId}. Add the chain to wallet`\n    );\n    const config = getNetworkConfig(chainId);\n    Ethers.send(\"wallet_addEthereumChain\", [\n      {\n        chainId: chainIdHex,\n        chainName: config.chainName,\n        nativeCurrency: config.nativeCurrency,\n        rpcUrls: [config.rpcUrl],\n      },\n    ]);\n  }\n}\n\nif (\n  state.chainId === undefined &&\n  ethers !== undefined &&\n  Ethers.send(\"eth_requestAccounts\", [])[0]\n) {\n  Ethers.provider()\n    .getNetwork()\n    .then((data) => {\n      const chainId = data?.chainId;\n      const config = getNetworkConfig(chainId);\n      if (!config) {\n        console.log(`Unsupport chain, chainId: ${chainId}`);\n        State.update({ isChainSupported: false });\n        switchEthereumChain(DEFAULT_CHAIN_ID);\n      } else {\n        State.update({ chainId, isChainSupported: true });\n      }\n    });\n}\n\nfunction isValid(a) {\n  if (!a) return false;\n  if (isNaN(Number(a))) return false;\n  if (a === \"\") return false;\n  return true;\n}\n\nconst GAS_LIMIT_RECOMMENDATIONS = {\n  default: {\n    limit: \"210000\",\n    recommended: \"210000\",\n  },\n  approval: {\n    limit: \"65000\",\n    recommended: \"65000\",\n  },\n  creditDelegationApproval: {\n    limit: \"55000\",\n    recommended: \"55000\",\n  },\n  supply: {\n    limit: \"300000\",\n    recommended: \"300000\",\n  },\n  deposit: {\n    limit: \"300000\",\n    recommended: \"300000\",\n  },\n  borrow: {\n    limit: \"400000\",\n    recommended: \"400000\",\n  },\n  withdraw: {\n    limit: \"230000\",\n    recommended: \"300000\",\n  },\n  liquidationCall: {\n    limit: \"700000\",\n    recommended: \"700000\",\n  },\n  liquidationFlash: {\n    limit: \"995000\",\n    recommended: \"995000\",\n  },\n  repay: {\n    limit: \"300000\",\n    recommended: \"300000\",\n  },\n  borrowETH: {\n    limit: \"450000\",\n    recommended: \"450000\",\n  },\n  withdrawETH: {\n    limit: \"640000\",\n    recommended: \"640000\",\n  },\n  swapCollateral: {\n    limit: \"1000000\",\n    recommended: \"1000000\",\n  },\n  repayCollateral: {\n    limit: \"700000\",\n    recommended: \"700000\",\n  },\n  migrateV3: {\n    limit: \"700000\",\n    recommended: \"700000\",\n  },\n  supplyWithPermit: {\n    limit: \"350000\",\n    recommended: \"350000\",\n  },\n  repayWithPermit: {\n    limit: \"350000\",\n    recommended: \"350000\",\n  },\n  vote: {\n    limit: \"125000\",\n    recommended: \"125000\",\n  },\n  stake: {\n    limit: \"395000\",\n    recommended: \"395000\",\n  },\n  claimRewards: {\n    limit: \"275000\",\n    recommended: \"275000\",\n  },\n  setUsageAsCollateral: {\n    limit: \"138000\",\n    recommended: \"138000\",\n  },\n};\n\nfunction getGasPrice() {\n  return Ethers.provider().getGasPrice();\n}\n\nfunction gasEstimation(action) {\n  const assetsToSupply = state.assetsToSupply;\n  if (!assetsToSupply) {\n    return \"-\";\n  }\n  const baseAsset = assetsToSupply.find(\n    (asset) => asset.symbol === config.nativeCurrency.symbol\n  );\n  if (!baseAsset) {\n    return \"-\";\n  }\n  const { marketReferencePriceInUsd, decimals } = baseAsset;\n  return getGasPrice().then((gasPrice) => {\n    const gasLimit = GAS_LIMIT_RECOMMENDATIONS[action].limit;\n    return Big(gasPrice.toString())\n      .mul(gasLimit)\n      .div(Big(10).pow(decimals))\n      .mul(marketReferencePriceInUsd)\n      .toFixed(2);\n  });\n}\n\nfunction depositETHGas() {\n  return gasEstimation(\"deposit\");\n}\n\nfunction depositERC20Gas() {\n  return gasEstimation(\"supplyWithPermit\");\n}\n\nfunction withdrawETHGas() {\n  return gasEstimation(\"withdrawETH\");\n}\n\nfunction withdrawERC20Gas() {\n  return gasEstimation(\"withdraw\");\n}\n\nfunction borrowETHGas() {\n  return gasEstimation(\"borrowETH\");\n}\n\nfunction borrowERC20Gas() {\n  return gasEstimation(\"borrow\");\n}\n\nfunction repayETHGas() {\n  return gasEstimation(\"repay\");\n}\n\nfunction repayERC20Gas() {\n  return gasEstimation(\"repayWithPermit\");\n}\n\n// interface Market {\n//   id: string,\n//   underlyingAsset: string,\n//   name: string,\n//   symbol: string,\n//   decimals: number,\n//   supplyAPY: string;\n//   marketReferencePriceInUsd: string;\n//   usageAsCollateralEnabled: boolean;\n//   aTokenAddress: string;\n//   variableBorrowAPY: string;\n// }\n// returns Market[]\nfunction getMarkets(chainId) {\n  const query = `\n  query MarketsDataQuery {\n    markets {\n      totalValueLockedUSD\n      totalDepositBalanceUSD\n      totalBorrowBalanceUSD\n      maximumLTV\n      liquidationThreshold\n      liquidationPenalty\n      canUseAsCollateral\n      name\n      canBorrowFrom\n      cumulativeProtocolSideRevenueUSD\n      cumulativeSupplySideRevenueUSD\n      cumulativeTotalRevenueUSD\n      rewardTokenEmissionsAmount\n      rewardTokenEmissionsUSD\n      id\n      _lastRewardsUpdated\n      _liquidityIndex\n      _prePauseState\n      closedPositionCount\n      isActive\n      outputTokenPriceUSD\n      inputTokenPriceUSD\n      rates {\n        rate\n        side\n        type\n      }\n      totalAllocPoint\n      supplyAllocPoint\n      borrowAllocPoint\n      inputToken {\n        symbol\n        decimals\n      }\n    }\n  }\n  `;\n\n  return asyncFetch(GRAPHQL_URL, {\n    method: \"POST\",\n    headers: { \"Content-Type\": \"application/json\" },\n    body: JSON.stringify({ query }),\n  }).then((res) => {\n    const markets = res.body.data.markets;\n    const mappedMarkets = markets.map((market) => ({\n      underlyingAsset: market.id,\n      name: market.name,\n      symbol: market.inputToken.symbol,\n      decimals: market.inputToken.decimals,\n      supplyAPY:\n        Number(market.rates.find((rate) => rate.side === \"LENDER\").rate) / 100,\n      marketReferencePriceInUsd: market.outputTokenPriceUSD,\n      usageAsCollateralEnabled: market.canUseAsCollateral,\n      aTokenAddress: market.id,\n      variableBorrowAPY:\n        Number(market.rates.find((rate) => rate.side === \"BORROWER\").rate) /\n        100,\n      availableLiquidityUSD: market.totalValueLockedUSD,\n      availableLiquidity: market.totalValueLockedUSD,\n      totalBorrowBalanceUSD: market.totalBorrowBalanceUSD,\n      totalDepositBalanceUSD: market.totalDepositBalanceUSD,\n    }));\n    return {\n      body: mappedMarkets,\n    };\n  });\n}\n\n/**\n * @param {string} account user address\n * @param {string[]} tokens list of token addresses\n */\n// interface TokenBalance {\n//   token: string,\n//   balance: string,\n//   decimals: number,\n// }\n// returns TokenBalance[]\nfunction getUserBalances(chainId, account, tokens) {\n  const url = `${\n    config.AAVE_API_BASE_URL\n  }/${chainId}/balances?account=${account}&tokens=${tokens.join(\"|\")}`;\n  return asyncFetch(url);\n}\n\n// interface UserDeposit {\n//   underlyingAsset: string,\n//   name: string,\n//   symbol: string,\n//   scaledATokenBalance: string,\n//   usageAsCollateralEnabledOnUser: boolean,\n//   underlyingBalance: string,\n//   underlyingBalanceUSD: string,\n// }\n// returns UserDeposit[]\nfunction getUserDeposits(chainId, address) {\n  const query = `\n  query GetAccountReservesData {\n    account(id: \"${address.toLowerCase()}\") {\n      positions(where: { balance_gt: \"0\" }) {\n        side\n        balance\n        market {\n          name\n          rates {\n            rate\n            side\n          }\n          inputToken {\n            name\n            symbol\n            decimals\n            id\n          }\n        }\n        isCollateral\n      }\n    }\n  }\n  `;\n  return asyncFetch(GRAPHQL_URL, {\n    method: \"POST\",\n    headers: { \"Content-Type\": \"application/json\" },\n    body: JSON.stringify({ query }),\n  }).then((res) => {\n    if (!res.body.data.account) {\n      return {\n        body: [],\n      };\n    }\n    const positions = res.body.data.account.positions;\n    const mappedPositions = positions\n      .filter((pos) => pos.side === \"LENDER\")\n      .map((position) => {\n        const formattedBalance = Big(position.balance)\n          .div(Big(10).pow(position.market.inputToken.decimals))\n          .toString();\n        return {\n          underlyingAsset: position.market.inputToken.id,\n          name: position.market.name,\n          symbol: position.market.inputToken.symbol,\n          decimals: position.market.inputToken.decimals,\n          scaledATokenBalance: position.balance,\n          usageAsCollateralEnabledOnUser: position.isCollateral,\n          underlyingBalance: formattedBalance,\n          underlyingBalanceUSD: formattedBalance,\n        };\n      });\n    return {\n      body: mappedPositions,\n    };\n  });\n}\n\n// interface UserDebtSummary {\n//   healthFactor: string,\n//   netWorthUSD: string,\n//   availableBorrowsUSD: string,\n//   debts: UserDebt[],\n// }\n// interface UserDebt {\n//   underlyingAsset: string;\n//   name: string;\n//   symbol: string;\n//   usageAsCollateralEnabledOnUser: boolean,\n//   scaledVariableDebt: string,\n//   variableBorrows: string,\n//   variableBorrowsUSD: string,\n// }\n// returns UserDebtSummary\nfunction getUserDebts(chainId, address) {\n  const query = `\n  query GetAccountReservesData {\n    account(id: \"${address.toLowerCase()}\") {\n      positions(where: { balance_gt: \"0\" }) {\n        side\n        balance\n        market {\n          name\n          rates {\n            rate\n            side\n          }\n          inputToken {\n            name\n            symbol\n            decimals\n            id\n          }\n        }\n        isCollateral\n      }\n    }\n  }\n  `;\n  return asyncFetch(GRAPHQL_URL, {\n    method: \"POST\",\n    headers: { \"Content-Type\": \"application/json\" },\n    body: JSON.stringify({ query }),\n  }).then((res) => {\n    if (!res.body.data.account) {\n      return {\n        body: {\n          healthFactor: \"\u221e\",\n          netWorthUSD: \"0\",\n          availableBorrowsUSD: \"0\",\n          debts: [],\n        },\n      };\n    }\n\n    const positions = res.body.data.account.positions;\n    const mappedPositions = positions\n      .filter((pos) => pos.side === \"BORROWER\")\n      .map((position) => {\n        const formattedBalance = Big(position.balance)\n          .div(Big(10).pow(position.market.inputToken.decimals))\n          .toString();\n        return {\n          underlyingAsset: position.market.inputToken.id,\n          name: position.market.name,\n          symbol: position.market.inputToken.symbol,\n          usageAsCollateralEnabledOnUser: position.isCollateral,\n          scaledVariableDebt: formattedBalance,\n          variableBorrows: formattedBalance,\n          variableBorrowsUSD: formattedBalance,\n        };\n      });\n\n    const healthFactor = \"\u221e\";\n    const netWorthUSD = \"0\";\n    const availableBorrowsUSD = \"2\";\n    const debts = mappedPositions;\n\n    return {\n      body: {\n        healthFactor,\n        netWorthUSD,\n        availableBorrowsUSD,\n        debts,\n      },\n    };\n  });\n}\n\n// App config\nfunction getConfig(network) {\n  const chainId = state.chainId;\n  switch (network) {\n    case \"mainnet\":\n      return {\n        ownerId:\n          \"lendle.near\",\n        nodeUrl: \"https://rpc.mainnet.near.org\",\n        ipfsPrefix: \"https://ipfs.near.social/ipfs\",\n        ipfsPrefixLendle: \"https://ipfs.io/ipfs\",\n        ...(chainId ? getNetworkConfig(chainId) : {}),\n      };\n    case \"testnet\":\n      return {\n        ownerId: \"aave-v3.testnet\",\n        nodeUrl: \"https://rpc.testnet.near.org\",\n        ipfsPrefix: \"https://ipfs.near.social/ipfs\",\n        ipfsPrefixLendle: \"https://ipfs.io/ipfs\",\n        ...(chainId ? getNetworkConfig(chainId) : {}),\n      };\n    default:\n      throw Error(`Unconfigured environment '${network}'.`);\n  }\n}\nconst config = getConfig(context.networkId);\n\n// App states\nState.init({\n  imports: {},\n  chainId: undefined, // chainId is undefined in the case of unsupported chains\n  isChainSupported: true,\n  showWithdrawModal: false,\n  showSupplyModal: false,\n  showRepayModal: false,\n  showBorrowModal: false,\n  walletConnected: false,\n  assetsToSupply: undefined,\n  yourSupplies: undefined,\n  assetsToBorrow: undefined,\n  yourBorrows: undefined,\n  address: undefined,\n  baseAssetBalance: undefined,\n  selectTab: \"supply\", // supply | borrow\n  markets: undefined,\n});\n\nconst loading =\n  !state.assetsToSupply || !state.yourSupplies || !state.assetsToBorrow;\n\n// Import functions to state.imports\nfunction importFunctions(imports) {\n  if (loading) {\n    State.update({\n      imports,\n    });\n  }\n}\n\n// Define the modules you'd like to import\nconst modules = {\n  number: `${config.ownerId}/widget/Utils.Number`,\n  date: `${config.ownerId}/widget/Utils.Date`,\n  data: `${config.ownerId}/widget/Lendle.Data`,\n};\n// Import functions\n// const { formatAmount } = state.imports.number;\n// const { formatDateTime } = state.imports.date;\n\nfunction checkProvider() {\n  const provider = Ethers.provider();\n  if (provider) {\n    State.update({ walletConnected: true });\n  } else {\n    State.update({ walletConnected: false });\n  }\n}\n\nfunction calculateAvailableBorrows({\n  availableBorrowsUSD,\n  marketReferencePriceInUsd,\n}) {\n  return isValid(availableBorrowsUSD) && isValid(marketReferencePriceInUsd)\n    ? Big(availableBorrowsUSD).div(marketReferencePriceInUsd).toFixed()\n    : Number(0).toFixed();\n}\n\nfunction bigMin(_a, _b) {\n  const a = Big(_a);\n  const b = Big(_b);\n  return a.gt(b) ? b : a;\n}\n\nfunction formatHealthFactor(healthFactor) {\n  if (healthFactor === \"\u221e\") return healthFactor;\n  if (!healthFactor || !isValid(healthFactor)) return \"-\";\n  if (Number(healthFactor) === -1) return \"\u221e\";\n  return Big(healthFactor).toFixed(2, ROUND_DOWN);\n}\n\nfunction batchBalanceOf(chainId, userAddress, tokenAddresses, abi) {\n  tokenAddresses = tokenAddresses.filter((ele) => !!ele);\n\n  const balanceProvider = new ethers.Contract(\n    config.balanceProviderAddress,\n    abi,\n    Ethers.provider().getSigner()\n  );\n\n  return balanceProvider.batchBalanceOf([userAddress], tokenAddresses);\n}\n\n// update data in async manner\nfunction updateData(refresh) {\n  getMarkets(state.chainId || DEFAULT_CHAIN_ID).then((marketsResponse) => {\n    if (!marketsResponse) {\n      return;\n    }\n    const markets = marketsResponse.body;\n    State.update({\n      markets,\n    });\n    const marketsMapping = markets.reduce((prev, cur) => {\n      prev[cur.underlyingAsset] = cur;\n      return prev;\n    }, {});\n\n    const nativeMarket = markets.find(\n      (market) => market.symbol === config.nativeWrapCurrency.symbol\n    );\n    markets.push({\n      ...nativeMarket,\n      ...{\n        ...config.nativeCurrency,\n        supportPermit: true,\n      },\n    });\n\n    // check abi loaded\n    if (\n      Object.keys(CONTRACT_ABI)\n        .map((key) => config[key])\n        .filter((ele) => !!ele).length !== Object.keys(CONTRACT_ABI).length\n    ) {\n      return;\n    }\n    const provider = Ethers.provider();\n    if (!provider) {\n      return;\n    }\n    provider\n      .getSigner()\n      ?.getAddress()\n      ?.then((address) => {\n        State.update({ address });\n      });\n    provider\n      .getSigner()\n      ?.getBalance()\n      .then((balance) => State.update({ baseAssetBalance: balance }));\n    if (!state.address || !state.baseAssetBalance) {\n      return;\n    }\n\n    // get user balances\n    batchBalanceOf(\n      state.chainId,\n      state.address,\n      markets.map((market) => market.underlyingAsset),\n      config.walletBalanceProviderABI.body\n    )\n      .then((balances) => {\n        return balances.map((balance) => balance.toString());\n      })\n      .then((userBalances) => {\n        const assetsToSupply = markets\n          .map((market, idx) => {\n            const balanceRaw = Big(\n              market.symbol === config.nativeCurrency.symbol\n                ? state.baseAssetBalance\n                : userBalances[idx]\n            ).div(Big(10).pow(market.decimals));\n            const balance = balanceRaw.toFixed(market.decimals, ROUND_DOWN);\n            const balanceInUSD = balanceRaw\n              .mul(market.marketReferencePriceInUsd)\n              .toFixed(3, ROUND_DOWN);\n\n            return {\n              ...market,\n              balance,\n              balanceInUSD,\n            };\n          })\n          .sort((asset1, asset2) => {\n            const balanceInUSD1 = Number(asset1.balanceInUSD);\n            const balanceInUSD2 = Number(asset2.balanceInUSD);\n            if (balanceInUSD1 !== balanceInUSD2)\n              return balanceInUSD2 - balanceInUSD1;\n            return asset1.symbol.localeCompare(asset2.symbol);\n          });\n\n        State.update({\n          assetsToSupply,\n        });\n        // get user borrow data\n        updateUserDebts(markets, assetsToSupply, refresh);\n      });\n    // get user supplies\n    updateUserSupplies(marketsMapping, refresh);\n  });\n}\n\nfunction updateUserSupplies(marketsMapping, refresh) {\n  const prevYourSupplies = state.yourSupplies;\n  getUserDeposits(state.chainId, state.address).then((userDepositsResponse) => {\n    if (!userDepositsResponse) {\n      return;\n    }\n    const userDeposits = userDepositsResponse.body.filter(\n      (row) => Number(row.underlyingBalance) !== 0\n    );\n    const yourSupplies = userDeposits.map((userDeposit) => {\n      const market = marketsMapping[userDeposit.underlyingAsset];\n      return {\n        ...market,\n        ...userDeposit,\n        ...(market.symbol === config.nativeWrapCurrency.symbol\n          ? {\n              ...config.nativeCurrency,\n              supportPermit: true,\n            }\n          : {}),\n      };\n    });\n\n    State.update({\n      yourSupplies,\n    });\n\n    if (\n      refresh &&\n      JSON.stringify(prevYourSupplies) === JSON.stringify(yourSupplies) &&\n      yourSupplies.length !== 0\n    ) {\n      console.log(\"refresh supplies again ...\", prevYourSupplies, yourSupplies);\n      setTimeout(updateData, 500);\n    }\n  });\n}\n\nfunction updateUserDebts(markets, assetsToSupply, refresh) {\n  if (!markets || !assetsToSupply) {\n    return;\n  }\n\n  const prevYourBorrows = state.yourBorrows;\n  // userDebts depends on the balance from assetsToSupply\n  const assetsToSupplyMap = assetsToSupply.reduce((prev, cur) => {\n    if (cur.symbol !== config.nativeCurrency.symbol) {\n      prev[cur.underlyingAsset] = cur;\n    } else {\n      prev[NATIVE_SYMBOL_ADDRESS_MAP_KEY] = cur;\n    }\n    return prev;\n  }, {});\n\n  getUserDebts(state.chainId, state.address).then((userDebtsResponse) => {\n    if (!userDebtsResponse) {\n      return;\n    }\n    const userDebts = userDebtsResponse.body;\n    const assetsToBorrow = {\n      ...userDebts,\n      healthFactor: formatHealthFactor(userDebts.healthFactor),\n      debts: markets\n        .map((market) => {\n          const userDebt = userDebts.debts.find(\n            (debt) => debt.underlyingAsset === market.underlyingAsset\n          );\n\n          if (!market) {\n            return;\n          }\n          const { availableLiquidityUSD } = market;\n          const availableBorrowsUSD = bigMin(\n            userDebts.availableBorrowsUSD,\n            availableLiquidityUSD\n          )\n            .times(ACTUAL_BORROW_AMOUNT_RATE)\n            .toFixed();\n          const assetsToSupplyMapKey =\n            market.symbol === config.nativeWrapCurrency.symbol\n              ? NATIVE_SYMBOL_ADDRESS_MAP_KEY\n              : userDebt.underlyingAsset;\n          return {\n            ...market,\n            ...userDebt,\n            // ...(market.symbol === config.nativeWrapCurrency.symbol\n            //   ? {\n            //       ...config.nativeCurrency,\n            //       supportPermit: true,\n            //     }\n            //   : {}),\n            availableBorrows: calculateAvailableBorrows({\n              availableBorrowsUSD,\n              marketReferencePriceInUsd: market.marketReferencePriceInUsd,\n            }),\n            availableBorrowsUSD,\n            balance: assetsToSupplyMap[assetsToSupplyMapKey].balance,\n            balanceInUSD: assetsToSupplyMap[assetsToSupplyMapKey].balanceInUSD,\n            borrowingEnabled: true,\n          };\n        })\n        .filter((asset) => !!asset)\n        .sort((asset1, asset2) => {\n          const availableBorrowsUSD1 = Number(asset1.availableBorrowsUSD);\n          const availableBorrowsUSD2 = Number(asset2.availableBorrowsUSD);\n          if (availableBorrowsUSD1 !== availableBorrowsUSD2)\n            return availableBorrowsUSD2 - availableBorrowsUSD1;\n          return asset1.symbol.localeCompare(asset2.symbol);\n        })\n        .filter((asset) => {\n          return asset.borrowingEnabled;\n        }),\n    };\n    const yourBorrows = {\n      ...assetsToBorrow,\n      debts: assetsToBorrow.debts.filter(\n        (row) =>\n          !isNaN(Number(row.variableBorrowsUSD)) &&\n          Number(row.variableBorrowsUSD) > 0\n      ),\n    };\n\n    State.update({\n      yourBorrows,\n      assetsToBorrow,\n    });\n\n    if (\n      refresh &&\n      JSON.stringify(prevYourBorrows) === JSON.stringify(yourBorrows)\n    ) {\n      console.log(\"refresh borrows again ...\", prevYourBorrows, yourBorrows);\n      setTimeout(updateData, 500);\n    }\n  });\n}\n\nfunction onActionSuccess({ msg, callback }) {\n  // update data if action finishes\n  updateData(true);\n  // update UI after data has almost loaded\n  setTimeout(() => {\n    if (callback) {\n      callback();\n    }\n    if (msg) {\n      State.update({ alertModalText: msg });\n    }\n  }, 5000);\n}\n\ncheckProvider();\n// if (state.walletConnected && state.chainId && loading) {\nupdateData();\n// }\n\nconst Body = styled.div`\n  padding: 24px 15px;\n  background: #1b0027;\n  min-height: 100vh;\n  color: white;\n`;\n\nconst FlexContainer = styled.div`\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  flex-direction: column;\n`;\n// Component body\nconst body = loading ? (\n  <>\n    <Widget src={`${config.ownerId}/widget/Lendle.Header`} props={{ config }} />\n    <Body>\n      {state.walletConnected\n        ? state.isChainSupported\n          ? \"Loading...\"\n          : `Please switch network to ${\n              getNetworkConfig(DEFAULT_CHAIN_ID).chainName\n            }`\n        : \"Connect your wallet to see your supplies, borrowings, and open positions.\"}\n      <Widget\n        src={`${config.ownerId}/widget/Lendle.Card.Markets`}\n        props={{\n          config,\n          markets: state.markets,\n          // chainId: state.chainId,\n          // showVestModal: state.showVestModal,\n          // setShowVestModal: (isShow) =>\n          //   State.update({ showVestModal: isShow }),\n          // onActionSuccess,\n          // healthFactor: formatHealthFactor(\n          //   state.assetsToBorrow.healthFactor\n          // ),\n          // formatHealthFactor,\n          // depositETHGas,\n          // depositERC20Gas,\n        }}\n      />\n    </Body>\n  </>\n) : (\n  <>\n    <Widget src={`${config.ownerId}/widget/Lendle.Header`} props={{ config }} />\n    <Body>\n      <FlexContainer>\n        {/* <Widget\n          src={`${config.ownerId}/widget/Lendle.NetworkSwitcher`}\n          props={{\n            chainId: state.chainId,\n            config,\n            switchNetwork: (chainId) => {\n              switchEthereumChain(chainId);\n            },\n          }}\n        /> */}\n        <Widget\n          src={`${config.ownerId}/widget/Lendle.HeroData`}\n          props={{\n            config,\n            netWorth: `$ ${\n              state.assetsToBorrow?.netWorthUSD\n                ? Big(state.assetsToBorrow.netWorthUSD).toFixed(2)\n                : \"-\"\n            }`,\n            netApy: `${\n              state.assetsToBorrow?.netAPY\n                ? Number(\n                    Big(state.assetsToBorrow.netAPY).times(100).toFixed(2)\n                  ) === 0\n                  ? \"0.00\"\n                  : Big(state.assetsToBorrow.netAPY).times(100).toFixed(2)\n                : \"-\"\n            }%`,\n            healthFactor: formatHealthFactor(state.assetsToBorrow.healthFactor),\n            showHealthFactor:\n              state.yourBorrows &&\n              state.yourBorrows.debts &&\n              state.yourBorrows.debts.length > 0,\n          }}\n        />\n      </FlexContainer>\n      <Widget\n        src={`${config.ownerId}/widget/Lendle.TabSwitcher`}\n        props={{\n          config,\n          select: state.selectTab,\n          setSelect: (tabName) => State.update({ selectTab: tabName }),\n        }}\n      />\n      {state.selectTab === \"supply\" && (\n        <>\n          <Widget\n            src={`${config.ownerId}/widget/Lendle.Card.YourSupplies`}\n            props={{\n              config,\n              chainId: state.chainId,\n              yourSupplies: state.yourSupplies,\n              showWithdrawModal: state.showWithdrawModal,\n              setShowWithdrawModal: (isShow) =>\n                State.update({ showWithdrawModal: isShow }),\n              onActionSuccess,\n              healthFactor: formatHealthFactor(\n                state.assetsToBorrow.healthFactor\n              ),\n              formatHealthFactor,\n              withdrawETHGas,\n              withdrawERC20Gas,\n            }}\n          />\n          <Widget\n            src={`${config.ownerId}/widget/Lendle.Card.AssetsToSupply`}\n            props={{\n              config,\n              chainId: state.chainId,\n              assetsToSupply: state.assetsToSupply,\n              showSupplyModal: state.showSupplyModal,\n              setShowSupplyModal: (isShow) =>\n                State.update({ showSupplyModal: isShow }),\n              onActionSuccess,\n              healthFactor: formatHealthFactor(\n                state.assetsToBorrow.healthFactor\n              ),\n              formatHealthFactor,\n              depositETHGas,\n              depositERC20Gas,\n            }}\n          />\n        </>\n      )}\n      {state.selectTab === \"borrow\" && (\n        <>\n          <Widget\n            src={`${config.ownerId}/widget/Lendle.Card.YourBorrows`}\n            props={{\n              config,\n              chainId: state.chainId,\n              yourBorrows: state.yourBorrows,\n              showRepayModal: state.showRepayModal,\n              setShowRepayModal: (isShow) =>\n                State.update({ showRepayModal: isShow }),\n              showBorrowModal: state.showBorrowModal,\n              setShowBorrowModal: (isShow) =>\n                State.update({ showBorrowModal: isShow }),\n              formatHealthFactor,\n              onActionSuccess,\n              repayETHGas,\n              repayERC20Gas,\n              borrowETHGas,\n              borrowERC20Gas,\n            }}\n          />\n          <Widget\n            src={`${config.ownerId}/widget/Lendle.Card.AssetsToBorrow`}\n            props={{\n              config,\n              chainId: state.chainId,\n              assetsToBorrow: state.assetsToBorrow,\n              showBorrowModal: state.showBorrowModal,\n              yourSupplies: state.yourSupplies,\n              setShowBorrowModal: (isShow) =>\n                State.update({ showBorrowModal: isShow }),\n              formatHealthFactor,\n              onActionSuccess,\n              borrowETHGas,\n              borrowERC20Gas,\n            }}\n          />\n        </>\n      )}\n      {state.alertModalText && (\n        <Widget\n          src={`${config.ownerId}/widget/Lendle.Modal.AlertModal`}\n          props={{\n            config,\n            title: \"All done!\",\n            description: state.alertModalText,\n            onRequestClose: () => State.update({ alertModalText: false }),\n          }}\n        />\n      )}\n    </Body>\n  </>\n);\n\nreturn (\n  <div>\n    {/* Component Head */}\n    <Widget\n      src={`${config.ownerId}/widget/Utils.Import`}\n      props={{ modules, onLoad: importFunctions }}\n    />\n    {/* Component Body */}\n    {body}\n  </div>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/lendle.near/widget/Lendle", "fact_widget_deployments_id": "5d97e8871b720562b2ee66d0b59652de", "inserted_timestamp": "2024-03-07T05:24:05.087Z", "modified_timestamp": "2024-03-07T05:24:05.087Z", "__row_index": 5}