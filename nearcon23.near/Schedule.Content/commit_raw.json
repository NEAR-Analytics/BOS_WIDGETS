{"tx_hash": "9pgwW5UuBgDCBsyG7zS3dsrDEw1baJdpqW78UYxHcFn7", "action_id_social": "CejHuXQJ87m9s1U6aJKj97Ksa1rnYBNCVjs5XknAMavW-0-widget", "block_id": 104116261, "block_timestamp": "2023-10-24T16:57:31.684Z", "signer_id": "nearcon23.near", "widget_name": "Schedule.Content", "source_code": "const accountId = \"nearcon23.near\";\n\ninitState({ data: [] });\nconst apiKey =\n  \"patWQQ6FY8H5O8wTY.4b08b48ac31aa13eb9fea974cfa60e103ae7297c010d4fe752e1abb37bd24c9d\";\n\n// Airtable API Url: \"https://api.airtable.com/v0/appcR9zt96Wv7VXWl/tblSMeBodnZWPL1vj\"\nconst airtableId = \"appcR9zt96Wv7VXWl\";\nconst airtableTableId = \"tblSMeBodnZWPL1vj\";\n\nconst airtableApiUrl = `https://api.airtable.com/v0/${airtableId}/${airtableTableId}`;\nconst sessionsByDate = {};\n//\u2699\ufe0f Start Time- get event Data and time\n// \u2699\ufe0f End Time Calculated by Duration- get the end time\n//fields.title\n// fields.description\n//fields.track\n//fields.Confirmed Speakers Full Name - if speaker\n//\n//fields.Start Time Formatted for Calendar\n//fields.End Time Formatted for Calendar\n\nconst imageLink =\n  \"https://plus.unsplash.com/premium_photo-1664541336896-b3d5f7dec9a3?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxzZWFyY2h8MTN8fHBlcnNvbnxlbnwwfHwwfHx8MA%3D%3D&auto=format&fit=crop&w=500&q=60\";\n\nasyncFetch(airtableApiUrl, {\n  headers: {\n    Authorization: `Bearer ${apiKey}`,\n  },\n}).then(({ body }) => {\n  const { records } = body;\n  const dataToSet = [...records];\n  dataToSet.sort((a, b) => {\n    let dateA = new Date(a.fields[\"\u2699\ufe0f Start Time\"]);\n    let dateB = new Date(b.fields[\"\u2699\ufe0f Start Time\"]);\n    return dateA - dateB;\n  });\n\n  // Extract the relevant fields and store them in a new array of objects:\n  let allLocations = {};\n\n  const simplifiedData = dataToSet\n    .filter((data) => {\n      const wps = data.fields[\"Web Publishing Status\"];\n\n      return (\n        data.fields[\"Web Publishing Status\"]?.length > 0 &&\n        !wps.includes(\"reczlWVomn8QUBxXF\")\n      );\n    })\n    .map((data) => {\n      allLocations[data.fields[\"Location\"]] = true;\n\n      const speakers = [\n        ...(data?.fields?.[\"Confirmed Speakers Full Name\"] ?? []),\n        ...(data?.fields?.[\"Confirmed Moderator Full Name\"] ?? []),\n      ];\n\n      const ids = [\n        ...(data?.fields?.[\"Potential Speakers\"] ?? []),\n        ...(data?.fields?.[\"Confirmed Moderator\"] ?? []),\n      ];\n\n      return {\n        startTime: data.fields[\"\u2699\ufe0f Start Time\"],\n        endTime: data.fields[\"\u2699\ufe0f End Time\"],\n        title: data.fields[\"Session Name\"],\n        description: data.fields[\"Description\"],\n        location: data.fields[\"Location\"],\n        track: data?.fields?.[\"Track\"]\n          ? data?.fields?.[\"Track\"].map((item) => item.toLowerCase())\n          : null,\n        imageIds: ids,\n        // Assuming that you want to retrieve some speaker name from a different field:\n        confirmedSpeakers: speakers, // Replace with an actual field name if applicable\n        startTimeFormatted: data.fields[\"Start Time Formatted for Calendar\"],\n        endTimeFormatted: data.fields[\"End Time Formatted for Calendar\"],\n      };\n    });\n\n  simplifiedData.forEach((session) => {\n    let date = new Date(session.startTime).toDateString(); // Converts time to a string that represents only the date, not the time\n    sessionsByDate[date] = sessionsByDate[date] || [];\n    sessionsByDate[date].push(session);\n  });\n\n  // Convert the grouped sessions object into an array of session arrays:\n  let groupedSessionsArray = Object.values(sessionsByDate);\n\n  State.update({\n    data: groupedSessionsArray,\n    locations: Object.keys(allLocations),\n  });\n});\n\nreturn (\n  <>\n    <div\n      style={{\n        zIndex: -100,\n        position: \"none\",\n        minHeight: 600,\n        overflow: \"visible\",\n      }}\n    >\n      <Widget\n        src={`${accountId}/widget/Schedule.Filters`}\n        props={{\n          update: (d) => State.update({ filters: d }),\n          locations: state.locations,\n        }}\n      />\n      {state.data.map((dateData, index) => {\n        return (\n          <div key={index}>\n            <Widget\n              src={`${accountId}/widget/Schedule.ContentScheduleShow`}\n              props={{\n                dateData,\n                index,\n                filter: state.filters,\n              }}\n            />\n          </div>\n        );\n      })}\n    </div>\n  </>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/nearcon23.near/widget/Schedule.Content", "fact_widget_deployments_id": "52314b75181d375568d2a200b972ae37", "inserted_timestamp": "2023-10-24T18:46:34.839Z", "modified_timestamp": "2023-10-24T18:46:34.839Z", "__row_index": 9}